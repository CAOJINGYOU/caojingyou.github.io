<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://caojingyou.github.io">
  <title>曹景游</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="C++,C">
<meta property="og:type" content="website">
<meta property="og:title" content="曹景游">
<meta property="og:url" content="https://caojingyou.github.io/page/3/index.html">
<meta property="og:site_name" content="曹景游">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曹景游">
  
    <link rel="alternative" href="/atom.xml" title="曹景游" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/blogImg/yhcao.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">yhcao</a></h1>
		</hgroup>
		
		<p class="header-subtitle">曹景游</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://caojingyou.github.io" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/chihun" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://caojingyou.github.io/2016/09/01/Github%20Pages%E5%92%8CHexo%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/b3d40949d7bd" title="jianshu"><i class="icon-jianshu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/blogImg/yhcao.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">yhcao</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>曹景游<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://caojingyou.github.io" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/chihun" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://caojingyou.github.io/2016/09/01/Github%20Pages%E5%92%8CHexo%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/b3d40949d7bd" title="jianshu"><i class="icon-jianshu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-进程、线程、同步、并发" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/进程、线程、同步、并发/">进程、线程、同步、并发</a>
    </h1>
  

        
        <a href="/2018/05/30/进程、线程、同步、并发/" class="archive-article-date">
  	<time datetime="2018-05-30T08:02:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-30</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Boost-Thread"><a href="#Boost-Thread" class="headerlink" title="Boost.Thread"></a>Boost.Thread</h1><h2 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h2><p>Thread</p>
<p>thread_group</p>
<h2 id="线程局部存储："><a href="#线程局部存储：" class="headerlink" title="线程局部存储："></a>线程局部存储：</h2><pre><code>thread_specific_ptr
</code></pre><h2 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h2><pre><code>lock_guard


unique_lock


scoped_lock


shared_lock
</code></pre><p>如果只是为了保证数据同步，那么<code>lock_guard</code>完全够用；<br>如果除了同步，还需要使用condition进行阻塞时，那么就需要用<code>unique_lock</code>。<br>boost还要一个<code>boost::mutex::scoped_lock</code>，这个是<code>boost::unique_lock&lt;boost::mutex&gt;</code>的typedef，在C++11中已经禁用。</p>
<p>独占锁：</p>
<p><code>boost::unique_lock&lt;T&gt;</code>，其中T可以mutex中的任意一种。</p>
<p>  如果T为mutex，那么<code>boost::unique_lock&lt;boost::mutex&gt;</code>，构造与析构时则分别自动调用lock和unlock方法。</p>
<p>  如果T为shared_mutex，那么<code>boost::unique_lock&lt;boost::shared_mutex&gt;</code>，构造与析构时则分别调用<code>shared_mutex</code>的<code>shared_lock</code>和<code>shared_unlock</code>方法。</p>
<p>注意：<code>scoped_lock</code>也是独占锁，其源代码中定义如下；</p>
<pre><code>typedef unique_lock&lt;mutex&gt; scoped_lock;
typedef unique_lock&lt;timed_mutex&gt; scoped_timed_lock;
</code></pre><p>共享锁：</p>
<p><code>boost::shared_lock&lt;T&gt;</code>，其中的T只能是<code>shared_mutex</code>类。<br>当然还有其他一些锁：<code>lock_guard</code>, <code>upgrade_lock</code>等。</p>
<p><a href="https://blog.csdn.net/huang_xw/article/details/8457599" target="_blank" rel="noopener">boost库中thread多线程详解</a></p>
<h2 id="互斥："><a href="#互斥：" class="headerlink" title="互斥："></a>互斥：</h2><p>独占式互斥量</p>
<pre><code>mutex

try_mutex

timed_mutex
</code></pre><p>递归式互斥量</p>
<pre><code>recursive_mutex

recursive_try_mutex

recursive_timed_mutex
</code></pre><p>共享式互斥量</p>
<pre><code>shared_mutex
</code></pre><h2 id="条件变量："><a href="#条件变量：" class="headerlink" title="条件变量："></a>条件变量：</h2><pre><code>condition_variable
condition_variable_any
</code></pre><h2 id="原子变量："><a href="#原子变量：" class="headerlink" title="原子变量："></a>原子变量：</h2><h2 id="future："><a href="#future：" class="headerlink" title="future："></a>future：</h2><pre><code>packaged_task

unique_future

Promise
</code></pre><p>Promise对象可保存T类型的值，该值可被future对象读取(可能在另一个线程中)，这是promise提供的同步的一种手段。</p>
<p>在构造promise时，promise对象可以与共享状态关联起来，这个共享状态可以存储一个T类型或者一个由std::exception派生出的类的值，并可以通过get_future来获取与promise对象关联的对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。</p>
<p>Promise对象是异步provider，它可以在某一时刻设置共享状态的值。</p>
<p>Future对象可以返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标识变为ready，然后才能获取共享状态的值。</p>
<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>//保证在多线程中只允许一次</p>
<pre><code>once_flag

call_once
</code></pre><p>示例：</p>
<pre><code>#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;complex.h&gt;
#include &lt;stack&gt;
#include &lt;mutex&gt;
#include &lt;boost/thread/once.hpp&gt;
#include &lt;boost/thread/future.hpp&gt;
#include &lt;boost/asio.hpp&gt;

void my_func()
{
    std::cout &lt;&lt; &quot;detach-分离 或 join-等待 线程&quot; &lt;&lt; std::endl;
}

TEST(BoostThread, detachOrjoin)//简单线程,线程状态joinable、detached
{
    boost::thread t(my_func);
    boost::thread::yield();//当前线程放弃余下的时间片。
    std::cout &lt;&lt; t.joinable() &lt;&lt; std::endl;
    t.join();

    boost::thread t1(my_func);
    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;
    t1.detach();
    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;
}

//线程的创建需要传递给thread对象一个可调用物（函数或函数对象），它必须具
//有operator()以供线程执行。
boost::mutex io_mutex;
struct count 
{
    count(int id) : id(id) { }

    void operator()()
    {
        for (int i = 0; i &lt; 10; ++i)
        {
            boost::mutex::scoped_lock
                lock(io_mutex);
            std::cout &lt;&lt; id &lt;&lt; &quot;: &quot;
                &lt;&lt; i &lt;&lt; std::endl;
        }
    }

    int id;
};

TEST(BoostThread, Typeobject)//复杂类型对象作为参数来创建线程
{
    boost::thread thrd1(count(1));
    boost::thread thrd2(count(2));
    thrd1.join();
    thrd2.join();
}

class HelloWorldStatic
{
public:
    static void hello()
    {
        std::cout &lt;&lt;
            &quot;Hello world, I&apos;&apos;m a thread!&quot;
            &lt;&lt; std::endl;
    }
    static void start()
    {

        boost::thread thrd(hello);
        thrd.join();
    }

};

TEST(BoostThread, InClassStatic)//类内部创建线程
{
    HelloWorldStatic::start();//在这里start()和hello()方法都必须是static方法。
}

class HelloWorld
{
public:
    void hello()
    {
        std::cout &lt;&lt;
            &quot;Hello world, I&apos;&apos;m a thread!&quot;
            &lt;&lt; std::endl;
    }
    void start()
    {
        boost::function0&lt; void&gt; f = boost::bind(&amp;HelloWorld::hello, this);
        boost::thread thrd(f);
        thrd.join();
    }

};

TEST(BoostThread, InClass)//start()和hello()方法不是静态方法则采用此方法创建线程
{
    HelloWorld hello;
    hello.start();
}

class HelloWorldOut
{
public:
    void hello(const std::string&amp; str)
    {
        std::cout &lt;&lt; str;
    }
};

TEST(BoostThread, OutClass)
{
    HelloWorldOut obj;
    boost::thread thrd(boost::bind(&amp;HelloWorldOut::hello, &amp;obj, &quot;Hello world, I&apos;&apos;m a thread!&quot; ) ) ;
    thrd.join();
}

void func1(const int &amp;id)
{
    std::cout &lt;&lt; &quot;func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;
}

struct MyThread
{
    void operator()(const int &amp;id)
    {
        std::cout &lt;&lt; &quot;MyThread id : &quot; &lt;&lt; id &lt;&lt; std::endl;
    }

    void func1(const int &amp;id)
    {
        std::cout &lt;&lt; &quot;MyThread::func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;
    }
};

TEST(BoostThread, Threadparameters)
{
    //普通函数  
    boost::thread t1(func1, 11);
    t1.join();

    //函数对象  
    MyThread myThread;
    boost::thread t2(myThread, 22);
    t2.join();

    //成员函数  
    boost::thread t3(&amp;MyThread::func1, myThread, 33);
    t3.join();

    //临时对象  
    boost::thread t4(MyThread(), 44);
    t4.join();

    //对象引用  
    boost::thread t5(boost::ref(myThread), 55);
    t5.join();
}

void wait(int seconds)
{
    boost::this_thread::sleep(boost::posix_time::seconds(seconds));
}

void threadinterrupt()
{
    try
    {
        for (int i = 0; i &lt; 4; ++i)
        {
            wait(1);
            std::cout &lt;&lt; i&lt;&lt;&quot; 是否允许中断:&quot;&lt;&lt; boost::this_thread::interruption_enabled()&lt;&lt;&quot; 是否被要求中断:&quot;&lt;&lt; boost::this_thread::interruption_requested() &lt;&lt; std::endl;
        }
    }
    catch (boost::thread_interrupted&amp;)
    {
        std::cout &lt;&lt; &quot;已经中断&quot; &lt;&lt; std::endl;
    }
}

#define testinterruption() { std::cout &lt;&lt; &quot;\r\n是否允许中断:&quot; &lt;&lt; boost::this_thread::interruption_enabled() &lt;&lt; &quot; 是否被要求中断:&quot; &lt;&lt; boost::this_thread::interruption_requested()&lt;&lt; __FUNCTION__&lt;&lt; __LINE__ &lt;&lt; std::endl;}

void f()
{
    testinterruption();
    // interruption enabled here
    {
        boost::this_thread::disable_interruption di;
        boost::this_thread::interruption_point();
        testinterruption();
        // interruption disabled
        {
            testinterruption();
            boost::this_thread::disable_interruption di2;
            testinterruption();
            // interruption still disabled
        } // di2 destroyed, interruption state restored
          // interruption still disabled
        boost::this_thread::interruption_point();
        testinterruption();
    } // di destroyed, interruption state restored
      // interruption now enabled
    testinterruption();
    boost::this_thread::interruption_point();
    testinterruption();
}

void g()
{
    testinterruption();
    // interruption enabled here
    {
        testinterruption();
        boost::this_thread::disable_interruption di;
        boost::this_thread::interruption_point();
        testinterruption();
        // interruption disabled
        {
            testinterruption();
            boost::this_thread::restore_interruption ri(di);
            testinterruption();
            // interruption now enabled
        } // ri destroyed, interruption disable again
        testinterruption();
        boost::this_thread::interruption_point();
    } // di destroyed, interruption state restored
      // interruption now enabled
    testinterruption();
    boost::this_thread::interruption_point();
    testinterruption();
}

//预定于中断点：
//boost::thread::join()
//boost::thread::timed_join()
//boost::thread::try_join_for(),
//boost::thread::try_join_until(),
//boost::condition_variable::wait()
//boost::condition_variable::timed_wait()
//boost::condition_variable::wait_for()
//boost::condition_variable::wait_until()
//boost::condition_variable_any::wait()
//boost::condition_variable_any::timed_wait()
//boost::condition_variable_any::wait_for()
//boost::condition_variable_any::wait_until()
//boost::thread::sleep()
//boost::this_thread::sleep_for()
//boost::this_thread::sleep_until()
//boost::this_thread::interruption_point()

TEST(BoostThread, interrupt)//中断
{
    std::cout &lt;&lt; &quot;中断&quot; &lt;&lt; std::endl;
    boost::thread t(threadinterrupt);
    wait(3);
    t.interrupt();
    t.join();

    boost::thread tf(f);
    tf.interrupt();
    tf.join();

    boost::thread tg(g);
    tg.interrupt();
    tg.join();
}

TEST(BoostThread, threadid_count)
{
    std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;
    std::cout &lt;&lt; boost::thread::hardware_concurrency() &lt;&lt; std::endl;
}

void thread_group_Fun()
{
    std::cout &lt;&lt;&quot;当前线程ID:&quot;&lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;
}

TEST(BoostThread, thread_group)
{
    boost::thread_group grp;
    boost::thread *p = new boost::thread(thread_group_Fun);
    grp.add_thread(p);
    std::cout &lt;&lt; &quot;remove_thread:&quot; &lt;&lt; p-&gt;get_id()&lt;&lt; std::endl;
    grp.remove_thread(p);

    grp.create_thread(thread_group_Fun);
    grp.create_thread(thread_group_Fun);   

    grp.join_all();                 
}

class BankAccount {
    boost::mutex mtx_; // explicit mutex declaration 
    int balance_;
public:
    void Deposit(int amount) {
        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);
        balance_ += amount;
    }
    void Withdraw(int amount) {
        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);
        balance_ -= amount;
    }
    int GetBalance() {
        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);
        return balance_;
    }
};

BankAccount JoesAccount;

void bankAgent()
{
    for (int i = 10; i &gt; 0; --i) {
        JoesAccount.Deposit(500);
        std::cout &lt;&lt; &quot;bankAgent:&quot; &lt;&lt; JoesAccount.GetBalance() &lt;&lt; std::endl;
    }
}

void Joe() {
    for (int i = 10; i &gt; 0; --i) {
        JoesAccount.Withdraw(100);
        std::cout &lt;&lt;&quot;Joe:&quot;&lt;&lt; JoesAccount.GetBalance() &lt;&lt; std::endl;
    }
}

TEST(BoostThread, mutex)//互斥
{
    boost::thread thread1(bankAgent); // start concurrent execution of bankAgent
    boost::thread thread2(Joe); // start concurrent execution of Joe
    thread1.join();
    thread2.join();
}

typedef boost::shared_lock&lt;boost::shared_mutex&gt; readLock;
typedef boost::unique_lock&lt;boost::shared_mutex&gt; writeLock;
boost::shared_mutex rwmutex;

std::vector&lt;int&gt; random_numbers;

void readOnly()
{
    for (int i = 0; i &lt; 3; ++i)
    {
        wait(1);
        readLock rdlock(rwmutex);
        std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;
    }
}

void writeOnly()
{
    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));
    for (int i = 0; i &lt; 3; ++i)
    {
        writeLock wtlock(rwmutex);
        random_numbers.push_back(std::rand());
        wait(1);
    }
}

int sum = 0;

void count()
{
    for (int i = 0; i &lt; 3; ++i)
    {
        wait(1);
        readLock rdlock(rwmutex);
        sum += random_numbers.back();
    }
}

TEST(BoostThread, readwrite)//读写锁
{
    boost::thread t1(writeOnly);
    boost::thread t2(readOnly);
    boost::thread t3(count);
    t1.join();
    t2.join();
    t3.join();
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;
}

boost::condition_variable_any cond;
boost::mutex rwmutexCV;
std::vector&lt;int&gt; random_numbersCV;

void print()
{
    std::size_t next_size = 1;
    for (int i = 0; i &lt; 3; ++i)
    {
        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);
        while (random_numbersCV.size() != next_size)
            cond.wait(rwmutexCV);
        std::cout &lt;&lt; random_numbersCV.back() &lt;&lt; std::endl;
        ++next_size;
        cond.notify_all();
    }
}

void fill()
{
    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));
    for (int i = 0; i &lt; 3; ++i)
    {
        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);
        random_numbersCV.push_back(std::rand());
        cond.notify_all();
        cond.wait(rwmutexCV);
    }
}

TEST(BoostThread, ConditionVariables)//条件变量
{
    boost::thread t1(fill);
    boost::thread t2(print);
    t1.join();
    t2.join();
}

//生产者-消费者模式的后进先出型(std::stack)缓冲区
class Buffer
{
public:
    //构造函数
    Buffer(size_t n) :un_read(0), capacity(n) {}

    //写入数据x
    void put(int x) {
        //局部域
        {
            boost::mutex::scoped_lock lock(mu);  //锁定互斥量
            while (is_full()) {
                cond_put.wait(mu);  //条件变量等待
            }
            stk.push(x);  //写入数据
            ++un_read;
        }  //解锁互斥量

        cond_get.notify_one();  //通知可以读取数据
    }

    //读取数据
    void get(int *x) {

        {
            boost::mutex::scoped_lock lock(mu);
            while (is_empty()) {
                cond_get.wait(mu);
            }
            *x = stk.top();
            stk.pop();
            --un_read;
        }

        cond_put.notify_one();
    }

private:
    //判断缓冲区是否满
    bool is_full() {
        return un_read == capacity;
    }

    //判断缓冲区是否为空
    bool is_empty() {
        return un_read == 0;
    }

private:
    boost::mutex mu;  //互斥量，配合条件变量使用
    boost::condition_variable_any cond_put;  //写入条件变量
    boost::condition_variable_any cond_get;  //读取条件变量
    std::stack&lt;int&gt; stk;  //缓冲区对象
    int un_read;
    int capacity;
};

Buffer buf(5);  //定义一个缓冲区对象

boost::mutex io_mu_;  //定义一个输出互斥量

//生产者,n个
void producer(int n)
{
    for (int i = 0; i &lt; n; i++) {
        //输出信息
        {
            boost::mutex::scoped_lock lock(io_mu_);
            std::cout &lt;&lt; &quot;put &quot; &lt;&lt; i &lt;&lt; &quot; to buffer&quot; &lt;&lt; std::endl;

        }
        buf.put(i);  //写入数据
    }
}

//消费者
void consumer(int n)
{
    int result(0);
    for (int i = 0; i &lt; n; i++) {
        {
            buf.get(&amp;result);  //读取数据
            boost::mutex::scoped_lock lock(io_mu_);
            std::cout &lt;&lt; &quot;get &quot; &lt;&lt; result &lt;&lt; &quot; from buffer&quot; &lt;&lt; std::endl;
        }
    }
}

TEST(BoostThread, producer_consumer_test)
{
    boost::thread t_producer(producer, 20);
    boost::thread t_consumer1(consumer, 10);
    boost::thread t_consumer2(consumer, 10);

    t_producer.join();
    t_consumer1.join();
    t_consumer2.join();
}

class ThreadPool {
public:
    explicit ThreadPool(size_t size) : work_(io_service_) {
        for (size_t i = 0; i &lt; size; ++i) {
            workers_.create_thread(
                boost::bind(&amp;boost::asio::io_service::run, &amp;io_service_));
        }
    }

    ~ThreadPool() {
        io_service_.stop();
        workers_.join_all();
    }

    // Add new work item to the pool.
    template&lt;class F&gt;
    void Enqueue(F f) {
        io_service_.post(f);
    }

private:
    boost::thread_group workers_;
    boost::asio::io_service io_service_;
    boost::asio::io_service::work work_;
};

TEST(BoostThread, ThreadPool)
{
    // Create a thread pool of 4 worker threads.
    ThreadPool pool(4);

    // Queue a bunch of work items.
    for (int i = 0; i &lt; 8; ++i) {
        pool.Enqueue([i] {
            std::cout &lt;&lt; &quot;hello &quot; &lt;&lt; i &lt;&lt; std::endl;
            boost::this_thread::sleep(boost::posix_time::seconds(1));
            std::cout &lt;&lt; &quot;world &quot; &lt;&lt; i &lt;&lt; std::endl;
        });
    }
}

void init_number_generator()
{
    static boost::thread_specific_ptr&lt;bool&gt; tls;
    if (!tls.get())
        tls.reset(new bool(false));
    if (!*tls)
    {
        *tls = true;
        std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));
    }
}

boost::mutex mutex;

void random_number_generator()
{
    init_number_generator();
    int i = std::rand();
    boost::lock_guard&lt;boost::mutex&gt; lock(mutex);
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}

TEST(BoostThread, thread_specific_ptr)//线程局部存储
{
    boost::thread t[3];

    for (int i = 0; i &lt; 3; ++i)
        t[i] = boost::thread(random_number_generator);

    for (int i = 0; i &lt; 3; ++i)
        t[i].join();
}

std::once_flag flag1, flag2;

void simple_do_once()
{
    std::call_once(flag1, []() { std::cout &lt;&lt; &quot;Simple example: called once\n&quot;; });
}

void may_throw_function(bool do_throw)
{
    if (do_throw) {
        std::cout &lt;&lt; &quot;throw: call_once will retry\n&quot;; // 这会出现多于一次
        throw std::exception();
    }
    std::cout &lt;&lt; &quot;Didn&apos;t throw, call_once will not attempt again\n&quot;; // 保证一次
}

void do_once(bool do_throw)
{
    try {
        std::call_once(flag2, may_throw_function, do_throw);
    }
    catch (...) {
    }
}

TEST(StdThread, std_call_once)
{
    std::thread st1(simple_do_once);
    std::thread st2(simple_do_once);
    std::thread st3(simple_do_once);
    std::thread st4(simple_do_once);
    st1.join();
    st2.join();
    st3.join();
    st4.join();

    std::thread t1(do_once, true);
    std::thread t2(do_once, true);
    std::thread t3(do_once, false);
    std::thread t4(do_once, true);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
}

// Some sort of connection class that should only be initialized once
struct Conn {
    static void init() { ++i_; }
    static boost::once_flag init_;
    static int i_;
    // ...
};

int Conn::i_ = 0;
boost::once_flag Conn::init_ = BOOST_ONCE_INIT;

void worker() {
    boost::call_once(Conn::init, Conn::init_);
    // Do the real work...
}

Conn c;  // You probably don&apos;t want to use a global, so see the
         // next Recipe

TEST(BoostThread, Boost_call_once)
{

    boost::thread_group grp;

    for (int i = 0; i &lt; 100; ++i)
        grp.create_thread(worker);

    grp.join_all();

    std::cout &lt;&lt; c.i_ &lt;&lt; &apos;\n&apos;;// c.i_ = 1
}

int fab(int n)
{
    if (n == 0 || n == 1)
    {
        return 1;
    }
    return fab(n - 1) + fab(n - 2);
}


TEST(BoostThread, futuretest)
{
    // 声明packaged_task对象，用模板参数指明返回值类型
    // packaged_task只接受无参函数，因此需要使用bind
    boost::packaged_task&lt;int&gt; pt(boost::bind(fab, 10));

    // 声明unique_future对象，接受packaged_task的future值
    // 同样要用模板参数指明返回值类型
    boost::unique_future&lt;int&gt; uf = pt.get_future();

    // 启动线程计算，必须使用boost::move()来转移package_task对象
    // 因为packaged_task是不可拷贝的
    boost::thread(boost::move(pt));
    uf.wait(); // unique_future等待计算结果
    assert(uf.is_ready() &amp;&amp; uf.has_value());
    std::cout &lt;&lt; uf.get()&lt;&lt;std::endl; // 输出计算结果99
}

int calculate_the_answer_to_life_the_universe_and_everything()
{
    return 42;
}

void invoke_lazy_task(boost::packaged_task&lt;int&gt;&amp; task)
{
    try
    {
        task();
    }
    catch (boost::task_already_started&amp;)
    {
    }
}

//shared_future与unique_future
TEST(BoostThread, BoostFuture)
{
    {
        boost::packaged_task&lt;int&gt; pt(calculate_the_answer_to_life_the_universe_and_everything);
        boost::unique_future&lt;int&gt; fi = pt.get_future();

        boost::thread task(boost::move(pt)); // launch task on a thread

        fi.wait(); // wait for it to finish

        ASSERT_TRUE(fi.is_ready());
        ASSERT_TRUE(fi.has_value());
        ASSERT_TRUE(!fi.has_exception());
        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);
        ASSERT_TRUE(fi.get() == 42);
    }

    {
        boost::promise&lt;int&gt; pi;
        boost::unique_future&lt;int&gt; fi;
        fi = pi.get_future();

        pi.set_value(42);

        ASSERT_TRUE(fi.is_ready());
        ASSERT_TRUE(fi.has_value());
        ASSERT_TRUE(!fi.has_exception());
        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);
        ASSERT_TRUE(fi.get() == 42);
    }

    {
        boost::packaged_task&lt;int&gt; task(calculate_the_answer_to_life_the_universe_and_everything);
        task.set_wait_callback(invoke_lazy_task);
        boost::unique_future&lt;int&gt; f(task.get_future());

        ASSERT_TRUE(f.get() == 42);
    }
}
</code></pre><h1 id="Win32-API"><a href="#Win32-API" class="headerlink" title="Win32 API"></a>Win32 API</h1><p><a href="http://blog.jobbole.com/109200/" target="_blank" rel="noopener">C++ 线程同步的四种方式</a></p>
<p>内核对象的线程同步则主要由<code>事件</code>、<code>等待定时器</code>、<code>信号量</code>以及<code>信号灯</code>等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。</p>
<p>在WIN32中，同步机制主要有以下几种：</p>
<p>（1）事件(Event);<br>（2）信号量(semaphore);<br>（3）互斥量(mutex);<br>（4）临界区(Critical section)。</p>
<p>下面简单对比一下Windows中的Mutex、Semaphore、Event和Critical Section。</p>
<p>Mutext，也叫做Mutant。只允许一个线程进入，这个进入的线程被认为是Mutex的所有者。所有者可以重入。Mutex的所有者需要在操作完成后释放这个Mutex，如果没有释放就结束了，操作系统会释放这个Mutex，但是会设置成Abandoned Mutex。</p>
<p>Semaphore。维护了一个计数器，每当一个线程获取这个Semaphore，就会减一。当线程释放这个Semaphore，就会加一。Semaphore不维护所有者信息。</p>
<p>Event。维护一个布尔标志。分为自动和手动两种。</p>
<p>Critical Section。和Mutex类似，但是是用户态的对象，前面3个都是内核态的。只能用在进程内。线程退出前必须释放（LeaveCriticalSection），否则其他等待这个Critical Section的线程会永远等待下去。</p>
<p>windows其实也有<a href="https://blog.csdn.net/u010261063/article/details/80293266" target="_blank" rel="noopener">条件变量</a>和读写锁。</p>
<p><a href="https://www.cnblogs.com/tocy/archive/2012/06/03/2532559.html" target="_blank" rel="noopener">线程通信机制之条件变量</a></p>
<ul>
<li>可等待定时器</li>
<li>原子锁</li>
</ul>
<p>根据用户模式及内核模式下的同步方式的不同，分类及对比如下：</p>
<p><img src="https://i.imgur.com/J3dEHpV.jpg" alt=""></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>如果自旋锁已经被锁住，这时有程序申请“获取”这个自旋锁时，程序则处于“自旋”状态。所谓自旋状态，就是不停的询问是否可以“获取”自旋锁。</p>
<p>自旋锁不同于其他的等待事件。在线程中如果等待某个事件（Event），操作系统会让这个线程进入睡眠状态，CPU会转而运行其他线程。而自旋锁则不同，它不会切换到别的线程，而是一直让这个线程“自旋”。因此，对自旋锁占用时间不宜过长，否则会导致申请自旋锁的其他线程处于自旋，这会浪费宝贵的CPU时间。</p>
<p>自旋锁的作用一般是使各派遣函数之间同步。尽量不要将自旋锁放在全局变量中，而应该将自旋锁放在设备扩展里面。自旋锁用KSPIN_LOCK数据结构表示。</p>
<h2 id="内核模式下线程同步"><a href="#内核模式下线程同步" class="headerlink" title="内核模式下线程同步"></a><a href="http://www.voidcn.com/article/p-bhakxtfz-beq.html" target="_blank" rel="noopener">内核模式下线程同步</a></h2><p><a href="http://www.voidcn.com/article/p-bqnbnjzn-ye.html" target="_blank" rel="noopener">内核模式下的线程同步——事件内核对象</a><br><a href="http://www.voidcn.com/article/p-qdxfckob-uy.html" target="_blank" rel="noopener">Windows Via C/C++：内核模式下的线程同步——概述</a></p>
<p>以下是拥有signaled/unsignaled状态的内核对象：</p>
<p>进程（Processes）<br>线程（Threads）<br>作业（Jobs）<br>文件和控制台标准输入/输出/错误流（File and console standard input/output/error streams）<br>事件（Events）<br>可待待定时器（Waitable timers）<br>信号量（Semaphores）<br>互斥量（Mutexes）</p>
<p>内核对象线程同步】概述</p>
<p>用户方式同步的优点是它的 同步速度非常快。但它也有其局限性。</p>
<h2 id="线程同步方式比较"><a href="#线程同步方式比较" class="headerlink" title="线程同步方式比较"></a><a href="https://www.cnblogs.com/raichen/p/5768752.html" target="_blank" rel="noopener">线程同步方式比较</a></h2><h2 id="windows-多线程：-CreateThread、-beginthread、-beginthreadex、AfxBeginThread-的区别"><a href="#windows-多线程：-CreateThread、-beginthread、-beginthreadex、AfxBeginThread-的区别" class="headerlink" title="windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别"></a><a href="http://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022036.html" target="_blank" rel="noopener">windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别</a></h2><h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><h1 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a>线程同步：</h1><p>线程可分为UI线程，工作者线程</p>
<ul>
<li>临界区(Critical Section)</li>
<li>互斥量(Mutex)、互斥对象</li>
<li>信号量(Semaphore)</li>
<li>事件(Event)</li>
<li>读写锁shared_mutex、shared_lock、unique_lock</li>
<li>可等待定时器</li>
<li>原子锁</li>
<li>条件变量</li>
<li>线程池threadpool</li>
<li>生产者-消费者</li>
<li>期货future</li>
</ul>
<h1 id="进程间的同步"><a href="#进程间的同步" class="headerlink" title="进程间的同步"></a>进程间的同步</h1><p>windows和linux共有的进程间通信方式：1. 消息（linux中叫做信号） 2. 共享内存  3. 邮槽  4. 管道   5.socket</p>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>文件映射</li>
<li>共享内存（是文件映射的一种特殊情况）</li>
<li>邮件槽（mailslot）（点对点消息队列）CreateMailSlot</li>
<li>命名管道 createNamePipe   connectNamePipe</li>
<li>匿名管道</li>
<li>剪贴板</li>
<li>动态数据交换DDE</li>
<li>对象链接与嵌入OLE</li>
<li>远程过程调用RPC</li>
<li>动态链接库DLL</li>
<li>Socket</li>
<li>WM_COPYDATA 消息</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li>无名管道Pipe</li>
<li>信号量semaphore</li>
<li>共享内存</li>
<li>消息队列、报文队列</li>
<li>套接字</li>
<li>信号Signal</li>
<li>D-Bus主要概念是总线</li>
</ul>
<p>windows和linux共有的进程间通信方式：1. 消息（linux中叫做信号） 2. 共享内存  3. 邮槽  4. 管道   5.socket</p>
<h2 id="其他总结："><a href="#其他总结：" class="headerlink" title="其他总结："></a>其他总结：</h2><p>Unix和windows进程间通信的主要方式</p>
<p>　　linux系统IPC：<br>　　管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>　　命名管道 (named pipe) ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>　　信号量( semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>　　消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>　　信号 ( sinal )：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>　　共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>　　套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
<p>　　windows系统IPC：<br>　　剪贴板(Clipboard)：当用户在应用程序中执行剪切或复制操作时，应用程序将选定的数据以一个或多个标准或应用程序定义的格式放在剪贴板中。</p>
<p>　　WM_COPYDATA消息：当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage函数， 接收方只需像处理其它消息那样处理WM_COPYDATA消息，这样收发双方就实现了数据共享，它在底层实际上是通过文件映射来实现的。</p>
<p>　　文件映射(File Mapping )：使进程把文件内容当作进程地址区间一块内存那样来对待。只需简单的指针操作就可读取和修改文件的内容。 允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针，通过使用这些指针，不同进程就可以读写文件的内容，实现了对文件中数据的共享。</p>
<p>　　共享内存(Shared Memory)是文件映射的一种特殊情况进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的， 所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。</p>
<p>　　动态数据交换(DDE)：是使用共享内存在应用程序之间进行数据交换的一种进程间通信形式。应用程序可以使用DDE进行一次性数据传输，也可以当出现新数据时， 通过发送更新值在应用程序间动态交换数据。DDE和剪贴板一样既支持标准数据格式(如文本、位图等)，又可以支持自己定义的数据格式。但它们的数据传输机制却不同，一个明显区别是剪贴板操作几乎总是用作对用户指定操作的一次性应答，如从菜单中选择Paste命令。尽管DDE也可以由用户启动，但它继续发挥作用一般不必用户进一步干预。可以发生在单机或网络中不同计算机的应用程序之间。</p>
<p>　　邮件槽(Mailslot)：提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个 邮件槽实现进程间的双向通信。</p>
<p>　　管道( pipe )：同上linux系统 &amp; 命名管道</p>
<p>　　套接字（Sockets ）：同上linux系统</p>
<p><a href="https://www.cnblogs.com/findumars/p/6329593.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6329593.html</a></p>
<p><a href="http://blog.163.com/laylau_ll/blog/static/178625909201173131345423/" target="_blank" rel="noopener">http://blog.163.com/laylau_ll/blog/static/178625909201173131345423/</a></p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程，又称微线程，纤程。</p>
<p>Boost.Coroutine</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>原子库为细粒度的原子操作提供组件，允许无锁并发编程。</p>
<p><a href="http://zh.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/atomic</a></p>
<h1 id="Win32多线程程序设计中关键函数"><a href="#Win32多线程程序设计中关键函数" class="headerlink" title="Win32多线程程序设计中关键函数"></a>Win32多线程程序设计中关键函数</h1><ul>
<li>_beginthread</li>
<li>_beginthreadex</li>
<li>_endthread</li>
<li>_endthreadex</li>
<li>AfxBeginThread</li>
<li>CloseHandle</li>
<li>CoInitializeEx</li>
<li>CreateEvent</li>
<li>CreateFile</li>
<li>CreateFileMapping</li>
<li>CreateIoCompletionPort</li>
<li>CreateMutex</li>
<li>CreateSemaphore</li>
<li>CreateThread</li>
<li>DeleteCriticalSection</li>
<li>DisableThreadLibraryCalls</li>
<li>EnterCriticalSection</li>
<li>ExitThread</li>
<li>FileIOCompletionRoutine</li>
<li>GetExitCodeThread</li>
<li>GetQueuedCompletionStatus</li>
<li>GetStdHandle</li>
<li>GetThreadPriority</li>
<li>InitializeCriticalSection</li>
<li>InterlockedDecrement</li>
<li>InterlockedExchange</li>
<li>InterlockedIncrement</li>
<li>LeaveCriticalSection</li>
<li>MapViewOfFile</li>
<li>MsgWaitForMultipleObjects</li>
<li>MsgWaitForMultipleObjectsEx</li>
<li>MsgWaitForMultipleObjects</li>
<li>OpenFileMapping</li>
<li>PostThreadMessage</li>
<li>ReadFile</li>
<li>ReadFileEx</li>
<li>ReleaseMutex</li>
<li>ReleaseSemaphore</li>
<li>ReplyMessage</li>
<li>ResumeThread</li>
<li>SetThreadPriority</li>
<li>SleepEx</li>
<li>SuspendThread</li>
<li>TerminateThread</li>
<li>TlsAlloc</li>
<li>TlsFree</li>
<li>TlsGetValue</li>
<li>TlsSetValue</li>
<li>UnmapViewOfFile</li>
<li>GetOverlappedResult</li>
<li>WaitForMultipleObjects</li>
<li>WaitForMultipleObjectsEx</li>
<li>WaitForSingleObject</li>
<li>WaitForSingleObjectEx</li>
<li>WriteFile</li>
<li>WriteFileEx</li>
</ul>
<h1 id="C-11线程"><a href="#C-11线程" class="headerlink" title="C++11线程"></a>C++11线程</h1><p><a href="http://zh.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/thread</a></p>
<p><a href="https://blog.csdn.net/jiange_zh/article/details/51602938" target="_blank" rel="noopener">C++11 多线程 future/promise简介</a></p>
<h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h2><p>std::async大概的工作过程：先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果。</p>
<p>可以说，std::async帮我们将std::future、std::promise和std::packaged_task三者结合了起来。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="一个-Linux-上分析死锁的简单方法"><a href="#一个-Linux-上分析死锁的简单方法" class="headerlink" title="一个 Linux 上分析死锁的简单方法"></a><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-deadlock/index.html" target="_blank" rel="noopener">一个 Linux 上分析死锁的简单方法</a></h3><p>产生死锁的四个必要条件</p>
<ul>
<li>（1） 互斥条件：一个资源每次只能被一个进程（线程）使用。</li>
<li>（2） 请求与保持条件：一个进程（线程）因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>（3） 不剥夺条件 : 此进程（线程）已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>（4） 循环等待条件 : 多个进程（线程）之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>使用 pstack 和 gdb 工具对死锁程序进行分析</p>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><h3 id="LockCop"><a href="#LockCop" class="headerlink" title="LockCop"></a>LockCop</h3><p>LockCop通过下载Windows核心编程的源码编译可以得到</p>
<p> 多线程程序开发过程中，最难的是对多线程的调试和逻辑分析，特别是与锁相关的缺陷分析，比如：死锁和无限等待。为此，微乳提供了一套API，从系统层面来辅助开发者分析各个线程的运行状态（running or blocking）和线程与锁的等待关系，这就是：Wait Chain Tranversal。</p>
<p>Windows核心编程》也提供了Lockcop.exe和badlock.exe这一对示例来演示WCT</p>
<h4 id="WCT"><a href="#WCT" class="headerlink" title="WCT"></a>WCT</h4><p>要检索一个或多个线程的等待链，请使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-openthreadwaitchainsession" target="_blank" rel="noopener">OpenThreadWaitChainSession</a>和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-getthreadwaitchain" target="_blank" rel="noopener">GetThreadWaitChain</a>函数创建WCT会话。WCT会话由HWCT类型的句柄表示。会话本质上可以是同步的，也可以是异步的。同步会话将阻止调用线程，直到检索到等待链。无法取消同步会话。异步会话不会阻塞调用线程，并且可以使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-closethreadwaitchainsession" target="_blank" rel="noopener">CloseThreadWaitChainSession</a>函数由应用程序取消。异步操作的结果通过应用程序提供的<a href="https://msdn.microsoft.com/en-us/library/ms681421(v=VS.85" target="_blank" rel="noopener">WaitChainCallback</a>.aspx)回调函数提供。</p>
<p>对于异步会话，调用者可以通过<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-getthreadwaitchain" target="_blank" rel="noopener">GetThreadWaitChain</a>指定指向上下文数据结构的指针。相同的指针传递给回调函数。该上下文数据结构是用户定义的并且对WCT不透明。应用程序可以使用它来在WCT查询和回调函数之间传递上下文。一种常见的方法是通过此结构传递事件句柄; 执行回调时，它会发出此事件的信号，并通知某个监控线程查询已完成。</p>
<p><a href="https://msdn.microsoft.com/en-us/library/cc308564.aspx" target="_blank" rel="noopener">Developing with Wait Chain Traversal</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000006232497" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006232497</a></p>
<p><a href="http://www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php" target="_blank" rel="noopener">http://www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php</a></p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul>
<li>Win32多线程程序设计</li>
<li>Windows核心编程</li>
<li>C++并发编程</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">并发</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">多线程</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">同步</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">并行</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/30/进程、线程、同步、并发/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-IO模型" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/IO模型/">IO模型</a>
    </h1>
  

        
        <a href="/2018/05/30/IO模型/" class="archive-article-date">
  	<time datetime="2018-05-30T06:20:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-30</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><ul>
<li>阻塞（blocking）模型</li>
<li>选择（select）模型</li>
<li>WSAAsyncSelect模型</li>
<li>WSAEventSelect 模型</li>
</ul>
<p>函数:WSAEventSelect 、WSAWaitForMultipleEvents、WSAEnumNetworkEvents </p>
<ul>
<li>重叠（overlapped）模型</li>
</ul>
<p>overlapped I/O是Win32的一项技术</p>
<p>函数：WSAGetOverlappedResult </p>
<ul>
<li>完成端口（completion port）模型</li>
</ul>
<p>函数：CreateIoCompletionPort、GetQueuedCompletionStatus</p>
<ul>
<li><p>内核对象</p>
<p>  Windows提供了几种内核对象可以处于已通知状态和未通知状态：进程、线程、作业、文件、控制台输入/输出/错误流、事件、等待定时器、信号量、互斥对象。</p>
</li>
</ul>
<p>函数：WaitForSingleObject与WaitForMultipleObjects</p>
<ul>
<li>线程池 + 完成端口</li>
</ul>
<p>函数：CreateThreadpoolIo，StartThreadpoolIo，CloseThreadpoolIo</p>
<p><a href="https://blog.csdn.net/column/details/windowssocketbyiter.html" target="_blank" rel="noopener">windows socket 网络编程系列</a></p>
<p>Select(选择)</p>
<p>WSAAsyncSelect(异步选择)</p>
<p>WSAEventSelect(事件选择)</p>
<p>Overlapped(重叠IO)-事件通知</p>
<p>IOCP Completion port(完成端口) </p>
<p><a href="https://my.oschina.net/zengjs275/blog/524145" target="_blank" rel="noopener">关于网络编程六种IO模型的形象比喻</a></p>
<p><a href="https://blog.csdn.net/ithzhang/article/details/8508161" target="_blank" rel="noopener">《Windows核心编程系列》十异步IO之IO完成端口</a></p>
<p><a href="https://blog.csdn.net/ithzhang/article/details/8316171" target="_blank" rel="noopener">《Windows核心编程系列》十谈谈﻿﻿﻿﻿同步设备IO与异步设备IO之异步IO</a></p>
<p><a href="https://blog.csdn.net/ithzhang/article/details/8307633" target="_blank" rel="noopener">《Windows核心编程系列》九谈谈同步设备IO与异步设备IO之同步设备IO</a></p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>select、kqueue、poll/epoll、overlapped I/O等</p>
<p><a href="https://blog.csdn.net/shallwake/article/details/5265287" target="_blank" rel="noopener">再谈select, iocp, epoll,kqueue及各种I/O复用机制</a></p>
<p>那么，为什么epoll,kqueue比select高级？ </p>
<p>答案是，他们无轮询。因为他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p>ASIO:</p>
<p>“C++的I/O框架，逐渐成为Boost库的一部分。it’s like ACE updated for the STL era。”</p>
<p>支持select、epoll、IOCP等IO模型；</p>
<p>libevent:</p>
<p>由Niels Provos用C编写的一个轻量级的I/O框架。它支持kqueue和select、poll和epoll。</p>
<p>广为人知的有ACE,Libevent这些，他们都是跨平台的，而且他们自动选择最优的I/O复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。</p>
<p>Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。</p>
<p>Reactor: </p>
<p>libevent/libev/libuv/ZeroMQ/Event Library in Redis</p>
<p>Proactor</p>
<p>IOCP/Boost.Asio</p>
<p>linux下还是Reactor把, 没有os支持, Proactor玩不转.</p>
<p><a href="https://segmentfault.com/a/1190000002715832" target="_blank" rel="noopener">IO设计模式：Reactor和Proactor对比</a></p>
<p><a href="https://blog.csdn.net/chen8238065/article/details/48315085" target="_blank" rel="noopener">关于同步，异步，阻塞，非阻塞，IOCP/epoll,select/poll,AIO ,NIO ,BIO的总结</a></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://www.jianshu.com/p/5cf67fab6d61" target="_blank" rel="noopener">https://www.jianshu.com/p/5cf67fab6d61</a></p>
<p><a href="https://blog.csdn.net/HQ354974212/article/details/76423050?locationNum=2&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/HQ354974212/article/details/76423050?locationNum=2&amp;fps=1</a></p>
<p><a href="https://blog.csdn.net/zj510/article/details/44652923" target="_blank" rel="noopener">https://blog.csdn.net/zj510/article/details/44652923</a></p>
<p><a href="https://blog.csdn.net/u010807583/article/details/52433159" target="_blank" rel="noopener">https://blog.csdn.net/u010807583/article/details/52433159</a></p>
<p><a href="https://blog.csdn.net/zhangzeyuaaa/article/details/42609723" target="_blank" rel="noopener">https://blog.csdn.net/zhangzeyuaaa/article/details/42609723</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">IO模型</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/30/IO模型/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Socket" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/28/Socket/">Socket</a>
    </h1>
  

        
        <a href="/2018/05/28/Socket/" class="archive-article-date">
  	<time datetime="2018-05-28T07:59:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://i.imgur.com/0AuPUYT.jpg" alt=""></p>
<p><img src="https://i.imgur.com/DVPu7GN.jpg" alt=""></p>
<h1 id="使用-Socket-通信实现-FTP-客户端程序-转载"><a href="#使用-Socket-通信实现-FTP-客户端程序-转载" class="headerlink" title="使用 Socket 通信实现 FTP 客户端程序 - 转载"></a><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/index.html" target="_blank" rel="noopener">使用 Socket 通信实现 FTP 客户端程序</a> - 转载</h1><h2 id="FTP-协议"><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h2><p>相比其他协议，如 HTTP 协议，FTP 协议要复杂一些。与一般的 C/S 应用不同点在于一般的C/S 应用程序一般只会建立一个 Socket 连接，这个连接同时处理服务器端和客户端的连接命令和数据传输。而FTP协议中将命令与数据分开传送的方法提高了效率。</p>
<p>FTP 使用 2 个端口，一个数据端口和一个命令端口（也叫做控制端口）。这两个端口一般是21 （命令端口）和 20 （数据端口）。控制 Socket 用来传送命令，数据 Socket 是用于传送数据。每一个 FTP 命令发送之后，FTP 服务器都会返回一个字符串，其中包括一个响应代码和一些说明信息。其中的返回码主要是用于判断命令是否被成功执行了。</p>
<h2 id="数据端口"><a href="#数据端口" class="headerlink" title="数据端口"></a>数据端口</h2><p>对于有数据传输的操作，主要是显示目录列表，上传、下载文件，我们需要依靠另一个 Socket来完成。</p>
<p>如果使用被动模式，通常服务器端会返回一个端口号。客户端需要用另开一个 Socket 来连接这个端口，然后我们可根据操作来发送命令，数据会通过新开的一个端口传输。</p>
<p>如果使用主动模式，通常客户端会发送一个端口号给服务器端，并在这个端口监听。服务器需要连接到客户端开启的这个数据端口，并进行数据的传输。</p>
<h2 id="主动模式-PORT"><a href="#主动模式-PORT" class="headerlink" title="主动模式 (PORT)"></a>主动模式 (PORT)</h2><p>主动模式下，客户端随机打开一个大于 1024 的端口向服务器的命令端口 P，即 21 端口，发起连接，同时开放N +1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从它自己的数据端口 (20) 主动连接到客户端指定的数据端口 (N+1)。</p>
<p>FTP 的客户端只是告诉服务器自己的端口号，让服务器来连接客户端指定的端口。对于客户端的防火墙来说，这是从外部到内部的连接，可能会被阻塞。</p>
<h2 id="被动模式-PASV"><a href="#被动模式-PASV" class="headerlink" title="被动模式 (PASV)"></a>被动模式 (PASV)</h2><p>为了解决服务器发起到客户的连接问题，有了另一种 FTP 连接方式，即被动方式。命令连接和数据连接都由客户端发起，这样就解决了从服务器到客户端的数据端口的连接被防火墙过滤的问题。</p>
<p>被动模式下，当开启一个 FTP 连接时，客户端打开两个任意的本地端口 (N &gt; 1024 和 N+1) 。</p>
<p>第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 (P &gt; 1024 )，返回如“227 entering passive mode (127,0,0,1,4,18)”。 它返回了 227 开头的信息，在括号中有以逗号隔开的六个数字，前四个指服务器的地址，最后两个，将倒数第二个乘 256 再加上最后一个数字，这就是 FTP 服务器开放的用来进行数据传输的端口。如得到 227 entering passive mode (h1,h2,h3,h4,p1,p2)，那么端口号是 p1*256+p2，ip 地址为h1.h2.h3.h4。这意味着在服务器上有一个端口被开放。客户端收到命令取得端口号之后, 会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。</p>
<h2 id="主要用到的-FTP-命令"><a href="#主要用到的-FTP-命令" class="headerlink" title="主要用到的 FTP 命令"></a>主要用到的 FTP 命令</h2><p>FTP 每个命令都有 3 到 4 个字母组成，命令后面跟参数，用空格分开。每个命令都以 “\r\n”结束。</p>
<p>要下载或上传一个文件，首先要登入 FTP 服务器，然后发送命令，最后退出。这个过程中，主要用到的命令有 USER、PASS、SIZE、REST、CWD、RETR、PASV、PORT、QUIT。</p>
<p>USER: 指定用户名。通常是控制连接后第一个发出的命令。“USER gaoleyi\r\n”： 用户名为gaoleyi 登录。</p>
<p>PASS: 指定用户密码。该命令紧跟 USER 命令后。“PASS gaoleyi\r\n”：密码为 gaoleyi。</p>
<p>SIZE: 从服务器上返回指定文件的大小。“SIZE file.txt\r\n”：如果 file.txt 文件存在，则返回该文件的大小。</p>
<p>CWD: 改变工作目录。如：“CWD dirname\r\n”。</p>
<p>PASV: 让服务器在数据端口监听，进入被动模式。如：“PASV\r\n”。</p>
<p>PORT: 告诉 FTP 服务器客户端监听的端口号，让 FTP 服务器采用主动模式连接客户端。如：“PORT h1,h2,h3,h4,p1,p2”。</p>
<p>RETR: 下载文件。“RETR file.txt \r\n”：下载文件 file.txt。</p>
<p>STOR: 上传文件。“STOR file.txt\r\n”：上传文件 file.txt。</p>
<p>REST: 该命令并不传送文件，而是略过指定点后的数据。此命令后应该跟其它要求文件传输的 FTP 命令。“REST 100\r\n”：重新指定文件传送的偏移量为 100 字节。</p>
<p>QUIT: 关闭与服务器的连接。</p>
<h2 id="FTP-响应码"><a href="#FTP-响应码" class="headerlink" title="FTP 响应码"></a>FTP 响应码</h2><p>客户端发送 FTP 命令后，服务器返回响应码。</p>
<p>响应码用三位数字编码表示：</p>
<p>第一个数字给出了命令状态的一般性指示，比如响应成功、失败或不完整。</p>
<p>第二个数字是响应类型的分类，如 2 代表跟连接有关的响应，3 代表用户认证。</p>
<p>第三个数字提供了更加详细的信息。</p>
<p>第一个数字的含义如下：</p>
<p>1 表示服务器正确接收信息，还未处理。</p>
<p>2 表示服务器已经正确处理信息。</p>
<p>3 表示服务器正确接收信息，正在处理。</p>
<p>4 表示信息暂时错误。</p>
<p>5 表示信息永久错误。</p>
<p>第二个数字的含义如下：</p>
<p>0 表示语法。</p>
<p>1 表示系统状态和信息。</p>
<p>2 表示连接状态。</p>
<p>3 表示与用户认证有关的信息。</p>
<p>4 表示未定义。</p>
<p>5 表示与文件系统有关的信息。</p>
<h2 id="Socket-编程的几个重要步骤"><a href="#Socket-编程的几个重要步骤" class="headerlink" title="Socket 编程的几个重要步骤"></a>Socket 编程的几个重要步骤</h2><p>Socket 客户端编程主要步骤如下：</p>
<ul>
<li>socket() 创建一个 Socket</li>
<li>connect() 与服务器连接</li>
<li>write() 和 read() 进行会话</li>
<li>close() 关闭 Socket</li>
</ul>
<p>Socket 服务器端编程主要步骤如下：</p>
<ul>
<li>socket() 创建一个 Socket</li>
<li>bind()</li>
<li>listen() 监听</li>
<li>accept() 接收连接的请求</li>
<li>write() 和 read() 进行会话</li>
<li>close() 关闭 Socket</li>
</ul>
<h2 id="实现-FTP-客户端上传下载功能"><a href="#实现-FTP-客户端上传下载功能" class="headerlink" title="实现 FTP 客户端上传下载功能"></a>实现 FTP 客户端上传下载功能</h2><p>下面让我们通过一个例子来对 FTP 客户端有一个深入的了解。本文实现的 FTP 客户端有下列功能：</p>
<ul>
<li>客户端和 FTP 服务器建立 Socket 连接。</li>
<li>向服务器发送 USER、PASS 命令登录 FTP 服务器。</li>
<li>使用 PASV 命令得到服务器监听的端口号，建立数据连接。</li>
<li>使用 RETR/STOR 命令下载/上传文件。</li>
<li>在下载完毕后断开数据连接并发送 QUIT 命令退出。</li>
</ul>
<p>本例中使用的 FTP 服务器为 filezilla。在整个交互的过程中，控制连接始终处于连接的状态，数据连接在每传输一个文件时先打开，后关闭。</p>
<h3 id="客户端和-FTP-服务器建立-Socket-连接"><a href="#客户端和-FTP-服务器建立-Socket-连接" class="headerlink" title="客户端和 FTP 服务器建立 Socket 连接"></a>客户端和 FTP 服务器建立 Socket 连接</h3><p>当客户端与服务器建立连接后，服务器会返回 220 的响应码和一些欢迎信息。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image001.jpg" alt=""></p>
<p> 客户端连接到 FTP 服务器，接收欢迎信息</p>
<pre><code>SOCKET control_sock;
struct hostent *hp;
struct sockaddr_in server;
memset(&amp;server, 0, sizeof(struct sockaddr_in));

/* 初始化socket */
control_sock = socket(AF_INET, SOCK_STREAM, 0);
hp = gethostbyname(server_name);
memcpy(&amp;server.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
server.sin_family = AF_INET;
server.sin_port = htons(port);

/* 连接到服务器端 */
connect(control_sock,(struct sockaddr *)&amp;server, sizeof(server));
/* 客户端接收服务器端的一些欢迎信息 */
read(control_sock, read_buf, read_len);
</code></pre><h3 id="客户端登录-FTP-服务器"><a href="#客户端登录-FTP-服务器" class="headerlink" title="客户端登录 FTP 服务器"></a>客户端登录 FTP 服务器</h3><p>当客户端发送用户名和密码，服务器验证通过后，会返回 230 的响应码。然后客户端就可以向服务器端发送命令了。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image002.jpg" alt=""></p>
<pre><code>客户端发送用户名和密码，登入 FTP 服务器

/* 命令 ”USER username\r\n” */
sprintf(send_buf,&quot;USER %s\r\n&quot;,username);
/*客户端发送用户名到服务器端 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”331 User name okay, need password.” */
read(control_sock, read_buf, read_len);

/* 命令 ”PASS password\r\n” */
sprintf(send_buf,&quot;PASS %s\r\n&quot;,password);
/* 客户端发送密码到服务器端 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”230 User logged in, proceed.” */
read(control_sock, read_buf, read_len);
</code></pre><h3 id="客户端让-FTP-服务器进入被动模式"><a href="#客户端让-FTP-服务器进入被动模式" class="headerlink" title="客户端让 FTP 服务器进入被动模式"></a>客户端让 FTP 服务器进入被动模式</h3><p>当客户端在下载/上传文件前，要先发送命令让服务器进入被动模式。服务器会打开数据端口并监听。并返回响应码 227 和数据连接的端口号。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image003.jpg" alt=""></p>
<p>让服务器进入被动模式，在数据端口监听</p>
<pre><code>/* 命令 ”PASV\r\n” */
sprintf(send_buf,&quot;PASV\r\n&quot;);
/* 客户端告诉服务器用被动模式 */
write(control_sock, send_buf, strlen(send_buf));
/*客户端接收服务器的响应码和新开的端口号，
* 正常为 ”227 Entering passive mode (&lt;h1,h2,h3,h4,p1,p2&gt;)” */
read(control_sock, read_buf, read_len);
</code></pre><h3 id="客户端通过被动模式下载文件"><a href="#客户端通过被动模式下载文件" class="headerlink" title="客户端通过被动模式下载文件"></a>客户端通过被动模式下载文件</h3><p>当客户端发送命令下载文件。服务器会返回响应码 150，并向数据连接发送文件内容。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image004.jpg" alt=""></p>
<p>客户端连接到 FTP 服务器的数据端口并下载文件</p>
<pre><code>/* 连接服务器新开的数据端口 */
connect(data_sock,(struct sockaddr *)&amp;server, sizeof(server));
/* 命令 ”CWD dirname\r\n” */
sprintf(send_buf,&quot;CWD %s\r\n&quot;, dirname);
/* 客户端发送命令改变工作目录 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”250 Command okay.” */
read(control_sock, read_buf, read_len);

/* 命令 ”SIZE filename\r\n” */
sprintf(send_buf,&quot;SIZE %s\r\n&quot;,filename);
/* 客户端发送命令从服务器端得到下载文件的大小 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”213 &lt;size&gt;” */
read(control_sock, read_buf, read_len);

/* 命令 ”RETR filename\r\n” */
sprintf(send_buf,&quot;RETR %s\r\n&quot;,filename);
/* 客户端发送命令从服务器端下载文件 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”150 Opening data connection.” */
read(control_sock, read_buf, read_len);

/* 客户端创建文件 */
file_handle = open(disk_name, CRFLAGS, RWXALL);
for( ; ; ) {
... ...
/* 客户端通过数据连接 从服务器接收文件内容 */
read(data_sock, read_buf, read_len);
/* 客户端写文件 */
write(file_handle, read_buf, read_len);
... ... 
}
/* 客户端关闭文件 */
rc = close(file_handle);
</code></pre><h3 id="客户端退出服务器"><a href="#客户端退出服务器" class="headerlink" title="客户端退出服务器"></a>客户端退出服务器</h3><p>当客户端下载完毕后，发送命令退出服务器，并关闭连接。服务器会返回响应码 200。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image005.jpg" alt=""></p>
<p>客户端关闭数据连接,退出 FTP 服务器并关闭控制连接</p>
<pre><code>/* 客户端关闭数据连接 */
close(data_sock);
/* 客户端接收服务器的响应码和信息，正常为 ”226 Transfer complete.” */
read(control_sock, read_buf, read_len);

/* 命令 ”QUIT\r\n” */
sprintf(send_buf,&quot;QUIT\r\n&quot;);
/* 客户端将断开与服务器端的连接 */
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码，正常为 ”200 Closes connection.” */
read(control_sock, read_buf, read_len);
/* 客户端关闭控制连接 */
close(control_sock);
</code></pre><p>至此，下载文件已经完成。需要注意的是发送 FTP 命令的时候，在命令后要紧跟 “\r\n”,否则服务器不会返回信息。回车换行符号 “\r\n” 是 FTP 命令的结尾符号，当服务器接收到这个符号时，认为客户端发送的命令已经结束，开始处理。否则会继续等待。</p>
<p>让我们来看一下 FTP 服务器这一端的响应情况：</p>
<p>客户端下载文件时，FTP 服务器的响应输出</p>
<pre><code>(not logged in) (127.0.0.1)&gt; Connected, sending welcome message...
(not logged in) (127.0.0.1)&gt; 220-FileZilla Server version 0.9.36 beta
(not logged in) (127.0.0.1)&gt; 220 hello gaoleyi
(not logged in) (127.0.0.1)&gt; USER gaoleyi
(not logged in) (127.0.0.1)&gt; 331 Password required for gaoleyi
(not logged in) (127.0.0.1)&gt; PASS *********
gaoleyi (127.0.0.1)&gt; 230 Logged on
gaoleyi (127.0.0.1)&gt; PWD 
gaoleyi (127.0.0.1)&gt; 257 &quot;/&quot; is current directory.
gaoleyi (127.0.0.1)&gt; SIZE file.txt
gaoleyi (127.0.0.1)&gt; 213 4096
gaoleyi (127.0.0.1)&gt; PASV
gaoleyi (127.0.0.1)&gt; 227 Entering Passive Mode (127,0,0,1,13,67)
gaoleyi (127.0.0.1)&gt; RETR file.txt
gaoleyi (127.0.0.1)&gt; 150 Connection accepted
gaoleyi (127.0.0.1)&gt; 226 Transfer OK
gaoleyi (127.0.0.1)&gt; QUIT
gaoleyi (127.0.0.1)&gt; 221 Goodbye
</code></pre><p>首先，服务器准备就绪后返回 220。客户端接收到服务器端返回的响应码后，相继发送“USER username” 和 “PASS password” 命令登录。随后，服务器返回的响应码为 230 开头，说明客户端已经登入了。这时，客户端发送 PASV 命令让服务器进入被动模式。服务器返回如 “227 Entering Passive Mode (127,0,0,1,13,67)”，客户端从中得到端口号，然后连接到服务器的数据端口。接下来，客户端发送下载命令，服务器会返回响应码 150，并从数据端口发送数据。最后，服务器返回 “226 transfer complete”，表明数据传输完成。</p>
<p>需要注意的是，客户端不要一次发送多条命令，例如我们要打开一个目录并且显示这个目录，我们得发送 CWD dirname，PASV，LIST。在发送完 CWD dirname 之后等待响应代码，然后再发送后面一条。当 PASV 返回之后，我们打开另一个 Socket 连接到相关端口上。然后发送 LIST，返回 125 之后在开始接收数据，最后返回 226 表明完成。</p>
<p>在传输多个文件的过程中，需要注意的是每次新的传输都必须重新使用 PASV 获取新的端口号，接收完数据后应该关闭该数据连接，这样服务器才会返回一个 2XX 成功的响应。然后客户端可以继续下一个文件的传输。</p>
<p>上传文件与下载文件相比，登入验证和切换被动模式都如出一辙，只需要改变发送到服务器端的命令，并通过数据连接发送文件内容。</p>
<h3 id="客户端通过被动模式向服务器上传文件"><a href="#客户端通过被动模式向服务器上传文件" class="headerlink" title="客户端通过被动模式向服务器上传文件"></a>客户端通过被动模式向服务器上传文件</h3><p>当客户端发送命令上传文件，服务器会从数据连接接收文件。</p>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image006.jpg" alt=""></p>
<h3 id="客户端通过主动模式向服务器上传文件"><a href="#客户端通过主动模式向服务器上传文件" class="headerlink" title="客户端通过主动模式向服务器上传文件"></a>客户端通过主动模式向服务器上传文件</h3><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/image007.jpg" alt=""></p>
<pre><code>SOCKET data_sock;
data_sock = socket(AF_INET, SOCK_STREAM, 0);
struct  sockaddr_in  name;
name.sin_family = AF_INET;
name.sin_addr.s_addr = htons(INADDR_ANY);
server_port = p1*256+p2;
length = sizeof(name);
name.sin_port = htons(server_port);
bind(server_sock, (struct sockaddr *)&amp;name, length);
struct  sockaddr_in client_name;
length = sizeof(client_name);

/* 客户端开始监听端口p1*256+p2 */
listen(server_sock, 64); 

/* 命令 ”PORT \r\n” */
sprintf(send_buf,&quot;PORT 1287,0,0,1,%d,%d\r\n&quot;, p1, p2);
write(control_sock, send_buf,strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”200 Port command successful” */
read(control_sock, read_buf, read_len);

sprintf(send_buf,&quot;RETR filename.txt\r\n&quot;);
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，正常为 ”150 Opening data channel for file transfer.” */
read(control_sock, read_buf, read_len);

/* ftp客户端接受服务器端的连接请求 */
data_sock = accept(server_sock,(struct sockaddr *)&amp;client_name, &amp;length);
... ...

file_handle = open(disk_name, ROFLAGS, RWXALL);
for( ; ; ) {
... ...
read(data_sock, read_buf, read_len);
write(file_handle, read_buf, read_len);
... ... 
}
close(file_handle);
</code></pre><p>客户端通过 PORT 命令告诉服务器连接自己的 p1*256+p2 端口。随后在这个端口进行监听，等待 FTP 服务器连接上来， 再通过这个数据端口来传输文件。PORT 方式在传送数据时，FTP 客户端其实就相当于一个服务器端，由 FTP 服务器主动连接自己。</p>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>由于网络不稳定，在传输文件的过程中，可能会发生连接断开的情况，这时候需要客户端支持断点续传的功能，下次能够从上次终止的地方开始接着传送。需要使用命令 REST。如果在断开连接前，一个文件已经传输了 512 个字节。则断点续传开始的位置为 512，服务器会跳过传输文件的前 512 字节。</p>
<pre><code>... ...
/* 命令 ”REST offset\r\n” */
sprintf(send_buf,&quot;REST %ld\r\n&quot;, offset);
/* 客户端发送命令指定下载文件的偏移量 */
write(control_sock, send_buf, strlen(send_buf)); 
/* 客户端接收服务器的响应码和信息，
*正常为 ”350 Restarting at &lt;position&gt;. Send STORE or RETRIEVE to initiate transfer.” */
read(control_sock, read_buf, read_len); 
... ...

/* 命令 ”RETR filename\r\n” */
sprintf(send_buf,&quot;RETR %s\r\n&quot;,filename);
/* 客户端发送命令从服务器端下载文件, 并且跳过该文件的前offset字节*/
write(control_sock, send_buf, strlen(send_buf));
/* 客户端接收服务器的响应码和信息，*
*正常为 ”150 Connection accepted, restarting at offset &lt;position&gt;” */
read(control_sock, read_buf, read_len);
... ...

file_handle = open(disk_name, CRFLAGS, RWXALL);
/* 指向文件写入的初始位置 */
lseek(file_handle, offset, SEEK_SET);
... ...
</code></pre><p><a href="http://www.w3.org/Protocols/rfc959/" target="_blank" rel="noopener">FILE TRANSFER PROTOCOL (FTP)</a></p>
<p><a href="http://en.wikipedia.org/wiki/File_Transfer_Protocol" target="_blank" rel="noopener">FILE TRANSFER PROTOCOL</a></p>
<h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><p>《TCP/IP网络编程》</p>
<p>《Windows网络编程》</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Socket</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">FTP</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/28/Socket/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-COM" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/25/COM/">COM</a>
    </h1>
  

        
        <a href="/2018/05/25/COM/" class="archive-article-date">
  	<time datetime="2018-05-25T03:13:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-25</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开发ActiveX控件有两种方式，一是MFC,二是ATL,而后者是专门用于COM组件开发</p>
<h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><ul>
<li>Visual C++实践与提高-COM和COM+篇</li>
<li>COM原理与应用</li>
<li>COM技术内幕</li>
<li>COM本质论</li>
</ul>
<h1 id="网络教程"><a href="#网络教程" class="headerlink" title="网络教程"></a>网络教程</h1><p><a href="https://www.codeproject.com/Articles/633/Introduction-to-COM-What-It-Is-and-How-to-Use-It" target="_blank" rel="noopener">Introduction to COM - What It Is and How to Use It.</a></p>
<p><a href="https://www.codeproject.com/Articles/901/Introduction-to-COM-Part-II-Behind-the-Scenes-of-a" title="Introduction to COM Part II - Behind the Scenes of a COM Server" target="_blank" rel="noopener">https://www.codeproject.com/Articles/901/Introduction-to-COM-Part-II-Behind-the-Scenes-of-a</a></p>
<p><a href="https://blog.csdn.net/q5806622/article/category/2846441" title="https://blog.csdn.net/q5806622/article/category/2846441" target="_blank" rel="noopener">https://blog.csdn.net/q5806622/article/category/2846441</a></p>
<p><a href="https://www.cnblogs.com/hanford/p/6103069.html" title="COM组件（ATL篇）" target="_blank" rel="noopener">COM组件（ATL篇）</a></p>
<p><a href="http://www.cnblogs.com/hanford/p/6103127.html" title="ActiveX控件(ATL篇)" target="_blank" rel="noopener">ActiveX控件(ATL篇)</a></p>
<p><a href="http://www.cnblogs.com/hanford/p/6103047.html" title="COM组件（MFC篇）" target="_blank" rel="noopener">COM组件（MFC篇）</a></p>
<p><a href="http://www.cnblogs.com/hanford/p/6103111.html" title="ActiveX控件(MFC篇)" target="_blank" rel="noopener">ActiveX控件(MFC篇)</a></p>
<p><a href="https://blog.csdn.net/woshinia/article/details/22300089" title="C++ COM组件的编写" target="_blank" rel="noopener">https://blog.csdn.net/woshinia/article/details/22300089</a></p>
<p><a href="https://www.cnblogs.com/jyz/archive/2009/03/08/1406229.html" title="进程内COM与进程外COM" target="_blank" rel="noopener">https://www.cnblogs.com/jyz/archive/2009/03/08/1406229.html</a></p>
<p><a href="http://blog.e-works.net.cn/395307/articles/16044.html" title="C++ 类的动态组件化技术" target="_blank" rel="noopener">http://blog.e-works.net.cn/395307/articles/16044.html</a></p>
<p><a href="https://blog.csdn.net/q5806622/article/category/2846441" target="_blank" rel="noopener">COM/ActiveX</a></p>
<p><a href="https://blog.csdn.net/q5806622/article/details/43964673" target="_blank" rel="noopener">使用ATL开发COM组件</a></p>
<p><a href="https://blog.csdn.net/zj510/article/category/2510453" target="_blank" rel="noopener">https://blog.csdn.net/zj510/article/category/2510453</a></p>
<h1 id="ATL创建过程"><a href="#ATL创建过程" class="headerlink" title="ATL创建过程"></a>ATL创建过程</h1><p>运行VC++2010，新建”ATL Project”项目</p>
<p>ATL Simple Object 增加COM类</p>
<p>鼠标右键单击接口，弹出菜单中添加方法或属性</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="https://i.imgur.com/A3knAl9.jpg" alt=""></p>
<ul>
<li>方法<ul>
<li>参数特性<ul>
<li>in 指示一个参数从调用过程传入被调用过程</li>
<li>out 特性标示从被调用过程返回到调用过程(从服务器到客户端)的指针参数</li>
<li>retval 特性指定接收该成员的返回值的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[in]类型表明参数是一个输入参数，所以这个参数不会向外界返回结果 </p>
<p>[out]类型表明参数是个输出参数，所以这个参数会向外界返回结果,参数类型只能是指针类型</p>
<p>[out，retval]类型表明参数是个输出参数， retval 必须与 out 联用，并且在参数类表中只有最后一个参数可以被指定为 [out，retval] 属性，包装类会用这个参数的类型作为包装类方法的返回值</p>
<p>我们在 vc 中引入一个COM组件， vc 会分析 com 组件的类型库信息<br>假设有一个方法说明如下</p>
<p>[id(1), helpstring(“method Foo”)] HRESULT Foo([in] long lIn, [out] BSTR<em> bstrOut, [out,retval] BSTR</em> bstrResult);</p>
<p>那么vc生成的包装类的方法可能是</p>
<p>BSTR Foo(long lIn , BSTR&amp; bstrOut);</p>
<p>我们看到，由于 bstrResult 具有 [out,retval] 属性，所以生成的包装类的方法返回值不再是 HRESULT类型，而是 BSTR 类型，这样，包装类就会更加易于使用</p>
<p><a href="https://www.cnblogs.com/vedgtar/archive/2014/03/20/3613552.html" target="_blank" rel="noopener">COM 参数有in, out ,retval</a></p>
<p><a href="https://blog.csdn.net/only_endure/article/details/18698437" target="_blank" rel="noopener">[in][out][retval]</a></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><img src="https://i.imgur.com/lVsUaX2.jpg" alt=""></p>
<ul>
<li>属性<ul>
<li>函数类型<ul>
<li>Get</li>
<li>Put<ul>
<li>PropPut值传递</li>
<li>PropPutRef引用传递</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ATL代码"><a href="#ATL代码" class="headerlink" title="ATL代码"></a>ATL代码</h1><h2 id="ATL-NO-VTABLE"><a href="#ATL-NO-VTABLE" class="headerlink" title="ATL_NO_VTABLE"></a><code>ATL_NO_VTABLE</code></h2><p>ATL_NO_VTABLE可以让编译器不产生VTable，并且不设置VPointer的值。 基类虚函数表会被派生类覆盖掉，所以我们可以对基类使用 ATL_NO_VTABLE 避免产生虚函数表！    ATL是通过多重继承来实现COM组件的，继承层次中的每个类都有自己的虚函数表，所以在继承层次很深的情况下，虚函数表会变得非常宏大，如果用ATL_NO_VTABLE宏来阻止生成虚函数表，就会有限的减少组件的长度。</p>
<p>novtable不是去掉了虚函数表，要知道，虚函数表可是COM二进制复用的基础，怎么会去掉呢？这个宏，只是阻止了在多步构造对象时对虚函数表的调整。一般C++在构造一个派生类的时候，会从最初的祖先开始构造，这时该虚函数表指向最初的祖先的虚函数表，然后一步步构造派生类，虚函数表也不断的调整指向相应的派生类的虚函数表，这样能保证各个派生类构造时，调用的是该派生类实现的虚函数，ATL_NO_VTABLE只是阻止了这个过程，在构造过程中虚函数表没有做相应的调整，所以在构造函数中不能调用虚函数，以免产生错误的调用。</p>
<p><a href="https://www.cnblogs.com/weiqubo/archive/2011/03/16/1985773.html" target="_blank" rel="noopener">__declspec(novtable)作用</a></p>
<h2 id="CComObjectRootEx类"><a href="#CComObjectRootEx类" class="headerlink" title="CComObjectRootEx类"></a><a href="https://msdn.microsoft.com/en-us/library/8hzca2fs.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">CComObjectRootEx类</a></h2><p>线程模型,CComObjectRootEx类提供了处理非聚合和聚合对象的对象引用计数管理的方法。您可以通过设置ThreadModel为CComSingleThreadModel，CComMultiThreadModel或CComMultiThreadModelNoCS来明确选择线程模型。您可以通过设置ThreadModel为CComObjectThreadModel或CComGlobalsThreadModel来接受服务器的默认线程模型。</p>
<h2 id="接口映射表"><a href="#接口映射表" class="headerlink" title="接口映射表"></a>接口映射表</h2><p>ATL提供了<code>BEGIN_COM_MAP</code>、<code>END_COM_MAP</code>、<code>COM_INTERFACE_ENTRY</code>与<code>COM_INTERFACE_ENTRY2</code>这4个宏来创建接口映射表。</p>
<p><a href="https://blog.csdn.net/luckysym/article/details/625615" target="_blank" rel="noopener">COM接口映射表</a></p>
<h2 id="DECLARE-PROTECT-FINAL-CONSTRUCT"><a href="#DECLARE-PROTECT-FINAL-CONSTRUCT" class="headerlink" title="DECLARE_PROTECT_FINAL_CONSTRUCT"></a><code>DECLARE_PROTECT_FINAL_CONSTRUCT</code></h2><p><code>DECLARE_PROTECT_FINAL_CONSTRUCT    ()</code>    //内部聚合对象增加引用计数然后将计数减少到0，则保护您的对象不被删除。</p>
<pre><code>#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
void InternalFinalConstructAddRef() {InternalAddRef();}\
void InternalFinalConstructRelease() {InternalRelease();}
</code></pre><h2 id="禁用警告"><a href="#禁用警告" class="headerlink" title="禁用警告"></a>禁用警告</h2><pre><code>#define ATLPREFAST_SUPPRESS(x) __pragma(warning(push)) __pragma(warning(disable: x))
#define ATLPREFAST_UNSUPPRESS() __pragma(warning(pop))

#pragma warning（push）   
#pragma warning（disable：4705）   
#pragma warning（disable：4706）   
#pragma warning（disable：4707）   
//一些代码   
#pragma warning（pop）   
</code></pre><h2 id="深入解析C-编程中alignof-与uuidof运算符的使用"><a href="#深入解析C-编程中alignof-与uuidof运算符的使用" class="headerlink" title="深入解析C++编程中alignof 与uuidof运算符的使用"></a><a href="https://www.ctolib.com/topics-55778.html" target="_blank" rel="noopener">深入解析C++编程中<strong>alignof 与</strong>uuidof运算符的使用</a></h2><p><strong>alignof 运算符<br>C++11 引入 alignof 运算符，该运算符返回指定类型的对齐方式（以字节为单位）。为实现最大的可移植性，应使用 alignof 运算符，而不是特定于 Microsoft 的 </strong>alignof 运算符。<br>返回一个 size_t 类型的值，该值是类型的对齐要求。</p>
<p>__uuidof 运算符</p>
<p>检索 GUID 并附加到表达式。</p>
<h2 id="OBJECT-ENTRY-AUTO-uuidof-Statistic01-CStatistic01"><a href="#OBJECT-ENTRY-AUTO-uuidof-Statistic01-CStatistic01" class="headerlink" title="OBJECT_ENTRY_AUTO(__uuidof(Statistic01), CStatistic01)"></a><code>OBJECT_ENTRY_AUTO(__uuidof(Statistic01), CStatistic01)</code></h2><p><code>__uuidof</code> 运算符,检索 GUID 并附加到表达式。</p>
<p><code>OBJECT_ENTRY_AUTO</code> 将ATL对象输入对象映射，更新注册表，并创建对象的实例。</p>
<h2 id="IUnknown"><a href="#IUnknown" class="headerlink" title="IUnknown"></a>IUnknown</h2><p> IUnknown接口是COM的核心，因为所有其他的COM接口都必须从IUnknown继承。</p>
<pre><code>class IUnknown{
public:
     virtual HRESULT __stdcall QueryInterface(const IID&amp; iid, void** ppv) = 0;
     virtual ULONG __stdcall AddRef() = 0;
     virtual ULONG __stdcall Release() = 0;
};
</code></pre><h2 id="临界区类"><a href="#临界区类" class="headerlink" title="临界区类"></a>临界区类</h2><p>ATL将Windows临界区封装了一下，即CComCriticalSection和CComAutoCriticalSection类。</p>
<h1 id="类型库"><a href="#类型库" class="headerlink" title="类型库"></a>类型库</h1><p>作为C/C++程序员，要使用其他程序员编写的动态库或静态库，需要头文件。通过头文件，才能知道动态库或静态库里有什么函数，函数的参数、返回值情况……同样的，客户端程序要使用COM组件，也需要类似头文件功能的东西，这就是类型库。</p>
<p>可以编写文本格式的odl或idl文件，然后使用midl.exe将其编译为二进制的tlb文件——这就是类型库文件。</p>
<h1 id="Dual和Custom"><a href="#Dual和Custom" class="headerlink" title="Dual和Custom"></a>Dual和Custom</h1><p>接口：双重，自定义</p>
<p>实际上Custom接口是从IUnknown继承下来的，而Dual接口是从IDispatch继承下来的（IDispatch从IUnknown继承下来）。</p>
<p>Dual：接口同时支持IDispatch方式和vtable方式</p>
<p>vtable调用方式，指的是直接通过接口指针的虚函数表。比如</p>
<pre><code>CComPtr&lt;IMyCar&gt; spCar;  
spCar.CoCreateInstance(CLSID_MyCar, NULL, CLSCTX_INPROC_SERVER);  
spCar-&gt;Run();
</code></pre><p>Custom：没有支持IDispatch，只支持vtable。</p>
<p>如果是custom接口，那么只能通过vtable的方式了，就是通过接口指针来调用成员函数，而不能用IDispatch的invoke了。</p>
<p>那什么时候用Dual，什么时候用Custom呢？</p>
<p>当com组件只在C++里面被调用的时候，用custom；如果com组件可能被其他语言调用，那么就用dual。</p>
<p>另外，通过IDispatch::Invoke(),效率会比vtable调用方式低很多，因为它要经过很多转换。如果是C++调用环境，尽可能使用vtable的方式，如果是其他语言就没办法了，只能是IDispatch方式。</p>
<h1 id="COM线程模型"><a href="#COM线程模型" class="headerlink" title="COM线程模型"></a>COM线程模型</h1><h2 id="STA接口"><a href="#STA接口" class="headerlink" title="STA接口"></a><a href="https://blog.csdn.net/zj510/article/details/38824353" target="_blank" rel="noopener">STA接口</a></h2><p>STA的规则很简单，但是需要小心的遵守这些规则：</p>
<ul>
<li>每一个STA COM 对象只能存在于一个线程中 （在一个STA套间内）</li>
<li>每一个线程都需要初始化COM库</li>
<li>在套间之间传递com对象指针的时候，需要列集(marshal)</li>
<li>每一个STA套间必须拥有一个消息循环，用来处理从其他进程或者当前进程的其他套间过来的消息。（后面一句没有理解，就不翻译了，以免误导。）其实，我个人感觉如果一个STA套间创建了一个COM对象，只要这个COM对象不传递到其他线程，消息循环是可以省略的。但是如果COM对象需要传递到其他进程，那么就必须创建一个消息循环。</li>
<li>COM对象本身并不需要调用COM的初始化函数；相反，他们会把他们的线程模型放在注册表中的一个叫做InprocServer32的键下面。后面的也不是很了解。以后弄明白了再说。</li>
</ul>
<p>Apartment类型(单元)，也就是STA。</p>
<p>COM的线程模型，其实指的是两方面：一个是客户程序的线程模式，一个是组件所支持的线程模式。客户程序的线程模式只有两种，单线程公寓(STA)和多线程公寓(MTA)。组件所支持的线程模式有四种：Single(单线程)、Apartment(STA)、Free(MTA)、Both(STA+MTA)。</p>
<ul>
<li>STA客户程序调用STA COM组件</li>
<li>MTA客户程序调用STA COM组件</li>
</ul>
<h3 id="跨线程传递对象，消息循环"><a href="#跨线程传递对象，消息循环" class="headerlink" title="跨线程传递对象，消息循环"></a>跨线程传递对象，消息循环</h3><h3 id="STA客户创建STA对象，然后传递到另外一个线程"><a href="#STA客户创建STA对象，然后传递到另外一个线程" class="headerlink" title="STA客户创建STA对象，然后传递到另外一个线程"></a>STA客户创建STA对象，然后传递到另外一个线程</h3><p>Marshal和Unmarshal</p>
<p>通常中文翻译成列集和散集</p>
<pre><code>CoMarshalInterThreadInterfaceInStream
CoGetInterfaceAndReleaseStream
</code></pre><h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><p>STA对象的线性调用其实就是通过Windows的消息循环来实现的。</p>
<p>给我们的主调STA客户加上消息循环</p>
<pre><code>// TestCom.cpp : Defines the entry point for the console application.
//

#include &quot;stdafx.h&quot;

#include &lt;atlbase.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;windows.h&gt;

#include &quot;../MyCom/MyCom_i.h&quot;
#include &quot;../MyCom/MyCom_i.c&quot;

LRESULT CALLBACK WndProc_Notify(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{

    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}

void CreateWnd(void)
{

    WNDCLASS wc = { 0 };
    wc.style = 0;
    wc.lpfnWndProc = WndProc_Notify;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    //    wc.hInstance = g_hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetSysColorBrush(COLOR_WINDOW);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT(&quot;NOTIFY_MSG_LOOP&quot;);

    RegisterClass(&amp;wc);

    HWND g_hNotifyMsgLoop = CreateWindowExW(0,
        wc.lpszClassName,
        wc.lpszClassName,
        WS_OVERLAPPEDWINDOW,
        0,
        0,
        200,
        200,
        NULL,
        NULL,
        NULL,
        0);

    //    ShowWindow(g_hNotifyMsgLoop, SW_HIDE);
}


void Test(LPSTREAM pStream)
{
    CreateWnd();

    WCHAR temp[100] = { 0 };
    swprintf_s(temp, L&quot;STA calling thread (used passed in com object): %d\n&quot;, ::GetCurrentThreadId());
    OutputDebugStringW(temp);

    CoInitialize(NULL);

    CComPtr&lt;ICircle&gt; spCircle;
    HRESULT hr = CoGetInterfaceAndReleaseStream(pStream, IID_ICircle, (LPVOID*)&amp;spCircle);  // unmarshal to get a com object
    if (SUCCEEDED(hr))
    {
        spCircle-&gt;Draw(CComBSTR(L&quot;yellow&quot;));
    }


    CoUninitialize();
}

int _tmain(int argc, _TCHAR* argv[])
{
    CoInitialize(NULL);
    WCHAR temp[100] = { 0 };
    swprintf_s(temp, L&quot;Main thread: %d\n&quot;, ::GetCurrentThreadId());
    OutputDebugStringW(temp);

    {
        CComPtr&lt;ICircle&gt; spCircle;
        spCircle.CoCreateInstance(CLSID_Circle, NULL, CLSCTX_INPROC);

        spCircle-&gt;Draw(CComBSTR(L&quot;red&quot;));

        std::vector&lt;std::thread&gt; vThreads;
        for (int i = 0; i &lt; 5; i++)
        {
            LPSTREAM pStream = nullptr;
            CoMarshalInterThreadInterfaceInStream(IID_ICircle, spCircle, &amp;pStream);  // marshal

            vThreads.push_back(std::thread(Test, pStream));  // pass a stream instead of com object
        }

        MSG msg;
        while (GetMessage(&amp;msg, NULL, 0, 0))
        {
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }

        for (auto&amp; t: vThreads)
        {
            t.join();
        }
    }


    CoUninitialize();

    return 0;
}
</code></pre><p>如果想要把一个STA对象往另外一个线程传递，就需要：</p>
<ol>
<li><p>列集/散列， (marshal/unmarshal)</p>
</li>
<li><p>创建STA对象的线程一定要有个windows消息循环。</p>
</li>
</ol>
<p>COM系统发现有其他线程（套间）调用COM对象的方法，COM系统就会往创建COM对象的线程发送消息，但是如果那个线程没有消息循环来接收，那就永远都处理不了了。</p>
<h3 id="MTA客户，跨线程传递COM对象"><a href="#MTA客户，跨线程传递COM对象" class="headerlink" title="MTA客户，跨线程传递COM对象"></a>MTA客户，跨线程传递COM对象</h3><p>MTA调用STA对象的时候，STA本来就在一个default STA里面运行的。MTA客户获得的不过是一个代理而已。</p>
<p>当MTA客户在调用STA对象的时候，本来就涉及到2个套间：MTA和default STA。</p>
<p>MTA套间里的线程直接调用STA对象，不需要做marshal，MTA里面的线程调用的是STA对象的代理，系统会把这些调用转发给default STA，default STA默认就有个消息循环了，这个是由COM系统创建的，不需要程序员干涉。</p>
<p>如果我们直接把MTA创建的STA对象指针传递给STA线程，调用对象方法的时候，会得到一个错误：</p>
<p>RPC_E_WRONG_THREAD The application called an interface that was marshalled for a different thread.</p>
<p>那么这个地方就碰到一个问题，MTA创建的STA对象存在于一个default STA中，而我们的STA线程如果直接访问COM对象的话，又涉及跨套间的问题了。所有就得mashal，在MTA线程里面，把STA对象（代理）mashal一下，再传给STA线程，会发现调用正常了。而且STA的运行线程就是default STA里面的那个线程。这样就可以实现串行调用了。</p>
<p>总之对于STA COM 对象，所有方法的调用总是串行的，不会并发，不需要考虑同步问题。</p>
<ol>
<li><p>STA客户调用STA对象，是通过消息循环来保证串行的。就是通过往创建对象的套间发送消息，套间线程来接收消息。</p>
</li>
<li><p>MTA客户调用STA对象， COM系统会处理marshal，并且在default STA里面创建默认消息循环。</p>
</li>
</ol>
<h2 id="MTA接口"><a href="#MTA接口" class="headerlink" title="MTA接口"></a><a href="https://blog.csdn.net/zj510/article/details/38857239" target="_blank" rel="noopener">MTA接口</a></h2><p>跟STA相比，</p>
<ol>
<li><p>COM系统不会帮助序列号，需要程序员自己来处理并发同步问题；</p>
</li>
<li><p>不需要消息循环。</p>
</li>
</ol>
<p>另外，一个进程里面只能有一个MTA套间，MTA套间里面可以有多个线程。</p>
<p>Threading model中选择Free</p>
<p>MTA组件需要自己实现同步</p>
<h3 id="传递MTA-COM对象给STA套间线程"><a href="#传递MTA-COM对象给STA套间线程" class="headerlink" title="传递MTA COM对象给STA套间线程"></a>传递MTA COM对象给STA套间线程</h3><p>目前的COM设计允许一个没有显式初始化COM的线程成为MTA套间的一部分。只有当另外一个线程已经调用过CoInitializeEx(NULL, COINIT_MULTITHREADED)后，一个没有初始化COM的线程会在开始使用COM属于MTA套间。（有一个可能性是：COM自己会初始化成MTA但是客户并没有显式初始化；比如，一个STA线程在一个标记为”ThreadingModel=Free”的CLSID上调用CoGetClssObject/CoCreateInstance[x]，COM会隐式创建一个MTA套间）</p>
<p>ok，针对我们的情况，辅助线程尽管自己没有初始化COM，但是它也是MTA套间里面的一个线程。所以，也不需要marshal。</p>
<h3 id="STA套间调用MTA对象"><a href="#STA套间调用MTA对象" class="headerlink" title="STA套间调用MTA对象"></a>STA套间调用MTA对象</h3><ol>
<li>当在STA套间里面创建MTA对象时，系统会自动创建一个MTA套间。</li>
<li>MTA对象在MTA套间里面运行。</li>
<li>运行线程由系统来创建，系统会创建几个运行线程，并且挑选某个线程为当前调用服务。</li>
</ol>
<h3 id="运行线程"><a href="#运行线程" class="headerlink" title="运行线程"></a>运行线程</h3><p>一个STA对象只能属于一个STA套间，那么一个STA对象一定是在一个线程里面运行的。所以STA对象不需要考虑并发，因为它永远是串行运行的。</p>
<p>MTA套间调用MTA对象：COM对象都是运行在创建它的线程里面</p>
<p>STA套间调用MTA对象：MTA对象是运行在系统创建的线程里面</p>
<h2 id="COM连接点"><a href="#COM连接点" class="headerlink" title="COM连接点"></a><a href="https://blog.csdn.net/zj510/article/details/39056097" target="_blank" rel="noopener">COM连接点</a></h2><p>COM里面的连接点就好像是C语言的回调函数，只不过它是基于面向对象实现的。连接点的作用也就是COM对象将一些事件通知客户（调用者）。</p>
<h3 id="创建连接点"><a href="#创建连接点" class="headerlink" title="创建连接点"></a>创建连接点</h3><p><a href="https://blog.csdn.net/csfreebird/article/details/1154718" target="_blank" rel="noopener">ATL7.1创建连接点组件</a></p>
<ul>
<li>用ATL创建一个工程（DLL COM) CAtlComTest</li>
<li>然后创建一个COM接口，ATL简单对象，IMyCar. 在options那里选上connection points(连接点)。</li>
<li>然后在class view那里找到_IMyCarEvents(在CAtlComTestLib下面),右键点击Add Method.如图，增加一个方法OnStop。</li>
<li>之后在CMyCar上点击右键，选择Add Connection Point(添加连接点)。</li>
</ul>
<p>在CProxy_IMyCarEvents里面可以看到多了个函数。如下</p>
<pre><code>#pragma once
template&lt;class T&gt;
class CProxy_IMyCarEvents :
    public ATL::IConnectionPointImpl&lt;T, &amp;__uuidof(_IMyCarEvents)&gt;
{
public:
    HRESULT Fire_OnStop( FLOAT Distance)
    {
        HRESULT hr = S_OK;
        T * pThis = static_cast&lt;T *&gt;(this);
        int cConnections = m_vec.GetSize();

        for (int iConnection = 0; iConnection &lt; cConnections; iConnection++)
        {
            pThis-&gt;Lock();
            CComPtr&lt;IUnknown&gt; punkConnection = m_vec.GetAt(iConnection);
            pThis-&gt;Unlock();

            IDispatch * pConnection = static_cast&lt;IDispatch *&gt;(punkConnection.p);

            if (pConnection)
            {
                CComVariant avarParams[1];
                avarParams[0] = Distance;
                avarParams[0].vt = VT_R4;
                CComVariant varResult;

                DISPPARAMS params = { avarParams, NULL, 1, 0 };
                hr = pConnection-&gt;Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &amp;params, &amp;varResult, NULL, NULL);
            }
        }
        return hr;
    }
};
</code></pre><h3 id="使用这个连接点"><a href="#使用这个连接点" class="headerlink" title="使用这个连接点"></a>使用这个连接点</h3><p>IMyCar增加一个方法</p>
<pre><code>STDMETHODIMP CMyCar::Run()
{
    // TODO: Add your implementation code here

    this-&gt;Fire_OnStop(1000);

    return S_OK;
}
</code></pre><p>然后写个客户程序</p>
<pre><code>// TestCom.cpp : Defines the entry point for the console application.
//

#include &quot;stdafx.h&quot;
#include &lt;atlbase.h&gt;
#include &lt;atlcom.h&gt;
#include &quot;../MyCOM/MyCOM_i.h&quot;
#include &quot;../MyCOM/MyCOM_i.c&quot;

#include &lt;iostream&gt;
#include &lt;thread&gt;


using namespace std;

class CSink :
    public CComObjectRoot,
    public _IMyCarEvents
{
    BEGIN_COM_MAP(CSink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(_IMyCarEvents)
    END_COM_MAP()

public:
    virtual ~CSink(){}
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)   { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)  { return E_NOTIMPL; }

    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    {
        printf(&quot;sink, id: %d, parm: %f&quot;, dispIdMember, pDispParams-&gt;rgvarg[0].fltVal);

        return S_OK;
    }
};


CComModule m_commodule;

int _tmain(int argc, _TCHAR* argv[])
{
    CoInitializeEx(0, COINIT_APARTMENTTHREADED);

    {
        CComPtr&lt;IMyCar&gt; spCar;
        spCar.CoCreateInstance(CLSID_MyCar, NULL, CLSCTX_INPROC_SERVER);

        CComObject&lt;CSink&gt;* sinkptr = nullptr;
        CComObject&lt;CSink&gt;::CreateInstance(&amp;sinkptr);

        DWORD cookies = 0;

        AtlAdvise(spCar, sinkptr, __uuidof(_IMyCarEvents), &amp;cookies);

        spCar-&gt;Run();
    }


    CoUninitialize();


    return 0;
}
</code></pre><p>发现CSink里面的invoke被调用到了<br>其中pDispParams-&gt;rgvarg[0].fltVal就是COM对象触发这个连接点的时候传进来的参数1000.</p>
<p>主要过程是：</p>
<ol>
<li><p>创建sink对象</p>
</li>
<li><p>挂载sink对象到一个COM对象上</p>
</li>
<li><p>COM对象调用Run函数</p>
</li>
<li><p>Run函数内部触发了一个连接点</p>
</li>
<li><p>调用者的对应函数会被调用，这里是Invoke。</p>
</li>
</ol>
<p>总结一下：</p>
<ol>
<li><p>如果COM对象需要支持连接点，那么这个对象类需要从连接点和连接点容器继承下来；（一个类可以有多个连接点）</p>
</li>
<li><p>创建接收对象（sink），接收对象需要从CComObjectRoot(或者类似的其他类）和连接点接口继承下来；</p>
</li>
<li><p>使用AtlAdvise来将一个sink对象挂载到相应的COM对象上。（当COM对象释放的时候，会相应释放所有拥有的sink对象）</p>
</li>
<li><p>这样，当COM对象需要触发一个事件的时候，就可以遍历所有sink对象，一个一个来触发。</p>
</li>
</ol>
<p>整个过程也还是蛮简单的。其实仔细看看这个结构，这活脱脱就是一个观察者模式的典型例子。sink是观察者，具体COM对象是被观察者。当具体COM对象有事件需要触发的时候，就通过m_vec来通知所有的观察者（sink）。IConnectionPoint::m_vec是一个数组,存放所有的观察者。</p>
<h2 id="IDispatch接口-GetIDsOfNames和Invoke"><a href="#IDispatch接口-GetIDsOfNames和Invoke" class="headerlink" title="IDispatch接口 - GetIDsOfNames和Invoke"></a><a href="https://blog.csdn.net/zj510/article/details/39494873" target="_blank" rel="noopener">IDispatch接口 - GetIDsOfNames和Invoke</a></h2><p>GetIDsOfNames</p>
<p>这个函数的主要功能就是：把COM接口的方法名字和参数（可选）映射成一组DISPID。</p>
<p>Invoke</p>
<p>Invoke是IDispatch里面非常重要的一样函数，方法调用就靠这个函数了。</p>
<h3 id="CComDispatchDriver智能指针"><a href="#CComDispatchDriver智能指针" class="headerlink" title="CComDispatchDriver智能指针"></a>CComDispatchDriver智能指针</h3><pre><code>#include &quot;stdafx.h&quot;

#include &lt;thread&gt;
#include &lt;atlbase.h&gt;
#include &lt;atlcom.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

#include &quot;../MyCom/MyCom_i.h&quot;
#include &quot;../MyCom/MyCom_i.c&quot;

int _tmain(int argc, _TCHAR* argv[])
{
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    CComDispatchDriver dsp;
    dsp.CoCreateInstance(CLSID_MyCar);

    CComVariant rt;
    dsp.GetPropertyByName(L&quot;Gas&quot;, &amp;rt);
    LONG total = rt.lVal;

    CComVariant p1;
    p1.vt = VT_I4;
    p1.lVal = 12;

    CComVariant p2;
    p2.vt = VT_I4 | VT_BYREF;
    LONG Gas = 0;
    p2.byref = &amp;Gas;

    dsp.Invoke2(L&quot;AddGas&quot;, &amp;p1, &amp;p2, NULL);

    CComVariant totalGas;
    dsp.GetPropertyByName(L&quot;Gas&quot;, &amp;totalGas);
    total = totalGas.lVal;

    dsp.Release();

    CoUninitialize();

    return 0;
}
</code></pre><p>看一下就知道怎么通过CComDispatchDriver来调用支持IDispatch接口的COM组件了。其实CComDispatchDriver内部还是通过GetIDsOfNames和Invoke等函数来调用COM组件的方法的。</p>
<h3 id="ATL：连接点及接收事件的两种方法"><a href="#ATL：连接点及接收事件的两种方法" class="headerlink" title="ATL：连接点及接收事件的两种方法"></a><a href="https://fanglz.wordpress.com/2011/03/24/connection-point/" target="_blank" rel="noopener">ATL：连接点及接收事件的两种方法</a></h3><p><a href="https://blog.csdn.net/debehe/article/details/2291771" target="_blank" rel="noopener">深入解析连接点</a></p>
<h1 id="COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch"><a href="#COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch" class="headerlink" title="COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch"></a><a href="https://blog.csdn.net/wangqiulin123456/article/details/8274620?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch</a></h1><p>COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown包含三个函数，分别是 QueryInterface、AddRef、Release。这三个函数是无比重要的，而且它们的排列顺序也是不可改变的。QueryInterface用于查询组件实现的其它接口，说白了也就是看看这个组件的父类中还有哪些接口类，AddRef用于增加引用计数，Release用于减少引用计数。引用计数也是COM中的一个非常重要的概念。大体上简单的说来可以这么理解，COM组件是个DLL，当客户程序要用它时就要把它装到内存里。另一方面，一个组件也不是只给你一个人用的，可能会有很多个程序同时都要用到它。但实际上DLL只装载了一次，即内存中只有一个COM组件，那COM组件由谁来释放？由客户程序吗？不可能，因为如果你释放了组件，那别人怎么用，所以只能由COM组件自己来负责。所以出现了引用计数的概念，COM维持一个计数，记录当前有多少人在用它，每多一次调用计数就加一，少一个客户用它就减一，当最后一个客户释放它的时侯，COM知道已经没有人用它了，它的使用已经结束了，那它就把它自己给释放了。引用计数是COM编程里非常容易出错的一个地方，但所幸VC的各种各样的类库里已经基本上把AddRef的调用给隐含了，在我的印象里，我编程的时侯还从来没有调用过AddRef，我们只需在适当的时侯调用Release。至少有两个时侯要记住调用Release，第一个是调用了 QueryInterface以后，第二个是调用了任何得到一个接口的指针的函数以后，记住多查MSDN 以确定某个函数内部是否调用了AddRef，如果是的话那调用Release的责任就要归你了。 IUnknown的这三个函数的实现非常规范但也非常烦琐，容易出错，所幸的事我们可能永远也不需要自己来实现它们。</p>
<p>　　IClassFactory的作用是创建COM组件。我们已经知道COM组件实际上就是一个类，那我们平常是怎么实例化一个类对象的？是用‘new’命令!很简单吧，COM组件也一样如此。但是谁来new它呢？不可能是客户程序，因为客户程序不可能知道组件的类名字，如果客户知道组件的类名字那组件的可重用性就要打个大大的折扣了，事实上客户程序只不过知道一个代表着组件的128位的数字串而已，这个等会再介绍。所以客户无法自己创建组件，而且考虑一下，如果组件是在远程的机器上，你还能new出一个对象吗？所以创建组件的责任交给了一个单独的对象，这个对象就是类厂。每个组件都必须有一个与之相关的类厂，这个类厂知道怎么样创建组件，当客户请求一个组件对象的实例时，实际上这个请求交给了类厂，由类厂创建组件实例，然后把实例指针交给客户程序。这个过程在跨进程及远程创建组件时特别有用，因为这时就不是一个简单的new操作就可以的了，它必须要经过调度，而这些复杂的操作都交给类厂对象去做了。IClassFactory最重要的一个函数就是CreateInstance，顾名思议就是创建组件实例，一般情况下我们不会直接调用它，API函数都为我们封装好它了，只有某些特殊情况下才会由我们自己来调用它，这也是VC编写COM组件的好处，使我们有了更多的控制机会，而VB给我们这样的机会则是太少太少了。</p>
<p>　　IDispatch叫做调度接口。它的作用何在呢？这个世上除了C++还有很多别的语言，比如VB、 VJ、VBScript、JavaScript等等。可以这么说，如果这世上没有这么多乱七八糟的语言，那就不会有IDispatch。:-) 我们知道COM组件是C++类，是靠虚函数表来调用函数的，对于VC来说毫无问题，这本来就是针对C++而设计的，以前VB不行，现在VB也可以用指针了，也可以通过VTable来调用函数了，VJ也可以，但还是有些语言不行，那就是脚本语言，典型的如 VBScript、JavaScript。不行的原因在于它们并不支持指针，连指针都不能用还怎么用多态性啊，还怎么调这些虚函数啊。唉，没办法，也不能置这些脚本语言于不顾吧，现在网页上用的都是这些脚本语言，而分布式应用也是COM组件的一个主要市场，它不得不被这些脚本语言所调用，既然虚函数表的方式行不通，我们只能另寻他法了。时势造英雄，IDispatch应运而生。:-) 调度接口把每一个函数每一个属性都编上号，客户程序要调用这些函数属性的时侯就把这些编号传给IDispatch接口就行了，IDispatch再根据这些编号调用相应的函数，仅此而已。当然实际的过程远比这复杂，仅给一个编号就能让别人知道怎么调用一个函数那不是天方夜潭吗，你总得让别人知道你要调用的函数要带什么参数，参数类型什么以及返回什么东西吧，而要以一种统一的方式来处理这些问题是件很头疼的事。IDispatch接口的主要函数是Invoke，客户程序都调用它，然后Invoke再调用相应的函数，如果看一看MS的类库里实现 Invoke的代码就会惊叹它实现的复杂了，因为你必须考虑各种参数类型的情况，所幸我们不需要自己来做这件事，而且可能永远也没这样的机会。:-) </p>
<h1 id="ATL-调用COM对象"><a href="#ATL-调用COM对象" class="headerlink" title="ATL 调用COM对象"></a><a href="https://blog.csdn.net/luo_xianming/article/details/40458393?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">ATL 调用COM对象</a></h1><p>创建COM对象一般有三种方法，正常创建一个对象，使用CoCreateInstance函数。若在远程系统中创建一个对象，使用CoCreateInstanceEX函数。而创建多个同一CLSID的对象时，使用CoGetClassObject函数。</p>
<p>1.先简单的使用CoCreateInstance函数创建一个COM对象。</p>
<pre><code>//要加载生成的文件和这个c文件。
#include &quot;ATLProject1_i.h&quot;
#include &quot;ATLProject1_i.c&quot;

int _tmain(int argc, _TCHAR* argv[])
{
    //声明的是接口的指针
    ITryCOM *it = NULL;
    //声明一个HRESULT变量
    HRESULT hr;
    //初始化COM，并告诉Windows以单线程的方式创建COM对象
    hr = CoInitialize(0);
    //使用SUCCEDED宏判断是否初始化成功。
    if(SUCCEEDED(hr)){
        //加载COM对象
        hr = CoCreateInstance(CLSID_TryCOM,NULL,CLSCTX_INPROC_SERVER,IID_ITryCOM,(void**)&amp;it);
        //检测是否加载成功
        if(SUCCEEDED(hr)){
            long ReturnValue ;
            printf(&quot;Find DLL\n&quot;);
            int a= 1;
            int b = 2;
            it-&gt;Add(a,b,&amp;ReturnValue);
            printf(&quot;%d&quot;,ReturnValue);
            //对于com对象，使用后都要使用release进行释放
            it-&gt;Release();
        }
        //关闭当前线程的COM库，卸载所有dll，并释放资源。
        CoUninitialize();
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>2.使用CoGetClassObject来创建COM对象。</p>
<pre><code>//要加载生成的文件和这个c文件。
#include &quot;ATLProject1_i.h&quot;
#include &quot;ATLProject1_i.c&quot;

int _tmain(int argc, _TCHAR* argv[])
{
    //声明的是接口的指针
    ITryCOM *it = NULL;
    //一个工厂对象的指针
    IClassFactory *ifp = NULL ;
    //声明一个HRESULT变量
    HRESULT hr;
    //初始化COM，并告诉Windows以单线程的方式创建COM对象
    hr = CoInitialize(0);
    //使用SUCCEDED宏判断是否初始化成功。
    if(SUCCEEDED(hr)){
        //加载厂类
        hr = CoGetClassObject(CLSID_TryCOM,CLSCTX_INPROC_SERVER    ,NULL,IID_IClassFactory,(void**)&amp;ifp);
        //检测是否加载成功
        if(SUCCEEDED(hr)){
            hr = ifp-&gt;CreateInstance(NULL,IID_ITryCOM,(void**)&amp;it);//使用工厂创建COM对象
            ifp-&gt;Release();//释放
            if(SUCCEEDED(hr)){
                long ReturnValue ;
                printf(&quot;Find DLL\n&quot;);
                int a= 1;
                int b = 2;
                it-&gt;Add(a,b,&amp;ReturnValue);
                printf(&quot;%d&quot;,ReturnValue);
                //对于com对象，使用后都要使用release进行释放
                it-&gt;Release();//释放
            }
        }
        //关闭当前线程的COM库，卸载所有dll，并释放资源。
        CoUninitialize();
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>3.忽略远程创建实例函数EX，最后在来考虑一下不使用CoCreateInstance or CoGetClassObject,直接从dll中得到DllGetClassObject，接着生成类对象及类实例（本方法适合于你想用某个组件，却不想在注册表中注册该组件）。之前的两个函数能调用，是因为其在系统中通过注册表对其唯一的ID进行了DLL的注册，所以调用这两个函数，使其能从系统中获得对应的DLL。最后是一个不注册dll的方法。</p>
<pre><code>//要加载生成的文件和这个c文件。
#include &quot;ATLProject1_i.h&quot;
#include &quot;ATLProject1_i.c&quot;

int _tmain(int argc, _TCHAR* argv[])
{
    //定义一个这样的函数指针
    typedef HRESULT (__stdcall * pfnGCO) (REFCLSID, REFIID, void**);
    //声明一个函数指针
    pfnGCO fnGCO = NULL;
    //加载dll
    HINSTANCE hdllInst = LoadLibrary(&quot;D:/360data/重要数据/我的文档/Visual Studio 2012/Projects/TryDll/TryDll/ATLProject1.dll&quot;);
    //在dll中寻找DllGetClassObject函数，并将其赋值给fnGCO指针，是fnGCO指针可以进行创建工厂类的操作
    fnGCO = (pfnGCO)GetProcAddress(hdllInst, &quot;DllGetClassObject&quot;);
    if (fnGCO != 0)
    {
        //工厂对象
        IClassFactory* pcf = NULL;
        //释放fnGCO函数，即DllGetClassObject函数来获得一个工厂类对象，然后就是正常使用工厂类对象创建COM对象的操作了
        HRESULT hr= (fnGCO) (CLSID_TryCOM, IID_IClassFactory, (void**)&amp;pcf);
        if (SUCCEEDED(hr) &amp;&amp; (pcf != NULL))
        {
            ITryCOM* iTry = NULL;
            hr = pcf-&gt;CreateInstance(NULL, IID_ITryCOM, (void**)&amp;iTry);
            if (SUCCEEDED(hr) &amp;&amp; (iTry != NULL))
            {
                long ReturnValue ;
                printf(&quot;Find DLL\n&quot;);
                int a= 1;
                int b = 2;
                iTry-&gt;Add(a,b,&amp;ReturnValue);
                printf(&quot;%d&quot;,ReturnValue);
                iTry-&gt;Release();
            }
            pcf-&gt;Release();
        }
    }
    //释放加载的dll
    FreeLibrary(hdllInst);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><h2 id="总结一下在VC中调用COM组件的方法"><a href="#总结一下在VC中调用COM组件的方法" class="headerlink" title="总结一下在VC中调用COM组件的方法"></a><a href="https://bbs.csdn.net/topics/50319093" target="_blank" rel="noopener">总结一下在VC中调用COM组件的方法</a></h2><p>一、最简单最常用的一种，用#import导入类型库，利用VC提供的智能指针包装类</p>
<p>二、引入midl.exe产生的<em>.h,</em>_i.c文件，利用CoCreateInstance函数来调用</p>
<p>三、不用CoCreateInstance，直接用CoGetClassObejct得到类厂对象接口，然后用该接口的方法CreateInstance来生成实例。</p>
<p>四、不用CoCreateInstance or CoGetClassObject,直接从dll中得到DllGetClassObject，接着生成类对象及类实例（本方法适合于你想用某个组件，却不想在注册表中注册该组件）</p>
<p>在MFC中调用</p>
<p>在MFC中除了上面的几种方法外，还有一种更方便的方法，就是通过ClassWizard利用类型库生成包装类，不过有个前提就是com组件的接口必须是派生自IDispatch</p>
<p>具体方法：<br>１、按Ctrl+W调出类向导，按Add Class按钮弹出新菜单，选From a type libarary，然后定位到simpCOM.dll，接下来会出来该simpCOM中的所有接口，选择你想生成的接口包装类后，向导会自动生成相应的.cpp和.h文件.<br>这样你就可以在你的MFC工程中像使用普通类那样使用COM组件了.</p>
<p><a href="http://www.cppblog.com/woaidongmao/archive/2011/01/10/138250.aspx" target="_blank" rel="noopener">vc中调用Com组件的方法详解</a></p>
<p><a href="http://www.zeroplace.cn/article.asp?id=628" target="_blank" rel="noopener">vc中调用Com组件的方法详解</a></p>
<h2 id="c-简单的ATL-COM开发和调用实例"><a href="#c-简单的ATL-COM开发和调用实例" class="headerlink" title="c++简单的ATL COM开发和调用实例"></a><a href="https://blog.csdn.net/ghevinn/article/details/31729951?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">c++简单的ATL COM开发和调用实例</a></h2><p>1、在MFC中调用有一种很方便的方法，就是通过ClassWizard利用类型库生成包装类，不过有个前提就是com组件的接口必须是派生自IDispatch。<br>具体方法：</p>
<p>（1）VS2010新建一个MFC基于对话框程序，调出类向导，点击“添加类”下拉菜单，选择“类型库中的MFC类”（From a type libarary）。</p>
<p>（2）选“注册表”，然后在“可用类型库”中定位到FirstCOMLib<1.0>，接下来会出来该库中的所有接口，选择你想生成的接口包装类IFirstClass后点击“完成”，向导会自动生成相应的.h文件,这样你就可以在你的MFC工程中像使用普通类那样使用COM组件了.</1.0></p>
<h1 id="tlb"><a href="#tlb" class="headerlink" title="tlb"></a>tlb</h1><p>类型库文件，一般是COM技术所生成的东东的库，是IDL语言编写的.idl文件编译以后产生的东东，生成这个文件是为了让其他非C语言的程序使用的</p>
<p>tlb是在生成com时产生的,提供了该com的接口函数。在其他程序中想要引用已经有的COM中的方法<br>就可以import “*.tlb” 之后就可以调用里面的方法和函数了。打开看一下.tlb文件就明白了，<br>里面是一些须函数。</p>
<h2 id="生成tlb文件："><a href="#生成tlb文件：" class="headerlink" title="生成tlb文件："></a>生成tlb文件：</h2><ul>
<li>使用命令midl XXX.idl来成成tlb文件即可</li>
<li>直接使用VC6或者Visual Studio打开dll文件，注意在打开文件对话框中一定要选择Resource方式，VC6默认是auto.找到资源中的TypeLib，其中的文件可以Export成bin，这个bin就是tlb,保存的时候使用将扩展名指定为tlb即可。</li>
</ul>
<p>使用Visual Studio的Object Viewer可以直接对tlb文件进行查看。</p>
<h2 id="使用tlb"><a href="#使用tlb" class="headerlink" title="使用tlb"></a>使用tlb</h2><p><code>#import &quot;ATLProject1.tlb&quot; no_namespace</code>, 然后重新编译生成<code>*.tlh</code>与<code>*.tli</code>。</p>
<p>Visual Studio有很多内置的支持将类型库导入到C++项目中，并使用这些定义的对象。例如，您可以使用#import指令：</p>
<pre><code>#import &quot;CANoe.tlb&quot;
</code></pre><p>这将导入类型库，并将其转换为头文件和实现文件 - 也会导致实现文件与您的项目和头文件一起构建，因此这里有很多魔术。 然后，为类型库中定义的类型和对象提供了大量针对智能指针包装的typedef。例如，如果有一个名为Application的CoClass实现了IApplication接口，那么可以这样做：</p>
<pre><code>ApplicationPtr app(__uuidof(Application));
</code></pre><p>这会在运行时导致创建coclass应用程序并绑定到变量app，您可以像这样调用它：</p>
<pre><code>app-&gt;DoSomeCoolStuff();
</code></pre><p>通过检查COM调用的结果来完成错误处理，并根据需要抛出相应的<code>_com_error</code>异常，这意味着您需要安全地编写异常。</p>
<p>更简单的方法是使用 #include 语句将.h和_i.c项目包含在.cpp文件中。</p>
<p>要创建接口指针，其中一种更安全的方法是使用CComPTR，如下所示：</p>
<pre><code>CComPtr myPtr;
myPtr.CoCreateInstance(__uuidof(&quot;ClassNamehere&quot;));
myPtr-&gt;Method(....);
</code></pre><h1 id="实现的事件处理接口"><a href="#实现的事件处理接口" class="headerlink" title="实现的事件处理接口"></a><a href="https://docs.microsoft.com/zh-cn/cpp/atl/implementing-the-event-handling-interface" target="_blank" rel="noopener">实现的事件处理接口</a></h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>tlb、oxc、dll文件</p>
<p>vc6.0项目中：</p>
<p>Comments:</p>
<pre><code>regsvr32 /s /c &quot;$(TargetPath)&quot; 
echo regsvr32 exec. time &gt; &quot;$(OutDir)\regsvr32.trg&quot; 
</code></pre><p>Outputs:</p>
<pre><code>$(OutDir)\regsvr32.trg
</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>可以<code>include &quot;xx_i.h&quot;、include &quot;xx_i.c&quot;</code>文件</p>
<p>也可以<code>#import &quot;xx.tlb&quot; no_namespace</code></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">COM</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/25/COM/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Boost与设计模式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/Boost与设计模式/">Boost与设计模式</a>
    </h1>
  

        
        <a href="/2018/05/24/Boost与设计模式/" class="archive-article-date">
  	<time datetime="2018-05-24T01:16:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-24</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>面向对象的软件开发的基础是对象。随着系统的不断演化,会出现越来越多的对象,如果单纯使用C++提供的new操作符,将使程序中到处都是硬编码的对象创建代码,很难适应变,化。而创建型模式抽象了类的实例化过程,它封装了对象的创建动作,使对象的创建可以独立.于系统的其他部分。</p>
<h2 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂(Abstract Factory)"></a>抽象工厂(Abstract Factory)</h2><p>抽象工厂模式把对象的创建封装在一个类中,这个类唯一的任务就是按需生产各种对象,通过派生子类的方式抽象工厂可以生产不同系列的、整套的对象。工厂类通常是单件,以保证,在系统的任何地方都可以访问,其中的每个方法都是工厂方法。在较小的软件系统中,抽象工,厂有时候会退化成一个没有子类的简单工厂。</p>
<p>xpressive库有一个抽象工厂regex_compiler,可以生产各种正则表达式解析对象,但它用模板技术而不是继承实例化出了具体的工厂。</p>
<h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器(Builder)"></a>生成器(Builder)</h2><p>生成器模式分解了复杂对象的创建过程,创建过程可以被子类改变,使同样的过程可以生产出不同的对象。生成器与抽象工厂不同,它不是一次性地创建出产品,而是分步骤逐渐地“装配”出对象,因而可以对创建过程进行更精细的控制。</p>
<p>Boost库没有生成器模式的具体应用,因为生成器模式主要用来构造复杂的对象,对于库来说复杂的创建过程会令库难以使用。</p>
<p>multi_array对象的创建过程类似生成器模式,它先用模板参数设定基本维数,然后再逐个指定各个维度,最后生成一个多维数组。</p>
<h2 id="工厂方法-Factory-Method"><a href="#工厂方法-Factory-Method" class="headerlink" title="工厂方法(Factory Method)"></a>工厂方法(Factory Method)</h2><p>工厂方法模式是另一种生产对象的方式,它把对象的创建封装在一个方法中,子类可以改变工厂方法的生产行为生产不同的对象。工厂方法所属的类不一定是工厂类(抽象工厂或者生成器),它可能是一个普通类、一个框架类,或者是一个自由函数。</p>
<p>Boost 库中的 make_shared () 、make_optional() 、make_tuple ()、regex&lt;&gt;:: complie ()等函数都属于工厂方法模式。而functional/factory组件则实现了对new操作符的完全封装,类似于泛化的make_pair ()、 make_optional()。</p>
<h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a>原型(Prototype)</h2><p>原型模式使用类的实例通过拷贝的方式创建对象,具体的拷贝行为可以定制,它最常见的用法是为类实现一个clone()成员函数,这个函数创建,个与原型相同或相似的新对象。</p>
<p>weak_ptr的enable_shared _rom_this用法类似于一个原型模式,它创建了一个指向自身的shared_ptr, exception库提供了一个enable_current_exception()函数,它被用于线程安全地处理异常,返回一个clone的异常对象。</p>
<p>指针容器库pointer_container容纳的指针不允许共享,如果要拷贝指针容器,则需要被容纳的元素提供clone()操作,使用原型模式创建一个等价的副本。</p>
<h2 id="单件-Singleton"><a href="#单件-Singleton" class="headerlink" title="单件(Singleton)"></a>单件(Singleton)</h2><p>单件模式保证类有且仅有一个实例,并且提供一个全局的访问点。通常的全局变量技术虽,然也可以提供类似的功能,但它不能防止用户创建多个实例。单件的基本原理很简单,但有很,多实现的变化。</p>
<p>Boost库目前没有专门的单件库,但在serialization库提供了一个可用的实现。</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式专注于如何组合类或对象,进而形成更大更有用的新对象。</p>
<p>组合对象有两种方式:第一种是C++语言本身提供的继承机制,但它在编译期就已经确定,了对象的关系,无法在运行时改变,缺乏足够的灵活性。第二种方法是运行时对象组合,不同的对象之间彼此互相独立,仅通过定义良好的接口通信协同工作,它更灵活和易于模块化,但因为组合方式富有变化而较难以理解。</p>
<h2 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器(Adapter)"></a>适配器(Adapter)</h2><p>适配器模式把一个类的接口转换(适配)为另一个接口,从而在不改变原有代码的基础上,复用原代码。它的别名wrapper更清晰地说明了它的实现结构:包装了原有对象,再给出一个新的接口。</p>
<p>array类是适配器模式的一个很好例子,它把原始数组适配成了符合STL标准的容器,<br>使数组可以与其他标准库组件(算法、迭代器、其他容器)协同工作。同样, multi_ array_ref和const_multi_array_ref把原始数组适配成了Boost的多维数组容器。</p>
<p>thread库的lockable_adapter是适配器类用法的例子,它工作在编译期,把一个类适配为可以被锁定的类型,用于多线程环境编程。</p>
<h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接(Bridge )"></a>桥接(Bridge )</h2><p>桥接模式分离了类的抽象和实现,使它们可以彼此独立地变化而互不影响。桥接模式与适配器模式有些相似,在两个对象之间加入了一个中间层次,提供间接联系增加了系统的灵活性。但两者的意图不同,适配器模式关心的是接口不匹配的问题,不关心接口的实现,只要求对象能,够协同工作。桥接模式的侧重点是接口和实现,通常接口是稳定的,桥接解决实现的变化问题。</p>
<p>智能指针的pimpl用法是桥接模式的一个应用,它向外界提供接口的同时并没有暴露任,何内部的实现信息,因此实现可以任意地改变而不会影响到使用接口的客户代码。</p>
<p>桥接模式的另一个例子是随机数库random的硬件随机数发生器。random_device的对外,接口不变,而内部的pimpl指针可以采用不同的硬件设备从而有不同的实现。</p>
<h2 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合(Composite)"></a>组合(Composite)</h2><p>组合模式将小对象组合成树形结构,使用户操作组合对象如同操作一个单个对象。组合模,式定义了“部分一整体”的层次结构,基本对象可以被组合成更大的对象,而且这种操作是可重复的,不断重复下去就可以得到一个非常大的组合对象,但这些组合对象与基本对象拥有相,同的接口,因而组合是透明的,用法完全一致。</p>
<p>xpressive库就利用了组合模式,它定义了许多小的正则表达式元素,通过重载操作符把它们逐个组合起来,形成一个大的正则表达式,而这些正则表达式又可以被继续组合下去。</p>
<p>property_tree更好地诠释了组合模式。属性树的每一个子节点也是属性树,属性树可以有任意复杂的组合,但最终呈现给用户的还是一个basic ptree接口,使用时完全不需要关心它内部的复杂结构,这是一个透明的接口。</p>
<p>multi_array也是组合模式的一个具体应用,它是递归定义的,每个维度都是一个multi_array。</p>
<h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰(Decorator)"></a>装饰(Decorator)</h2><p>装饰模式可以在运行时动态地给对象增加功能。它也是对对象的包装,但与适配器模式不,同的是它并没有改变被包装对象的接口,只是改变了它的能力范围,而且可以递归组合。<br>通过生成子类的方式也可以为对象增加功能,但它是静态的,而且大量的功能组合很容易,产生“子类爆炸”现象。装饰模式可以动态、透明地给对象增加职责,并且在不需要的时候很,容易去除,使用派生子类的方式无法达到这种灵活程度。</p>
<p>operators库的基类链技术很类似装饰模式,用后一个运算概念装饰前一个运算概念,不断组,合增加了操作符重载的能力,但它是运用泛型编程技术在编译期实现的。</p>
<h2 id="外观-Facade"><a href="#外观-Facade" class="headerlink" title="外观(Facade)"></a>外观(Facade)</h2><p>外观模式为系统中的大量对象提供一个一致的对外接口,以简化系统的使用。外观是另-种形式的wrapper,它不是包装一个对象,而是包装一组对象,简化了这组对象间的通信关系,给出一个高层次的易用接口。但外观并不屏蔽系统里的对象,如果需要,用户完全可以越过外观的包装使用底层对象以获得更灵活的功能。</p>
<p>随机数库random的变量发生器就是一个外观模式,它屏蔽了random库内部的大量细,节,给用户提供一个可轻松生成随机数的operator ()。</p>
<h2 id="享元-Flyweight"><a href="#享元-Flyweight" class="headerlink" title="享元(Flyweight)"></a>享元(Flyweight)</h2><p>享元模式使用共享的方式节约内存的使用,可以支持大量细粒度的对象。它将对象的内部,状态与外部状态分离,配合工厂模式(抽象工厂或工厂方法)生成仅有内部状态的小对象,工厂内部保持小对象的引用计数从而实现共享,外部状态可以通过计算得到。</p>
<p>xpressive库的regex_compiler不仅是一个抽象工厂模式,它同时也是享元模式,在内部保存了所有正则表达式对象从而实现共享。Boost里还有一个flyweight库直接实现了享元模式。</p>
<h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理(Proxy)"></a>代理(Proxy)</h2><p>代理模式与适配器模式、装饰模式很像,也包装对象,但它的意图不是改变接口插入新系统(适配),也不是为对象增加职责(装饰),而是要控制对象。外界不能直接访问对象,必须通过代理才能与被包装的对象通信。</p>
<p>代理模式的应用非常广泛, smart_ptr库就是代理模式的最佳应用。scoped_ptr.shared_ptr等智能指针包装了原始指针,代理了原始指针的职能,用户只需使用智能指针的代理就可以获得原始指针同样的功能,而且不用担心资源泄漏,因为智能指针控制了原始指针的行为。</p>
<p>bind. optional, ref和function也属于代理模式,它们都包装了原始的对象或者函数,为它们提供一定程度的控制,在需要时把消息转发给原始的对象或函数完成工作。</p>
<h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><p>行为模式关注的是程序运行时的对象通信和职责分配,跟踪动态的、复杂的控制流和消息,流,比创建型模式和结构型模式更难于掌握。通常对象一旦创建,它们就立即联系起来,这种联系是动态的,很难甚至不可能从代码中看出来。行为模式以可文档化的形式描述对象通信机,制,可以帮助我们深入了解把握对象之间的关系。</p>
<p>行为模式大都采用对象组合,封装程序的可变部分。</p>
<h2 id="职责链-Chain-of-Responsibility"><a href="#职责链-Chain-of-Responsibility" class="headerlink" title="职责链(Chain of Responsibility)"></a>职责链(Chain of Responsibility)</h2><p>职责链模式把对象链成一条链,使链上的每个对象都有机会处理请求。职责链把请求的发,送者和接收者解耦,使两者都互不知情,而且职责链中的对象可以动态地增减,从而增强了处理请求的灵活性。</p>
<p>assign库的工作原理类似职责链模式,但链上仅有一个对象,它使用重载操作符operator()和operator,,将赋值请求连接成一个链逐个处理,最后完成赋值或初始化工作。</p>
<p>iostreams库也使用了职责链模式,它定义了source, sink, filter等概念,对象,间可以串联起来,一个的输出作为另一个的输入,完成流处理的功能。</p>
<h2 id="命令-Command"><a href="#命令-Command" class="headerlink" title="命令(Command)"></a>命令(Command)</h2><p>命令模式把请求封装成一个对象,使请求能够存储更多的信息拥有更多的能力。命令模式,同样能够把请求的发送者和接收者解耦,但它不关心请求将以何种方式被处理。命令模式经常!与职责链模式和组合模式一起使用:职责链模式处理命令模式封装的对象,组合模式可以把简单的命令对象组合成复杂的命令对象。</p>
<p>exception库是命令模式的一个例子。它把错误信息包装在异常中,使用c++的异常机制传递,直到有一个catch块处理它。</p>
<h2 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器( Interpreter)"></a>解释器( Interpreter)</h2><p>解释器模式定义了个类体系,用1实现,个小型语言的解释器。它与组合模式很相似,而且常常利用组合模式来实现语法树的构建。</p>
<p>regex, xpressive, proto, spirit, wave等库都使用了解释器模式,前两者可以解析正则表达式, proto是一个通用的表达式树构建工具, spirit实现了EBNF语法解析器,<br>vave则是C/C++的预处理解析器。</p>
<p>program_options也是一个解释器模式应用,它可以解析命令行参数这种简单的语法,结构。</p>
<h2 id="代器-Iterator"><a href="#代器-Iterator" class="headerlink" title="代器(Iterator)"></a>代器(Iterator)</h2><p>迭代器模式把按某种顺序访问一个集合中的元素的方式封装在一个对象中,从而无须知道,售合的内部表示就可以访问集合。</p>
<p>迭代器模式可能是面向对象软件开发中应用的最广泛的一个设计模式,在STL中就已经有了大量的迭代器实践,它是泛化的指针,被用于以正序或逆序遍历容器内的元素。boost.iterators和boost.range在STL的基础上进一步深化创新了迭代器的概念。</p>
<h2 id="中介者-Mediator"><a href="#中介者-Mediator" class="headerlink" title="中介者(Mediator)"></a>中介者(Mediator)</h2><p>中介者模式用一个中介对象封装了一系列对象的交互联系,使它们不需要相互了解就可以协同工作。中介者模式在存在大量需要相互通信对象的系统中特别有用,因为对象数量的增加,会使对象间的联系非常复杂,整个系统变得难以理解难以改动。这时中介者可以把这些对象解,耦,每个对象只需要与中介对象通信,中介对象集中了控制逻辑,降低了系统的通信复杂度。</p>
<p>中介者模式与观察者模式是相互竞争的模式,通常观察者模式比中介者模式更容易生成可,复用的对象,中介者模式如果使用不当很容易导致中介对象过度复杂,抵消了模式带来的好处。</p>
<p>Boost库暂没有中介者模式的应用例子。</p>
<h2 id="备忘录-Memento"><a href="#备忘录-Memento" class="headerlink" title="备忘录(Memento)"></a>备忘录(Memento)</h2><p>备忘录模式可以捕获一个对象的内部状态,并在对象之外保存该状态,在之后可以随时把,|对象恢复到之前保存的状态。</p>
<p>io_state_savers库的实现类似备忘录模式,它可以保存10流的各种状念,在析构时,自动恢复,防止10流因状态异常而发生错误。</p>
<h2 id="观察者-Observer"><a href="#观察者-Observer" class="headerlink" title="观察者(Observer)"></a>观察者(Observer)</h2><p>观察者模式定义了对象间一对多的联系,当个对象的状态发生变化时,所有与它有联系的观察者对象都会得到通知。观察者模式将被观察的目1标和观察者解糊,个11标可以有任意多的观察者,观察者也可以观察任意多的1标,构成复杂的联系,而每个观察者都不知道其他,观察者的存在。</p>
<p>观察者模式是一个非常著名、威力强大的设计模式,很多编程语言都有它不同形式的实现,<br>如Java的Observable/observer和C#的event/delegate.Boost库提供signals2,完全实现了观察者模式。</p>
<h2 id="状态-State"><a href="#状态-State" class="headerlink" title="状态(State)"></a>状态(State)</h2><p>状态模式允许对象在状态发生变化时行为也同时改变。</p>
<p>状态转换通常的做法是对象内部有一个值来保存当前的状态,根据状态的不同使用,if-else或者switch来执行不同的功能。这样会使类中存在大量结构类似的分支语句,变得难以维护和理解。状态模式消除了分支语句,把状态处理分散到了各个状态子类,每个子类集中处理一种状态,使状态的转换清晰明确。</p>
<p>boost.statechat和msm库实现了有限状态自动机,它们是状态模式的泛化。</p>
<h2 id="策略-Strategy"><a href="#策略-Strategy" class="headerlink" title="策略(Strategy)"></a>策略(Strategy)</h2><p>策略模式封装了不同的“算法”,使它们可以在运行时相互替换。它与结构型模式里的装.饰模式功能接近,策略模式改变类的行为内核,而装饰模式改变类的行为外观。如果类的接口很庞大,那么装饰模式的实现代价就过高,而策略模式仅改变类的内核,可能很小。策略模式,的实现结构很像状态模式,但它不改变对象的状态。</p>
<p>标准库和Boost库中的大量函数对象就是策略模式的应用。函数对象封装了各种操作,标准算法或者其他类使用传入函数对象来动态改变它的行为。</p>
<p>Boost库中大部分组件的模板类型参数也可以看作是策略模式,通过配置不同的模板类,型,最后实例化的模板类内部的算法都不相同。</p>
<h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法(Template Method)"></a>模板方法(Template Method)</h2><p>模板方法模式在父类中定义操作的主要步骤,但并不实现,而是留给子类去实现。注意这个模板与C++中泛型编程用的template没有任何联系,不要引起误解。它常见的用法是“钩,子操作”,父类定义了所有的公开方法,在公开方法中调用保护的钩子方法,子类实现不同的,钩子方法来扩展父类的行为。</p>
<p>模板方法模式是一个非常基本的设计模式,也可能是最容易使用的,个设计模式,许多框!架都使用模板方法定义基本的操作步骤,用户只需实现少量的具体化代码就可以利用框架的全部功能。</p>
<p>boost. test定义了单元测试的框架,它使用模板方法模式定义了许多可扩展的方法,用户只需要依据test库的规则编写测试用例,就可以插入到UTF中进行测试。</p>
<h2 id="访问者-Visitor"><a href="#访问者-Visitor" class="headerlink" title="访问者(Visitor)"></a>访问者(Visitor)</h2><p>访问者模式分离了类的内部元素与访问它们的操作,可以在不改变内部元素的情况下增加,作用于它们的新操作。如果一个类有很多内部数据,因此也就有很多访问操作,这样会使它的接口非常庞大,难以变动难以学习。访问者模式可以做到数据的存储与使用分离,不同的访问,者可以集中不同类别的操作,并且可以随时增加新的访问者或者新方法来增加新的操作。</p>
<p>boost.variant提供static visitor实现了访问者模式,可以对一个很小的variant对象实施各种操作,如果variant对象发生改变, static visitor也可以很容,易地适应变化。</p>
<h1 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h1><p>推荐书目[11成书于1994年,在那以后软件界开始了广泛的模式运动,在软件开发的各,个领域各个层次都逐步发现了很多新的模式,但最经典最基本的仍然是上面讲到的23个设计模式。本节介绍四个较为常用的其他模式,供读者参考。</p>
<h2 id="空对象-Null-Object"><a href="#空对象-Null-Object" class="headerlink" title="空对象(Null Object)"></a>空对象(Null Object)</h2><p>空对象模式又称哑对象模式(Dumb object),它是一个行为模式,扩展了空指针的含义,给空指针一个默认的、可接受的行为,通常是空操作,可以说是一个“智能空指针”。使用空对象模式,程序就可以不必用条件语句专门处理空指针或类似的概念,所有的对象都会有一致的、可理解的行为。</p>
<p>空对象模式可以和许多行为模式配合,充当“哨兵”的角色,完善它们的概念。例如,策略模式有一个空策略对象,它不做任何事情;职责链模式把空对象用在链的末尾,它可以“吞下”所有无法处理的请求;空迭代器对象则适用于叶子节点,表示总完成遍历操作:还可以有空命令、空观察者等等。</p>
<p>在tuple中的null_type就是个空对象,它表示了一个空的tuple,什么也不做,但它非常重要,没有它就无法完成tuple的部件链。</p>
<p>空对象模式还可以应用在pointer container库中,使指针容器可以安全地容纳空指,针,用一致的行为处理容器元素。</p>
<p>空对象模式也不仅用在面向对象的软件构建,操作系统中也有类似的概念,如Linux的,/dev/nul1设备。</p>
<h2 id="对象池-Object-Pool"><a href="#对象池-Object-Pool" class="headerlink" title="对象池(Object Pool)"></a>对象池(Object Pool)</h2><p>对象池模式属于创建型模式,可以说是一个特殊的工厂模式:它预先创建好若干个可用的.对象,用户向池申请对象,使用完毕归还池而不是直接销毁,所以归还的对象可以被之后的请,求复用。通过这种方式,对象池模式摊平了昂贵的构造成本,消除了对象的销毁成本,可以提,高系统的整体运行效率。</p>
<p>对象池模式在软件开发中已经得到了广泛的应用,例如耳熟能详的连接池、内存池、线程池等名词。Boost库里的poo1实现了内存池, thread_group则实现了简单的线程池。</p>
<h2 id="包装外观-Wrapper-Facade"><a href="#包装外观-Wrapper-Facade" class="headerlink" title="包装外观(Wrapper Facade)"></a>包装外观(Wrapper Facade)</h2><p>包装外观模式很类似外观模式,但它包装的目标不是一个面向对象子系统,而是底层的,API。包装外观模式把大量的原始c接口分类整理,给外界一个统一的、面向对象的易用接口,增强了原始底层接口的内聚性,同时又没有效率的损失(可以使用静态成员函数、名字空间和,inline关键字),包装外观模式可以屏蔽系统底层的细节,简化功能调用,有利于外界不受,平台变化的影响,增强可移植性。</p>
<p>system库是包装外观模式的一个例子,它对UNIX和Windows等操作系统的错误代码,分类包装,对外提供了一个方便使用、易于理解的接口。</p>
<p>atomic. thread, asio库和interprocess也都在不同的层次上使用了包装外观模,式,提供了可移植的并发处理功能。<br>,</p>
<h2 id="前摄器模式-Proactor"><a href="#前摄器模式-Proactor" class="headerlink" title="前摄器模式(Proactor)"></a>前摄器模式(Proactor)</h2><p>前摄器模式是应用于异步调用的设计模式,它的核心是前摄器、异步的操作处理器、异步的事件多路分离器和完成事件队列,可以不使用线程实现异步操作。</p>
<p>前摄器模式的基本流程可以简要描述如下:</p>
<p>前摄发起器创建一个完成处理器,用于在异步调用完成后的回调,然后发起个异步操作,交给操作处理器异步执行,当是步操作完成时操作处理器将把事件放入宗成事件队列。前摄器调用多路分离器从完成事件队列中获得事件, 分派事件回调完成处理器执行所需的后续操作。</p>
<p>前摄器模式用于异步调用有很多的好处,它封装了并发机制,将并发机制与线程的执行解耦,简化了功能代码的编写,不需要考虑多线程的同步问题,能够提供高性能的异步操作。但它也有缺点,模式比较复杂,处理流程难以理解和调试。</p>
<p>asio库基于操作系统的异步调用机制实现了可移植的前摄器模式,解耦了应用程序与操作系统,可以高效地实现异步10操作。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章结合Boost程序库介绍了附录A推荐书目[1]中的23个经典设计模式和4个常用,的其他设计模式。Boost库应用了以上几乎所有的设计模式,因此学习设计模式有助于更好更快地理解Boost组件的结构和用法。</p>
<p>设计模式通常分为三类,创建型模式管理面向对象系统中对象的产生,结构型模式管理!面向对象系统中对象的组合,行为模式管理面向对象系统中对象的通信。</p>
<p>创建型模式是程序的基础,因为面向对象系统就是由许许多多的对象组成的,创建型模式能够使对象的创建独立于系统单独变化。最常用的创建型模式是抽象工厂和单件,而且这两者经常联合使用。</p>
<p>结构型模式把对象组合起来,以获得功能更强大更灵活的对象。使用结构型模式,我们可以避免继承滥用和“子类爆炸”现象,并在不改变原有类的基础上生成许多新的可用对象。最常用的结构型模式有适配器、组合、装饰、外观和代理。</p>
<p>行为模式确定了多个对象间通信与合作的最佳方式,它刻画了对象之间的合作机制,这种合,作机制高效且能够适应未来的变化。常用的行为模式有迭代器、观察者、状态、策略和访问者。<br>学习设计模式时理解模式的目的、意图和用途很重要,因为编程语言的语法、语义限制,很多设计模式的实现结构很相似甚至完全相同(例如装饰和代理),但不同的设计出发点(意图)和应用领域导致了模式的用法有很大的区别。</p>
<p>设计模式也经常与重构联系在一起,重构会导致应用设计模式,而设计模式的目的是为了避免将来的重构。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">Boost</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">设计模式</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/24/Boost与设计模式/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++调试" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/23/C++调试/">C++调试</a>
    </h1>
  

        
        <a href="/2018/05/23/C++调试/" class="archive-article-date">
  	<time datetime="2018-05-23T09:35:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-23</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="err-hr"><a href="#err-hr" class="headerlink" title="err,hr"></a><code>err,hr</code></h1><p>调试代码时，监视窗口里面填入<code>“$err,hr”(@err,hr或err,hr)</code></p>
<p>它的意义相当于让调试器帮你获取GetLastError的值</p>
<h2 id="Pseudovariables"><a href="#Pseudovariables" class="headerlink" title="Pseudovariables"></a><a href="https://msdn.microsoft.com/en-us/library/ms164891.aspx" target="_blank" rel="noopener">Pseudovariables</a></h2><ul>
<li>$err    显示通过SetLastError设置的错误代码，何在代码中调用GetLastError效果一样。可以用$err,hr来显示错误代码对应的文本信息</li>
<li>$handles    显示应用程序中的句柄数量</li>
<li>$vframe    显示当前栈帧的地址</li>
<li>$tid    显示当前的线程ID</li>
<li>$env    显示当前应用的环境变量</li>
<li>$cmdline    显示运行当前应用的命令行参数</li>
<li>$pid    显示进程ID</li>
<li>$registername或@registername    显示寄存器的内容，如果寄存器的名字不和当前其他变量重名，直接写寄存器的名字也行</li>
<li>$clk    显示clock cycles</li>
<li>$user    显示运行当前用户的用户信息</li>
</ul>
<p>在C#的程序中可以使用的Pseudovariables</p>
<ul>
<li>$exception    显示最后的异常信息</li>
<li>$user    显示运行当前用户的用户信息</li>
</ul>
<h1 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h1><p>使用windbg分析dmp文件定位程序bug</p>
<p><a href="http://www.windbg.org/" target="_blank" rel="noopener">http://www.windbg.org/</a></p>
<p><a href="https://debugging.wellisolutions.de/windbg-versions/" target="_blank" rel="noopener">https://debugging.wellisolutions.de/windbg-versions/</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p>
<p><a href="https://blog.csdn.net/hjing1988/article/details/44399093" target="_blank" rel="noopener">调试相关</a></p>
<p><a href="http://www.zhimengzhe.com/windows/296803.html" target="_blank" rel="noopener">用GFlags和UMDH发现堆内存泄漏</a></p>
<p><a href="https://blog.csdn.net/lluozh2015/article/details/73611079" target="_blank" rel="noopener">【性能分析】UMDH分析内存泄露</a></p>
<p><a href="https://blog.csdn.net/flyingleo1981/article/details/78127625" target="_blank" rel="noopener">windbg小工具umdh查找内存泄露</a></p>
<h1 id="Dbgview"><a href="#Dbgview" class="headerlink" title="Dbgview"></a>Dbgview</h1><p>DebugView跟踪调试信息</p>
<h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p>生成dump文件</p>
<p><a href="http://www.debuginfo.com/articles/effminidumps.html" target="_blank" rel="noopener">http://www.debuginfo.com/articles/effminidumps.html</a></p>
<p><a href="http://www.cppblog.com/woaidongmao/archive/2011/05/10/146086.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2011/05/10/146086.html</a></p>
<p><a href="http://www.cppblog.com/woaidongmao/archive/2009/10/22/99210.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2009/10/22/99210.html</a></p>
<p><a href="http://www.cppblog.com/woaidongmao/archive/2009/10/21/99135.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2009/10/21/99135.html</a></p>
<h2 id="SetUnhandledExceptionFilter"><a href="#SetUnhandledExceptionFilter" class="headerlink" title="SetUnhandledExceptionFilter"></a>SetUnhandledExceptionFilter</h2><p>如果在异常发生之前调用了SetUnhandledExceptionFilter()函数。</p>
<h2 id="set-purecall-handler"><a href="#set-purecall-handler" class="headerlink" title="_set_purecall_handler"></a>_set_purecall_handler</h2><p>调用纯虚函数是一个错误 </p>
<h2 id="set-terminate"><a href="#set-terminate" class="headerlink" title="set_terminate"></a>set_terminate</h2><p>当CRT遇到一个未被处理的C++类型化异常时，它会调用terminate()函数</p>
<h2 id="set-purecall-handler-1"><a href="#set-purecall-handler-1" class="headerlink" title="_set_purecall_handler"></a>_set_purecall_handler</h2><p>使用_set_purecall_handler()函数来处理纯虚函数调用</p>
<h2 id="set-new-handler"><a href="#set-new-handler" class="headerlink" title="_set_new_handler"></a><a href="https://zh.cppreference.com/w/cpp/memory/new/set_new_handler" target="_blank" rel="noopener">_set_new_handler</a></h2><p>使用_set_new_handler()函数处理内存分配失败。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;new&gt;

void handler()
{
    std::cout &lt;&lt; &quot;Memory allocation failed, terminating\n&quot;;
    std::set_new_handler(nullptr);
}

int main()
{
    std::set_new_handler(handler);
    try {
        while (true) {
            new int[100000000ul];
        }
    } catch (const std::bad_alloc&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; &apos;\n&apos;;
    }
}
</code></pre><h2 id="set-invalid-parameter-handler"><a href="#set-invalid-parameter-handler" class="headerlink" title="_set_invalid_parameter_handler"></a><code>_set_invalid_parameter_handler</code></h2><p>当系统函数调用检测到非法的参数时，会使用_set_invalid_parameter_handler()函数来处理这种情况</p>
<h1 id="XCrashReport"><a href="#XCrashReport" class="headerlink" title="XCrashReport"></a>XCrashReport</h1><p><a href="https://www.codeproject.com/Articles/5260/XCrashReport-Exception-Handling-and-Crash-Report" target="_blank" rel="noopener">https://www.codeproject.com/Articles/5260/XCrashReport-Exception-Handling-and-Crash-Report</a></p>
<p><a href="https://blog.csdn.net/ljmscsq/article/details/4998738" target="_blank" rel="noopener">https://blog.csdn.net/ljmscsq/article/details/4998738</a></p>
<p><a href="https://www.codeproject.com/Articles/207464/Exception-Handling-in-Visual-Cplusplus" target="_blank" rel="noopener">https://www.codeproject.com/Articles/207464/Exception-Handling-in-Visual-Cplusplus</a>-可成功生成dump</p>
<p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html" target="_blank" rel="noopener">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p>
<p><a href="https://www.cnblogs.com/kanego/p/4081287.html" target="_blank" rel="noopener">https://www.cnblogs.com/kanego/p/4081287.html</a></p>
<h1 id="crashrpt"><a href="#crashrpt" class="headerlink" title="crashrpt"></a>crashrpt</h1><p><img src="http://crashrpt.sourceforge.net/images/maindlg.png" alt=""></p>
<p>可以使用<code>crashrpt</code>直接集成到自己的项目中，程序崩溃是生成错误报告</p>
<p><a href="http://crashrpt.sourceforge.net/" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/</a></p>
<p><a href="http://crashrpt.sourceforge.net/docs/html/index.html" target="_blank" rel="noopener">CrashRpt文档</a></p>
<p><a href="http://crashrpt.sourceforge.net/docs/html/simple_example.html" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/docs/html/simple_example.html</a></p>
<p><a href="http://crashrpt.sourceforge.net/docs/html/exception_handling.html#getting_exception_context" target="_blank" rel="noopener">关于异常和异常处理</a></p>
<p>crashrpt是一个包含能够在程序出现各种类型未处理异常时生成程序错误报告，然后将该报告按照指定的方式(例如HTTP或者SMTP)发送给开发者，最后分析这些信息的工具。crashrpt由3个部分组成，错误报告生成库CrashRpt，我们需要在自己的程序中使用该库捕获我们的程序没有处理的异常，在该库捕获到这些未处理的异常后，CrashRpt会生成MiniDump文件，并将和你使用该库指定的信息(例如日志文件和屏幕截图等)一起打包成错误报告。CrashRpt库支持处理我所知道的所有Windows C/C++程序抛出的各类异常，例如我前面提到过的SEH，它还能捕获C++异常、信号和调用各类CRT库中的函数出现的错误。异常信息发送工具CrashSender，该工具能够按照我们使用CrashRpt设置的方式，将生成的错误报告按照我们指定的方式(HTTP、SMTP或者MAPI)发送给我们。自动异常信息处理工具crprober，该工具能够在后台接收CrashSender发送给我们的错误报告，通过分析错误报告后以文本的形式输出程序的异常信息。</p>
<p><a href="https://blog.csdn.net/shining100/article/details/7760872" target="_blank" rel="noopener">https://blog.csdn.net/shining100/article/details/7760872</a></p>
<p><a href="http://crashrpt.sourceforge.net/docs/html/configuring_project.html" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/docs/html/configuring_project.html</a></p>
<h1 id="crashfix"><a href="#crashfix" class="headerlink" title="crashfix"></a>crashfix</h1><p>crashfix CrashRpt的免费和开源服务器，接收、存储、组织及分析事故报告发送的 C + + 应用程序。</p>
<p>崩溃报告是一种允许接收用户反馈并提高软件质量和稳定性的技术。当您的应用遇到严重错误（也称为异常或崩溃）时，会生成崩溃报告文件并通过Internet发送到您的服务器。CrashFix服务器允许轻松接收，存储，组织和分析C ++应用程序发送的崩溃报告。</p>
<p><a href="http://crashfix.sourceforge.net/" target="_blank" rel="noopener">http://crashfix.sourceforge.net/</a></p>
<p><a href="http://crashfix.sourceforge.net/doc/html/index.html" target="_blank" rel="noopener">http://crashfix.sourceforge.net/doc/html/index.html</a></p>
<p><a href="https://blog.csdn.net/aa13058219642/article/details/80431100#comments" target="_blank" rel="noopener">CrashFix——CrshRpt的分析工具</a></p>
<h1 id="http-www-debuginfo-com"><a href="#http-www-debuginfo-com" class="headerlink" title="http://www.debuginfo.com"></a><a href="http://www.debuginfo.com" target="_blank" rel="noopener">http://www.debuginfo.com</a></h1><h2 id="MINIDUMPS"><a href="#MINIDUMPS" class="headerlink" title="MINIDUMPS"></a>MINIDUMPS</h2><p><a href="http://www.debuginfo.com/articles/effminidumps.html" target="_blank" rel="noopener">http://www.debuginfo.com/articles/effminidumps.html</a></p>
<p><a href="http://www.debuginfo.com/examples/effmdmpexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/effmdmpexamples.html</a></p>
<p><a href="http://www.debuginfo.com/download/effminidumpexamples.zip" target="_blank" rel="noopener">effminidumpexamples.zip</a></p>
<h2 id="dbghelp"><a href="#dbghelp" class="headerlink" title="dbghelp"></a>dbghelp</h2><p><a href="http://www.debuginfo.com/examples/dbghelpexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/dbghelpexamples.html</a></p>
<p><a href="http://www.debuginfo.com/download/dbghelpexamples.zip" target="_blank" rel="noopener">dbghelpexamples.zip</a></p>
<h2 id="DEBUGGING-API-EXAMPLES"><a href="#DEBUGGING-API-EXAMPLES" class="headerlink" title="DEBUGGING API EXAMPLES"></a>DEBUGGING API EXAMPLES</h2><p><a href="http://www.debuginfo.com/examples/dbgexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/dbgexamples.html</a></p>
<p><a href="http://www.debuginfo.com/download/dbgexamples.zip" target="_blank" rel="noopener">dbgexamples.zip</a></p>
<h2 id="MINIDUMP-WIZARD"><a href="#MINIDUMP-WIZARD" class="headerlink" title="MINIDUMP WIZARD"></a>MINIDUMP WIZARD</h2><p><a href="http://www.debuginfo.com/tools/minidumpwizard.html" target="_blank" rel="noopener">http://www.debuginfo.com/tools/minidumpwizard.html</a></p>
<p><a href="http://www.debuginfo.com/download/minidumpwizfull.zip" target="_blank" rel="noopener">minidumpwizfull.zip</a></p>
<p><a href="http://www.debuginfo.com/download/minidumpwiz.zip" target="_blank" rel="noopener">minidumpwiz.zip</a></p>
<h2 id="UNEXPECTED-USER-BREAKPOINT-IN-NTDLL-DLL"><a href="#UNEXPECTED-USER-BREAKPOINT-IN-NTDLL-DLL" class="headerlink" title="UNEXPECTED USER BREAKPOINT IN NTDLL.DLL"></a>UNEXPECTED USER BREAKPOINT IN NTDLL.DLL</h2><p>用户在断点意外 NTDLL. DLL</p>
<p><a href="http://www.debuginfo.com/tips/userbpntdll.html" target="_blank" rel="noopener">http://www.debuginfo.com/tips/userbpntdll.html</a></p>
<p><a href="https://www.cnblogs.com/lidabo/p/3706725.html" title="使用PageHeap.EXE或GFlags.EXE检查内存越界错误" target="_blank" rel="noopener">https://www.cnblogs.com/lidabo/p/3706725.html</a></p>
<h1 id="About-DbgHelp"><a href="#About-DbgHelp" class="headerlink" title="About DbgHelp"></a>About DbgHelp</h1><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679267%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MSDN-About DbgHelp</a></p>
<h1 id="STL扩展库"><a href="#STL扩展库" class="headerlink" title="STL扩展库"></a><a href="http://cplusplus.wikidot.com/cn:stdext" target="_blank" rel="noopener">STL扩展库</a></h1><p><a href="http://cplusplus.wikidot.com/cn:memory-management" target="_blank" rel="noopener">内存管理专题（Memory Management）</a></p>
<h1 id="关于MFC中的-ifdef-DEBUG-undef-THIS-FILE-static-char-THIS-FILE-FILE-endif"><a href="#关于MFC中的-ifdef-DEBUG-undef-THIS-FILE-static-char-THIS-FILE-FILE-endif" class="headerlink" title="关于MFC中的#ifdef _DEBUG #undef THIS_FILE static char THIS_FILE[]=__FILE__; #endif"></a><a href="https://blog.csdn.net/ZYTTAE/article/details/44926393" target="_blank" rel="noopener">关于MFC中的<code>#ifdef _DEBUG #undef THIS_FILE static char THIS_FILE[]=__FILE__; #endif</code></a></h1><p>情况1:</p>
<pre><code>#ifdef _DEBUG
virtual void AssertValid() const; //assert(断言)valid(有效的，正确的)
virtual void Dump(CDumpContext&amp; dc) const; //存储上下文
#endif
</code></pre><p>这两个函数是调试用的，第一个函数检查可用性，即是否有效。第二个函数如果未更改的话，最终调用的是Cwnd::Dump();输出窗口类名，标题名等一系列信息（在输出窗口中）。</p>
<pre><code>#ifdef _DEBUG
#endif
</code></pre><p>这是条件编译，即如果有#define _DEBUG这两个函数会编译，否则忽略。当你用debug生成时（相对于release）开发环境则自动的加上这个宏定义，这两个函数有效。</p>
<p>情况2:</p>
<pre><code>#ifdef _DEBUG // 判断是否定义_DEBUG
#undef THIS_FILE // 取消THIS_FILE的定义
static char THIS_FILE[]=__FILE__; // 定义THIS_FILE指向文件名
#define new DEBUG_NEW // 定义调试new宏，取代new关键字
#endif // 结束
</code></pre><p>如果定义了_DEBUG，表示在调试状态下编译，因此相应修改了两个符号的定义。<br><code>THIS_FILE</code>是一个char数组全局变量，字符串值为当前文件的全路径，这样在Debug版本中当程序出错时出错处理代码可用这个变量告诉你是哪个文件中的代码有问题。</p>
<p>定义 _DEBUG后，由于定义了_DEBUG,编译器确定这是一个调试，编译<code>#ifdef _DEBUG</code>和<code>#endif</code>之间的代码。<code>#undef</code> 表示清除当前定义的宏，使得<code>THIS_FILE</code>无定义。<br><code>__FILE__</code> 是编译器能识别的事先定义的ANSI C 的6个宏之一。</p>
<p>DEBUG_NEW定位内存泄露并且跟踪文件名和行号。</p>
<p>情况3:</p>
<pre><code>#ifdef _DEBUG //如果是debug状态
#undef THIS_FILE //清除THIS_FILE
static char THIS_FILE[]=__FILE__; //定义THIS_FILE为__FILE__（这是当前文件全路径名字）
#define new DEBUG_NEW //定义new为DEBUG_NEW（这个可以检测到内存泄露之类的问题，其实就是可以使用crt开头的那几个调试函数）
#endif
</code></pre><p>ANSI C 的6个宏：</p>
<pre><code>__FILE__为预编译器常量，返回当前编译的文件名，还有比较常用的几个预编译器常量；
__LINE__编译器正在编译的文件的第几行；
__DATE__返回当前的日期Jul-20-2004；
__TIME__返回当前的时间hh:mm:ss； 
__TIMESTAMP__ 的预定义的编译器宏始终返回时间戳信息。在太平洋标准的时间内无论本地时间和CL.EXE 的运行位置在计算机上的时区。
__STDC__条件编译，意思是：如果定义了标准C或c++，那么编译这句话后面直到#endif以前的源代码。
_STDC__cplusplus这两个都是标准宏，_STDC_表示是是否符合标准C；_cplusplus表示是否是C++。
</code></pre><p>曾经一个解释说，多次使用<code>__FILE__</code>宏，虽然得到字符串的内容相同，但是可能地址不同，即同一个字符串常量多次用到时占用不同的地址，这样导致需要的内存增加了。为了检测内在泄露, Debug 版本的 new 附加上了调用 new 的文件名与调用所在的行号信息, 这是通过 <code>__FILE__</code> 和 <code>__LINE__</code> 来实现的, 这两个属于预定义的内部宏, 而之所以要用 <code>THIS_FILE</code> 来代替 <code>__FILE__</code>, 是为了减少程序大小: 如果你在一个文件中有 10000 次对 new 的调用, 那么会生成 10000 个当前文件名的常量字符串(第一个都是由 <code>__FILE__</code> 宏扩展而来的), 最后生成的目标文件会很大, 而用 <code>THIS_FILE</code> 来代替, 当前文件名只有一份, 传递文件名使用 <code>THIS_FILE</code> 指针就可以了。<br><code>__FILE__</code>和<code>__LINE__</code>一样都是编译器定义的宏。当碰到<code>__FILE__</code>时，编译器会把<code>__FILE__</code>替换成一个字符串，这个字符串就是当前在编译的文件的路径名。在<code>DEBUG_NEW</code>的定义中没有直接使用<code>__FILE__</code>，而是用了<code>THIS_FILE</code>，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用<code>__FILE__</code>，那编译器会产生100个常量字符串，这100个字符串都是这个cpp文件的路径名，显然十分冗余。如果使用<code>THIS_FILE</code>，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。</p>
<p>在MFC中，可以使用 <code>DEBUG_NEW</code> 宏代替 new 运算符来帮助定位内存泄漏。在程序的“Debug”版本中，<code>DEBUG_NEW</code> 将为所分配的每个对象跟踪文件名和行号。当编译程序的“Release”版本时，<code>DEBUG_NEW</code> 将解析为不包含文件名和行号信息的简单 new 操作。因此，在程序的“Release”版本中不会造成任何速度损失。 </p>
<h1 id="最快速度找到内存泄漏"><a href="#最快速度找到内存泄漏" class="headerlink" title="最快速度找到内存泄漏"></a><a href="http://cplusplus.wikidot.com/cn:the-fastest-way-to-find-memory-leak" target="_blank" rel="noopener">最快速度找到内存泄漏</a></h1><h1 id="dmp调试"><a href="#dmp调试" class="headerlink" title="dmp调试"></a>dmp调试</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/d5zhxt22.aspx" target="_blank" rel="noopener">使用转储文件在 Visual Studio 中调试应用程序崩溃和挂起</a></p>
<p>exe + pdb + dmp 在同一目录，然后双击dmp文件VC就可以打开，然后点击右上角的调试按钮就可以直接定位到崩溃的代码了；</p>
<h1 id="适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）"><a href="#适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）" class="headerlink" title="适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）"></a><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index" target="_blank" rel="noopener">适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）</a></h1><h1 id="SEH（结构化异常处理）"><a href="#SEH（结构化异常处理）" class="headerlink" title="SEH（结构化异常处理）"></a>SEH（结构化异常处理）</h1><p><a href="https://blog.csdn.net/xuhao_xuhao/article/details/49519695" target="_blank" rel="noopener">异常和异常处理（windows平台）</a></p>
<p><a href="https://blog.csdn.net/aa13058219642/article/details/80253609" target="_blank" rel="noopener">深入解析结构化异常处理(SEH)</a></p>
<h1 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h1><p><a href="https://blog.csdn.net/hjing1988/article/details/50933735" target="_blank" rel="noopener">CRT内存泄露检测</a></p>
<p><a href="https://blog.csdn.net/hongxingabc/article/details/49873541?locationNum=4" target="_blank" rel="noopener">内存泄露检测之使用CRT的Debug技术</a></p>
<h1 id="MemTrack"><a href="#MemTrack" class="headerlink" title="MemTrack"></a><a href="http://www.almostinfinite.com/memtrack.html" target="_blank" rel="noopener">MemTrack</a></h1><p>Appendix A: MemTrack.h</p>
<pre><code>/*
Copyright (c) 2002, 2008 Curtis Bartley
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the
distribution.

- Neither the name of Curtis Bartley nor the names of any other
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MemTrack_H_
#define MemTrack_H_

#include &lt;typeinfo&gt;

namespace MemTrack
{
    /* ---------------------------------------- class MemStamp */

    class MemStamp
    {
        public:        // member variables
            char const * const filename;
            int const lineNum;
        public:        // construction/destruction
            MemStamp(char const *filename, int lineNum)
                : filename(filename), lineNum(lineNum) { }
            ~MemStamp() { }
    };

    /* ---------------------------------------- memory allocation and stamping prototypes */

    void *TrackMalloc(size_t size);
    void TrackFree(void *p);
    void TrackStamp(void *p, const MemStamp &amp;stamp, char const *typeName);
    void TrackDumpBlocks();
    void TrackListMemoryUsage();

    /* ---------------------------------------- operator * (MemStamp, ptr) */

    template &lt;class T&gt; inline T *operator*(const MemStamp &amp;stamp, T *p)
    {
        TrackStamp(p, stamp, typeid(T).name());
        return p;
    }

}    // namespace MemTrack

/* ---------------------------------------- new macro */

#define MEMTRACK_NEW MemTrack::MemStamp(__FILE__, __LINE__) * new
#define new MEMTRACK_NEW

#endif    // MemTrack_H_
</code></pre><p>Appendix B: MemTrack.cpp</p>
<pre><code>/*
Copyright (c) 2002, 2008 Curtis Bartley
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the
distribution.

- Neither the name of Curtis Bartley nor the names of any other
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* ---------------------------------------- includes */

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;new&gt;

#include &quot;MemTrack.h&quot;
#undef new    // IMPORTANT!

/* ------------------------------------------------------------ */
/* -------------------- namespace MemTrack -------------------- */
/* ------------------------------------------------------------ */

namespace MemTrack
{

    /* ------------------------------------------------------------ */
    /* --------------------- class BlockHeader -------------------- */
    /* ------------------------------------------------------------ */

    class BlockHeader
    {
        private:    // static member variables
            static BlockHeader *ourFirstNode;

        private:    // member variables
            BlockHeader *myPrevNode;
            BlockHeader *myNextNode;
            size_t myRequestedSize;
            char const *myFilename;
            int myLineNum;
            char const *myTypeName;

        public:     // members
            BlockHeader(size_t requestedSize);
            ~BlockHeader();

            size_t GetRequestedSize() const { return myRequestedSize; }
            char const *GetFilename() const { return myFilename; }
            int GetLineNum() const { return myLineNum; }
            char const *GetTypeName() const { return myTypeName; }

            void Stamp(char const *filename, int lineNum, char const *typeName);

            static void AddNode(BlockHeader *node);
            static void RemoveNode(BlockHeader *node);
            static size_t CountBlocks();
            static void GetBlocks(BlockHeader **blockHeaderPP);
            static bool TypeGreaterThan(BlockHeader *header1, BlockHeader *header2);
    };

    /* ---------------------------------------- BlockHeader static member variables */

    BlockHeader *BlockHeader::ourFirstNode = NULL;

    /* ---------------------------------------- BlockHeader constructor */

    BlockHeader::BlockHeader(size_t requestedSize)
    {
        myPrevNode = NULL;
        myNextNode = NULL;
        myRequestedSize = requestedSize;
        myFilename = &quot;[unknown]&quot;;
        myLineNum = 0;
        myTypeName = &quot;[unknown]&quot;;
    }

    /* ---------------------------------------- BlockHeader destructor */

    BlockHeader::~BlockHeader()
    {
    }

    /* ---------------------------------------- BlockHeader Stamp */

    void BlockHeader::Stamp(char const *filename, int lineNum, char const *typeName)
    {
        myFilename = filename;
        myLineNum = lineNum;
        myTypeName = typeName;
    }

    /* ---------------------------------------- BlockHeader AddNode */

    void BlockHeader::AddNode(BlockHeader *node)
    {
        assert(node != NULL);
        assert(node-&gt;myPrevNode == NULL);
        assert(node-&gt;myNextNode == NULL);

        // If we have at least one node in the list ...        
        if (ourFirstNode != NULL)
        {
            // ... make the new node the first node&apos;s predecessor.
            assert(ourFirstNode-&gt;myPrevNode == NULL);
            ourFirstNode-&gt;myPrevNode = node;
        }

        // Make the first node the new node&apos;s succesor.
        node-&gt;myNextNode = ourFirstNode;

        // Make the new node the first node.
        ourFirstNode = node;
    }

    /* ---------------------------------------- BlockHeader RemoveNode */

    void BlockHeader::RemoveNode(BlockHeader *node)
    {
        assert(node != NULL);
        assert(ourFirstNode != NULL);

        // If target node is the first node in the list...
        if (ourFirstNode == node)
        {
            // ... make the target node&apos;s successor the first node.
            assert(ourFirstNode-&gt;myPrevNode == NULL);
            ourFirstNode = node-&gt;myNextNode;
        }

        // Link target node&apos;s predecessor, if any, to its successor.
        if (node-&gt;myPrevNode != NULL)
        {
            node-&gt;myPrevNode-&gt;myNextNode = node-&gt;myNextNode;
        }

        // Link target node&apos;s successor, if any, to its predecessor.
        if (node-&gt;myNextNode != NULL)
        {
            node-&gt;myNextNode-&gt;myPrevNode = node-&gt;myPrevNode;
        }

        // Clear target node&apos;s previous and next pointers.
        node-&gt;myPrevNode = NULL;
        node-&gt;myNextNode = NULL;
    }

    /* ---------------------------------------- BlockHeader CountBlocks */

    size_t BlockHeader::CountBlocks()
    {
        size_t count = 0;
        BlockHeader *currNode = ourFirstNode;
        while (currNode != NULL)
        {
            count++;
            currNode = currNode-&gt;myNextNode;
        }
        return count;
    }

    /* ---------------------------------------- BlockHeader GetBlocks */

    void BlockHeader::GetBlocks(BlockHeader **blockHeaderPP)
    {
        BlockHeader *currNode = ourFirstNode;
        while (currNode != NULL)
        {
            *blockHeaderPP = currNode;
            blockHeaderPP++;
            currNode = currNode-&gt;myNextNode;
        }
    }

    /* ---------------------------------------- BlockHeader TypeGreaterThan */

    bool BlockHeader::TypeGreaterThan(BlockHeader *header1, BlockHeader *header2)
    {
        return (strcmp(header1-&gt;myTypeName, header2-&gt;myTypeName) &gt; 0);
    }

    /* ------------------------------------------------------------ */
    /* ---------------------- class Signature --------------------- */
    /* ------------------------------------------------------------ */

    class Signature
    {
        private:    // constants
            static const unsigned int SIGNATURE1 = 0xCAFEBABE;
            static const unsigned int SIGNATURE2 = 0xFACEFACE;

        private:    // member variables
            unsigned int mySignature1;
            unsigned int mySignature2;

        public:        // construction/destruction
            Signature() : mySignature1(SIGNATURE1), mySignature2(SIGNATURE2) {};
            ~Signature() { mySignature1 = 0; mySignature2 = 0; }

        public:        // static member functions
            static bool IsValidSignature(const Signature *pProspectiveSignature)
            {
                try
                {
                    if (pProspectiveSignature-&gt;mySignature1 != SIGNATURE1) return false;
                    if (pProspectiveSignature-&gt;mySignature2 != SIGNATURE2) return false;
                    return true;
                }
                catch (...)
                {
                    return false;
                }
            }
    };

    /* ------------------------------------------------------------ */
    /* -------------------- address conversion -------------------- */
    /* ------------------------------------------------------------ */

    /* We divide the memory blocks we allocate into two &quot;chunks&quot;, the
     * &quot;prolog chunk&quot; where we store information about the allocation,
     * and the &quot;user chunk&quot; which we return to the caller to use.
     */

    /* ---------------------------------------- alignment */

    const size_t ALIGNMENT = 4;

    /* If &quot;value&quot; (a memory size or offset) falls on an alignment boundary,
     * then just return it.  Otherwise return the smallest number larger
     * than &quot;value&quot; that falls on an alignment boundary.
     */    

    #define PAD_TO_ALIGNMENT_BOUNDARY(value) \
        ((value) + ((ALIGNMENT - ((value) % ALIGNMENT)) % ALIGNMENT))

    /* ---------------------------------------- chunk structs */

    /* We declare incomplete structures for each chunk, just to 
     * provide type safety.
     */

    struct PrologChunk;
    struct UserChunk;

    /* ---------------------------------------- chunk sizes and offsets */

    const size_t SIZE_BlockHeader = PAD_TO_ALIGNMENT_BOUNDARY(sizeof(BlockHeader));
    const size_t SIZE_Signature = PAD_TO_ALIGNMENT_BOUNDARY(sizeof(Signature));

    const size_t OFFSET_BlockHeader = 0;
    const size_t OFFSET_Signature = OFFSET_BlockHeader + SIZE_BlockHeader;
    const size_t OFFSET_UserChunk = OFFSET_Signature + SIZE_Signature;

    const size_t SIZE_PrologChunk = OFFSET_UserChunk;

    /* ---------------------------------------- GetUserAddress */

    static UserChunk *GetUserAddress(PrologChunk *pProlog)
    {
        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);
        char *pchUser = pchProlog + OFFSET_UserChunk;
        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(pchUser);
        return pUser;
    }

    /* ---------------------------------------- GetPrologAddress */

    static PrologChunk *GetPrologAddress(UserChunk *pUser)
    {
        char *pchUser = reinterpret_cast&lt;char *&gt;(pUser);
        char *pchProlog = pchUser - OFFSET_UserChunk;
        PrologChunk *pProlog = reinterpret_cast&lt;PrologChunk *&gt;(pchProlog);
        return pProlog;
    }

    /* ---------------------------------------- GetHeaderAddress */

    static BlockHeader *GetHeaderAddress(PrologChunk *pProlog)
    {
        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);
        char *pchHeader = pchProlog + OFFSET_BlockHeader;
        BlockHeader *pHeader = reinterpret_cast&lt;BlockHeader *&gt;(pchHeader);
        return pHeader;
    }

    /* ---------------------------------------- GetSignatureAddress */

    static Signature *GetSignatureAddress(PrologChunk *pProlog)
    {
        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);
        char *pchSignature = pchProlog + OFFSET_Signature;
        Signature *pSignature = reinterpret_cast&lt;Signature *&gt;(pchSignature);
        return pSignature;
    }

    /* ------------------------------------------------------------ */
    /* -------------- memory allocation and stamping -------------- */
    /* ------------------------------------------------------------ */

    /* ---------------------------------------- TrackMalloc */

    void *TrackMalloc(size_t size)
    {
        // Allocate the memory, including space for the prolog.
        PrologChunk *pProlog = (PrologChunk *)malloc(SIZE_PrologChunk + size);

        // If the allocation failed, then return NULL.
        if (pProlog == NULL) return NULL;

        // Use placement new to construct the block header in place.
        BlockHeader *pBlockHeader = new (pProlog) BlockHeader(size);

        // Link the block header into the list of extant block headers.
        BlockHeader::AddNode(pBlockHeader);

        // Use placement new to construct the signature in place.
        Signature *pSignature = new (GetSignatureAddress(pProlog)) Signature;

        // Get the offset to the user chunk and return it.
        UserChunk *pUser = GetUserAddress(pProlog);

        return pUser;
    }

    /* ---------------------------------------- TrackFree */

    void TrackFree(void *p)
    {
        // It&apos;s perfectly valid for &quot;p&quot; to be null; return if it is.
        if (p == NULL) return;

        // Get the prolog address for this memory block.
        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(p);    
        PrologChunk *pProlog = GetPrologAddress(pUser);

        // Check the signature, and if it&apos;s invalid, return immediately.
        Signature *pSignature = GetSignatureAddress(pProlog);
        if (!Signature::IsValidSignature(pSignature)) return;

        // Destroy the signature.
        pSignature-&gt;~Signature();
        pSignature = NULL;

        // Unlink the block header from the list and destroy it.
        BlockHeader *pBlockHeader = GetHeaderAddress(pProlog);
        BlockHeader::RemoveNode(pBlockHeader);
        pBlockHeader-&gt;~BlockHeader();
        pBlockHeader = NULL;

        // Free the memory block.    
        free(pProlog);
    }

    /* ---------------------------------------- TrackStamp */

    void TrackStamp(void *p, const MemStamp &amp;stamp, char const *typeName)
    {
        // Get the header and signature address for this pointer.
        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(p);
        PrologChunk *pProlog = GetPrologAddress(pUser);
        BlockHeader *pHeader = GetHeaderAddress(pProlog);
        Signature *pSignature = GetSignatureAddress(pProlog);

        // If the signature is not valid, then return immediately.
        if (!Signature::IsValidSignature(pSignature)) return;

        // &quot;Stamp&quot; the information onto the header.
        pHeader-&gt;Stamp(stamp.filename, stamp.lineNum, typeName);
    }

    /* ---------------------------------------- TrackDumpBlocks */

    void TrackDumpBlocks()
    {
        // Get an array of pointers to all extant blocks.
        size_t numBlocks = BlockHeader::CountBlocks();
        BlockHeader **ppBlockHeader =
            (BlockHeader **)calloc(numBlocks, sizeof(*ppBlockHeader));
        BlockHeader::GetBlocks(ppBlockHeader);

        // Dump information about the memory blocks.
        printf(&quot;\n&quot;);
        printf(&quot;=====================\n&quot;);
        printf(&quot;Current Memory Blocks\n&quot;);
        printf(&quot;=====================\n&quot;);
        printf(&quot;\n&quot;);
        for (size_t i = 0; i &lt; numBlocks; i++)
        {
            BlockHeader *pBlockHeader = ppBlockHeader[i];
            char const *typeName = pBlockHeader-&gt;GetTypeName();
            size_t size = pBlockHeader-&gt;GetRequestedSize();
            char const *fileName = pBlockHeader-&gt;GetFilename();
            int lineNum = pBlockHeader-&gt;GetLineNum();
            printf(&quot;*** #%-6d %5d bytes %-50s\n&quot;, i, size, typeName);
            printf(&quot;... %s:%d\n&quot;, fileName, lineNum);
        }

        // Clean up.
        free(ppBlockHeader);
    }

    /* ---------------------------------------- struct MemDigest */

    struct MemDigest
    {
        char const *typeName;
        int blockCount;
        size_t totalSize;

        static bool TotalSizeGreaterThan(const MemDigest &amp;md1, const MemDigest &amp;md2)
            { return md1.totalSize &gt; md2.totalSize; }
    };


    /* ---------------------------------------- SummarizeMemoryUsageForType */

    static void SummarizeMemoryUsageForType(
        MemDigest *pMemDigest,
        BlockHeader **ppBlockHeader,
        size_t startPost,
        size_t endPost
    )
    {
        pMemDigest-&gt;typeName = ppBlockHeader[startPost]-&gt;GetTypeName();
        pMemDigest-&gt;blockCount = 0;
        pMemDigest-&gt;totalSize = 0;
        for (size_t i = startPost; i &lt; endPost; i++)
        {
            pMemDigest-&gt;blockCount++;
            pMemDigest-&gt;totalSize += ppBlockHeader[i]-&gt;GetRequestedSize();
            assert(strcmp(ppBlockHeader[i]-&gt;GetTypeName(), pMemDigest-&gt;typeName) == 0);
        }
    }

    /* ---------------------------------------- TrackListMemoryUsage */

    void TrackListMemoryUsage()
    {
        // If there are no allocated blocks, then return now.
        size_t numBlocks = BlockHeader::CountBlocks();
        if (numBlocks == 0) return;

        // Get an array of pointers to all extant blocks.
        BlockHeader **ppBlockHeader =
            (BlockHeader **)calloc(numBlocks, sizeof(*ppBlockHeader));
        BlockHeader::GetBlocks(ppBlockHeader);

        // Sort the blocks by type name.
        std::sort(
            ppBlockHeader,
            ppBlockHeader + numBlocks,
            BlockHeader::TypeGreaterThan
        );

        // Find out how many unique types we have.
        size_t numUniqueTypes = 1;
        for (size_t i = 1; i &lt; numBlocks; i++)
        {
            char const *prevTypeName = ppBlockHeader[i - 1]-&gt;GetTypeName();
            char const *currTypeName = ppBlockHeader[i]-&gt;GetTypeName();
            if (strcmp(prevTypeName, currTypeName) != 0) numUniqueTypes++;
        }

        // Create an array of &quot;digests&quot; summarizing memory usage by type.
        size_t startPost = 0;
        size_t uniqueTypeIndex = 0;
        MemDigest *pMemDigestArray =
            (MemDigest *)calloc(numUniqueTypes, sizeof(*pMemDigestArray));
        for (size_t i = 1; i &lt;= numBlocks; i++)    // yes, less than or *equal* to
        {
            char const *prevTypeName = ppBlockHeader[i - 1]-&gt;GetTypeName();
            char const *currTypeName = (i &lt; numBlocks) ? ppBlockHeader[i]-&gt;GetTypeName() : &quot;&quot;;
            if (strcmp(prevTypeName, currTypeName) != 0)
            {
                size_t endPost = i;
                SummarizeMemoryUsageForType(
                    pMemDigestArray + uniqueTypeIndex,
                    ppBlockHeader,
                    startPost,
                    endPost
                );
                startPost = endPost;
                uniqueTypeIndex++;
            }
        }
        assert(uniqueTypeIndex = numUniqueTypes);

        // Sort the digests by total memory usage.
        std::sort(
            pMemDigestArray,
            pMemDigestArray + numUniqueTypes,
            MemDigest::TotalSizeGreaterThan
        );

        // Compute the grand total memory usage.
        size_t grandTotalNumBlocks = 0;
        size_t grandTotalSize = 0;
        for (size_t i = 0; i &lt; numUniqueTypes; i++)
        {
            grandTotalNumBlocks += pMemDigestArray[i].blockCount;
            grandTotalSize += pMemDigestArray[i].totalSize;
        }

        // Dump the memory usage statistics.
        printf(&quot;\n&quot;);
        printf(&quot;-----------------------\n&quot;);
        printf(&quot;Memory Usage Statistics\n&quot;);
        printf(&quot;-----------------------\n&quot;);
        printf(&quot;\n&quot;);
        printf(&quot;%-50s%5s  %5s %7s %s \n&quot;, &quot;allocated type&quot;, &quot;blocks&quot;, &quot;&quot;, &quot;bytes&quot;, &quot;&quot;);
        printf(&quot;%-50s%5s  %5s %7s %s \n&quot;, &quot;--------------&quot;, &quot;------&quot;, &quot;&quot;, &quot;-----&quot;, &quot;&quot;);

        for (size_t i = 0; i &lt; numUniqueTypes; i++)
        {
            MemDigest *pMD = pMemDigestArray + i;
            size_t blockCount = pMD-&gt;blockCount;
            double blockCountPct = 100.0 * blockCount / grandTotalNumBlocks;
            size_t totalSize = pMD-&gt;totalSize;
            double totalSizePct = 100.0 * totalSize / grandTotalSize;

            printf(
                &quot;%-50s %5d %5.1f%% %7d %5.1f%%\n&quot;,
                pMD-&gt;typeName,
                blockCount,
                blockCountPct,
                totalSize,
                totalSizePct
            );
        }
        printf(&quot;%-50s %5s %5s  %7s %s \n&quot;, &quot;--------&quot;, &quot;-----&quot;, &quot;&quot;, &quot;-------&quot;, &quot;&quot;);
        printf(&quot;%-50s %5d %5s  %7d %s \n&quot;, &quot;[totals]&quot;, grandTotalNumBlocks, &quot;&quot;, grandTotalSize, &quot;&quot;);

        // Clean up.
        free(ppBlockHeader);
        free(pMemDigestArray);
    }

}    // namespace MemTrack

/* ------------------------------------------------------------ */
/* ---------------------- new and delete ---------------------- */
/* ------------------------------------------------------------ */

/* ---------------------------------------- operator new */

void *operator new(size_t size)
{
    void *p = MemTrack::TrackMalloc(size);
    if (p == NULL) throw std::bad_alloc();
    return p;
}

/* ---------------------------------------- operator delete */

void operator delete(void *p)
{
    MemTrack::TrackFree(p);
}

/* ---------------------------------------- operator new[] */

void *operator new[](size_t size)
{
    void *p = MemTrack::TrackMalloc(size);
    if (p == NULL) throw std::bad_alloc();
    return p;
}

/* ---------------------------------------- operator delete[] */

void operator delete[](void *p)
{
    MemTrack::TrackFree(p);
}
</code></pre><h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a><a href="http://valgrind.org/" target="_blank" rel="noopener">Valgrind</a></h1><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="http://blog.chenxu.me/post/detail?id=f4301bf3-3709-4c8f-8a45-9b9015909ce2" target="_blank" rel="noopener">Visual Studio 调试扫盲</a></p>
<p><a href="https://www.jianshu.com/p/c6f0939d512e" target="_blank" rel="noopener">Dump调试</a></p>
<p><a href="http://fresky.github.io/tags/Debug/" target="_blank" rel="noopener">http://fresky.github.io/tags/Debug/</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">调试</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">错误报告</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">内存泄露</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/23/C++调试/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-内存泄漏及检测" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/23/内存泄漏及检测/">内存泄露检查</a>
    </h1>
  

        
        <a href="/2018/05/23/内存泄漏及检测/" class="archive-article-date">
  	<time datetime="2018-05-23T07:35:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-23</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="检测是否存在内存泄漏问题"><a href="#检测是否存在内存泄漏问题" class="headerlink" title="检测是否存在内存泄漏问题"></a>检测是否存在内存泄漏问题</h1><p>Windows平台下面Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏。在vs中启用内存检测的方法如下：</p>
<ul>
<li>STEP1，在程序中包括以下语句： （#include 语句必须采用上文所示顺序。 如果更改了顺序，所使用的函数可能无法正常工作。）</li>
</ul>
<pre><code>#define _CRTDBG_MAP_ALLOC

#include &lt;stdlib.h&gt;

#include &lt;crtdbg.h&gt;
</code></pre><p>通过包括 crtdbg.h，将 malloc 和 free 函数映射到它们的调试版本，即 _malloc_dbg 和 _free_dbg，这两个函数将跟踪内存分配和释放。 此映射只在调试版本（在其中定义了_DEBUG）中发生。 发布版本使用普通的 malloc和 free函数。</p>
<p><code>#define</code> 语句将 CRT 堆函数的基版本映射到对应的“Debug”版本。 并非绝对需要该语句；但如果没有该语句，内存泄漏转储包含的有用信息将较少。</p>
<ul>
<li><p>STEP2， 在添加了上述语句之后，可以通过在程序中包括以下语句（通常应恰好放在程序退出位置之前）来转储内存泄漏信息：</p>
<pre><code>_CrtDumpMemoryLeaks();
</code></pre></li>
</ul>
<p>未定义 _CRTDBG_MAP_ALLOC 时，所显示的会是：</p>
<pre><code>1. 内存分配编号（在大括号内）。
2. 块类型（普通、客户端或 CRT）。
3. 十六进制形式的内存位置。
4. 以字节为单位的块大小。
5. 前 16 字节的内容（亦为十六进制）。
</code></pre><p>块类型分为：</p>
<pre><code>1. “普通块”是由程序分配的普通内存。
2. “客户端块”是由 MFC 程序用于需要析构函数的对象的特殊类型内存块。 MFC new 操作根据正在创建的对象的需要创建普通块或客户端块。
3. “CRT 块”是由 CRT 库为自己使用而分配的内存块。 CRT 库处理这些块的释放，因此您不大可能在内存泄漏报告中看到这些块，除非出现严重错误（例如 CRT 库损坏）。
</code></pre><p>从不会在内存泄漏信息中看到下面两种块类型：</p>
<pre><code>1. “可用块”是已释放的内存块。
2. “忽略块”是您已特别标记的块，因而不出现在内存泄漏报告中。
</code></pre><p>定义了 _CRTDBG_MAP_ALLOC 时，还会显示在其中分配泄漏的内存的文件。 文件名后括号中的数字（本示例中为 10）是该文件中的行号。</p>
<p>如果程序总是在同一位置退出，调用 _CrtDumpMemoryLeaks 将非常容易。 如果程序从多个位置退出，则无需在每个可能退出的位置放置对_CrtDumpMemoryLeaks 的调用，而可以在程序开始处包含以下调用：</p>
<pre><code>_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
</code></pre><p>该语句在程序退出时自动调用 _CrtDumpMemoryLeaks。 必须同时设置 _CRTDBG_ALLOC_MEM_DF和 _CRTDBG_LEAK_CHECK_DF两个位域</p>
<h1 id="定位具体的内存泄漏地方"><a href="#定位具体的内存泄漏地方" class="headerlink" title="定位具体的内存泄漏地方"></a>定位具体的内存泄漏地方</h1><p>定位内存泄漏的另一种技术涉及在关键点对应用程序的内存状态拍快照。 CRT 库提供一种结构类型 _CrtMemState，您可用它存储内存状态的快照：</p>
<pre><code>_CrtMemState s1, s2, s3;
</code></pre><p>若要在给定点对内存状态拍快照，请向 _CrtMemCheckpoint 函数传递 _CrtMemState 结构。 该函数用当前内存状态的快照填充此结构：</p>
<pre><code>_CrtMemCheckpoint( &amp;s1 );
</code></pre><p>通过向 _CrtMemDumpStatistics 函数传递 _CrtMemState 结构，可以在任意点转储该结构的内容：</p>
<pre><code>_CrtMemDumpStatistics( &amp;s1 );
</code></pre><p>若要确定代码中某一部分是否发生了内存泄漏，可以在该部分之前和之后对内存状态拍快照，然后使用 _CrtMemDifference 比较这两个状态：</p>
<pre><code>_CrtMemCheckpoint( &amp;s1 );

// memory allocations take place here

_CrtMemCheckpoint( &amp;s2 );


if ( _CrtMemDifference( &amp;s3, &amp;s1, &amp;s2) )

_CrtMemDumpStatistics( &amp;s3 );
</code></pre><p>顾名思义，_CrtMemDifference 比较两个内存状态（s1 和 s2），生成这两个状态之间差异的结果（s3）。 在程序的开始和结尾放置 _CrtMemCheckpoint 调用，并使用_CrtMemDifference 比较结果，是检查内存泄漏的另一种方法。 如果检测到泄漏，则可以使用 _CrtMemCheckpoint 调用通过二进制搜索技术来划分程序和定位泄漏。</p>
<h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p><a href="https://archive.codeplex.com/?p=vld" target="_blank" rel="noopener">https://archive.codeplex.com/?p=vld</a></p>
<p>Visual Leak Detector是一个免费，强大的开源内存泄漏检测系统，适用于Visual C ++。</p>
<p>关键api:</p>
<pre><code>_CrtSetAllocHook

StackWalk64

SymGetLineFromAddr64

SymFromAddr
</code></pre><h2 id="Allocation-Hooking"><a href="#Allocation-Hooking" class="headerlink" title="Allocation Hooking"></a>Allocation Hooking</h2><p>对我们来说幸运的是，Microsoft提供了一种简单的方法来监视从调试堆进行的每个分配：分配挂钩。分配钩子只是一个用户提供的回调函数，它将在从调试堆进行每次分配之前调用。Microsoft提供了一个函数，_CrtSetAllocHook它使用调试堆注册分配挂钩函数。当调试堆调用分配挂钩时，传递的参数之一是唯一标识每个分配的ID号 - 它基本上是分配的每个内存块的序列号。内存块标题中没有足够的空间让我们直接在其中记录任何信息，但我们可以使用这个唯一的ID号作为键将每个块映射到我们想要记录的任何数据。</p>
<h2 id="Walking-the-Stack"><a href="#Walking-the-Stack" class="headerlink" title="Walking the Stack"></a>Walking the Stack</h2><p>现在我们有一种方法可以在每次分配一个块时得到通知，以及一种唯一标识每个分配的方法，剩下要做的就是每次分配时记录调用堆栈。我们可以想象使用内联汇编来尝试展开堆栈。但是堆栈帧可以以不同的方式组织，这取决于编译器优化和调用约定，因此以这种方式执行它可能变得复杂。微软再一次为我们提供了一个帮助我们的工具。这次它是一个函数，我们可以迭代地调用来逐帧遍历堆栈。那个功能是StackWalk64。它是Debug Help Library（dbghelp.dll）的一部分）。只要我们为它提供建立起始“参考框架”所需的信息，可以说，它可以从那里检查我们的堆栈并为我们可靠地解除它。每次StackWalk64调用时，它都会返回一个STACKFRAME64结构，可以将其重新用作下次调用的输入StackWalk64。它可以以这种方式重复调用，直到到达堆栈的末尾。</p>
<h2 id="Initializing-the-Memory-Leak-Detector"><a href="#Initializing-the-Memory-Leak-Detector" class="headerlink" title="Initializing the Memory Leak Detector"></a>Initializing the Memory Leak Detector</h2><p>我们现在有一个更好的内存泄漏检测器的开始。我们可以监控每个分配，对于每个监控的分配，我们可以获取并记录堆栈跟踪。剩下的唯一挑战是确保在程序开始执行时立即向调试堆注册分配挂钩函数。这可以通过创建C ++类对象的全局实例来非常简单地解决。初始化程序时，构造函数将运行。从构造函数中，我们可以调用_CrtSetAllocHook注册我们的分配钩子函数。但是等等，如果我们正在调试的程序已经有了其他的话分配内存的全局C ++类对象？我们如何确保首先调用构造函数，并且在构造任何其他全局对象之前安装我们的分配钩子函数？不幸的是，C ++规范没有说明决定构造全局对象的顺序的任何规则。因此，没有绝对保证我们的构造函数将首先被调用。但我们可以非常接近保证它。我们可以利用特定于编译器的预处理器指令，该指令明确告诉编译器确保我们的全局变量尽快构建：#pragma init_seg (compiler)。该指令告诉编译器将我们的全局对象放在“编译器”初始化段中。此段中的对象是第一个构造的对象。接下来，构建“库”段中的对象，并且最后构造“用户”段中的对象。“用户”段是全局对象的默认段。一般来说，不应将普通用户对象放在“编译器”段中，因此这提供了在任何用户对象之前构造我们的全局对象的合理确定性。</p>
<h2 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h2><p>因为全局对象以它们构造的相反顺序被销毁，所以我们的全局对象将在任何用户对象之后被销毁。然后我们可以检查堆，就像内置检测器一样。如果我们在堆上找到一个尚未释放的块，则它是一个泄漏，我们可以使用我们的分配钩子函数记录的唯一ID号查找其调用堆栈。STL映射在这里可以正常工作，用于将ID号映射到调用堆栈。我没有使用STL地图，因为我希望我的库兼容新旧版本的Visual C ++。旧版本的STL与较新版本不兼容，因此我无法使用STL组件。但好消息是，这让我有机会创建一个与STL地图概念相似的数据结构，</p>
<p>你还记得内置的泄漏检测器在内存块中对等，以获取文件的名称和分配块的行号吗？好吧，我们所有的调用堆栈都是一堆程序地址。将所有这些十六进制数转储到调试器中的用处不大。为了使这些地址更有意义，我们需要将它们转换为人类可读的信息：文件和行号（以及函数名称）。微软再次提供了有助于我们完成工作的工具：符号处理程序API。就像StackWalk64，它们也恰好是Debug Help Library的一部分。我不会在这里详细介绍它们，因为它们有很多，而且使用起来非常简单。他们不需要那么多的聪明才智StackWalk64确实。我们可以使用两个符号处理程序API来获取我们想要的文件名，行号和函数名。恰当命名的SymGetLineFromAddr64地址将地址转换为源文件名和行号。它的姐妹API SymFromAddr将地址转换为符号名称。对于我们所拥有的程序地址，相应的符号名称将是包含该程序地址的函数的名称。</p>
<h2 id="源代码的关键部分"><a href="#源代码的关键部分" class="headerlink" title="源代码的关键部分"></a>源代码的关键部分</h2><p>如果你对上面的部分感到厌倦并跳过了，我会在这里总结一下。简而言之，这个内存泄漏检测器的工作原理如下：</p>
<p>自动构建全局对象。它是第一个构建的对象。构造函数注册我们的分配钩子函数。<br>每个分配最终调用我们的分配钩子函数。分配挂钩函数获取并记录每个分配的调用堆栈。调用堆栈信息记录在类似STL的专用映射中。<br>程序终止时，全局对象是最后一个被销毁的对象。它检查堆并识别泄漏。在地图中查找泄漏的块并与其对应的调用堆栈进行匹配。生成的数据将发送到调试器以进行显示。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>VLD不会检测COM泄漏，进程外资源泄漏或与CRT堆无关的任何其他类型的内存泄漏。简单来说，VLD只检测因调用new或导致的内存泄漏malloc。请记住，VLD是作为内置内存泄漏检测器的替代产品而创建的，它也只检测来自new和的泄漏malloc。</p>
<h1 id="内容转载："><a href="#内容转载：" class="headerlink" title="内容转载："></a>内容转载：</h1><p>太有用了，故直接转载以下链接内容</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;mid=401055447&amp;idx=1&amp;sn=a3d1237c10b7352f827d95110c0f4b61#rd" target="_blank" rel="noopener">C/C++内存泄漏及检测</a></p>
<h1 id="最快速度找到内存泄漏"><a href="#最快速度找到内存泄漏" class="headerlink" title="最快速度找到内存泄漏"></a><a href="http://cplusplus.wikidot.com/cn:the-fastest-way-to-find-memory-leak" target="_blank" rel="noopener">最快速度找到内存泄漏</a></h1><h2 id="确认是否存在内存泄漏"><a href="#确认是否存在内存泄漏" class="headerlink" title="确认是否存在内存泄漏"></a>确认是否存在内存泄漏</h2><pre><code>inline void EnableMemLeakCheck()
{
   _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);
}

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

void main()
{
   EnableMemLeakCheck();
   int* leak = new int[10];
}
</code></pre><p>如果检测到存在内存泄漏，退出程序的时候会在调试窗口提醒内存泄漏。现在内存泄漏报告和MFC没有任何分别了。</p>
<h2 id="快速找到内存泄漏"><a href="#快速找到内存泄漏" class="headerlink" title="快速找到内存泄漏"></a>快速找到内存泄漏</h2><p>单确定了内存泄漏发生在哪一行，有时候并不足够。特别是同一个new对应有多处释放的情形。在实际的工程中，以下两种情况很典型：</p>
<p>创建对象的地方是一个类工厂（ClassFactory）模式。很多甚至全部类实例由同一个new创建。对于此，定位到了new出对象的所在行基本没有多大帮助。</p>
<p>COM对象。我们知道COM对象采用Reference Count维护生命周期。也就是说，对象new的地方只有一个，但是Release的地方很多，你要一个个排除。</p>
<p>我们让程序运行到第52次内存分配操作的时候，自动停下来，进入调试状态？所幸，crtdbg确实提供了这样的函数：即 long _CrtSetBreakAlloc(long nAllocID)。我们加上它：</p>
<pre><code>inline void EnableMemLeakCheck()
{
   _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);
}

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

void main()
{
   EnableMemLeakCheck();
   _CrtSetBreakAlloc(52);
   int* leak = new int[10];
}
</code></pre><h1 id="Aspect-C"><a href="#Aspect-C" class="headerlink" title="Aspect C ++"></a><a href="https://www.aspectc.org/" target="_blank" rel="noopener">Aspect C ++</a></h1><p>面向AOP切面编程</p>
<p><a href="http://www.cppblog.com/cpunion/archive/2005/12/16/1836.html" target="_blank" rel="noopener">实战Aspect C ++之检查内存泄漏</a></p>
<p>实现一个内存分配记录管理器：</p>
<p>memory_recorder.h</p>
<pre><code>#ifndef __MEMORY_RECORDER_H__
#define __MEMORY_RECORDER_H__

#include &lt;map&gt;
#include &lt;typeinfo&gt;
using namespace std;

class MemoryRecorder
{
    map&lt;void *, const type_info *&gt; objects;
public:
    ~MemoryRecorder ();
    void addObject(void *obj, const type_info &amp;ti);
    void removeObject(void *obj, const type_info &amp;ti);
};

extern MemoryRecorder g_memoryRecorder;

#endif // __MEMORY_RECORDER_H__
</code></pre><p>memory_recorder.cc</p>
<pre><code>#include &quot;memory_recorder.h&quot;

#include &lt;iostream&gt;
using namespace std;


MemoryRecorder g_memoryRecorder;


MemoryRecorder::~MemoryRecorder ()
{
    if (objects.size() &gt; 0)
    {
        cout &lt;&lt; objects.size() &lt;&lt; &quot; objects not released:&quot; &lt;&lt; endl;
        for (map&lt;void *, const type_info *&gt;::const_iterator iter = objects.begin();
                iter != objects.end();
                iter ++)
        {
            cout &lt;&lt; &quot;\t&quot; &lt;&lt; iter-&gt;second-&gt;name() &lt;&lt; &quot;: &quot; &lt;&lt; (iter-&gt;first) &lt;&lt; endl;
            delete (iter-&gt;first);
        }
    }
}

void MemoryRecorder::addObject(void *obj, const type_info &amp;ti)
{
    objects.insert(make_pair(obj, &amp;ti));
}

void MemoryRecorder::removeObject(void *obj, const type_info &amp;ti)
{
    objects.erase(obj);
}
</code></pre><p>实现方面，test.ah</p>
<pre><code>#ifndef __TEST_AH__
#define __TEST_AH__

#include &quot;memory_recorder.h&quot;
#include &lt;iostream&gt;
using namespace std;

aspect MemberRecorder
{
    pointcut all_class() = classes(&quot;Test%&quot;);

    advice construction (all_class()) : after ()
    {
        g_memoryRecorder.addObject (tjp-&gt;target(), typeid(*tjp-&gt;target()));
    }

    advice destruction (all_class()) : after ()
    {
        g_memoryRecorder.removeObject (tjp-&gt;target(), typeid(*tjp-&gt;target()));
    }
};

#endif // __TEST_AH__
</code></pre><p>这个方面实现的功能很简单，首先定义了一个pointcut(切面)，它匹配所有以“Test”开头的类。<br>接下来定义了2个处理方法，分别在这些类的构造函数和析构函数调用之后执行。</p>
<p>tjp-&gt;target()指向Test*对象实例</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>实际项目中检测内存泄漏通常会十分繁琐，所以有许多工具帮助我们检测内存泄漏，比如 mtrace，valgrind。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="http://blog.jobbole.com/95375/" target="_blank" rel="noopener">C/C++内存泄漏及检测</a></li>
<li><a href="http://www.codeproject.com/KB/applications/visualleakdetector.aspx" target="_blank" rel="noopener">Visual Leak Detector Visual C ++增强的内存泄漏检测</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/x98tx3cf.aspx" target="_blank" rel="noopener">使用CRT库查找内存泄漏</a></li>
<li><a href="http://codeyarns.com/2010/09/11/visual-leak-detector-investigate-memory-leaks-in-visual-c/" target="_blank" rel="noopener">Visual Leak Detector：调查Visual C ++中的内存泄漏</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mtrace" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mtrace</a></li>
<li><a href="http://valgrind.org/docs/manual/manual.html" target="_blank" rel="noopener">http://valgrind.org/docs/manual/manual.html</a></li>
<li><a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md</a></li>
<li><a href="http://fresky.github.io/2015/06/21/how-to-attack-the-memory-leak-issue/" target="_blank" rel="noopener">调试内存泄漏问题的一些经验</a></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">调试</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">内存泄露</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/23/内存泄漏及检测/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-结巴分词" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/22/结巴分词/">结巴分词</a>
    </h1>
  

        
        <a href="/2018/05/22/结巴分词/" class="archive-article-date">
  	<time datetime="2018-05-22T02:15:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-22</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="结巴分词"><a href="#结巴分词" class="headerlink" title="结巴分词"></a>结巴分词</h1><p><a href="https://github.com/fxsjy/jieba" title="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p>
<p><a href="https://github.com/yanyiwu/cppjieba" title="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">cppjieba C++</a></p>
<p><a href="https://github.com/anderscui/jieba.NET" title="jieba.NET" target="_blank" rel="noopener">jieba.NET</a></p>
<p><a href="https://yanyiwu.com/work/2014/02/10/cppjieba-dai-ma-xiang-jie.html" title="CppJieba代码详解" target="_blank" rel="noopener">https://yanyiwu.com/work/2014/02/10/cppjieba-dai-ma-xiang-jie.html</a></p>
<p><a href="https://www.cnblogs.com/wxquare/p/6666341.html" title="cppjieba分词学习笔记" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/6666341.html</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">分词</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/22/结巴分词/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-CShap和C++ Socket通信" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/CShap和C++ Socket通信/">CShap和C++ Socket通信</a>
    </h1>
  

        
        <a href="/2018/05/21/CShap和C++ Socket通信/" class="archive-article-date">
  	<time datetime="2018-05-21T06:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-21</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通信传输数据类型"><a href="#通信传输数据类型" class="headerlink" title="通信传输数据类型"></a>通信传输数据类型</h1><pre><code>C++:char*

C#:byte[]

java:byte[]
</code></pre><p>在C++中：<br>在C++中，char是基础数据类型，8位，1个字节。byte不是基础数据类型，一般是typedef unsigned char byte;这样子的，也就是说，byte其实是unsigned char类型，那么也是8位，1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。</p>
<p>在Java中：<br>在java中，char和byte都是基础数据类型，其中的byte和C++中的char类型是一样的，8位，1个字节，-128-127。但是，char类型，是16位，2个字节，’\u0000’-‘\uFFFF’。</p>
<p>为什么java里的char是2个字节？</p>
<p>因为java内部都是用unicode的，所以java其实是支持中文变量名的，比如string 世界 = “我的世界”;这样的语句是可以通过的。</p>
<h1 id="传输不定长度的数据"><a href="#传输不定长度的数据" class="headerlink" title="传输不定长度的数据"></a>传输不定长度的数据</h1><p>1 以结束符标记<br>2 长度 + 数据</p>
<pre><code>#pragma pack(push, 1)
//协议头
struct msg
{
    char     compressflag;     //压缩标志，如果为1，则启用压缩，反之不启用压缩
    int32_t  originsize;       //包体压缩前大小
    int32_t  compresssize;     //包体压缩后大小
    char     reserved[16];
};

#pragma pack(pop)

int32_t可换成msg
</code></pre><p>发送：</p>
<pre><code>std::string strBuffer,m_strSendBuf；

int32_t length = (int32_t)strBuffer.length();
 m_strSendBuf.append((const char*)&amp;length, sizeof(length));
m_strSendBuf.append(strDestBuf);
nRet = ::send(m_hSocket, m_strSendBuf.c_str(), m_strSendBuf.length(), 0);
</code></pre><p>接收：</p>
<pre><code>nRet = ::recv(m_hSocket, buff, 10 * 1024, 0);
m_strRecvBuf.append(buff, nRet);
int32_t length;
memcpy_s(&amp;length, sizeof(int32_t), m_strRecvBuf.data(), sizeof(int32_t));
m_strRecvBuf.erase(0, sizeof(int32_t));
std::string strTempMsg = m_strRecvBuf.substr(0, length);
</code></pre><h2 id="C-和-C-结构体Socket通信"><a href="#C-和-C-结构体Socket通信" class="headerlink" title="C# 和 C++ 结构体Socket通信"></a>C# 和 C++ 结构体Socket通信</h2><p><img src="https://i.imgur.com/RiswVtr.jpg" alt=""></p>
<pre><code>仿照C++结构体写出C#的结构来

using System.Runtime.InteropServices;

[Serializable] // 指示可序列化
[StructLayout(LayoutKind.Sequential, Pack = 1)] // 按1字节对齐
public struct Operator

{
    public ushort id;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 11)] // 声明一个字符数组，大小为11
    public char[] name;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 9)]
    public char[] pass;

    public Operator(string user, string pass) // 初始化
    {
        this.id = 10000;
        this.name = user.PadRight(11, &apos;\0&apos;).ToCharArray();
        this.pass = pass.PadRight(9, &apos;\0&apos;).ToCharArray();
    }
}

整个结构的字节数是22bytes。

对应的C++结构体是：

typedef struct
{
    WORD id;
    CHAR name[11];
    CHAR password[9];
} Operator;

发送的时候先要把结构转换成字节数组

using System.Runtime.InteropServices;

/// &lt;summary&gt;
/// 将结构转换为字节数组
/// &lt;/summary&gt;
/// &lt;param name=&quot;obj&quot;&gt;结构对象&lt;/param&gt;
/// &lt;returns&gt;字节数组&lt;/returns&gt;
public byte[] StructToBytes(object obj)
{
    //得到结构体的大小
    int size = Marshal.SizeOf(obj);
    //创建byte数组
    byte[] bytes = new byte[size];
    //分配结构体大小的内存空间
    IntPtr structPtr = Marshal.AllocHGlobal(size);
    //将结构体拷到分配好的内存空间
    Marshal.StructureToPtr(obj, structPtr, false);
    //从内存空间拷到byte数组
    Marshal.Copy(structPtr, bytes, 0, size);
    //释放内存空间
    Marshal.FreeHGlobal(structPtr);
    //返回byte数组
    return bytes;

}

接收的时候需要把字节数组转换成结构

/// &lt;summary&gt;
/// byte数组转结构
/// &lt;/summary&gt;
/// &lt;param name=&quot;bytes&quot;&gt;byte数组&lt;/param&gt;
/// &lt;param name=&quot;type&quot;&gt;结构类型&lt;/param&gt;
/// &lt;returns&gt;转换后的结构&lt;/returns&gt;
public object BytesToStruct(byte[] bytes, Type type)
{
    //得到结构的大小
    int size = Marshal.SizeOf(type);
    Log(size.ToString(), 1);
    //byte数组长度小于结构的大小
    if (size &gt; bytes.Length)
    {
        //返回空
        return null;
    }
    //分配结构大小的内存空间
    IntPtr structPtr = Marshal.AllocHGlobal(size);
    //将byte数组拷到分配好的内存空间
    Marshal.Copy(bytes, 0, structPtr, size);
    //将内存空间转换为目标结构
    object obj = Marshal.PtrToStructure(structPtr, type);
    //释放内存空间
    Marshal.FreeHGlobal(structPtr);
    //返回结构
    return obj;
}


实际操作：

using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;

byte[] Message = StructToBytes(new Operator(&quot;user&quot;, &quot;pass&quot;)); // 将结构转换成字节数组

TcpClient socket = new TcpClient();

socket.Connect(ip, port);

NetworkStream ns = Socket.GetStream();

ns.Write(Message, 0, Message.Length); // 发送

byte[] Recv = new byte[1024]; // 缓冲

int NumberOfRecv = 0;

IList&lt;byte&gt; newRecv = new List&lt;byte&gt;();
ns.ReadTimeout = 3000;
try
{
    do
    {
        // 接收响应
        NumberOfRecv = ns.Read(Recv, 0, Recv.Length);
        for (int i = 0; i &lt; NumberOfRecv; i++)
            newRecv.Add(Recv[i]);
    }
    while (ns.DataAvailable);
    byte[] resultRecv = new byte[newRecv.Count];
    newRecv.CopyTo(resultRecv, 0);

    Operator MyOper = new Operator();

    MyOper = (Operator)BytesToStruct(resultRecv, MyOper.GetType()); // 将字节数组转换成结构

    在这里取值的时候可能会出现只能取到一个字段，剩余的取不到的问题，怎么回事我也搞不懂，反正我的解决办法就是按照字节的顺序从resultRecv里分别取出对应的字段的字节数组，然后解码，例如：

    Operator.name是11个字节，最后一位是0，Operator.id是2个字节，那么从第3位到第12位的字节就是Operator.name的内容，取出另存为一个数组MyOperName，Encoding.Default.GetString(MyOperName)就是MyOper.name的内容。

    socket.Close();

    ns.Close();

    可以看到，该仁兄在接收解析的时候，还是被C#的默认排序给黑到了，这里还是建议暂时用比较笨的方法，等待大牛出来好方法：
  所以比较笨的解决办法是，把所有定义好的数据结构先手动进行按名字排序！~~

自己对数据结构中的类型名称进行按名字排序
</code></pre><h1 id="protobuf或者flatbuffer"><a href="#protobuf或者flatbuffer" class="headerlink" title="protobuf或者flatbuffer"></a>protobuf或者flatbuffer</h1><h2 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h2><p>Protocol Buffers（简称protobuf）是谷歌的一项技术，用于将结构化的数据序列化、反序列化，经常用于网络传输。</p>
<p><a href="https://github.com/google/protobuf" title="https://github.com/google/protobuf" target="_blank" rel="noopener">https://github.com/google/protobuf</a></p>
<p><a href="https://github.com/google/protobuf/tree/master/examples" title="https://github.com/google/protobuf/tree/master/examples" target="_blank" rel="noopener">https://github.com/google/protobuf/tree/master/examples</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" title="Google Protocol Buffer 的使用和原理" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html</a></p>
<p><a href="https://blog.csdn.net/shensky711/article/details/69696392" title="Protocol Buffers 3.0 技术手册" target="_blank" rel="noopener">https://blog.csdn.net/shensky711/article/details/69696392</a></p>
<p><a href="https://blog.csdn.net/u012391923/article/details/54908464" title="Protocol Buffers编程指南与应用" target="_blank" rel="noopener">https://blog.csdn.net/u012391923/article/details/54908464</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/70568606" title="Protocol Buffer 序列化原理大揭秘 - 为什么Protocol Buffer性能这么好？" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/70568606</a></p>
<h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。</p>
<p><a href="https://grpc.io/" title="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a></p>
<p><a href="https://github.com/grpc/grpc" title="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc</a></p>
<p><a href="https://grpc.io/docs/quickstart/" title="https://grpc.io/docs/quickstart/" target="_blank" rel="noopener">https://grpc.io/docs/quickstart/</a></p>
<p><a href="http://doc.oschina.net/grpc?t=57966" title="gRPC 官方文档中文版" target="_blank" rel="noopener">http://doc.oschina.net/grpc?t=57966</a></p>
<h2 id="flatbuffers"><a href="#flatbuffers" class="headerlink" title="flatbuffers"></a>flatbuffers</h2><p>跨平台序列化工具FlatBuffers，提供了C++/Java/Go/C#接口支持，这是一个注重性能和资源使用的序列化类库。相较于Protocol Buffers，其更适用于移动设备，FlatBuffers提供更高的性能以及更低的资源需求。</p>
<p><a href="https://github.com/google/flatbuffers" title="https://github.com/google/flatbuffers" target="_blank" rel="noopener">https://github.com/google/flatbuffers</a></p>
<p><a href="http://google.github.io/flatbuffers/index.html" title="http://google.github.io/flatbuffers/index.html" target="_blank" rel="noopener">http://google.github.io/flatbuffers/index.html</a></p>
<p><a href="https://www.jianshu.com/p/6eb04a149cd8" target="_blank" rel="noopener">FlatBuffers使用简介</a></p>
<p><a href="https://blog.csdn.net/linuxheik/article/details/70743394" title="FlatBuffers学习总结" target="_blank" rel="noopener">https://blog.csdn.net/linuxheik/article/details/70743394</a></p>
<p><a href="https://www.race604.com/flatbuffers-intro/" title="FlatBuffers 体验" target="_blank" rel="noopener">https://www.race604.com/flatbuffers-intro/</a></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://blog.sina.com.cn/s/blog_668aae7801019mdf.html" title="http://blog.sina.com.cn/s/blog_668aae7801019mdf.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_668aae7801019mdf.html</a></p>
<p><a href="https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html" title="https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html" target="_blank" rel="noopener">https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">C#</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Socket</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Java</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">protobuf</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">grpc</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">flatbuffer</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/21/CShap和C++ Socket通信/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-X3框架" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/X3框架/">X3框架</a>
    </h1>
  

        
        <a href="/2018/05/18/X3框架/" class="archive-article-date">
  	<time datetime="2018-05-18T01:26:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-05-18</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><p>所有插件都是普通DLL，通过在工程内包含辅助文件自动实现了统一的导出函数，通过该导出函数就能获取到在该插件内所实现的所有接口的信息及对象创建函数地址；主程序使用插件管理器（PluginManager）加载这些DLL，插件管理器通过这个导出函数将各个类ID、对象创建函数地址统一管理起来，从而在插件管理器的中介作用下让各个插件能相互使用各种接口函数。</p>
<h2 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h2><p>对外提供接口文件，在插件内部用类来实现一个或多个接口，不需要对外导出该类或暴露实现细节。这样还有一个好处是只有约定了接口就可以让多个模块并行开发，模块相互之间不存在编译依赖（不需要其他插件的LIB等文件），这可用于测试驱动开发模式。</p>
<h2 id="多接口转换、引用计数管理"><a href="#多接口转换、引用计数管理" class="headerlink" title="多接口转换、引用计数管理"></a>多接口转换、引用计数管理</h2><p>采用智能指针类来管理接口的引用计数及生命期，可从一个接口动态转换为另一个接口（内部采用C++的RTTI机制动态转换），可以区分插件内部的接口引用和插件外部的接口引用。</p>
<h2 id="模块透明部署"><a href="#模块透明部署" class="headerlink" title="模块透明部署"></a>模块透明部署</h2><p>一个模块只需要使用其他模块的接口，不需要关心该接口是在哪个插件中实现的。可以根据需要将各个实现类进行合并或拆分，使其分布到不同插件中，而接口使用者不受影响。另外，插件部署于哪个目录也不影响插件接口的使用。</p>
<h2 id="模块可替换、可扩展"><a href="#模块可替换、可扩展" class="headerlink" title="模块可替换、可扩展"></a>模块可替换、可扩展</h2><p>可根据需要替换某个插件，只有该插件实现了相同的接口，即使内部功能不相同，这样就实现了插件可替换、按需组合。通过在新的插件中支持更多的接口，可扩展更多的功能。可以在新插件中局部替换原有插件的某些接口或部分函数，实现重用和扩展。</p>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>本插件机制所提供的内部实现文件考虑了线程安全性，允许多线程访问而不冲突，同时采用的是轻量级的锁定机制（计数原子锁定），运行开销很小。</p>
<h2 id="跨版本"><a href="#跨版本" class="headerlink" title="跨版本"></a>跨版本</h2><p>允许不同版本的VC++开发的插件相互调用对方的接口，虽然实际中一般不需要这样做。由于没有采用VC++特殊的编译指令，因此容易移植到其他开发平台下。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><pre><code>interface Ix_Example
{
    virtual void Foo() = 0;
    virtual void* GetData(std::vector&lt;int&gt;&amp; items) = 0;
};
</code></pre><h2 id="定义类UID"><a href="#定义类UID" class="headerlink" title="定义类UID"></a>定义类UID</h2><pre><code>const XCLSID CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);
</code></pre><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>下面的例子是在Cx_Example.h中定义了Cx_Example类，实现了两个接口。</p>
<pre><code>#pragma once

#include &lt;Ix_Example.h&gt;

class Cx_Example
    : public Ix_Example
    , public Ix_Example2
{
protected:
    Cx_Example();
    ~Cx_Example();

protected:
    // Ix_Example
    virtual void Foo();

    // Ix_Example2
    virtual void Foo2();
};
</code></pre><p>上面的例子中有两个地方值得留意（不是必须要这样，但推荐这样）：（1）构造函数和析构函数是保护类型，表示不允许直接实例化对象，也不允许直接删除销毁对象，通过智能指针类Cx_Interface或Cx_Ptr来自动实例化和销毁对象；（2）所实现的接口函数申明为保护类型，表示不允许直接调用该对象实例的函数，当然也可以申明为私有类型，表示不允许派生实现类调用其函数。</p>
<h2 id="在插件中登记实现类"><a href="#在插件中登记实现类" class="headerlink" title="在插件中登记实现类"></a>在插件中登记实现类</h2><p>通过智能指针类Cx_Interface或Cx_Ptr来实例化对象，需要在插件内登记该插件中有哪些可供实例化的类、实现类对应的类UID、是否为单实例类。例如下面的Module.cpp：</p>
<pre><code>// 登记有哪些可供实例化的类、实现类对应的类UID、是否为单实例类
XBEGIN_DEFINE_MODULE()
    XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)
    XDEFINE_CLASSMAP_ENTRY_Singleton(CLSID_ExamTool, Cx_ExampleTool)
XEND_DEFINE_MODULE()
</code></pre><p>其中包含XModuleImpl.h 用于自动实现插件内部机制，插件机制如何实现对插件开发者来说不用关心，宏XDEFINE_CLASSMAP_ENTRY 用于登记普通类及其类UID，可实例化出多个对象，XDEFINE_CLASSMAP_ENTRY_Singleton 用于登记单实例类及其类UID，在一个进程中不论创建多少次都会得到同一个对象实例。</p>
<p>对于以MFC扩展动态库或Win32动态库类型创建插件工程的情况，由于DLL入口函数基本上都相同，为了避免在多个插件中重复出现这样类似的DLL入口函数代码，可以将上面例子中的 XEND_DEFINE_MODULE() 换为下面两个宏之一：</p>
<pre><code>XEND_DEFINE_MODULE_MFCEXTDLL()
XEND_DEFINE_MODULE_WIN32DLL()
</code></pre><h1 id="框架核心代码以及测试"><a href="#框架核心代码以及测试" class="headerlink" title="框架核心代码以及测试"></a>框架核心代码以及测试</h1><pre><code>#pragma once
#include &lt;objbase.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;

interface Ix_Object
{
    virtual void AddRef(HMODULE fromdll) = 0;
    virtual void Release(HMODULE fromdll) = 0;
    virtual const char* GetClassName() const = 0;
};

//! class factory function.
typedef Ix_Object* (STDMETHODCALLTYPE *PFNXObjectCreator)(HMODULE);

//! object count of a class.
typedef long (STDMETHODCALLTYPE *PFNXGetObjectCount)();

//! object (used by other modules) count of a class.
typedef long (STDMETHODCALLTYPE *PFNXRefCountByOthers)();

#define MIN_SINGLETON_TYPE  10

#pragma pack(push, 8)

/*! \ingroup _GROUP_PLUGIN_CORE2_
*  \brief class factory registry.
*  \see   _xGetClassEntryTable, XBEGIN_DEFINE_MODULE
*  \internal
*/
struct _XCLASSMETA_ENTRY
{
    BYTE                type;               //!&lt; see MIN_SINGLETON_TYPE and XModuleMacro.h
    const char*         className;          //!&lt; implement class name
    std::string              clsid;              //!&lt; class id. may be empty if iidSpecial is valid.
    const char*         iidSpecial;         //!&lt; special interface name, see XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton.
    PFNXObjectCreator   pfnObjectCreator;   //!&lt; class factory function
    PFNXGetObjectCount  pfnGetObjectCount;  //!&lt; object count of this class
    PFNXRefCountByOthers    pfnRefCountByOthers;    //!&lt; count of objects used by other modules

                                                    //! Used by XDEFINE_CLASSMAP_ENTRY, XDEFINE_CLASSMAP_ENTRY_Singleton
    _XCLASSMETA_ENTRY(BYTE      _type,
        const char*             _className,
        const std::string &amp;           _clsid,
        const char*             _iidSpecial,
        PFNXObjectCreator       _pfnObjectCreator,
        PFNXGetObjectCount      _pfnGetObjectCount = NULL,
        PFNXRefCountByOthers    _pfnRefCountByOthers = NULL)

        : type(_type), className(_className)
        , clsid(_clsid), iidSpecial(_iidSpecial)
        , pfnObjectCreator(_pfnObjectCreator)
        , pfnGetObjectCount(_pfnGetObjectCount)
        , pfnRefCountByOthers(_pfnRefCountByOthers)
    {
    }

    //! Used by XEND_DEFINE_MODULE
    _XCLASSMETA_ENTRY()
        : type(0), className(&quot;&quot;), clsid(&quot;&quot;), iidSpecial(&quot;&quot;)
        , pfnObjectCreator(NULL), pfnGetObjectCount(NULL)
        , pfnRefCountByOthers(NULL)
    {
    }

    //! class factory registries. filled by XBEGIN_DEFINE_MODULE.
    static const _XCLASSMETA_ENTRY s_classes[];
};

#pragma pack(pop)

std::string GuidToString()
{
    GUID guid;
    CoCreateGuid(&amp;guid);

    char buf[64] = { 0 };

    _snprintf_s(

        buf,
        sizeof(buf),
        &quot;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;,
        guid.Data1, guid.Data2, guid.Data3,
        guid.Data4[0], guid.Data4[1],
        guid.Data4[2], guid.Data4[3],
        guid.Data4[4], guid.Data4[5],
        guid.Data4[6], guid.Data4[7]);
    return std::string(buf);
}

//注意：TRUE会导致DLL引用计数加1，FALSE不会改变引用计数，通常用FALSE
HMODULE GetCurrentModule(BOOL bRef = FALSE)
{
    HMODULE hModule = NULL;
    if (GetModuleHandleEx(bRef ? GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS : (GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
        | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT), (LPCTSTR)GetCurrentModule, &amp;hModule))
    {
        return hModule;
    }

    return NULL;
}

// Return the current module handle for making a distinction between plugins.
HMODULE xGetModuleHandle()
{
    return GetCurrentModule();
};

// Create an object with the class id.
HRESULT xCreateObject(const std::string&amp; clsid, Ix_Object** ppv)
{
    *ppv = NULL;

    const _XCLASSMETA_ENTRY* pCls = _XCLASSMETA_ENTRY::s_classes;

    for (; pCls-&gt;pfnObjectCreator; ++pCls)
    {
        if (clsid == pCls-&gt;clsid)
        {
            *ppv = (*pCls-&gt;pfnObjectCreator)(xGetModuleHandle());
            return S_OK;
        }
    }

    return E_NOTIMPL;
}

template &lt;class ClsType&gt;
class Cx_Object
    : public ClsType
    , public Ix_Object
{
protected:
    Cx_Object(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)
    {
        InterlockedIncrement(&amp;ObjectCount());
    }

    virtual ~Cx_Object()
    {
        InterlockedDecrement(&amp;ObjectCount());
    }

protected:
    virtual void AddRef(HMODULE fromdll)
    {
        if (fromdll != xGetModuleHandle())
        {
            InterlockedIncrement(&amp;RefCountByOthers());
        }
        InterlockedIncrement(&amp;m_lRefCount);
    }

    virtual void Release(HMODULE fromdll)
    {
        if (fromdll != xGetModuleHandle())
        {
            InterlockedDecrement(&amp;RefCountByOthers());
        }
        if (0 == InterlockedDecrement(&amp;m_lRefCount))
        {
            delete this;
        }
    }

    virtual const char* GetClassName() const
    {
        return typeid(*this).name();
    }

public:
    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)
    {
        Cx_Object&lt;ClsType&gt;* p = new Cx_Object&lt;ClsType&gt;(false);
        p-&gt;AddRef(fromdll);
        return p;
    }

    static long STDMETHODCALLTYPE GetObjectCount()
    {
        return ObjectCount();
    }

    static long STDMETHODCALLTYPE GetRefCountByOthers()
    {
        return RefCountByOthers();
    }

private:
    long        m_lRefCount;

    static long&amp; ObjectCount()
    {
        static long s_lObjCount = 0;
        return s_lObjCount;
    }

    static long&amp; RefCountByOthers()
    {
        static long s_lRefCount = 0;
        return s_lRefCount;
    }
};

#if defined(_MSC_VER) &amp;&amp; !defined(_CPPRTTI)
#error must enable RTTI (compiled with /GR)
#endif

class Cx_Ptr;

//! An autoptr class with a specified interface.
template &lt;class IF_Type&gt;
class Cx_Interface
{
    typedef Cx_Interface&lt;IF_Type&gt; thisClass;
public:
    Cx_Interface() : m_pInterface(NULL), m_pObj(NULL)
    {
    }

    Cx_Interface(const Cx_Ptr&amp; src);

#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt; 1200 // not VC60

    Cx_Interface(const thisClass&amp; src)
        : m_pInterface(src.m_pInterface), m_pObj(src.m_pObj)
    {
        if (m_pInterface)
        {
            m_pObj-&gt;AddRef(xGetModuleHandle());
        }
    }

    Cx_Interface(IF_Type* pInterface) : m_pInterface(pInterface), m_pObj(NULL)
    {
        if (m_pInterface)
        {
            m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
            //ASSERT(m_pObj != NULL);
            m_pObj-&gt;AddRef(xGetModuleHandle());
        }
    }

#endif // _MSC_VER

    template &lt;class IF_Type2&gt;
    explicit Cx_Interface(IF_Type2* pInterface) : m_pInterface(NULL), m_pObj(NULL)
    {
        if (pInterface)
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);
            if (m_pInterface)
            {
                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
                //ASSERT(m_pObj != NULL);
                m_pObj-&gt;AddRef(xGetModuleHandle());
            }
        }
    }

    template &lt;class IF_Type2&gt;
    explicit Cx_Interface(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)
        : m_pInterface(NULL), m_pObj(NULL)
    {
        if (pIF)
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF.P());
            if (m_pInterface)
            {
                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
                //ASSERT(m_pObj != NULL);
                m_pObj-&gt;AddRef(xGetModuleHandle());
            }
        }
    }

    explicit Cx_Interface(const std::string&amp; clsid) : m_pInterface(NULL), m_pObj(NULL)
    {
        if (S_OK == xCreateObject(clsid, &amp;m_pObj))
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);
            if (NULL == m_pInterface)
            {
                m_pObj-&gt;Release(xGetModuleHandle());
                m_pObj = NULL;
            }
        }
    }

    ~Cx_Interface()
    {
        Unload();
    }

    inline IF_Type* P() const
    {
        return m_pInterface;
    }

    inline IF_Type* operator-&gt;() const
    {
        return m_pInterface;
    }

    template &lt;class IF_Type2&gt;
    thisClass&amp; operator=(IF_Type2* pInterface)
    {
        Unload();

        if (pInterface)
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);
            if (m_pInterface)
            {
                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
                //ASSERT(m_pObj != NULL);
                m_pObj-&gt;AddRef(xGetModuleHandle());
            }
        }

        return *this;
    }

    template &lt;class IF_Type2&gt;
    thisClass&amp; operator=(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)
    {
        return operator=(pIF.P());
    }

    thisClass&amp; operator=(const thisClass&amp; src)
    {
        if (this != &amp;src)
        {
            Load(src.m_pInterface);
        }

        return *this;
    }

    thisClass&amp; operator=(const Cx_Ptr&amp; src);

    thisClass&amp; operator=(const int)
    {
        //ASSERT(0 == nul);
        Unload();
        return *this;
    }

    bool operator==(const int) const
    {
        //ASSERT(0 == nul);
        return m_pInterface == NULL;
    }

    bool operator!=(const int) const
    {
        //ASSERT(0 == nul);
        return m_pInterface != NULL;
    }

    bool operator==(const IF_Type* pInterface) const
    {
        return m_pInterface == pInterface;
    }

    bool operator!=(const IF_Type* pInterface) const
    {
        return m_pInterface != pInterface;
    }

    bool operator==(const thisClass&amp; src) const
    {
        return m_pInterface == src.m_pInterface;
    }

    bool operator!=(const thisClass&amp; src) const
    {
        return m_pInterface != src.m_pInterface;
    }

    inline operator bool() const
    {
        return m_pInterface != NULL;
    }

    inline bool operator!() const
    {
        return NULL == m_pInterface;
    }

    inline bool IsNull() const
    {
        return NULL == m_pInterface;
    }

    inline bool IsNotNull() const
    {
        return m_pInterface != NULL;
    }

    void Release()
    {
        Unload();
    }

    IF_Type* DetachInterface()
    {
        IF_Type* pIF = m_pInterface;
        m_pInterface = NULL;
        m_pObj = NULL;
        return pIF;
    }

    bool AttachInterface(IF_Type* pIF)
    {
        Unload();
        m_pInterface = pIF;
        m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
        return (m_pObj != NULL || NULL == m_pInterface);
    }

    bool AttachInterface(Ix_Object* pIF)
    {
        Unload();

        if (pIF)
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF);
            if (m_pInterface)
            {
                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);
                //ASSERT(m_pObj != NULL);
            }
            else
            {
                pIF-&gt;Release(xGetModuleHandle());
                pIF = NULL;
                return false;
            }
        }

        return true;
    }

    bool Create(const std::string&amp; clsid)
    {
        Unload();

        if (S_OK == xCreateObject(clsid, &amp;m_pObj))
        {
            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);
            if (NULL == m_pInterface)
            {
                m_pObj-&gt;Release(xGetModuleHandle());
                m_pObj = NULL;
            }
        }

        return m_pInterface != NULL;
    }

private:
    void Unload()
    {
        if (m_pObj)
        {
            m_pObj-&gt;Release(xGetModuleHandle());
            m_pObj = NULL;
            m_pInterface = NULL;
        }
    }

    void Load(IF_Type* pIF)
    {
        Ix_Object* pObj = dynamic_cast&lt;Ix_Object*&gt;(pIF);
        if (m_pObj != pObj)
        {
            if (pObj)
            {
                pObj-&gt;AddRef(xGetModuleHandle());
            }
            if (m_pObj)
            {
                m_pObj-&gt;Release(xGetModuleHandle());
            }
            m_pObj = pObj;
            m_pInterface = pIF;
        }
    }

private:
    IF_Type*    m_pInterface;
    Ix_Object*  m_pObj;
};

//! An autoptr class with the Ix_Object interface.
class Cx_Ptr
{
public:
    Cx_Ptr() : m_pInterface(NULL)
    {
    }

    Cx_Ptr(const Cx_Ptr&amp; src) : m_pInterface(src.m_pInterface)
    {
        if (m_pInterface)
        {
            m_pInterface-&gt;AddRef(xGetModuleHandle());
        }
    }

    template &lt;class IF_Type&gt;
    explicit Cx_Ptr(IF_Type* pInterface) : m_pInterface(NULL)
    {
        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);
        if (m_pInterface)
        {
            m_pInterface-&gt;AddRef(xGetModuleHandle());
        }
    }

    template &lt;class IF_Type&gt;
    explicit Cx_Ptr(const Cx_Interface&lt;IF_Type&gt;&amp; pIF) : m_pInterface(NULL)
    {
        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pIF.P());
        if (m_pInterface)
        {
            m_pInterface-&gt;AddRef(xGetModuleHandle());
        }
    }

    explicit Cx_Ptr(const std::string&amp; clsid) : m_pInterface(NULL)
    {
        xCreateObject(clsid, &amp;m_pInterface);
    }

    ~Cx_Ptr()
    {
        Unload();
    }

    Ix_Object* P() const
    {
        return m_pInterface;
    }

    template &lt;class IF_Type&gt;
    Cx_Ptr&amp; operator=(IF_Type* pInterface)
    {
        Unload();

        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);
        if (m_pInterface)
        {
            m_pInterface-&gt;AddRef(xGetModuleHandle());
        }

        return *this;
    }

    template &lt;class IF_Type&gt;
    Cx_Ptr&amp; operator=(const Cx_Interface&lt;IF_Type&gt;&amp; pIF)
    {
        return operator=(pIF.P());
    }

    Cx_Ptr&amp; operator=(const Cx_Ptr&amp; src)
    {
        if (this != &amp;src)
        {
            Load(src.m_pInterface);
        }

        return *this;
    }

    Cx_Ptr&amp; operator=(const int)
    {
        //ASSERT(0 == nul);
        Unload();
        return *this;
    }

    bool operator==(const int) const
    {
        //ASSERT(0 == nul);
        return m_pInterface == NULL;
    }

    bool operator!=(const int) const
    {
        //ASSERT(0 == nul);
        return m_pInterface != NULL;
    }

    bool operator==(const Ix_Object* pInterface) const
    {
        return m_pInterface == pInterface;
    }

    bool operator!=(const Ix_Object* pInterface) const
    {
        return m_pInterface != pInterface;
    }

    bool operator==(const Cx_Ptr&amp; src) const
    {
        return m_pInterface == src.m_pInterface;
    }

    bool operator!=(const Cx_Ptr&amp; src) const
    {
        return m_pInterface != src.m_pInterface;
    }

    inline operator bool() const
    {
        return m_pInterface != NULL;
    }

    inline bool operator!() const
    {
        return NULL == m_pInterface;
    }

    inline bool IsNull() const
    {
        return NULL == m_pInterface;
    }

    inline bool IsNotNull() const
    {
        return m_pInterface != NULL;
    }

    void Release()
    {
        Unload();
    }

    Ix_Object* DetachInterface()
    {
        Ix_Object* pIF = m_pInterface;
        m_pInterface = NULL;
        return pIF;
    }

    void AttachInterface(Ix_Object* pIF)
    {
        Unload();
        m_pInterface = pIF;
    }

    bool Create(const std::string&amp; clsid)
    {
        Unload();
        return S_OK == xCreateObject(clsid, &amp;m_pInterface);
    }

private:
    void Unload()
    {
        if (m_pInterface)
        {
            m_pInterface-&gt;Release(xGetModuleHandle());
            m_pInterface = NULL;
        }
    }

    void Load(Ix_Object* pIF)
    {
        if (m_pInterface != pIF)
        {
            if (pIF)
            {
                pIF-&gt;AddRef(xGetModuleHandle());
            }
            if (m_pInterface)
            {
                m_pInterface-&gt;Release(xGetModuleHandle());
            }
            m_pInterface = pIF;
        }
    }

private:
    Ix_Object*  m_pInterface;
};

// Inlines for Cx_Interface
//
template &lt;class IF_Type&gt; inline
Cx_Interface&lt;IF_Type&gt;::Cx_Interface(const Cx_Ptr&amp; src) : m_pInterface(NULL), m_pObj(NULL)
{
    if (src.P())
    {
        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());
        if (m_pInterface)
        {
            m_pObj = src.P();
            m_pObj-&gt;AddRef(xGetModuleHandle());
        }
    }
}

template &lt;class IF_Type&gt; inline
Cx_Interface&lt;IF_Type&gt;&amp; Cx_Interface&lt;IF_Type&gt;::operator=(const Cx_Ptr&amp; src)
{
    Unload();

    if (src.P())
    {
        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());
        if (m_pInterface)
        {
            m_pObj = src.P();
            m_pObj-&gt;AddRef(xGetModuleHandle());
        }
    }

    return *this;
}

template &lt;class ClsType&gt;
class Cx_SingletonObject
    : public ClsType
    , public Ix_Object
    , public CModuleItem
{
protected:
    Cx_SingletonObject(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)
    {
    }

    virtual ~Cx_SingletonObject()
    {
        if (Instance() == this)
        {
            Instance() = NULL;
        }
    }

protected:
    virtual void AddRef(HMODULE fromdll)
    {
        if (fromdll != xGetModuleHandle())
        {
            InterlockedIncrement(&amp;RefCountByOthers());
        }
        InterlockedIncrement(&amp;m_lRefCount);
    }

    virtual void Release(HMODULE fromdll)
    {
        if (fromdll != xGetModuleHandle())
        {
            InterlockedDecrement(&amp;RefCountByOthers());
        }
        InterlockedDecrement(&amp;m_lRefCount);
    }

    virtual const char* GetClassName() const
    {
        return typeid(*this).name();
    }

public:
    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)
    {
        if (NULL == Instance())
        {
            Cx_SingletonObject&lt;ClsType&gt;* p = new Cx_SingletonObject&lt;ClsType&gt;(false);

#ifdef InterlockedCompareExchangePointer
            if (InterlockedCompareExchangePointer(
                (PVOID volatile *)(&amp;Instance()), p, NULL) == NULL)
#else
            if (InterlockedCompareExchange((void**)(&amp;Instance()), p, NULL) == NULL)
#endif
            {
                p-&gt;AddRef(fromdll);
                p-&gt;AddModuleItem();
            }
            else
            {
                delete p;   // has created by another thread
            }
        }

        return Instance();
    }

    static long STDMETHODCALLTYPE GetObjectCount()
    {
        return (Instance() &amp;&amp; Instance()-&gt;m_lRefCount &gt; 0) ? 1 : 0;
    }

    static long STDMETHODCALLTYPE GetRefCountByOthers()
    {
        return RefCountByOthers();
    }

private:
    long        m_lRefCount;

    static Cx_SingletonObject&lt;ClsType&gt;*&amp; Instance()
    {
        static Cx_SingletonObject&lt;ClsType&gt;* s_pSingleton = NULL;
        return s_pSingleton;
    }

    static long&amp; RefCountByOthers()
    {
        static long s_lRefCount = 0;
        return s_lRefCount;
    }
};

// XBEGIN_DEFINE_MODULE()
//     XDEFINE_CLASSMAP_ENTRY(clsid, cls)
//     XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)
//     XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(clsid, iid, cls)
// XEND_DEFINE_MODULE()
// XEND_DEFINE_MODULE_WIN32DLL()
// XEND_DEFINE_MODULE_MFCEXTDLL()
// XEND_DEFINE_MODULE_MFCDLL()

//! Begin group of class factory registry.
/*!
\ingroup _GROUP_PLUGIN_CORE_
\see XEND_DEFINE_MODULE
\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL
*/
#define XBEGIN_DEFINE_MODULE()  \
    const _XCLASSMETA_ENTRY _XCLASSMETA_ENTRY::s_classes[] = {
//! Register a regular class.
/*!
\ingroup _GROUP_PLUGIN_CORE_
\param clsid class unique id, XCLSID constant.
\param cls implement class
*/
#define XDEFINE_CLASSMAP_ENTRY(clsid, cls)      \
    _XCLASSMETA_ENTRY(1, &quot;Cx_Object&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \
        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_Object&lt;cls&gt;::CreateObject), \
        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_Object&lt;cls&gt;::GetObjectCount),  \
        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_Object&lt;cls&gt;::GetRefCountByOthers)),

//! Register a single instance class.
/*!
\ingroup _GROUP_PLUGIN_CORE_
\param clsid class unique id, XCLSID constant.
\param cls implement class
*/
#define XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)    \
    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE,   \
        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \
        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \
        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \
        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),

//! Register a single instance class that support the specific interface.
/*!
\ingroup _GROUP_PLUGIN_CORE_
\param iid the specific interface id name. char array constant.
\param cls implement class
*/
#define XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(iid, cls)     \
    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE + 1,   \
        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, XCLSID(), iid,  \
        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \
        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \
        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),

//! End group of class factory registry.
/*!
\ingroup _GROUP_PLUGIN_CORE_
\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL
*/
#define XEND_DEFINE_MODULE() \
        _XCLASSMETA_ENTRY() \
    };

#pragma warning(disable:4710)   // inline function not expanded

//! End group of class factory registry and implement entry function of Win32DLL(USRDLL).
/*! Using this macro need include this file and XModuleImpl.h file.
\ingroup _GROUP_PLUGIN_CORE_
\see XEND_DEFINE_MODULE_MFCEXTDLL, XEND_DEFINE_MODULE_MFCDLL
*/
#define XEND_DEFINE_MODULE_WIN32DLL() \
        _XCLASSMETA_ENTRY() \
    };  \
BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID)   \
{   \
    if (dwReason == DLL_PROCESS_ATTACH) \
    {   \
        _xGetModuleInterface(NULL, (HMODULE)hModule);   \
    }   \
    else if (dwReason == DLL_PROCESS_DETACH)    \
    {   \
        xGetCurrentModule()-&gt;ClearModuleItems();    \
    }   \
    return TRUE;    \
}

//! End group of class factory registry and implement entry function of MFC Extension DLL.
/*! Using this macro need include this file and XModuleImpl.h file.
\ingroup _GROUP_PLUGIN_CORE_
\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCDLL
*/
#define XEND_DEFINE_MODULE_MFCEXTDLL() \
        _XCLASSMETA_ENTRY() \
    };  \
static AFX_EXTENSION_MODULE MFCExtDLL = { NULL, NULL }; \
extern &quot;C&quot; int APIENTRY \
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)    \
{   \
    if (dwReason == DLL_PROCESS_ATTACH) \
    {   \
        if (!AfxInitExtensionModule(MFCExtDLL, hInstance))  \
            return 0;   \
        new CDynLinkLibrary(MFCExtDLL); \
        _xGetModuleInterface(NULL, MFCExtDLL.hModule);  \
    }   \
    else if (dwReason == DLL_PROCESS_DETACH)    \
    {   \
        xGetCurrentModule()-&gt;ClearModuleItems();        \
        AfxTermExtensionModule(MFCExtDLL);  \
    }   \
    return 1;   \
}

//! End group of class factory registry and implement entry function of MFC regular DLL.
/*! This macro implements CPluginApp class.\n
Using this macro need include this file and XModuleImpl.h file.
\note Call the following statemant before call any MFC function: \n
AFX_MANAGE_STATE(AfxGetStaticModuleState());
\ingroup _GROUP_PLUGIN_CORE_
\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL
*/
#define XEND_DEFINE_MODULE_MFCDLL() \
        _XCLASSMETA_ENTRY() \
    };  \
class CPluginApp : public CWinApp   \
{   \
public: \
    CPluginApp()    \
    {   \
    }   \
    virtual BOOL InitInstance() \
    {   \
        CWinApp::InitInstance();    \
        _xGetModuleInterface(NULL, m_hInstance);    \
        return TRUE;    \
    }   \
    virtual int ExitInstance()  \
    {   \
        xGetCurrentModule()-&gt;ClearModuleItems();    \
        return CWinApp::ExitInstance(); \
    }   \
};

//以上为基础核心代码，以下为例子

const std::string CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);

interface Ix_Example
{
    virtual void Foo() = 0;
};

interface Ix_Example2
{
    virtual void Foo2() = 0;
};

class Cx_Example
    : public Ix_Example
    , public Ix_Example2
{
protected:
    Cx_Example() {};
    virtual ~Cx_Example() {};

private:
    // From Ix_Example
    virtual void Foo()
    {
        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;
    };

    // From Ix_Example2
    virtual void Foo2()
    {
        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;
    };
};

XBEGIN_DEFINE_MODULE()
XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)
XEND_DEFINE_MODULE()

void MyFunc2(const Cx_Ptr&amp; obj)
{
    // Cx_Interface与Cx_Ptr互转，转为特定接口
    Cx_Interface&lt;Ix_Example&gt; pIFExample(obj);
    if (pIFExample)
    {
        pIFExample-&gt;Foo();
    }
}

Cx_Ptr MyFunc1()
{
    // 使用类ID和接口类型创建对象
    Cx_Interface&lt;Ix_Example&gt; pIFExample(CLSID_Example);
    if (pIFExample)
    {
        pIFExample-&gt;Foo();    // 调用接口函数
    }

    // 从一个接口转换为其他接口
    Cx_Interface&lt;Ix_Example2&gt; pIFExample2(pIFExample);
    if (pIFExample2.IsNotNull())
    {
        pIFExample2-&gt;Foo2();
    }

    MyFunc2(Cx_Ptr(pIFExample));
    return Cx_Ptr(pIFExample);
}
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">随笔</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">C/C++</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">X3框架</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/05/18/X3框架/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 yhcao
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">ABOUT ME</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">http</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">C#</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">运行外部程序</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">VidCoder</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">VLC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ffmpeg</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">系统托盘</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">通信</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">tinyXML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">XML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">浏览器</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">字符串</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">文件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">代码</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">智能指针</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Crypto++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">密码</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">CentOS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">hadoop</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">GUID</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">EChart</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">图表</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Doxygen</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Github Pages</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">静态博客</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jekyll</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">图像</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ImageMagick</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Json</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">JsonCpp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">ggicci--json</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Log4Net</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">MFC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">背景透明</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Markdown</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Maven</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">eclipse</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">MahApps.Metro</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Shell</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">VC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">管理员权限</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Qt</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">boost</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">agsXMP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">即时通讯</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">electron</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">桌面应用程序</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jQuery</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">wxWidgets</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Code::Blocks</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">xmpp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Openfire</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">agsXMPP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">gloox</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">libstrophe</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">制作CAB包</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">打包</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Notepad++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">火狐</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">浏览器插件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">GitHub</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">InstallShield</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Inno</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">IP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">GetLastError</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">钩子</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">扁平化</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Json.NET</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">log4net</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Nlog</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MailKit</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">EasyHttp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">httplib</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Epplus</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">NPIO</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">TaskScheduler</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">NUnit</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MaterialDesignInXamlToolkit</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Fluent.Ribbon</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MSBuild</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">VS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">yilia主题</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">博客</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">OpenSSL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">加密</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">SQLite NET</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Python</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C/C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">代码片段</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">WPF</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">配置文件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">VS工具</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">CppUnit</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">单元测试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">bypy</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">百度云盘</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">gitbook</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">libcur</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">网络</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">libssh2</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">wolfSSL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">zlib</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">解压缩</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">电脑软件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">个人喜欢</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">美化桌面</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">svn</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">版本号</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">tesseract</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">ocr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CEF</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">c++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">ATL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">WTL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Photoshop插件</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Cryptlib</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Jenkins</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">自动构建</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">duilib</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">插件框架</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">正则表达式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">regex</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Boost</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">目录监控</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">CCNET</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CppUTest</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Google Test</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Google Mock</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Boost.Test</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">MicrosoftCppUnitTest</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Conan</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">vcpkg</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nuget</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">cppcheck</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Resharper</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CodeMaid</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">设计模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">NLog</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">X3框架</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Socket</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">protobuf</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">grpc</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">flatbuffer</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ZeroMQ</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">调试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">错误报告</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">内存泄露</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">COM</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">IO模型</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">curl</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">libcurl</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">LibIconv</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">DShow</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">OpenCV</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">FFmpeg</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">视频</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">并发</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">多线程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">同步</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">持续集成</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C++11</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">代码覆盖率</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">工具</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">分词</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ubuntu</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">读书笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">性能优化</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">chrome</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">UML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">网络编程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">TCP/IP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">SOCKET</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">并行</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">URL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">解密</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">字符转换</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">FTP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">加解密</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">数据签名</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">数字证书</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>C++ 参考手册</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.cplusplus.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>Cplusplus</a>
            </li>
          
            <li class="search-li">
              <a href="https://www.52pojie.cn/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>吾爱破解</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>免费编程编程</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/jobbole/awesome-cpp-cn" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>C++ 资源大全中文版</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/jobbole/awesome-c-cn" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>C 语言资源大全中文版</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/jobbole/awesome-machine-learning-cn" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>机器学习资源大全中文版</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/jobbole/awesome-programming-books" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>经典编程书籍大全</a>
            </li>
          
            <li class="search-li">
              <a href="https://github.com/jobbole" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>伯乐在线</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>