<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曹景游</title>
  <icon>https://www.gravatar.com/avatar/404413bf834782c83904fd110c940e38</icon>
  <subtitle>曹景游</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caojingyou.github.io/"/>
  <updated>2018-05-18T06:59:04.626Z</updated>
  <id>https://caojingyou.github.io/</id>
  
  <author>
    <name>yhcao</name>
    <email>caojingyoump@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>X3框架</title>
    <link href="https://caojingyou.github.io/2018/05/18/X3%E6%A1%86%E6%9E%B6/"/>
    <id>https://caojingyou.github.io/2018/05/18/X3框架/</id>
    <published>2018-05-18T01:26:00.000Z</published>
    <updated>2018-05-18T06:59:04.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><p>所有插件都是普通DLL，通过在工程内包含辅助文件自动实现了统一的导出函数，通过该导出函数就能获取到在该插件内所实现的所有接口的信息及对象创建函数地址；主程序使用插件管理器（PluginManager）加载这些DLL，插件管理器通过这个导出函数将各个类ID、对象创建函数地址统一管理起来，从而在插件管理器的中介作用下让各个插件能相互使用各种接口函数。</p><h2 id="多接口转换、引用计数管理"><a href="#多接口转换、引用计数管理" class="headerlink" title="多接口转换、引用计数管理"></a>多接口转换、引用计数管理</h2><p>采用智能指针类来管理接口的引用计数及生命期，可从一个接口动态转换为另一个接口（内部采用C++的RTTI机制动态转换），可以区分插件内部的接口引用和插件外部的接口引用。</p><h2 id="跨版本"><a href="#跨版本" class="headerlink" title="跨版本"></a>跨版本</h2><p>允许不同版本的VC++开发的插件相互调用对方的接口，虽然实际中一般不需要这样做。由于没有采用VC++特殊的编译指令，因此容易移植到其他开发平台下。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><pre><code>interface Ix_Example{    virtual void Foo() = 0;    virtual void* GetData(std::vector&lt;int&gt;&amp; items) = 0;};</code></pre><h2 id="定义类UID"><a href="#定义类UID" class="headerlink" title="定义类UID"></a>定义类UID</h2><pre><code>const XCLSID CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);</code></pre><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>下面的例子是在Cx_Example.h中定义了Cx_Example类，实现了两个接口。</p><pre><code>#pragma once#include &lt;Ix_Example.h&gt;class Cx_Example    : public Ix_Example    , public Ix_Example2{protected:    Cx_Example();    ~Cx_Example();protected:    // Ix_Example    virtual void Foo();    // Ix_Example2    virtual void Foo2();};</code></pre><p>上面的例子中有两个地方值得留意（不是必须要这样，但推荐这样）：（1）构造函数和析构函数是保护类型，表示不允许直接实例化对象，也不允许直接删除销毁对象，通过智能指针类Cx_Interface或Cx_Ptr来自动实例化和销毁对象；（2）所实现的接口函数申明为保护类型，表示不允许直接调用该对象实例的函数，当然也可以申明为私有类型，表示不允许派生实现类调用其函数。</p><h2 id="在插件中登记实现类"><a href="#在插件中登记实现类" class="headerlink" title="在插件中登记实现类"></a>在插件中登记实现类</h2><p>通过智能指针类Cx_Interface或Cx_Ptr来实例化对象，需要在插件内登记该插件中有哪些可供实例化的类、实现类对应的类UID、是否为单实例类。例如下面的Module.cpp：</p><pre><code>// 登记有哪些可供实例化的类、实现类对应的类UID、是否为单实例类XBEGIN_DEFINE_MODULE()    XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)    XDEFINE_CLASSMAP_ENTRY_Singleton(CLSID_ExamTool, Cx_ExampleTool)XEND_DEFINE_MODULE()</code></pre><p>其中包含XModuleImpl.h 用于自动实现插件内部机制，插件机制如何实现对插件开发者来说不用关心，宏XDEFINE_CLASSMAP_ENTRY 用于登记普通类及其类UID，可实例化出多个对象，XDEFINE_CLASSMAP_ENTRY_Singleton 用于登记单实例类及其类UID，在一个进程中不论创建多少次都会得到同一个对象实例。</p><p>对于以MFC扩展动态库或Win32动态库类型创建插件工程的情况，由于DLL入口函数基本上都相同，为了避免在多个插件中重复出现这样类似的DLL入口函数代码，可以将上面例子中的 XEND_DEFINE_MODULE() 换为下面两个宏之一：</p><pre><code>XEND_DEFINE_MODULE_MFCEXTDLL()XEND_DEFINE_MODULE_WIN32DLL()</code></pre><h1 id="框架核心代码以及测试"><a href="#框架核心代码以及测试" class="headerlink" title="框架核心代码以及测试"></a>框架核心代码以及测试</h1><pre><code>#pragma once#include &lt;objbase.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;interface Ix_Object{    virtual void AddRef(HMODULE fromdll) = 0;    virtual void Release(HMODULE fromdll) = 0;    virtual const char* GetClassName() const = 0;};//! class factory function.typedef Ix_Object* (STDMETHODCALLTYPE *PFNXObjectCreator)(HMODULE);//! object count of a class.typedef long (STDMETHODCALLTYPE *PFNXGetObjectCount)();//! object (used by other modules) count of a class.typedef long (STDMETHODCALLTYPE *PFNXRefCountByOthers)();#define MIN_SINGLETON_TYPE  10#pragma pack(push, 8)/*! \ingroup _GROUP_PLUGIN_CORE2_*  \brief class factory registry.*  \see   _xGetClassEntryTable, XBEGIN_DEFINE_MODULE*  \internal*/struct _XCLASSMETA_ENTRY{    BYTE                type;               //!&lt; see MIN_SINGLETON_TYPE and XModuleMacro.h    const char*         className;          //!&lt; implement class name    std::string              clsid;              //!&lt; class id. may be empty if iidSpecial is valid.    const char*         iidSpecial;         //!&lt; special interface name, see XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton.    PFNXObjectCreator   pfnObjectCreator;   //!&lt; class factory function    PFNXGetObjectCount  pfnGetObjectCount;  //!&lt; object count of this class    PFNXRefCountByOthers    pfnRefCountByOthers;    //!&lt; count of objects used by other modules                                                    //! Used by XDEFINE_CLASSMAP_ENTRY, XDEFINE_CLASSMAP_ENTRY_Singleton    _XCLASSMETA_ENTRY(BYTE      _type,        const char*             _className,        const std::string &amp;           _clsid,        const char*             _iidSpecial,        PFNXObjectCreator       _pfnObjectCreator,        PFNXGetObjectCount      _pfnGetObjectCount = NULL,        PFNXRefCountByOthers    _pfnRefCountByOthers = NULL)        : type(_type), className(_className)        , clsid(_clsid), iidSpecial(_iidSpecial)        , pfnObjectCreator(_pfnObjectCreator)        , pfnGetObjectCount(_pfnGetObjectCount)        , pfnRefCountByOthers(_pfnRefCountByOthers)    {    }    //! Used by XEND_DEFINE_MODULE    _XCLASSMETA_ENTRY()        : type(0), className(&quot;&quot;), clsid(&quot;&quot;), iidSpecial(&quot;&quot;)        , pfnObjectCreator(NULL), pfnGetObjectCount(NULL)        , pfnRefCountByOthers(NULL)    {    }    //! class factory registries. filled by XBEGIN_DEFINE_MODULE.    static const _XCLASSMETA_ENTRY s_classes[];};#pragma pack(pop)std::string GuidToString(){    GUID guid;    CoCreateGuid(&amp;guid);    char buf[64] = { 0 };    _snprintf_s(        buf,        sizeof(buf),        &quot;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;,        guid.Data1, guid.Data2, guid.Data3,        guid.Data4[0], guid.Data4[1],        guid.Data4[2], guid.Data4[3],        guid.Data4[4], guid.Data4[5],        guid.Data4[6], guid.Data4[7]);    return std::string(buf);}//注意：TRUE会导致DLL引用计数加1，FALSE不会改变引用计数，通常用FALSEHMODULE GetCurrentModule(BOOL bRef = FALSE){    HMODULE hModule = NULL;    if (GetModuleHandleEx(bRef ? GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS : (GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS        | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT), (LPCTSTR)GetCurrentModule, &amp;hModule))    {        return hModule;    }    return NULL;}// Return the current module handle for making a distinction between plugins.HMODULE xGetModuleHandle(){    return GetCurrentModule();};// Create an object with the class id.HRESULT xCreateObject(const std::string&amp; clsid, Ix_Object** ppv){    *ppv = NULL;    const _XCLASSMETA_ENTRY* pCls = _XCLASSMETA_ENTRY::s_classes;    for (; pCls-&gt;pfnObjectCreator; ++pCls)    {        if (clsid == pCls-&gt;clsid)        {            *ppv = (*pCls-&gt;pfnObjectCreator)(xGetModuleHandle());            return S_OK;        }    }    return E_NOTIMPL;}template &lt;class ClsType&gt;class Cx_Object    : public ClsType    , public Ix_Object{protected:    Cx_Object(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)    {        InterlockedIncrement(&amp;ObjectCount());    }    virtual ~Cx_Object()    {        InterlockedDecrement(&amp;ObjectCount());    }protected:    virtual void AddRef(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedIncrement(&amp;RefCountByOthers());        }        InterlockedIncrement(&amp;m_lRefCount);    }    virtual void Release(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedDecrement(&amp;RefCountByOthers());        }        if (0 == InterlockedDecrement(&amp;m_lRefCount))        {            delete this;        }    }    virtual const char* GetClassName() const    {        return typeid(*this).name();    }public:    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)    {        Cx_Object&lt;ClsType&gt;* p = new Cx_Object&lt;ClsType&gt;(false);        p-&gt;AddRef(fromdll);        return p;    }    static long STDMETHODCALLTYPE GetObjectCount()    {        return ObjectCount();    }    static long STDMETHODCALLTYPE GetRefCountByOthers()    {        return RefCountByOthers();    }private:    long        m_lRefCount;    static long&amp; ObjectCount()    {        static long s_lObjCount = 0;        return s_lObjCount;    }    static long&amp; RefCountByOthers()    {        static long s_lRefCount = 0;        return s_lRefCount;    }};#if defined(_MSC_VER) &amp;&amp; !defined(_CPPRTTI)#error must enable RTTI (compiled with /GR)#endifclass Cx_Ptr;//! An autoptr class with a specified interface.template &lt;class IF_Type&gt;class Cx_Interface{    typedef Cx_Interface&lt;IF_Type&gt; thisClass;public:    Cx_Interface() : m_pInterface(NULL), m_pObj(NULL)    {    }    Cx_Interface(const Cx_Ptr&amp; src);#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt; 1200 // not VC60    Cx_Interface(const thisClass&amp; src)        : m_pInterface(src.m_pInterface), m_pObj(src.m_pObj)    {        if (m_pInterface)        {            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }    Cx_Interface(IF_Type* pInterface) : m_pInterface(pInterface), m_pObj(NULL)    {        if (m_pInterface)        {            m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);            //ASSERT(m_pObj != NULL);            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }#endif // _MSC_VER    template &lt;class IF_Type2&gt;    explicit Cx_Interface(IF_Type2* pInterface) : m_pInterface(NULL), m_pObj(NULL)    {        if (pInterface)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }    }    template &lt;class IF_Type2&gt;    explicit Cx_Interface(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)        : m_pInterface(NULL), m_pObj(NULL)    {        if (pIF)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF.P());            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }    }    explicit Cx_Interface(const std::string&amp; clsid) : m_pInterface(NULL), m_pObj(NULL)    {        if (S_OK == xCreateObject(clsid, &amp;m_pObj))        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);            if (NULL == m_pInterface)            {                m_pObj-&gt;Release(xGetModuleHandle());                m_pObj = NULL;            }        }    }    ~Cx_Interface()    {        Unload();    }    inline IF_Type* P() const    {        return m_pInterface;    }    inline IF_Type* operator-&gt;() const    {        return m_pInterface;    }    template &lt;class IF_Type2&gt;    thisClass&amp; operator=(IF_Type2* pInterface)    {        Unload();        if (pInterface)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }        return *this;    }    template &lt;class IF_Type2&gt;    thisClass&amp; operator=(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)    {        return operator=(pIF.P());    }    thisClass&amp; operator=(const thisClass&amp; src)    {        if (this != &amp;src)        {            Load(src.m_pInterface);        }        return *this;    }    thisClass&amp; operator=(const Cx_Ptr&amp; src);    thisClass&amp; operator=(const int)    {        //ASSERT(0 == nul);        Unload();        return *this;    }    bool operator==(const int) const    {        //ASSERT(0 == nul);        return m_pInterface == NULL;    }    bool operator!=(const int) const    {        //ASSERT(0 == nul);        return m_pInterface != NULL;    }    bool operator==(const IF_Type* pInterface) const    {        return m_pInterface == pInterface;    }    bool operator!=(const IF_Type* pInterface) const    {        return m_pInterface != pInterface;    }    bool operator==(const thisClass&amp; src) const    {        return m_pInterface == src.m_pInterface;    }    bool operator!=(const thisClass&amp; src) const    {        return m_pInterface != src.m_pInterface;    }    inline operator bool() const    {        return m_pInterface != NULL;    }    inline bool operator!() const    {        return NULL == m_pInterface;    }    inline bool IsNull() const    {        return NULL == m_pInterface;    }    inline bool IsNotNull() const    {        return m_pInterface != NULL;    }    void Release()    {        Unload();    }    IF_Type* DetachInterface()    {        IF_Type* pIF = m_pInterface;        m_pInterface = NULL;        m_pObj = NULL;        return pIF;    }    bool AttachInterface(IF_Type* pIF)    {        Unload();        m_pInterface = pIF;        m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);        return (m_pObj != NULL || NULL == m_pInterface);    }    bool AttachInterface(Ix_Object* pIF)    {        Unload();        if (pIF)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);            }            else            {                pIF-&gt;Release(xGetModuleHandle());                pIF = NULL;                return false;            }        }        return true;    }    bool Create(const std::string&amp; clsid)    {        Unload();        if (S_OK == xCreateObject(clsid, &amp;m_pObj))        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);            if (NULL == m_pInterface)            {                m_pObj-&gt;Release(xGetModuleHandle());                m_pObj = NULL;            }        }        return m_pInterface != NULL;    }private:    void Unload()    {        if (m_pObj)        {            m_pObj-&gt;Release(xGetModuleHandle());            m_pObj = NULL;            m_pInterface = NULL;        }    }    void Load(IF_Type* pIF)    {        Ix_Object* pObj = dynamic_cast&lt;Ix_Object*&gt;(pIF);        if (m_pObj != pObj)        {            if (pObj)            {                pObj-&gt;AddRef(xGetModuleHandle());            }            if (m_pObj)            {                m_pObj-&gt;Release(xGetModuleHandle());            }            m_pObj = pObj;            m_pInterface = pIF;        }    }private:    IF_Type*    m_pInterface;    Ix_Object*  m_pObj;};//! An autoptr class with the Ix_Object interface.class Cx_Ptr{public:    Cx_Ptr() : m_pInterface(NULL)    {    }    Cx_Ptr(const Cx_Ptr&amp; src) : m_pInterface(src.m_pInterface)    {        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    template &lt;class IF_Type&gt;    explicit Cx_Ptr(IF_Type* pInterface) : m_pInterface(NULL)    {        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    template &lt;class IF_Type&gt;    explicit Cx_Ptr(const Cx_Interface&lt;IF_Type&gt;&amp; pIF) : m_pInterface(NULL)    {        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pIF.P());        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    explicit Cx_Ptr(const std::string&amp; clsid) : m_pInterface(NULL)    {        xCreateObject(clsid, &amp;m_pInterface);    }    ~Cx_Ptr()    {        Unload();    }    Ix_Object* P() const    {        return m_pInterface;    }    template &lt;class IF_Type&gt;    Cx_Ptr&amp; operator=(IF_Type* pInterface)    {        Unload();        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }        return *this;    }    template &lt;class IF_Type&gt;    Cx_Ptr&amp; operator=(const Cx_Interface&lt;IF_Type&gt;&amp; pIF)    {        return operator=(pIF.P());    }    Cx_Ptr&amp; operator=(const Cx_Ptr&amp; src)    {        if (this != &amp;src)        {            Load(src.m_pInterface);        }        return *this;    }    Cx_Ptr&amp; operator=(const int)    {        //ASSERT(0 == nul);        Unload();        return *this;    }    bool operator==(const int) const    {        //ASSERT(0 == nul);        return m_pInterface == NULL;    }    bool operator!=(const int) const    {        //ASSERT(0 == nul);        return m_pInterface != NULL;    }    bool operator==(const Ix_Object* pInterface) const    {        return m_pInterface == pInterface;    }    bool operator!=(const Ix_Object* pInterface) const    {        return m_pInterface != pInterface;    }    bool operator==(const Cx_Ptr&amp; src) const    {        return m_pInterface == src.m_pInterface;    }    bool operator!=(const Cx_Ptr&amp; src) const    {        return m_pInterface != src.m_pInterface;    }    inline operator bool() const    {        return m_pInterface != NULL;    }    inline bool operator!() const    {        return NULL == m_pInterface;    }    inline bool IsNull() const    {        return NULL == m_pInterface;    }    inline bool IsNotNull() const    {        return m_pInterface != NULL;    }    void Release()    {        Unload();    }    Ix_Object* DetachInterface()    {        Ix_Object* pIF = m_pInterface;        m_pInterface = NULL;        return pIF;    }    void AttachInterface(Ix_Object* pIF)    {        Unload();        m_pInterface = pIF;    }    bool Create(const std::string&amp; clsid)    {        Unload();        return S_OK == xCreateObject(clsid, &amp;m_pInterface);    }private:    void Unload()    {        if (m_pInterface)        {            m_pInterface-&gt;Release(xGetModuleHandle());            m_pInterface = NULL;        }    }    void Load(Ix_Object* pIF)    {        if (m_pInterface != pIF)        {            if (pIF)            {                pIF-&gt;AddRef(xGetModuleHandle());            }            if (m_pInterface)            {                m_pInterface-&gt;Release(xGetModuleHandle());            }            m_pInterface = pIF;        }    }private:    Ix_Object*  m_pInterface;};// Inlines for Cx_Interface//template &lt;class IF_Type&gt; inlineCx_Interface&lt;IF_Type&gt;::Cx_Interface(const Cx_Ptr&amp; src) : m_pInterface(NULL), m_pObj(NULL){    if (src.P())    {        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());        if (m_pInterface)        {            m_pObj = src.P();            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }}template &lt;class IF_Type&gt; inlineCx_Interface&lt;IF_Type&gt;&amp; Cx_Interface&lt;IF_Type&gt;::operator=(const Cx_Ptr&amp; src){    Unload();    if (src.P())    {        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());        if (m_pInterface)        {            m_pObj = src.P();            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }    return *this;}template &lt;class ClsType&gt;class Cx_SingletonObject    : public ClsType    , public Ix_Object    , public CModuleItem{protected:    Cx_SingletonObject(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)    {    }    virtual ~Cx_SingletonObject()    {        if (Instance() == this)        {            Instance() = NULL;        }    }protected:    virtual void AddRef(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedIncrement(&amp;RefCountByOthers());        }        InterlockedIncrement(&amp;m_lRefCount);    }    virtual void Release(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedDecrement(&amp;RefCountByOthers());        }        InterlockedDecrement(&amp;m_lRefCount);    }    virtual const char* GetClassName() const    {        return typeid(*this).name();    }public:    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)    {        if (NULL == Instance())        {            Cx_SingletonObject&lt;ClsType&gt;* p = new Cx_SingletonObject&lt;ClsType&gt;(false);#ifdef InterlockedCompareExchangePointer            if (InterlockedCompareExchangePointer(                (PVOID volatile *)(&amp;Instance()), p, NULL) == NULL)#else            if (InterlockedCompareExchange((void**)(&amp;Instance()), p, NULL) == NULL)#endif            {                p-&gt;AddRef(fromdll);                p-&gt;AddModuleItem();            }            else            {                delete p;   // has created by another thread            }        }        return Instance();    }    static long STDMETHODCALLTYPE GetObjectCount()    {        return (Instance() &amp;&amp; Instance()-&gt;m_lRefCount &gt; 0) ? 1 : 0;    }    static long STDMETHODCALLTYPE GetRefCountByOthers()    {        return RefCountByOthers();    }private:    long        m_lRefCount;    static Cx_SingletonObject&lt;ClsType&gt;*&amp; Instance()    {        static Cx_SingletonObject&lt;ClsType&gt;* s_pSingleton = NULL;        return s_pSingleton;    }    static long&amp; RefCountByOthers()    {        static long s_lRefCount = 0;        return s_lRefCount;    }};// XBEGIN_DEFINE_MODULE()//     XDEFINE_CLASSMAP_ENTRY(clsid, cls)//     XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)//     XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(clsid, iid, cls)// XEND_DEFINE_MODULE()// XEND_DEFINE_MODULE_WIN32DLL()// XEND_DEFINE_MODULE_MFCEXTDLL()// XEND_DEFINE_MODULE_MFCDLL()//! Begin group of class factory registry./*!\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XBEGIN_DEFINE_MODULE()  \    const _XCLASSMETA_ENTRY _XCLASSMETA_ENTRY::s_classes[] = {//! Register a regular class./*!\ingroup _GROUP_PLUGIN_CORE_\param clsid class unique id, XCLSID constant.\param cls implement class*/#define XDEFINE_CLASSMAP_ENTRY(clsid, cls)      \    _XCLASSMETA_ENTRY(1, &quot;Cx_Object&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_Object&lt;cls&gt;::CreateObject), \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_Object&lt;cls&gt;::GetObjectCount),  \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_Object&lt;cls&gt;::GetRefCountByOthers)),//! Register a single instance class./*!\ingroup _GROUP_PLUGIN_CORE_\param clsid class unique id, XCLSID constant.\param cls implement class*/#define XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)    \    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE,   \        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),//! Register a single instance class that support the specific interface./*!\ingroup _GROUP_PLUGIN_CORE_\param iid the specific interface id name. char array constant.\param cls implement class*/#define XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(iid, cls)     \    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE + 1,   \        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, XCLSID(), iid,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),//! End group of class factory registry./*!\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XEND_DEFINE_MODULE() \        _XCLASSMETA_ENTRY() \    };#pragma warning(disable:4710)   // inline function not expanded//! End group of class factory registry and implement entry function of Win32DLL(USRDLL)./*! Using this macro need include this file and XModuleImpl.h file.\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_MFCEXTDLL, XEND_DEFINE_MODULE_MFCDLL*/#define XEND_DEFINE_MODULE_WIN32DLL() \        _XCLASSMETA_ENTRY() \    };  \BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID)   \{   \    if (dwReason == DLL_PROCESS_ATTACH) \    {   \        _xGetModuleInterface(NULL, (HMODULE)hModule);   \    }   \    else if (dwReason == DLL_PROCESS_DETACH)    \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();    \    }   \    return TRUE;    \}//! End group of class factory registry and implement entry function of MFC Extension DLL./*! Using this macro need include this file and XModuleImpl.h file.\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCDLL*/#define XEND_DEFINE_MODULE_MFCEXTDLL() \        _XCLASSMETA_ENTRY() \    };  \static AFX_EXTENSION_MODULE MFCExtDLL = { NULL, NULL }; \extern &quot;C&quot; int APIENTRY \DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)    \{   \    if (dwReason == DLL_PROCESS_ATTACH) \    {   \        if (!AfxInitExtensionModule(MFCExtDLL, hInstance))  \            return 0;   \        new CDynLinkLibrary(MFCExtDLL); \        _xGetModuleInterface(NULL, MFCExtDLL.hModule);  \    }   \    else if (dwReason == DLL_PROCESS_DETACH)    \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();        \        AfxTermExtensionModule(MFCExtDLL);  \    }   \    return 1;   \}//! End group of class factory registry and implement entry function of MFC regular DLL./*! This macro implements CPluginApp class.\nUsing this macro need include this file and XModuleImpl.h file.\note Call the following statemant before call any MFC function: \nAFX_MANAGE_STATE(AfxGetStaticModuleState());\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XEND_DEFINE_MODULE_MFCDLL() \        _XCLASSMETA_ENTRY() \    };  \class CPluginApp : public CWinApp   \{   \public: \    CPluginApp()    \    {   \    }   \    virtual BOOL InitInstance() \    {   \        CWinApp::InitInstance();    \        _xGetModuleInterface(NULL, m_hInstance);    \        return TRUE;    \    }   \    virtual int ExitInstance()  \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();    \        return CWinApp::ExitInstance(); \    }   \};//以上为基础核心代码，以下为例子const std::string CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);interface Ix_Example{    virtual void Foo() = 0;};interface Ix_Example2{    virtual void Foo2() = 0;};class Cx_Example    : public Ix_Example    , public Ix_Example2{protected:    Cx_Example() {};    virtual ~Cx_Example() {};private:    // From Ix_Example    virtual void Foo()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    };    // From Ix_Example2    virtual void Foo2()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    };};XBEGIN_DEFINE_MODULE()XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)XEND_DEFINE_MODULE()void MyFunc2(const Cx_Ptr&amp; obj){    // Cx_Interface与Cx_Ptr互转，转为特定接口    Cx_Interface&lt;Ix_Example&gt; pIFExample(obj);    if (pIFExample)    {        pIFExample-&gt;Foo();    }}Cx_Ptr MyFunc1(){    // 使用类ID和接口类型创建对象    Cx_Interface&lt;Ix_Example&gt; pIFExample(CLSID_Example);    if (pIFExample)    {        pIFExample-&gt;Foo();    // 调用接口函数    }    // 从一个接口转换为其他接口    Cx_Interface&lt;Ix_Example2&gt; pIFExample2(pIFExample);    if (pIFExample2.IsNotNull())    {        pIFExample2-&gt;Foo2();    }    MyFunc2(Cx_Ptr(pIFExample));    return Cx_Ptr(pIFExample);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;插件原理&quot;&gt;&lt;a href=&quot;#插件原理&quot; class=&quot;headerlink&quot; title=&quot;插件原理&quot;&gt;&lt;/a&gt;插件原理&lt;/h
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="X3框架" scheme="https://caojingyou.github.io/tags/X3%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>NLog</title>
    <link href="https://caojingyou.github.io/2018/05/17/NLog/"/>
    <id>https://caojingyou.github.io/2018/05/17/NLog/</id>
    <published>2018-05-17T01:37:00.000Z</published>
    <updated>2018-05-17T02:30:57.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NLog"><a href="#NLog" class="headerlink" title="NLog"></a>NLog</h1><p><a href="http://nlog-project.org/" target="_blank" rel="noopener">Nlog</a></p><p><a href="https://github.com/NLog/NLog" title="https://github.com/NLog/NLog" target="_blank" rel="noopener">https://github.com/NLog/NLog</a></p><p>Nlog是.net平台下的开源日志组件，相当于log4net用法配置更简单。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>Install-Package NLog.Config -Version 4.5.4</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>获取一个Logger实例，取名为NLogConsoleExample（名字可任意），也可采用 LogManager.GetCurrentClassLogger()来获取一个以当前类名为名称的Logger实例；然后我们在main方法中添加几行简单调用NLog输出不同级别的日志信息的代码</p><p>下面的代码将会创建一个和class有着相同名字的Logger。</p><pre><code>namespace MyNamespace{  public class MyClass  {        private static Logger logger = LogManager.GetCurrentClassLogger();  }}</code></pre><p>管理Logger的名字也是可以的：</p><pre><code>using NLog;Logger logger = LogManager.GetLogger(&quot;MyClassName&quot;);</code></pre><h1 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h1><p>每一个日志消息都用一个日志级别来修饰，它们用来识别消息的重要性和具体细节。NLog可以以Logger对象的名称和日志级别为主，路由日志消息。</p><p>NLog支持下面的日志级别：</p><ul><li>Trace 特别细节的日志，可能包含大量的信息，比如说协议的负载。这个日志级别通常只会在开发期间被启用。</li><li>Debug Debug信息，比Trace的信息量要少一些，通常不会在生产环境下使用。</li><li>Info 信息消息，这个是在生产环境下经常使用到的。</li><li>Warn 警告消息，通常用来指示非关键性的问题，这些问题可以被恢复或者只是临时错误。</li><li>Error 错误消息 大多数时候，他们都是Exception（异常）。</li><li>Fatal 特别严重的错误！</li></ul><h1 id="书写日志消息"><a href="#书写日志消息" class="headerlink" title="书写日志消息"></a>书写日志消息</h1><pre><code>using NLog;public class MyClass{  private static Logger logger = LogManager.GetCurrentClassLogger();  public void MyMethod1()  {    logger.Trace(&quot;Sample trace message&quot;);    logger.Debug(&quot;Sample debug message&quot;);    logger.Info(&quot;Sample informational message&quot;);    logger.Warn(&quot;Sample warning message&quot;);    logger.Error(&quot;Sample error message&quot;);    logger.Fatal(&quot;Sample fatal error message&quot;);    // alternatively you can call the Log() method     // and pass log level as the parameter.    logger.Log(LogLevel.Info, &quot;Sample informational message&quot;);  }}</code></pre><p>日志消息也可以被参数化 - 你可以使用字符串格式，就像你在Console.WriteLine()和String.Format()中一样：</p><pre><code>using NLog;public class MyClass{  private static Logger logger = LogManager.GetCurrentClassLogger();  public void MyMethod1()  {    int k = 42;    int l = 100;    logger.Trace(&quot;Sample trace message, k={0}, l={1}&quot;, k, l);    logger.Debug(&quot;Sample debug message, k={0}, l={1}&quot;, k, l);    logger.Info(&quot;Sample informational message, k={0}, l={1}&quot;, k, l);    logger.Warn(&quot;Sample warning message, k={0}, l={1}&quot;, k, l);    logger.Error(&quot;Sample error message, k={0}, l={1}&quot;, k, l);    logger.Fatal(&quot;Sample fatal error message, k={0}, l={1}&quot;, k, l);    logger.Log(LogLevel.Info, &quot;Sample informational message, k={0}, l={1}&quot;, k, l);  }}</code></pre><h1 id="NLog配置文件支持两种方式"><a href="#NLog配置文件支持两种方式" class="headerlink" title="NLog配置文件支持两种方式"></a>NLog配置文件支持两种方式</h1><ul><li>是将配置写到应用程序的配置文件（通常是applicationName.exe.config）或者Web.config文件中；</li><li><p>独配置到一个文件，通常是NLog.config</p><p>  &lt;?xml version=”1.0” encoding=”utf-8” ?&gt;</p>  <nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><br><br>      <targets><br>          <target name="logfile" xsi:type="File" filename="file.txt"><br>      </target></targets><br><br>      <rules><br>          <logger name="*" minlevel="Info" writeto="logfile"><br>      </logger></rules><br>  </nlog></li></ul><p>多个目标</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;targets&gt;        &lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; /&gt;        &lt;target name=&quot;console&quot; xsi:type=&quot;Console&quot; /&gt;    &lt;/targets&gt;    &lt;rules&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;logfile&quot; /&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Info&quot; writeTo=&quot;console&quot; /&gt;    &lt;/rules&gt;&lt;/nlog&gt;</code></pre><p>还有一个比较常见的应用场景则是，需要为当前正在开发的组件提供更多细节的日志，而其他的组件将会减少输出。我们就可以用这样的配置文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;targets&gt;        &lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; /&gt;    &lt;/targets&gt;    &lt;rules&gt;        &lt;logger name=&quot;SomeNamespace.Component.*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;logfile&quot; final=&quot;true&quot; /&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Info&quot; writeTo=&quot;logfile&quot; /&gt;    &lt;/rules&gt;&lt;/nlog&gt;</code></pre><p>第一个规则将会将以SomeNamespace.Component开头的Logger对象的Trace级别及以上级别的日志发送到日志文件。属性final=true将会使得在写入操作之后停止进一步处理。<br>第二个规则将会将剩下的日志发送到同一个日志文件，但是这些日志有一个约束，那就是级别需要是Info或更高。</p><h1 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h1><p>层级提供了一个当日志被写入文件时，指定日志内容格式的方法。主要有两种层级：</p><pre><code>简单层级 - 使用层级渲染器撰写。结构层级 - 可以输出XML、CSV、以及其他复杂的格式。</code></pre><p>简单层级就是一个字符串，在${和}中嵌入一些特殊的标记。比如下面的声明将会使得每一条日志消息都是用一个格式为yyyMMddHHmmss:的日期前缀：</p><pre><code>&lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; layout=&quot;${date:format=yyyyMMddHHmmss} ${message}&quot; /&gt;</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/Toshiya14/article/details/52098088" title="NLog简易入门" target="_blank" rel="noopener">https://blog.csdn.net/Toshiya14/article/details/52098088</a></p><p><a href="https://github.com/NLog/NLog/wiki/Configuration-file" title="https://github.com/NLog/NLog/wiki/Configuration-file" target="_blank" rel="noopener">https://github.com/NLog/NLog/wiki/Configuration-file</a></p><p><a href="https://github.com/NLog/NLog/wiki/Configuration-API" title="https://github.com/NLog/NLog/wiki/Configuration-API" target="_blank" rel="noopener">https://github.com/NLog/NLog/wiki/Configuration-API</a></p><p><a href="https://blog.csdn.net/dsnq2011/article/details/51920265" target="_blank" rel="noopener">NLog的配置和使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NLog&quot;&gt;&lt;a href=&quot;#NLog&quot; class=&quot;headerlink&quot; title=&quot;NLog&quot;&gt;&lt;/a&gt;NLog&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://nlog-project.org/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="NLog" scheme="https://caojingyou.github.io/tags/NLog/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅-笔记</title>
    <link href="https://caojingyou.github.io/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"/>
    <id>https://caojingyou.github.io/2018/05/15/设计模式之禅/</id>
    <published>2018-05-15T01:32:00.000Z</published>
    <updated>2018-05-15T01:32:36.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="秦小波"><a href="#秦小波" class="headerlink" title="秦小波"></a>秦小波</h2><h3 id="Citation-APA-秦小波-2010-设计模式之禅-Kindle-Android-version-Retrieved-from-Amazon-com"><a href="#Citation-APA-秦小波-2010-设计模式之禅-Kindle-Android-version-Retrieved-from-Amazon-com" class="headerlink" title="Citation (APA): 秦小波. (2010). 设计模式之禅 [Kindle Android version]. Retrieved from Amazon.com"></a>Citation (APA): 秦小波. (2010). 设计模式之禅 [Kindle Android version]. Retrieved from Amazon.com</h3><p>单例模式和原型模式非常容易理解，单例模式是要保持在内存中只有一个对象，原型模式是要求通过复制的方式产生一个新的对象，这两个不容易混淆。</p><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步的精确构造创建出一个复杂的对象。</p><p>一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。</p><p>如果需要详细关注一个产品部件的生产、安装步骤，则选择建造者，否则选择工厂方法模式。</p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>为什么叫结构类模式呢？因为它们都是通过组合类或对象产生更大结构以适应更高层次的逻辑需求。</p><p>装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口，不同点则是代理模式着重对代理过程的控制，而装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化，</p><p>代理模式和装饰模式有非常相似的地方，甚至代码实现都非常相似，特别是装饰模式中省略抽象装饰角色后，两者代码基本上相同，但是还是有细微的差别。代理模式是把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，它不对被主题角色（也就是被代理类）的功能做任何处理，保证原汁原味的调用。代理模式使用到极致开发就是AOP，这是各位采用Spring架构开发必然要使用到的技术，它就是使用了代理和反射的技术。装饰模式是在要保证接口不变的情况下加强类的功能，它保证的是被修饰的对象功能比原始对象丰富（当然，也可以减弱），但不做准入条件判断和准入参数过滤，如是否可以执行类的功能，过滤输入参数是否合规等，这不是装饰模式关心的。</p><p>装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。</p><p>装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。</p><p>行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。</p><p>命令模式和策略模式的类图确实很相似，只是命令模式多了一个接收者（Receiver）角色。它们虽然同为行为类模式，但是两者的区别还是很明显的。策略模式的意图是封装算法，它认为“算法”已经是一个完整的、不可拆分的原子业务（注意这里是原子业务，而不是原子对象），即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象（接收者角色）、执行行为（命令角色），让两者相互独立而不相互影响。</p><p>策略模式和命令模式相似，特别是命令模式退化时，比如无接收者（接收者非常简单或者接收者是一个Java的基础操作，无需专门编写一个接收者），在这种情况下，命令模式和策略模式的类图完全一样，代码实现也比较类似，但是两者还是有区别的。</p><p>策略模式关注的是算法替换的问题，一个新的算法投产，旧算法退休，或者提供多种算法由调用者自己选择使用，算法的自由更替是它实现的要点。换句话说，策略模式关注的是算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换。命令模式则关注的是解耦问题，如何让请求者和执行者解耦是它需要首先解决的，解耦的要求就是把请求的内容封装为一个一个的命令，由接收者执行。由于封装成了命令，就同时可以对命令进行多种处理，例如撤销、记录等。</p><p>策略模式中的抽象算法和具体算法与命令模式的接收者非常相似，但是它们的职责不同。策略模式中的具体算法是负责一个完整算法逻辑，它是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。</p><p>策略模式适用于算法要求变换的场景，而命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。</p><p>策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；而状态模式封装的是不同的状态，以达到状态切换行为随之发生改变的目的。这两种模式虽然都有变换的行为，但是两者的目标却是不同的。</p><p>策略模式的环境角色只是一个委托作用，负责算法的替换；而状态模式的环境角色不仅仅是委托行为，它还具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。</p><p>策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模式对外暴露的是行为，状态的变化一般是由环境角色和具体状态共同完成的，也就是说状态模式封装了状态的变化而暴露了不同的行为或行为结果。</p><p>在责任链模式中，上下节点没有关系，都是接收同样的对象，所有传递的对象都是从链首传递过来，上一节点是什么没有关系，只要按照自己的逻辑处理就成。而触发链模式就不同了，它的上下级关系很亲密，下级对上级顶礼膜拜，上级对下级绝对信任，链中的任意两个相邻节点都是一个牢固的独立团体。</p><p>在责任链模式中，一个消息从链首传递进来后，就开始沿着链条向链尾运动，方向是单一的、固定的；而触发链模式则不同，由于它采用的是观察者模式，所以有非常大的灵活性，一个消息传递到链首后，具体怎么传递是不固定的，可以以广播方式传递，也可以以跳跃方式传递，这取决于处理消息的逻辑。</p><p>创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着重于如何建立一个软件结构，虽然三种模式的着重点不同，</p><p>策略模式实现两种算法的自由切换，它提供了这样的保证：封装邮件的两种行为是可选择的，至于选择哪个算法是由上层模块决定的。策略模式要完成的任务就是提供两种可以替换的算法。</p><p>桥梁模式关注的是抽象和实现的分离，它是结构型模式，</p><p>简单来说，策略模式是使用继承和多态建立一套可以自由切换算法的模式，桥梁模式是在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。桥梁模式必然有两个“桥墩”——抽象化角色和实现化角色，只要桥墩搭建好，桥就有了，而策略模式只有一个抽象角色，可以没有实现，也可以有很多实现。</p><p>门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的问题。中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构。</p><p>门面模式和中介者模式之间的区别还是比较明显的，门面模式是以封装和隔离为主要任务，而中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务逻辑控制。</p><p>门面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门面模式是完全可以独立运行的。而中介者模式则增加了业务功能，它把各个同事类中的原有耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂性和降低扩展性。</p><p>门面模式是一种简单的封装，所有的请求处理都委托给子系统完成，而中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的业务功能封装。</p><p>包装模式包括：装饰模式、适配器模式、门面模式、代理模式、桥梁模式。</p><p>5个包装模式是大家在系统设计中经常会用到的模式，它们具有相似的特征：都是通过委托的方式对一个对象或一系列对象（例如门面模式）施行包装，有了包装，设计的系统才更加灵活、稳定，并且极具扩展性。从实现的角度来看，它们都是代理的一种具体表现形式，</p><p>装饰模式是一种特殊的代理模式，它倡导的是在不改变接口的前提下为对象增强功能，或者动态添加额外职责。就扩展性而言，它比子类更加灵活，例如在一个已经运行的项目中，可以很轻松地通过增加装饰类来扩展系统的功能。适配器模式的主要意图是接口转换，把一个对象的接口转换成系统希望的另外一个接口，这里的系统指的不仅仅是一个应用，也可能是某个环境，比如通过接口转换可以屏蔽外界接口，以免外界接口深入系统内部，从而提高系统的稳定性和可靠性。桥梁模式是在抽象层产生耦合，解决的是自行扩展的问题，它可以使两个有耦合关系的对象互不影响地扩展，比如对于使用笔画图这样的需求，可以采用桥梁模式设计成用什么笔（铅笔、毛笔）画什么图（圆形、方形）的方案，至于以后需求的变更，如增加笔的类型，增加图形等，对该设计来说是小菜一碟。门面模式是一个粗粒度的封装，它提供一个方便访问子系统的接口，不具有任何的业务逻辑，仅仅是一个访问复杂系统的快速通道，没有它，子系统照样运行，有了它，只是更方便访问而已。</p><h1 id="23种设计模式彩图"><a href="#23种设计模式彩图" class="headerlink" title="23种设计模式彩图"></a>23种设计模式彩图</h1><p><img src="https://i.imgur.com/WT9XrQv.png" alt=""></p><p><img src="https://i.imgur.com/oOq0ZC4.png" alt=""></p><p><img src="https://i.imgur.com/ujyOLJH.png" alt=""></p><p><img src="https://i.imgur.com/fAc8qmZ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式之禅&quot;&gt;&lt;a href=&quot;#设计模式之禅&quot; class=&quot;headerlink&quot; title=&quot;设计模式之禅&quot;&gt;&lt;/a&gt;设计模式之禅&lt;/h1&gt;&lt;h2 id=&quot;秦小波&quot;&gt;&lt;a href=&quot;#秦小波&quot; class=&quot;headerlink&quot; title=&quot;秦小波
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="设计模式" scheme="https://caojingyou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="笔记" scheme="https://caojingyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>史上最全设计模式导学目录笔记</title>
    <link href="https://caojingyou.github.io/2018/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/05/09/设计模式/</id>
    <published>2018-05-09T10:10:00.000Z</published>
    <updated>2018-05-18T09:17:34.474Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录（完整版）</a></p><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责，在GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。</p><ol><li>创建型模式-Creational Pattern[(122434),(435532)]<ol><li>单例模式-Singleton Pattern</li><li>简单工厂模式-Simple Factory Pattern</li><li>工厂方法模式-Factory Method Pattern</li><li>抽象工厂模式-Abstract  Factory Pattern</li><li>原型模式-Prototype Pattern</li><li>建造者模式-Builder Pattern</li></ol></li><li>结构型模式-Structural Pattern[(2333143),(4343515)]<ol><li>适配器模式-Adapter Pattern</li><li>桥接模式-Bridge  Pattern</li><li>组合模式-Composite  Pattern</li><li>装饰模式-Decorator  Pattern</li><li>外观模式-Façade  Pattern</li><li>享元模式-Flyweight  Pattern</li><li>代理模式-Proxy  Pattern</li></ol></li><li>行为型模式-Behavioral Pattern [(33533233124),(24152253431)]<ol><li>职责链模式-Chain  of Responsibility Pattern</li><li>命令模式-Command  Pattern</li><li>解释器模式-Interpreter  Pattern</li><li>迭代器模式-Iterator  Pattern</li><li>中介者模式-Mediator  Pattern</li><li>备忘录模式-Memento  Pattern</li><li>观察者模式-Observer  Pattern</li><li>状态模式-State  Pattern</li><li>策略模式-Strategy  Pattern</li><li>模板方法模式-Template  Method Pattern</li><li>访问者模式-Visitor  Pattern</li></ol></li></ol><p>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。当你能够回答上述所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做。</p><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="7种常用的面向对象设计原则"><a href="#7种常用的面向对象设计原则" class="headerlink" title="7种常用的面向对象设计原则"></a>7种常用的面向对象设计原则</h2><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责</p><p>★★★★☆</p><h3 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h3><p>软件实体应对扩展开放，而对修改关闭</p><p>★★★★★</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle, LSP)"></a>里氏代换原则(Liskov Substitution Principle, LSP)</h3><p>所有引用基类对象的地方能够透明地使用其子类的对象</p><p>★★★★★</p><p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence  Inversion Principle, DIP)"></a>依赖倒转原则(Dependence  Inversion Principle, DIP)</h3><p>抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p>★★★★★</p><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><p>★★☆☆☆</p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p><h3 id="合成复用原则-Composite-Reuse-Principle-CRP"><a href="#合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle, CRP)"></a>合成复用原则(Composite Reuse Principle, CRP)</h3><p>尽量使用对象组合，而不是继承来达到复用的目的</p><p>★★★★☆</p><p>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p><h3 id="迪米特法则-Law-of-Demeter-LoD"><a href="#迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="迪米特法则(Law of Demeter, LoD)"></a>迪米特法则(Law of Demeter, LoD)</h3><p>一个软件实体应当尽可能少地与其他实体发生相互作用</p><p>★★★☆☆</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><h1 id="六个创建型模式"><a href="#六个创建型模式" class="headerlink" title="六个创建型模式"></a>六个创建型模式</h1><h2 id="简单工厂模式-Simple-Factory-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"><a href="#简单工厂模式-Simple-Factory-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】" class="headerlink" title="简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"></a>简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】</h2><pre><code>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</code></pre><p><img src="https://img-blog.csdn.net/20130711143612921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="简单工厂模式结构图"></p><p>在简单工厂模式结构图中包含如下几个角色：</p><pre><code>● Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。● Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。● ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</code></pre><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p><p><img src="https://img-blog.csdn.net/20130711145238171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="简化的简单工厂模式"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用简单工厂模式：(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</code></pre><h2 id="工厂方法模式-Factory-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】"><a href="#工厂方法模式-Factory-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】" class="headerlink" title="工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】"></a>工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】</h2><p>针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p><pre><code>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</code></pre><p><img src="https://img-blog.csdn.net/20130712101002890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="工厂方法模式结构图"></p><p>在工厂方法模式结构图中包含如下几个角色：</p><pre><code>● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</code></pre><p>工厂方法可重载、隐藏</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用工厂方法模式：(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</code></pre><h2 id="抽象工厂模式-Abstract-Factory-Pattern【学习难度：★★★★☆，使用频率：★★★★★】"><a href="#抽象工厂模式-Abstract-Factory-Pattern【学习难度：★★★★☆，使用频率：★★★★★】" class="headerlink" title="抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】"></a>抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】</h2><p>将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产</p><p>两个概念：</p><pre><code>(1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。(2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</code></pre><p> 当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。</p><p><img src="https://img-blog.csdn.net/20130713163008609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抽象工厂模式示意图"></p><pre><code>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</code></pre><p><img src="https://img-blog.csdn.net/20130713163800203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抽象工厂模式结构图"></p><p>在抽象工厂模式结构图中包含如下几个角色：</p><pre><code>● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</code></pre><p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><pre><code>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用抽象工厂模式：(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。(4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</code></pre><h2 id="单例模式-Singleton-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"><a href="#单例模式-Singleton-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】" class="headerlink" title="单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"></a>单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】</h2><p>为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个唯一实例创建成功之后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一实例。为了确保对象的唯一性，我们可以通过单例模式来实现，这就是单例模式的动机所在。</p><pre><code>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/02/1333305124_9327.gif" alt="单例模式结构图"></p><p><img src="http://my.csdn.net/uploads/201204/02/1333305889_1823.gif" alt="饿汉"></p><p><img src="http://my.csdn.net/uploads/201204/02/1333305983_8045.gif" alt="懒汉"></p><p>饿汉式单例类与懒汉式单例类比较</p><pre><code>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用单例模式：(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</code></pre><h2 id="原型模式-Prototype-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#原型模式-Prototype-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><pre><code>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/03/1333464346_2107.gif" alt="原型模式结构图"></p><p>在原型模式结构图中包含如下几个角色：</p><pre><code>●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</code></pre><p>3.适用场景</p><pre><code>    在以下情况下可以考虑使用原型模式：(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</code></pre><h2 id="建造者模式-Builder-Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】"><a href="#建造者模式-Builder-Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】" class="headerlink" title="建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】"></a>建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】</h2><pre><code>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/04/1333532291_9501.gif" alt="建造者模式结构图"></p><p>在建造者模式结构图中包含如下几个角色：</p><pre><code>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</code></pre><p>适用场景</p><pre><code>  在以下情况下可以考虑使用建造者模式：(1) 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。(2) 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。(3) 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。(4) 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</code></pre><h1 id="七个结构型模式"><a href="#七个结构型模式" class="headerlink" title="七个结构型模式"></a>七个结构型模式</h1><h2 id="适配器模式-Adapter-Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】"><a href="#适配器模式-Adapter-Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】" class="headerlink" title="适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】"></a>适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】</h2><pre><code>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</code></pre><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p><p><img src="http://img.my.csdn.net/uploads/201302/28/1362066399_9469.jpg" alt="对象适配器模式结构图"></p><p>在对象适配器模式结构图中包含如下几个角色：</p><pre><code>● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</code></pre><p>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系</p><p><img src="http://img.my.csdn.net/uploads/201303/01/1362099343_7447.jpg" alt="类适配器模式结构图"></p><p>在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器</p><p><img src="http://img.my.csdn.net/uploads/201303/01/1362100282_9857.jpg" alt="双向适配器结构示意图"></p><p>在实际开发中，我们很少使用双向适配器。</p><pre><code>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</code></pre><p><img src="http://img.my.csdn.net/uploads/201303/01/1362101177_9180.jpg" alt="缺省适配器模式结构图"></p><p>在缺省适配器模式中，包含如下三个角色：</p><pre><code>● ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。● AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。● ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用适配器模式： (1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 (2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</code></pre><h2 id="桥接模式-Bridge-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#桥接模式-Bridge-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p><p>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。</p><pre><code>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/16/1334505919_5277.gif" alt=""></p><p>在桥接模式结构图中包含如下几个角色：</p><pre><code>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</code></pre><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用桥接模式：(1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。(2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。(3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。(4)对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</code></pre><h2 id="组合模式-Composite-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#组合模式-Composite-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"></a>组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】</h2><p>组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子。</p><pre><code>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</code></pre><p><img src="http://img.my.csdn.net/uploads/201209/07/1347029718_6268.jpg" alt="组合模式结构图"></p><p>在组合模式结构图中包含如下几个角色：</p><pre><code>● Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</code></pre><p> 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。</p><p><img src="http://img.my.csdn.net/uploads/201209/07/1347030625_8865.jpg" alt="透明组合模式结构图"></p><p><img src="http://img.my.csdn.net/uploads/201209/07/1347030697_3976.jpg" alt=" 安全组合模式结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用组合模式：(1) 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。(2) 在一个使用面向对象语言开发的系统中需要处理一个树形结构。(3) 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</code></pre><h2 id="装饰模式-Decorator-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#装饰模式-Decorator-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为</p><p>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p><pre><code>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/04/1333528185_7832.gif" alt="装饰模式结构图"></p><p>在装饰模式结构图中包含如下几个角色：</p><pre><code>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。● Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</code></pre><p>如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类</p><p><img src="http://my.csdn.net/uploads/201204/04/1333528658_9163.gif" alt="没有抽象构件类的装饰模式"></p><p>适用场景</p><pre><code>  在以下情况下可以考虑使用装饰模式：(1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</code></pre><h2 id="外观模式-Facade-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】"><a href="#外观模式-Facade-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】" class="headerlink" title="外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】"></a>外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】</h2><p>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</p><pre><code>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</code></pre><p><img src="http://img.my.csdn.net/uploads/201212/04/1354636733_5965.jpg" alt="外观模式结构图"></p><p>外观模式包含如下两个角色：</p><pre><code>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</code></pre><p>模式适用场景<br>       在以下情况下可以考虑使用外观模式：</p><pre><code>(1) 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。(2) 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。(3) 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</code></pre><h2 id="享元模式-Flyweight-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"><a href="#享元模式-Flyweight-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】" class="headerlink" title="享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"></a>享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】</h2><p>享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。</p><pre><code>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201206/15/1339770628_5970.jpg" alt="享元模式结构图"></p><p>在享元模式结构图中包含如下几个角色：</p><pre><code>● Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。● ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。● UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。● FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</code></pre><p>标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式</p><p><img src="http://my.csdn.net/uploads/201206/15/1339772995_2995.jpg" alt="单纯享元模式结构图"></p><p><img src="http://my.csdn.net/uploads/201206/15/1339773003_5870.jpg" alt="复合享元模式结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用享元模式：(1) 一个系统有大量相同或者相似的对象，造成内存的大量耗费。(2) 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。(3) 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</code></pre><h2 id="代理模式-Proxy-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#代理模式-Proxy-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"></a>代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】</h2><p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理、智能引用代理等，它们应用于不同的场合，满足用户的不同需求。</p><pre><code>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</code></pre><p><img src="http://img.my.csdn.net/uploads/201211/26/1353942400_6301.jpg" alt=" 代理模式结构图"></p><p>代理模式包含如下三个角色：</p><pre><code>(1) Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。(2) Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。(3) RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</code></pre><p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p><pre><code>(1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。(2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。(3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。(4) 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。(5) 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</code></pre><p>模式适用场景<br>       代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：</p><pre><code>(1) 当客户端对象需要访问远程主机中的对象时可以使用远程代理。(2) 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。(3) 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。(4) 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。(5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</code></pre><h1 id="十一个行为型模式"><a href="#十一个行为型模式" class="headerlink" title="十一个行为型模式"></a>十一个行为型模式</h1><h2 id="职责链模式-Chain-of-Responsibility-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"><a href="#职责链模式-Chain-of-Responsibility-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】" class="headerlink" title="职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"></a>职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】</h2><pre><code>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/02/1333307613_2407.gif" alt=""></p><p>在职责链模式结构图中包含如下几个角色：</p><pre><code>● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。● ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</code></pre><p>职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用职责链模式： (1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 (2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。  (3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </code></pre><h2 id="命令模式-Command-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#命令模式-Command-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 ##\"></a>命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 ##\</h2><pre><code>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</code></pre><p><img src="http://img.my.csdn.net/uploads/201304/15/1366033467_9048.jpg" alt="命令模式结构图"></p><p>在命令模式结构图中包含如下几个角色：</p><pre><code>● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</code></pre><p>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。</p><p>有时候我们需要将多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，我们可以通过命令队列来实现。</p><p>在命令模式中，我们可以通过调用一个命令对象的execute()方法来实现对请求的处理，如果需要撤销(Undo)请求，可通过在命令类中增加一个逆向操作来实现。</p><p>除了通过一个逆向操作来实现撤销(Undo)外，还可以通过保存对象的历史状态来实现撤销，后者可使用备忘录模式(Memento Pattern)来实现。</p><p>请求日志<br>       请求日志就是将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件、Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，常用功能如下：</p><pre><code>(1) “天有不测风云”，一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态；(2) 请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列；(3) 可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取请求日志文件，再继续执行文件中剩余的命令即可。</code></pre><p>宏命令<br>       宏命令(Macro Command)又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</p><p><img src="http://img.my.csdn.net/uploads/201304/15/1366041322_3439.jpg" alt="宏命令结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用命令模式： (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 (4) 系统需要将一组操作组合在一起形成宏命令。</code></pre><h2 id="解释器模式-Interpreter-Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】"><a href="#解释器模式-Interpreter-Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】" class="headerlink" title="解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】"></a>解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】</h2><p><img src="http://my.csdn.net/uploads/201207/03/1341331162_2919.jpg" alt="抽象语法树示意图"></p><p>在该抽象语法树中，可以通过终结符表达式value和非终结符表达式operation组成复杂的语句，每个文法规则的语言实例都可以表示为一个抽象语法树，即每一条具体的语句都可以用类似上图所示的抽象语法树来表示，在图中终结符表达式类的实例作为树的叶子节点，而非终结符表达式类的实例作为非叶子节点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子节点。抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。</p><pre><code>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</code></pre><p> 由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素</p><p><img src="http://my.csdn.net/uploads/201207/04/1341331467_7271.jpg" alt="解释器模式结构图"></p><p>在解释器模式结构图中包含如下几个角色：</p><pre><code>● AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。● TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。● NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。● Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</code></pre><p> 在解释器模式中，环境类Context用于存储解释器之外的一些全局信息，它通常作为参数被传递到所有表达式的解释方法interpret()中，可以在Context对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外还可以在Context中增加一些所有表达式解释器都共有的功能，减轻解释器的职责。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用解释器模式：(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。(2) 一些重复出现的问题可以用一种简单的语言来进行表达。(3) 一个语言的文法较为简单。(4) 执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】</code></pre><h2 id="迭代器模式-Iterator-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"><a href="#迭代器模式-Iterator-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】" class="headerlink" title="迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"></a>迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】</h2><p>将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，无须暴露聚合类的内部属性即可对其进行操作，而这正是迭代器模式的意图所在。</p><p> 在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。</p><pre><code>迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</code></pre><p><img src="https://img-blog.csdn.net/20130815225537578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="迭代器模式结构图"></p><p>在迭代器模式结构图中包含如下几个角色：</p><pre><code>● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</code></pre><p>需要注意的是抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法都提供声明，另一方面又不能包含太多方法，接口中方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避免之后修改接口。</p><p>除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，我们还可以将迭代器类设计为聚合类的内部类</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用迭代器模式：(1) 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。(2) 需要为一个聚合对象提供多种遍历方式。(3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</code></pre><h2 id="中介者模式-Mediator-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"><a href="#中介者模式-Mediator-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】" class="headerlink" title="中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"></a>中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】</h2><pre><code>中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</code></pre><p><img src="http://img.my.csdn.net/uploads/201301/08/1357651874_7064.jpg" alt="中介者模式结构图"></p><p>在中介者模式结构图中包含如下几个角色：</p><pre><code>● Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。● ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。● Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。● ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</code></pre><p>中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：</p><pre><code> (1) 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。(2) 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</code></pre><p>在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需要修改少许代码（如果引入配置文件的话有时可以不修改任何代码）就可以实现中介者的更换。</p><p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用中介者模式：(1) 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。(2) 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。(3) 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</code></pre><h2 id="备忘录模式-Memento-Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】"><a href="#备忘录模式-Memento-Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】" class="headerlink" title="备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】"></a>备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】</h2><pre><code>备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</code></pre><p><img src="http://my.csdn.net/uploads/201205/02/1335891550_5966.jpg" alt=""></p><p>在备忘录模式结构图中包含如下几个角色：</p><pre><code>● Originator（原发器）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。●Memento（备忘录)：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。●Caretaker（负责人）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</code></pre><p>在设计备忘录类时需要考虑其封装性，除了Originator类，不允许其他类来调用备忘录类Memento的构造函数与相关方法，如果不考虑封装性，允许其他类调用setState()等方法，将导致在备忘录中保存的历史状态发生改变，通过撤销操作所恢复的状态就不再是真实的历史状态，备忘录模式也就失去了本身的意义。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用备忘录模式：(1)保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。(2)防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</code></pre><h2 id="观察者模式-Observer-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"><a href="#观察者模式-Observer-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】" class="headerlink" title="观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"></a>观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】</h2><pre><code>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201207/05/1341501815_4830.jpg" alt="观察者模式结构图"></p><p>在观察者模式结构图中包含如下几个角色：</p><pre><code>● Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。● ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。● ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</code></pre><p>在有些更加复杂的情况下，具体观察者类ConcreteObserver的update()方法在执行时需要使用到具体目标类ConcreteSubject中的状态（属性），因此在ConcreteObserver与ConcreteSubject之间有时候还存在关联或依赖关系，在ConcreteObserver中定义一个ConcreteSubject实例，通过该实例获取存储在ConcreteSubject中的状态。如果ConcreteObserver的update()方法不需要使用到ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。如果在具体层具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违反了“开闭原则”，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。</p><p>观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用观察者模式：(1) 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。(2) 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。(3) 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</code></pre><h2 id="状态模式-State-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#状态模式-State-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。</p><pre><code>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</code></pre><p><img src="http://img.my.csdn.net/uploads/201301/20/1358693242_5100.jpg" alt="状态模式结构图"></p><p>在状态模式结构图中包含如下几个角色：</p><pre><code>● Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。● State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。● ConcreteState（具体状态类）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</code></pre><p>环境类实际上是真正拥有状态的对象，我们只是将环境类中与状态有关的代码提取出来封装到专门的状态类中。在状态模式结构图中，环境类Context与抽象状态类State之间存在单向关联关系，在Context中定义了一个State对象。在实际使用时，它们之间可能存在更为复杂的关系，State与Context之间可能也存在依赖或者关联关系。</p><p>在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式：</p><pre><code>(1) 统一由环境类来负责状态之间的转换，此时，环境类还充当了状态管理器(State Manager)角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换 (2) 由具体状态类来负责状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性值再根据情况为环境类设置新的状态对象，实现状态转换，同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间就将存在依赖或关联关系，因为状态类需要访问环境类中的属性值</code></pre><p>在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。</p><p>在状态模式中实现状态转换时，具体状态类可通过调用环境类Context的setState()方法进行状态的转换操作，也可以统一由环境类Context来实现状态的转换。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用状态模式：(1) 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。(2) 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</code></pre><h2 id="策略模式-Strategy-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"><a href="#策略模式-Strategy-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】" class="headerlink" title="策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"></a>策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】</h2><p>在软件开发中，我们也常常会遇到类似的情况，实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开</p><pre><code>策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201208/01/1343811032_3729.jpg" alt=""></p><p>在策略模式结构图中包含如下几个角色：</p><pre><code>● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用策略模式：(1) 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。(2) 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。(3) 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</code></pre><h2 id="模板方法模式-Template-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"><a href="#模板方法模式-Template-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】" class="headerlink" title="模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"></a>模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】</h2><pre><code>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</code></pre><p>模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p><p><img src="http://img.my.csdn.net/uploads/201212/15/1355576024_5664.jpg" alt="模板方法模式结构图"></p><p>模板方法模式包含如下两个角色：</p><pre><code>(1) AbstractClass（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。(2) ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</code></pre><ol><li><p>模板方法</p><pre><code>一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。</code></pre></li><li><p>基本方法</p><pre><code>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。(1) 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。在C#语言里一个抽象方法以abstract关键字标识。(2) 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。(3) 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现（可使用virtual关键字将其定义为虚函数），并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。</code></pre></li></ol><p>模式适用场景<br>       在以下情况下可以考虑使用模板方法模式：</p><pre><code>(1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</code></pre><h2 id="访问者模式-Visitor-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"><a href="#访问者模式-Visitor-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】" class="headerlink" title="访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"></a>访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】</h2><p>访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。</p><p>在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。</p><pre><code>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</code></pre><p><img src="http://my.csdn.net/uploads/201204/06/1333713874_7112.gif" alt=""></p><p>在访问者模式结构图中包含如下几个角色：</p><pre><code>●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。【稍后将介绍为什么要这样设计。】●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。</code></pre><p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</p><p>在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementA elementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，则可以将操作代码移到抽象访问者类中</p><p><img src="http://my.csdn.net/uploads/201204/06/1333715011_8778.gif" alt=""></p><p>适用场景</p><pre><code>  在以下情况下可以考虑使用访问者模式：(1) 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。(2) 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。(3) 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lovelion/article/details/17517213&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;史上最全设计模式导学目录（完整版）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;设计模式概述
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="设计模式" scheme="https://caojingyou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="笔记" scheme="https://caojingyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>自动构建</title>
    <link href="https://caojingyou.github.io/2018/05/07/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    <id>https://caojingyou.github.io/2018/05/07/自动构建/</id>
    <published>2018-05-07T01:47:00.000Z</published>
    <updated>2018-05-07T01:51:08.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p><a href="https://caojingyou.github.io/2018/03/02/Jenkins/" title="https://caojingyou.github.io/2018/03/02/Jenkins/">https://caojingyou.github.io/2018/03/02/Jenkins/</a></p><h1 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a>MSBuild</h1><p><a href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++">https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/</a>/ “<a href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/">https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/</a>“)</p><h1 id="CCNET"><a href="#CCNET" class="headerlink" title="CCNET"></a>CCNET</h1><p><a href="http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/" title="http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/" target="_blank" rel="noopener">http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/</a></p><p><a href="http://www.cnblogs.com/hnlong1/p/4664978.html" title="http://www.cnblogs.com/hnlong1/p/4664978.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnlong1/p/4664978.html</a></p><p><a href="http://www.mamicode.com/info-detail-1690848.html" title="http://www.mamicode.com/info-detail-1690848.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1690848.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Jenkins&quot;&gt;&lt;/a&gt;Jenkins&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://caojingyou.github.io/2018/03/02/J
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MSBuild" scheme="https://caojingyou.github.io/tags/MSBuild/"/>
    
      <category term="Jenkins" scheme="https://caojingyou.github.io/tags/Jenkins/"/>
    
      <category term="自动构建" scheme="https://caojingyou.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="CCNET" scheme="https://caojingyou.github.io/tags/CCNET/"/>
    
  </entry>
  
  <entry>
    <title>linux下C开发</title>
    <link href="https://caojingyou.github.io/2018/05/02/linux%E4%B8%8BC%E5%BC%80%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/05/02/linux下C开发/</id>
    <published>2018-05-02T10:09:00.000Z</published>
    <updated>2018-05-02T10:13:56.655Z</updated>
    
    <content type="html"><![CDATA[<p>CodeBlocks跨平台</p><p>make是用来完成自动编译的工具</p><p>gcc/g++/gcc port/g++ port</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CodeBlocks跨平台&lt;/p&gt;
&lt;p&gt;make是用来完成自动编译的工具&lt;/p&gt;
&lt;p&gt;gcc/g++/gcc port/g++ port&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="linux" scheme="https://caojingyou.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++单元测试</title>
    <link href="https://caojingyou.github.io/2018/05/02/C++%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://caojingyou.github.io/2018/05/02/C++单元测试/</id>
    <published>2018-05-02T09:03:00.000Z</published>
    <updated>2018-05-09T07:26:59.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cppunit"><a href="#cppunit" class="headerlink" title="cppunit"></a>cppunit</h1><p><a href="https://caojingyou.github.io/2018/01/18/cppunit/" title="https://caojingyou.github.io/2018/01/18/cppunit/">https://caojingyou.github.io/2018/01/18/cppunit/</a></p><h1 id="CppUTest"><a href="#CppUTest" class="headerlink" title="CppUTest"></a>CppUTest</h1><p><a href="http://cpputest.github.io/" title="http://cpputest.github.io/" target="_blank" rel="noopener">http://cpputest.github.io/</a></p><p><a href="https://github.com/cpputest/cpputest" title="https://github.com/cpputest/cpputest" target="_blank" rel="noopener">https://github.com/cpputest/cpputest</a></p><h1 id="Google-Test-与-Google-Mock"><a href="#Google-Test-与-Google-Mock" class="headerlink" title="Google Test 与  Google Mock"></a>Google Test 与  Google Mock</h1><p><a href="https://github.com/google/googletest" title="https://github.com/google/googletest" target="_blank" rel="noopener">https://github.com/google/googletest</a></p><p><a href="https://code/google.com/p/googlemock/" target="_blank" rel="noopener">https://code/google.com/p/googlemock/</a></p><h2 id="Google-Test"><a href="#Google-Test" class="headerlink" title="Google Test"></a>Google Test</h2><p><a href="https://www.cnblogs.com/jycboy/p/6057677.html" title="https://www.cnblogs.com/jycboy/p/6057677.html" target="_blank" rel="noopener">https://www.cnblogs.com/jycboy/p/6057677.html</a></p><p><a href="https://segmentfault.com/a/1190000002454946" title="https://segmentfault.com/a/1190000002454946" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002454946</a></p><p><a href="http://developer.51cto.com/art/201108/285290.htm" title="http://developer.51cto.com/art/201108/285290.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201108/285290.htm</a></p><p><a href="http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html" title="http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html" target="_blank" rel="noopener">http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html</a></p><h3 id="simple代码"><a href="#simple代码" class="headerlink" title="simple代码:"></a>simple代码:</h3><pre><code>#ifndef GTEST_SAMPLES_PRIME_TABLES_H_#define GTEST_SAMPLES_PRIME_TABLES_H_#include &lt;algorithm&gt;// The prime table interface.class PrimeTable { public:  virtual ~PrimeTable() {}  // Returns true iff n is a prime number.  virtual bool IsPrime(int n) const = 0;  // Returns the smallest prime number greater than p; or returns -1  // if the next prime is beyond the capacity of the table.  virtual int GetNextPrime(int p) const = 0;};// Implementation #1 calculates the primes on-the-fly.class OnTheFlyPrimeTable : public PrimeTable { public:  virtual bool IsPrime(int n) const {    if (n &lt;= 1) return false;    for (int i = 2; i*i &lt;= n; i++) {      // n is divisible by an integer other than 1 and itself.      if ((n % i) == 0) return false;    }    return true;  }  virtual int GetNextPrime(int p) const {    for (int n = p + 1; n &gt; 0; n++) {      if (IsPrime(n)) return n;    }    return -1;  }};// Implementation #2 pre-calculates the primes and stores the result// in an array.class PreCalculatedPrimeTable : public PrimeTable { public:  // &apos;max&apos; specifies the maximum number the prime table holds.  explicit PreCalculatedPrimeTable(int max)      : is_prime_size_(max + 1), is_prime_(new bool[max + 1]) {    CalculatePrimesUpTo(max);  }  virtual ~PreCalculatedPrimeTable() { delete[] is_prime_; }  virtual bool IsPrime(int n) const {    return 0 &lt;= n &amp;&amp; n &lt; is_prime_size_ &amp;&amp; is_prime_[n];  }  virtual int GetNextPrime(int p) const {    for (int n = p + 1; n &lt; is_prime_size_; n++) {      if (is_prime_[n]) return n;    }    return -1;  } private:  void CalculatePrimesUpTo(int max) {    ::std::fill(is_prime_, is_prime_ + is_prime_size_, true);    is_prime_[0] = is_prime_[1] = false;    for (int i = 2; i &lt;= max; i++) {      if (!is_prime_[i]) continue;      // Marks all multiples of i (except i itself) as non-prime.      for (int j = 2*i; j &lt;= max; j += i) {        is_prime_[j] = false;      }    }  }  const int is_prime_size_;  bool* const is_prime_;  // Disables compiler warning &quot;assignment operator could not be generated.&quot;  void operator=(const PreCalculatedPrimeTable&amp; rhs);};#endif  // GTEST_SAMPLES_PRIME_TABLES_H_#ifndef GTEST_SAMPLES_SAMPLE1_H_#define GTEST_SAMPLES_SAMPLE1_H_// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.int Factorial(int n);// Returns true iff n is a prime number.bool IsPrime(int n);#endif  // GTEST_SAMPLES_SAMPLE1_H_#include &quot;sample1.h&quot;// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.int Factorial(int n) {  int result = 1;  for (int i = 1; i &lt;= n; i++) {    result *= i;  }  return result;}// Returns true iff n is a prime number.bool IsPrime(int n) {  // Trivial case 1: small numbers  if (n &lt;= 1) return false;  // Trivial case 2: even numbers  if (n % 2 == 0) return n == 2;  // Now, we have that n is odd and n &gt;= 3.  // Try to divide n by every odd number i, starting from 3  for (int i = 3; ; i += 2) {    // We only have to try i up to the squre root of n    if (i &gt; n/i) break;    // Now, we have i &lt;= n/i &lt; n.    // If n is divisible by i, n is not prime.    if (n % i == 0) return false;  }  // n has no integer factor in the range (1, n), and thus is prime.  return true;}// This sample shows how to write a simple unit test for a function,// using Google C++ testing framework.//// Writing a unit test using Google C++ testing framework is easy as 1-2-3:// Step 1. Include necessary header files such that the stuff your// test logic needs is declared.//// Don&apos;t forget gtest.h, which declares the testing framework.#include &lt;limits.h&gt;#include &quot;sample1.h&quot;#include &quot;gtest/gtest.h&quot;// Step 2. Use the TEST macro to define your tests.//// TEST has two parameters: the test case name and the test name.// After using the macro, you should define your test logic between a// pair of braces.  You can use a bunch of macros to indicate the// success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are// examples of such macros.  For a complete list, see gtest.h.//// &lt;TechnicalDetails&gt;//// In Google Test, tests are grouped into test cases.  This is how we// keep test code organized.  You should put logically related tests// into the same test case.//// The test case name and the test name should both be valid C++// identifiers.  And you should not use underscore (_) in the names.//// Google Test guarantees that each test you define is run exactly// once, but it makes no guarantee on the order the tests are// executed.  Therefore, you should write your tests in such a way// that their results don&apos;t depend on their order.//// &lt;/TechnicalDetails&gt;// Tests Factorial().// Tests factorial of negative numbers.TEST(FactorialTest, Negative) {  // This test is named &quot;Negative&quot;, and belongs to the &quot;FactorialTest&quot;  // test case.  EXPECT_EQ(1, Factorial(-5));  EXPECT_EQ(1, Factorial(-1));  EXPECT_GT(Factorial(-10), 0);  // &lt;TechnicalDetails&gt;  //  // EXPECT_EQ(expected, actual) is the same as  //  //   EXPECT_TRUE((expected) == (actual))  //  // except that it will print both the expected value and the actual  // value when the assertion fails.  This is very helpful for  // debugging.  Therefore in this case EXPECT_EQ is preferred.  //  // On the other hand, EXPECT_TRUE accepts any Boolean expression,  // and is thus more general.  //  // &lt;/TechnicalDetails&gt;}// Tests factorial of 0.TEST(FactorialTest, Zero) {  EXPECT_EQ(1, Factorial(0));}// Tests factorial of positive numbers.TEST(FactorialTest, Positive) {  EXPECT_EQ(1, Factorial(1));  EXPECT_EQ(2, Factorial(2));  EXPECT_EQ(6, Factorial(3));  EXPECT_EQ(40320, Factorial(8));}// Tests IsPrime()// Tests negative input.TEST(IsPrimeTest, Negative) {  // This test belongs to the IsPrimeTest test case.  EXPECT_FALSE(IsPrime(-1));  EXPECT_FALSE(IsPrime(-2));  EXPECT_FALSE(IsPrime(INT_MIN));}// Tests some trivial cases.TEST(IsPrimeTest, Trivial) {  EXPECT_FALSE(IsPrime(0));  EXPECT_FALSE(IsPrime(1));  EXPECT_TRUE(IsPrime(2));  EXPECT_TRUE(IsPrime(3));}// Tests positive input.TEST(IsPrimeTest, Positive) {  EXPECT_FALSE(IsPrime(4));  EXPECT_TRUE(IsPrime(5));  EXPECT_FALSE(IsPrime(6));  EXPECT_TRUE(IsPrime(23));}// Step 3. Call RUN_ALL_TESTS() in main().//// We do this by linking in src/gtest_main.cc file, which consists of// a main() function which calls RUN_ALL_TESTS() for us.//// This runs all the tests you&apos;ve defined, prints the result, and// returns 0 if successful, or 1 otherwise.//// Did you notice that we didn&apos;t register the tests?  The// RUN_ALL_TESTS() macro magically knows about all the tests we// defined.  Isn&apos;t this convenient?#ifndef GTEST_SAMPLES_SAMPLE2_H_#define GTEST_SAMPLES_SAMPLE2_H_#include &lt;string.h&gt;// A simple string class.class MyString { private:  const char* c_string_;  const MyString&amp; operator=(const MyString&amp; rhs); public:  // Clones a 0-terminated C string, allocating memory using new.  static const char* CloneCString(const char* a_c_string);  ////////////////////////////////////////////////////////////  //  // C&apos;tors  // The default c&apos;tor constructs a NULL string.  MyString() : c_string_(NULL) {}  // Constructs a MyString by cloning a 0-terminated C string.  explicit MyString(const char* a_c_string) : c_string_(NULL) {    Set(a_c_string);  }  // Copy c&apos;tor  MyString(const MyString&amp; string) : c_string_(NULL) {    Set(string.c_string_);  }  ////////////////////////////////////////////////////////////  //  // D&apos;tor.  MyString is intended to be a final class, so the d&apos;tor  // doesn&apos;t need to be virtual.  ~MyString() { delete[] c_string_; }  // Gets the 0-terminated C string this MyString object represents.  const char* c_string() const { return c_string_; }  size_t Length() const {    return c_string_ == NULL ? 0 : strlen(c_string_);  }  // Sets the 0-terminated C string this MyString object represents.  void Set(const char* c_string);};#endif  // GTEST_SAMPLES_SAMPLE2_H_#include &quot;sample2.h&quot;#include &lt;string.h&gt;// Clones a 0-terminated C string, allocating memory using new.const char* MyString::CloneCString(const char* a_c_string) {  if (a_c_string == NULL) return NULL;  const size_t len = strlen(a_c_string);  char* const clone = new char[ len + 1 ];  memcpy(clone, a_c_string, len + 1);  return clone;}// Sets the 0-terminated C string this MyString object// represents.void MyString::Set(const char* a_c_string) {  // Makes sure this works when c_string == c_string_  const char* const temp = MyString::CloneCString(a_c_string);  delete[] c_string_;  c_string_ = temp;}// This sample shows how to write a more complex unit test for a class// that has multiple member functions.//// Usually, it&apos;s a good idea to have one test for each method in your// class.  You don&apos;t have to do that exactly, but it helps to keep// your tests organized.  You may also throw in additional tests as// needed.#include &quot;sample2.h&quot;#include &quot;gtest/gtest.h&quot;// In this example, we test the MyString class (a simple string).// Tests the default c&apos;tor.TEST(MyString, DefaultConstructor) {  const MyString s;  // Asserts that s.c_string() returns NULL.  //  // &lt;TechnicalDetails&gt;  //  // If we write NULL instead of  //  //   static_cast&lt;const char *&gt;(NULL)  //  // in this assertion, it will generate a warning on gcc 3.4.  The  // reason is that EXPECT_EQ needs to know the types of its  // arguments in order to print them when it fails.  Since NULL is  // #defined as 0, the compiler will use the formatter function for  // int to print it.  However, gcc thinks that NULL should be used as  // a pointer, not an int, and therefore complains.  //  // The root of the problem is C++&apos;s lack of distinction between the  // integer number 0 and the null pointer constant.  Unfortunately,  // we have to live with this fact.  //  // &lt;/TechnicalDetails&gt;  EXPECT_STREQ(NULL, s.c_string());  EXPECT_EQ(0u, s.Length());}const char kHelloString[] = &quot;Hello, world!&quot;;// Tests the c&apos;tor that accepts a C string.TEST(MyString, ConstructorFromCString) {  const MyString s(kHelloString);  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1,            s.Length());}// Tests the copy c&apos;tor.TEST(MyString, CopyConstructor) {  const MyString s1(kHelloString);  const MyString s2 = s1;  EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString));}// Tests the Set method.TEST(MyString, Set) {  MyString s;  s.Set(kHelloString);  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  // Set should work when the input pointer is the same as the one  // already in the MyString object.  s.Set(s.c_string());  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  // Can we set the MyString to NULL?  s.Set(NULL);  EXPECT_STREQ(NULL, s.c_string());}#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_#define GTEST_SAMPLES_SAMPLE3_INL_H_#include &lt;stddef.h&gt;// Queue is a simple queue implemented as a singled-linked list.//// The element type must support copy constructor.template &lt;typename E&gt;  // E is the element typeclass Queue;// QueueNode is a node in a Queue, which consists of an element of// type E and a pointer to the next node.template &lt;typename E&gt;  // E is the element typeclass QueueNode {  friend class Queue&lt;E&gt;; public:  // Gets the element in this node.  const E&amp; element() const { return element_; }  // Gets the next node in the queue.  QueueNode* next() { return next_; }  const QueueNode* next() const { return next_; } private:  // Creates a node with a given element value.  The next pointer is  // set to NULL.  explicit QueueNode(const E&amp; an_element) : element_(an_element), next_(NULL) {}  // We disable the default assignment operator and copy c&apos;tor.  const QueueNode&amp; operator = (const QueueNode&amp;);  QueueNode(const QueueNode&amp;);  E element_;  QueueNode* next_;};template &lt;typename E&gt;  // E is the element type.class Queue { public:  // Creates an empty queue.  Queue() : head_(NULL), last_(NULL), size_(0) {}  // D&apos;tor.  Clears the queue.  ~Queue() { Clear(); }  // Clears the queue.  void Clear() {    if (size_ &gt; 0) {      // 1. Deletes every node.      QueueNode&lt;E&gt;* node = head_;      QueueNode&lt;E&gt;* next = node-&gt;next();      for (; ;) {        delete node;        node = next;        if (node == NULL) break;        next = node-&gt;next();      }      // 2. Resets the member variables.      head_ = last_ = NULL;      size_ = 0;    }  }  // Gets the number of elements.  size_t Size() const { return size_; }  // Gets the first element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Head() { return head_; }  const QueueNode&lt;E&gt;* Head() const { return head_; }  // Gets the last element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Last() { return last_; }  const QueueNode&lt;E&gt;* Last() const { return last_; }  // Adds an element to the end of the queue.  A copy of the element is  // created using the copy constructor, and then stored in the queue.  // Changes made to the element in the queue doesn&apos;t affect the source  // object, and vice versa.  void Enqueue(const E&amp; element) {    QueueNode&lt;E&gt;* new_node = new QueueNode&lt;E&gt;(element);    if (size_ == 0) {      head_ = last_ = new_node;      size_ = 1;    } else {      last_-&gt;next_ = new_node;      last_ = new_node;      size_++;    }  }  // Removes the head of the queue and returns it.  Returns NULL if  // the queue is empty.  E* Dequeue() {    if (size_ == 0) {      return NULL;    }    const QueueNode&lt;E&gt;* const old_head = head_;    head_ = head_-&gt;next_;    size_--;    if (size_ == 0) {      last_ = NULL;    }    E* element = new E(old_head-&gt;element());    delete old_head;    return element;  }  // Applies a function/functor on each element of the queue, and  // returns the result in a new queue.  The original queue is not  // affected.  template &lt;typename F&gt;  Queue* Map(F function) const {    Queue* new_queue = new Queue();    for (const QueueNode&lt;E&gt;* node = head_; node != NULL; node = node-&gt;next_) {      new_queue-&gt;Enqueue(function(node-&gt;element()));    }    return new_queue;  } private:  QueueNode&lt;E&gt;* head_;  // The first node of the queue.  QueueNode&lt;E&gt;* last_;  // The last node of the queue.  size_t size_;  // The number of elements in the queue.  // We disallow copying a queue.  Queue(const Queue&amp;);  const Queue&amp; operator = (const Queue&amp;);};#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_#define GTEST_SAMPLES_SAMPLE3_INL_H_#include &lt;stddef.h&gt;// Queue is a simple queue implemented as a singled-linked list.//// The element type must support copy constructor.template &lt;typename E&gt;  // E is the element typeclass Queue;// QueueNode is a node in a Queue, which consists of an element of// type E and a pointer to the next node.template &lt;typename E&gt;  // E is the element typeclass QueueNode {  friend class Queue&lt;E&gt;; public:  // Gets the element in this node.  const E&amp; element() const { return element_; }  // Gets the next node in the queue.  QueueNode* next() { return next_; }  const QueueNode* next() const { return next_; } private:  // Creates a node with a given element value.  The next pointer is  // set to NULL.  explicit QueueNode(const E&amp; an_element) : element_(an_element), next_(NULL) {}  // We disable the default assignment operator and copy c&apos;tor.  const QueueNode&amp; operator = (const QueueNode&amp;);  QueueNode(const QueueNode&amp;);  E element_;  QueueNode* next_;};template &lt;typename E&gt;  // E is the element type.class Queue { public:  // Creates an empty queue.  Queue() : head_(NULL), last_(NULL), size_(0) {}  // D&apos;tor.  Clears the queue.  ~Queue() { Clear(); }  // Clears the queue.  void Clear() {    if (size_ &gt; 0) {      // 1. Deletes every node.      QueueNode&lt;E&gt;* node = head_;      QueueNode&lt;E&gt;* next = node-&gt;next();      for (; ;) {        delete node;        node = next;        if (node == NULL) break;        next = node-&gt;next();      }      // 2. Resets the member variables.      head_ = last_ = NULL;      size_ = 0;    }  }  // Gets the number of elements.  size_t Size() const { return size_; }  // Gets the first element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Head() { return head_; }  const QueueNode&lt;E&gt;* Head() const { return head_; }  // Gets the last element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Last() { return last_; }  const QueueNode&lt;E&gt;* Last() const { return last_; }  // Adds an element to the end of the queue.  A copy of the element is  // created using the copy constructor, and then stored in the queue.  // Changes made to the element in the queue doesn&apos;t affect the source  // object, and vice versa.  void Enqueue(const E&amp; element) {    QueueNode&lt;E&gt;* new_node = new QueueNode&lt;E&gt;(element);    if (size_ == 0) {      head_ = last_ = new_node;      size_ = 1;    } else {      last_-&gt;next_ = new_node;      last_ = new_node;      size_++;    }  }  // Removes the head of the queue and returns it.  Returns NULL if  // the queue is empty.  E* Dequeue() {    if (size_ == 0) {      return NULL;    }    const QueueNode&lt;E&gt;* const old_head = head_;    head_ = head_-&gt;next_;    size_--;    if (size_ == 0) {      last_ = NULL;    }    E* element = new E(old_head-&gt;element());    delete old_head;    return element;  }  // Applies a function/functor on each element of the queue, and  // returns the result in a new queue.  The original queue is not  // affected.  template &lt;typename F&gt;  Queue* Map(F function) const {    Queue* new_queue = new Queue();    for (const QueueNode&lt;E&gt;* node = head_; node != NULL; node = node-&gt;next_) {      new_queue-&gt;Enqueue(function(node-&gt;element()));    }    return new_queue;  } private:  QueueNode&lt;E&gt;* head_;  // The first node of the queue.  QueueNode&lt;E&gt;* last_;  // The last node of the queue.  size_t size_;  // The number of elements in the queue.  // We disallow copying a queue.  Queue(const Queue&amp;);  const Queue&amp; operator = (const Queue&amp;);};#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_#ifndef GTEST_SAMPLES_SAMPLE4_H_#define GTEST_SAMPLES_SAMPLE4_H_// A simple monotonic counter.class Counter { private:  int counter_; public:  // Creates a counter that starts at 0.  Counter() : counter_(0) {}  // Returns the current counter value, and increments it.  int Increment();  // Prints the current counter value to STDOUT.  void Print() const;};#endif  // GTEST_SAMPLES_SAMPLE4_H_#include &lt;stdio.h&gt;#include &quot;sample4.h&quot;// Returns the current counter value, and increments it.int Counter::Increment() {  return counter_++;}// Prints the current counter value to STDOUT.void Counter::Print() const {  printf(&quot;%d&quot;, counter_);}#include &quot;gtest/gtest.h&quot;#include &quot;sample4.h&quot;// Tests the Increment() method.TEST(Counter, Increment) {  Counter c;  // EXPECT_EQ() evaluates its arguments exactly once, so they  // can have side effects.  EXPECT_EQ(0, c.Increment());  EXPECT_EQ(1, c.Increment());  EXPECT_EQ(2, c.Increment());}// This sample teaches how to reuse a test fixture in multiple test// cases by deriving sub-fixtures from it.//// When you define a test fixture, you specify the name of the test// case that will use this fixture.  Therefore, a test fixture can// be used by only one test case.//// Sometimes, more than one test cases may want to use the same or// slightly different test fixtures.  For example, you may want to// make sure that all tests for a GUI library don&apos;t leak important// system resources like fonts and brushes.  In Google Test, you do// this by putting the shared logic in a super (as in &quot;super class&quot;)// test fixture, and then have each test case use a fixture derived// from this super fixture.#include &lt;limits.h&gt;#include &lt;time.h&gt;#include &quot;sample3-inl.h&quot;#include &quot;gtest/gtest.h&quot;#include &quot;sample1.h&quot;// In this sample, we want to ensure that every test finishes within// ~5 seconds.  If a test takes longer to run, we consider it a// failure.//// We put the code for timing a test in a test fixture called// &quot;QuickTest&quot;.  QuickTest is intended to be the super fixture that// other fixtures derive from, therefore there is no test case with// the name &quot;QuickTest&quot;.  This is OK.//// Later, we will derive multiple test fixtures from QuickTest.class QuickTest : public testing::Test { protected:  // Remember that SetUp() is run immediately before a test starts.  // This is a good place to record the start time.  virtual void SetUp() {    start_time_ = time(NULL);  }  // TearDown() is invoked immediately after a test finishes.  Here we  // check if the test was too slow.  virtual void TearDown() {    // Gets the time when the test finishes    const time_t end_time = time(NULL);    // Asserts that the test took no more than ~5 seconds.  Did you    // know that you can use assertions in SetUp() and TearDown() as    // well?    EXPECT_TRUE(end_time - start_time_ &lt;= 5) &lt;&lt; &quot;The test took too long.&quot;;  }  // The UTC time (in seconds) when the test starts  time_t start_time_;};// We derive a fixture named IntegerFunctionTest from the QuickTest// fixture.  All tests using this fixture will be automatically// required to be quick.class IntegerFunctionTest : public QuickTest {  // We don&apos;t need any more logic than already in the QuickTest fixture.  // Therefore the body is empty.};// Now we can write tests in the IntegerFunctionTest test case.// Tests Factorial()TEST_F(IntegerFunctionTest, Factorial) {  // Tests factorial of negative numbers.  EXPECT_EQ(1, Factorial(-5));  EXPECT_EQ(1, Factorial(-1));  EXPECT_GT(Factorial(-10), 0);  // Tests factorial of 0.  EXPECT_EQ(1, Factorial(0));  // Tests factorial of positive numbers.  EXPECT_EQ(1, Factorial(1));  EXPECT_EQ(2, Factorial(2));  EXPECT_EQ(6, Factorial(3));  EXPECT_EQ(40320, Factorial(8));}// Tests IsPrime()TEST_F(IntegerFunctionTest, IsPrime) {  // Tests negative input.  EXPECT_FALSE(IsPrime(-1));  EXPECT_FALSE(IsPrime(-2));  EXPECT_FALSE(IsPrime(INT_MIN));  // Tests some trivial cases.  EXPECT_FALSE(IsPrime(0));  EXPECT_FALSE(IsPrime(1));  EXPECT_TRUE(IsPrime(2));  EXPECT_TRUE(IsPrime(3));  // Tests positive input.  EXPECT_FALSE(IsPrime(4));  EXPECT_TRUE(IsPrime(5));  EXPECT_FALSE(IsPrime(6));  EXPECT_TRUE(IsPrime(23));}// The next test case (named &quot;QueueTest&quot;) also needs to be quick, so// we derive another fixture from QuickTest.//// The QueueTest test fixture has some logic and shared objects in// addition to what&apos;s in QuickTest already.  We define the additional// stuff inside the body of the test fixture, as usual.class QueueTest : public QuickTest { protected:  virtual void SetUp() {    // First, we need to set up the super fixture (QuickTest).    QuickTest::SetUp();    // Second, some additional setup for this fixture.    q1_.Enqueue(1);    q2_.Enqueue(2);    q2_.Enqueue(3);  }  // By default, TearDown() inherits the behavior of  // QuickTest::TearDown().  As we have no additional cleaning work  // for QueueTest, we omit it here.  //  // virtual void TearDown() {  //   QuickTest::TearDown();  // }  Queue&lt;int&gt; q0_;  Queue&lt;int&gt; q1_;  Queue&lt;int&gt; q2_;};// Now, let&apos;s write tests using the QueueTest fixture.// Tests the default constructor.TEST_F(QueueTest, DefaultConstructor) {  EXPECT_EQ(0u, q0_.Size());}// Tests Dequeue().TEST_F(QueueTest, Dequeue) {  int* n = q0_.Dequeue();  EXPECT_TRUE(n == NULL);  n = q1_.Dequeue();  EXPECT_TRUE(n != NULL);  EXPECT_EQ(1, *n);  EXPECT_EQ(0u, q1_.Size());  delete n;  n = q2_.Dequeue();  EXPECT_TRUE(n != NULL);  EXPECT_EQ(2, *n);  EXPECT_EQ(1u, q2_.Size());  delete n;}// If necessary, you can derive further test fixtures from a derived// fixture itself.  For example, you can derive another fixture from// QueueTest.  Google Test imposes no limit on how deep the hierarchy// can be.  In practice, however, you probably don&apos;t want it to be too// deep as to be confusing.// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: wan@google.com (Zhanyong Wan)// This sample shows how to test common properties of multiple// implementations of the same interface (aka interface tests).// The interface and its implementations are in this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;// First, we define some factory functions for creating instances of// the implementations.  You may be able to skip this step if all your// implementations can be constructed the same way.template &lt;class T&gt;PrimeTable* CreatePrimeTable();template &lt;&gt;PrimeTable* CreatePrimeTable&lt;OnTheFlyPrimeTable&gt;() {  return new OnTheFlyPrimeTable;}template &lt;&gt;PrimeTable* CreatePrimeTable&lt;PreCalculatedPrimeTable&gt;() {  return new PreCalculatedPrimeTable(10000);}// Then we define a test fixture class template.template &lt;class T&gt;class PrimeTableTest : public testing::Test { protected:  // The ctor calls the factory function to create a prime table  // implemented by T.  PrimeTableTest() : table_(CreatePrimeTable&lt;T&gt;()) {}  virtual ~PrimeTableTest() { delete table_; }  // Note that we test an implementation via the base interface  // instead of the actual implementation class.  This is important  // for keeping the tests close to the real world scenario, where the  // implementation is invoked via the base interface.  It avoids  // got-yas where the implementation class has a method that shadows  // a method with the same name (but slightly different argument  // types) in the base interface, for example.  PrimeTable* const table_;};#if GTEST_HAS_TYPED_TESTusing testing::Types;// Google Test offers two ways for reusing tests for different types.// The first is called &quot;typed tests&quot;.  You should use it if you// already know *all* the types you are gonna exercise when you write// the tests.// To write a typed test case, first use////   TYPED_TEST_CASE(TestCaseName, TypeList);//// to declare it and specify the type parameters.  As with TEST_F,// TestCaseName must match the test fixture name.// The list of types we want to test.typedef Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt; Implementations;TYPED_TEST_CASE(PrimeTableTest, Implementations);// Then use TYPED_TEST(TestCaseName, TestName) to define a typed test,// similar to TEST_F.TYPED_TEST(PrimeTableTest, ReturnsFalseForNonPrimes) {  // Inside the test body, you can refer to the type parameter by  // TypeParam, and refer to the fixture class by TestFixture.  We  // don&apos;t need them in this example.  // Since we are in the template world, C++ requires explicitly  // writing &apos;this-&gt;&apos; when referring to members of the fixture class.  // This is something you have to learn to live with.  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(-5));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(0));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(1));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(4));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(6));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(100));}TYPED_TEST(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(2));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(3));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(5));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(7));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(11));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(131));}TYPED_TEST(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, this-&gt;table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, this-&gt;table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, this-&gt;table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, this-&gt;table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, this-&gt;table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, this-&gt;table_-&gt;GetNextPrime(128));}// That&apos;s it!  Google Test will repeat each TYPED_TEST for each type// in the type list specified in TYPED_TEST_CASE.  Sit back and be// happy that you don&apos;t have to define them multiple times.#endif  // GTEST_HAS_TYPED_TEST#if GTEST_HAS_TYPED_TEST_Pusing testing::Types;// Sometimes, however, you don&apos;t yet know all the types that you want// to test when you write the tests.  For example, if you are the// author of an interface and expect other people to implement it, you// might want to write a set of tests to make sure each implementation// conforms to some basic requirements, but you don&apos;t know what// implementations will be written in the future.//// How can you write the tests without committing to the type// parameters?  That&apos;s what &quot;type-parameterized tests&quot; can do for you.// It is a bit more involved than typed tests, but in return you get a// test pattern that can be reused in many contexts, which is a big// win.  Here&apos;s how you do it:// First, define a test fixture class template.  Here we just reuse// the PrimeTableTest fixture defined earlier:template &lt;class T&gt;class PrimeTableTest2 : public PrimeTableTest&lt;T&gt; {};// Then, declare the test case.  The argument is the name of the test// fixture, and also the name of the test case (as usual).  The _P// suffix is for &quot;parameterized&quot; or &quot;pattern&quot;.TYPED_TEST_CASE_P(PrimeTableTest2);// Next, use TYPED_TEST_P(TestCaseName, TestName) to define a test,// similar to what you do with TEST_F.TYPED_TEST_P(PrimeTableTest2, ReturnsFalseForNonPrimes) {  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(-5));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(0));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(1));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(4));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(6));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(100));}TYPED_TEST_P(PrimeTableTest2, ReturnsTrueForPrimes) {  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(2));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(3));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(5));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(7));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(11));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(131));}TYPED_TEST_P(PrimeTableTest2, CanGetNextPrime) {  EXPECT_EQ(2, this-&gt;table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, this-&gt;table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, this-&gt;table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, this-&gt;table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, this-&gt;table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, this-&gt;table_-&gt;GetNextPrime(128));}// Type-parameterized tests involve one extra step: you have to// enumerate the tests you defined:REGISTER_TYPED_TEST_CASE_P(    PrimeTableTest2,  // The first argument is the test case name.    // The rest of the arguments are the test names.    ReturnsFalseForNonPrimes, ReturnsTrueForPrimes, CanGetNextPrime);// At this point the test pattern is done.  However, you don&apos;t have// any real test yet as you haven&apos;t said which types you want to run// the tests with.// To turn the abstract test pattern into real tests, you instantiate// it with a list of types.  Usually the test pattern will be defined// in a .h file, and anyone can #include and instantiate it.  You can// even instantiate it more than once in the same program.  To tell// different instances apart, you give each of them a name, which will// become part of the test case name and can be used in test filters.// The list of types we want to test.  Note that it doesn&apos;t have to be// defined at the time we write the TYPED_TEST_P()s.typedef Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt;    PrimeTableImplementations;INSTANTIATE_TYPED_TEST_CASE_P(OnTheFlyAndPreCalculated,    // Instance name                              PrimeTableTest2,             // Test case name                              PrimeTableImplementations);  // Type list#endif  // GTEST_HAS_TYPED_TEST_P// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to test common properties of multiple// implementations of an interface (aka interface tests) using// value-parameterized tests. Each test in the test case has// a parameter that is an interface pointer to an implementation// tested.// The interface and its implementations are in this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;#if GTEST_HAS_PARAM_TESTusing ::testing::TestWithParam;using ::testing::Values;// As a general rule, to prevent a test from affecting the tests that come// after it, you should create and destroy the tested objects for each test// instead of reusing them.  In this sample we will define a simple factory// function for PrimeTable objects.  We will instantiate objects in test&apos;s// SetUp() method and delete them in TearDown() method.typedef PrimeTable* CreatePrimeTableFunc();PrimeTable* CreateOnTheFlyPrimeTable() {  return new OnTheFlyPrimeTable();}template &lt;size_t max_precalculated&gt;PrimeTable* CreatePreCalculatedPrimeTable() {  return new PreCalculatedPrimeTable(max_precalculated);}// Inside the test body, fixture constructor, SetUp(), and TearDown() you// can refer to the test parameter by GetParam().  In this case, the test// parameter is a factory function which we call in fixture&apos;s SetUp() to// create and store an instance of PrimeTable.class PrimeTableTest : public TestWithParam&lt;CreatePrimeTableFunc*&gt; { public:  virtual ~PrimeTableTest() { delete table_; }  virtual void SetUp() { table_ = (*GetParam())(); }  virtual void TearDown() {    delete table_;    table_ = NULL;  } protected:  PrimeTable* table_;};TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {  EXPECT_FALSE(table_-&gt;IsPrime(-5));  EXPECT_FALSE(table_-&gt;IsPrime(0));  EXPECT_FALSE(table_-&gt;IsPrime(1));  EXPECT_FALSE(table_-&gt;IsPrime(4));  EXPECT_FALSE(table_-&gt;IsPrime(6));  EXPECT_FALSE(table_-&gt;IsPrime(100));}TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(table_-&gt;IsPrime(2));  EXPECT_TRUE(table_-&gt;IsPrime(3));  EXPECT_TRUE(table_-&gt;IsPrime(5));  EXPECT_TRUE(table_-&gt;IsPrime(7));  EXPECT_TRUE(table_-&gt;IsPrime(11));  EXPECT_TRUE(table_-&gt;IsPrime(131));}TEST_P(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, table_-&gt;GetNextPrime(128));}// In order to run value-parameterized tests, you need to instantiate them,// or bind them to a list of values which will be used as test parameters.// You can instantiate them in a different translation module, or even// instantiate them several times.//// Here, we instantiate our tests with a list of two PrimeTable object// factory functions:INSTANTIATE_TEST_CASE_P(    OnTheFlyAndPreCalculated,    PrimeTableTest,    Values(&amp;CreateOnTheFlyPrimeTable, &amp;CreatePreCalculatedPrimeTable&lt;1000&gt;));#else// Google Test may not support value-parameterized tests with some// compilers. If we use conditional compilation to compile out all// code referring to the gtest_main library, MSVC linker will not link// that library at all and consequently complain about missing entry// point defined in that library (fatal error LNK1561: entry point// must be defined). This dummy test keeps gtest_main linked in.TEST(DummyTest, ValueParameterizedTestsAreNotSupportedOnThisPlatform) {}#endif  // GTEST_HAS_PARAM_TEST// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to test code relying on some global flag variables.// Combine() helps with generating all possible combinations of such flags,// and each test is given one combination as a parameter.// Use class definitions to test from this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;#if GTEST_HAS_COMBINE// Suppose we want to introduce a new, improved implementation of PrimeTable// which combines speed of PrecalcPrimeTable and versatility of// OnTheFlyPrimeTable (see prime_tables.h). Inside it instantiates both// PrecalcPrimeTable and OnTheFlyPrimeTable and uses the one that is more// appropriate under the circumstances. But in low memory conditions, it can be// told to instantiate without PrecalcPrimeTable instance at all and use only// OnTheFlyPrimeTable.class HybridPrimeTable : public PrimeTable { public:  HybridPrimeTable(bool force_on_the_fly, int max_precalculated)      : on_the_fly_impl_(new OnTheFlyPrimeTable),        precalc_impl_(force_on_the_fly ? NULL :                          new PreCalculatedPrimeTable(max_precalculated)),        max_precalculated_(max_precalculated) {}  virtual ~HybridPrimeTable() {    delete on_the_fly_impl_;    delete precalc_impl_;  }  virtual bool IsPrime(int n) const {    if (precalc_impl_ != NULL &amp;&amp; n &lt; max_precalculated_)      return precalc_impl_-&gt;IsPrime(n);    else      return on_the_fly_impl_-&gt;IsPrime(n);  }  virtual int GetNextPrime(int p) const {    int next_prime = -1;    if (precalc_impl_ != NULL &amp;&amp; p &lt; max_precalculated_)      next_prime = precalc_impl_-&gt;GetNextPrime(p);    return next_prime != -1 ? next_prime : on_the_fly_impl_-&gt;GetNextPrime(p);  } private:  OnTheFlyPrimeTable* on_the_fly_impl_;  PreCalculatedPrimeTable* precalc_impl_;  int max_precalculated_;};using ::testing::TestWithParam;using ::testing::Bool;using ::testing::Values;using ::testing::Combine;// To test all code paths for HybridPrimeTable we must test it with numbers// both within and outside PreCalculatedPrimeTable&apos;s capacity and also with// PreCalculatedPrimeTable disabled. We do this by defining fixture which will// accept different combinations of parameters for instantiating a// HybridPrimeTable instance.class PrimeTableTest : public TestWithParam&lt; ::testing::tuple&lt;bool, int&gt; &gt; { protected:  virtual void SetUp() {    // This can be written as    //    // bool force_on_the_fly;    // int max_precalculated;    // tie(force_on_the_fly, max_precalculated) = GetParam();    //    // once the Google C++ Style Guide allows use of ::std::tr1::tie.    //    bool force_on_the_fly = ::testing::get&lt;0&gt;(GetParam());    int max_precalculated = ::testing::get&lt;1&gt;(GetParam());    table_ = new HybridPrimeTable(force_on_the_fly, max_precalculated);  }  virtual void TearDown() {    delete table_;    table_ = NULL;  }  HybridPrimeTable* table_;};TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {  // Inside the test body, you can refer to the test parameter by GetParam().  // In this case, the test parameter is a PrimeTable interface pointer which  // we can use directly.  // Please note that you can also save it in the fixture&apos;s SetUp() method  // or constructor and use saved copy in the tests.  EXPECT_FALSE(table_-&gt;IsPrime(-5));  EXPECT_FALSE(table_-&gt;IsPrime(0));  EXPECT_FALSE(table_-&gt;IsPrime(1));  EXPECT_FALSE(table_-&gt;IsPrime(4));  EXPECT_FALSE(table_-&gt;IsPrime(6));  EXPECT_FALSE(table_-&gt;IsPrime(100));}TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(table_-&gt;IsPrime(2));  EXPECT_TRUE(table_-&gt;IsPrime(3));  EXPECT_TRUE(table_-&gt;IsPrime(5));  EXPECT_TRUE(table_-&gt;IsPrime(7));  EXPECT_TRUE(table_-&gt;IsPrime(11));  EXPECT_TRUE(table_-&gt;IsPrime(131));}TEST_P(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, table_-&gt;GetNextPrime(128));}// In order to run value-parameterized tests, you need to instantiate them,// or bind them to a list of values which will be used as test parameters.// You can instantiate them in a different translation module, or even// instantiate them several times.//// Here, we instantiate our tests with a list of parameters. We must combine// all variations of the boolean flag suppressing PrecalcPrimeTable and some// meaningful values for tests. We choose a small value (1), and a value that// will put some of the tested numbers beyond the capability of the// PrecalcPrimeTable instance and some inside it (10). Combine will produce all// possible combinations.INSTANTIATE_TEST_CASE_P(MeaningfulTestParameters,                        PrimeTableTest,                        Combine(Bool(), Values(1, 10)));#else// Google Test may not support Combine() with some compilers. If we// use conditional compilation to compile out all code referring to// the gtest_main library, MSVC linker will not link that library at// all and consequently complain about missing entry point defined in// that library (fatal error LNK1561: entry point must be// defined). This dummy test keeps gtest_main linked in.TEST(DummyTest, CombineIsNotSupportedOnThisPlatform) {}#endif  // GTEST_HAS_COMBINE// Copyright 2009 Google Inc. All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to use Google Test listener API to implement// an alternative console output and how to use the UnitTest reflection API// to enumerate test cases and tests and to inspect their results.#include &lt;stdio.h&gt;#include &quot;gtest/gtest.h&quot;using ::testing::EmptyTestEventListener;using ::testing::InitGoogleTest;using ::testing::Test;using ::testing::TestCase;using ::testing::TestEventListeners;using ::testing::TestInfo;using ::testing::TestPartResult;using ::testing::UnitTest;namespace {// Provides alternative output mode which produces minimal amount of// information about tests.class TersePrinter : public EmptyTestEventListener { private:  // Called before any test activity starts.  virtual void OnTestProgramStart(const UnitTest&amp; /* unit_test */) {}  // Called after all test activities have ended.  virtual void OnTestProgramEnd(const UnitTest&amp; unit_test) {    fprintf(stdout, &quot;TEST %s\n&quot;, unit_test.Passed() ? &quot;PASSED&quot; : &quot;FAILED&quot;);    fflush(stdout);  }  // Called before a test starts.  virtual void OnTestStart(const TestInfo&amp; test_info) {    fprintf(stdout,            &quot;*** Test %s.%s starting.\n&quot;,            test_info.test_case_name(),            test_info.name());    fflush(stdout);  }  // Called after a failed assertion or a SUCCEED() invocation.  virtual void OnTestPartResult(const TestPartResult&amp; test_part_result) {    fprintf(stdout,            &quot;%s in %s:%d\n%s\n&quot;,            test_part_result.failed() ? &quot;*** Failure&quot; : &quot;Success&quot;,            test_part_result.file_name(),            test_part_result.line_number(),            test_part_result.summary());    fflush(stdout);  }  // Called after a test ends.  virtual void OnTestEnd(const TestInfo&amp; test_info) {    fprintf(stdout,            &quot;*** Test %s.%s ending.\n&quot;,            test_info.test_case_name(),            test_info.name());    fflush(stdout);  }};  // class TersePrinterTEST(CustomOutputTest, PrintsMessage) {  printf(&quot;Printing something from the test body...\n&quot;);}TEST(CustomOutputTest, Succeeds) {  SUCCEED() &lt;&lt; &quot;SUCCEED() has been invoked from here&quot;;}TEST(CustomOutputTest, Fails) {  EXPECT_EQ(1, 2)      &lt;&lt; &quot;This test fails in order to demonstrate alternative failure messages&quot;;}}  // namespaceint main(int argc, char **argv) {  InitGoogleTest(&amp;argc, argv);  bool terse_output = false;  if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;--terse_output&quot;) == 0 )    terse_output = true;  else    printf(&quot;%s\n&quot;, &quot;Run this program with --terse_output to change the way &quot;           &quot;it prints its output.&quot;);  UnitTest&amp; unit_test = *UnitTest::GetInstance();  // If we are given the --terse_output command line flag, suppresses the  // standard output and attaches own result printer.  if (terse_output) {    TestEventListeners&amp; listeners = unit_test.listeners();    // Removes the default console output listener from the list so it will    // not receive events from Google Test and won&apos;t print any output. Since    // this operation transfers ownership of the listener to the caller we    // have to delete it as well.    delete listeners.Release(listeners.default_result_printer());    // Adds the custom output listener to the list. It will now receive    // events from Google Test and print the alternative output. We don&apos;t    // have to worry about deleting it since Google Test assumes ownership    // over it after adding it to the list.    listeners.Append(new TersePrinter);  }  int ret_val = RUN_ALL_TESTS();  // This is an example of using the UnitTest reflection API to inspect test  // results. Here we discount failures from the tests we expected to fail.  int unexpectedly_failed_tests = 0;  for (int i = 0; i &lt; unit_test.total_test_case_count(); ++i) {    const TestCase&amp; test_case = *unit_test.GetTestCase(i);    for (int j = 0; j &lt; test_case.total_test_count(); ++j) {      const TestInfo&amp; test_info = *test_case.GetTestInfo(j);      // Counts failed tests that were not meant to fail (those without      // &apos;Fails&apos; in the name).      if (test_info.result()-&gt;Failed() &amp;&amp;          strcmp(test_info.name(), &quot;Fails&quot;) != 0) {        unexpectedly_failed_tests++;      }    }  }  // Test that were meant to fail should not affect the test program outcome.  if (unexpectedly_failed_tests == 0)    ret_val = 0;  return ret_val;}// Copyright 2009 Google Inc. All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to use Google Test listener API to implement// a primitive leak checker.#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;gtest/gtest.h&quot;using ::testing::EmptyTestEventListener;using ::testing::InitGoogleTest;using ::testing::Test;using ::testing::TestCase;using ::testing::TestEventListeners;using ::testing::TestInfo;using ::testing::TestPartResult;using ::testing::UnitTest;namespace {// We will track memory used by this class.class Water { public:  // Normal Water declarations go here.  // operator new and operator delete help us control water allocation.  void* operator new(size_t allocation_size) {    allocated_++;    return malloc(allocation_size);  }  void operator delete(void* block, size_t /* allocation_size */) {    allocated_--;    free(block);  }  static int allocated() { return allocated_; } private:  static int allocated_;};int Water::allocated_ = 0;// This event listener monitors how many Water objects are created and// destroyed by each test, and reports a failure if a test leaks some Water// objects. It does this by comparing the number of live Water objects at// the beginning of a test and at the end of a test.class LeakChecker : public EmptyTestEventListener { private:  // Called before a test starts.  virtual void OnTestStart(const TestInfo&amp; /* test_info */) {    initially_allocated_ = Water::allocated();  }  // Called after a test ends.  virtual void OnTestEnd(const TestInfo&amp; /* test_info */) {    int difference = Water::allocated() - initially_allocated_;    // You can generate a failure in any event handler except    // OnTestPartResult. Just use an appropriate Google Test assertion to do    // it.    EXPECT_LE(difference, 0) &lt;&lt; &quot;Leaked &quot; &lt;&lt; difference &lt;&lt; &quot; unit(s) of Water!&quot;;  }  int initially_allocated_;};TEST(ListenersTest, DoesNotLeak) {  Water* water = new Water;  delete water;}// This should fail when the --check_for_leaks command line flag is// specified.TEST(ListenersTest, LeaksWater) {  Water* water = new Water;  EXPECT_TRUE(water != NULL);}}  // namespaceint main(int argc, char **argv) {  InitGoogleTest(&amp;argc, argv);  bool check_for_leaks = false;  if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;--check_for_leaks&quot;) == 0 )    check_for_leaks = true;  else    printf(&quot;%s\n&quot;, &quot;Run this program with --check_for_leaks to enable &quot;           &quot;custom leak checking in the tests.&quot;);  // If we are given the --check_for_leaks command line flag, installs the  // leak checker.  if (check_for_leaks) {    TestEventListeners&amp; listeners = UnitTest::GetInstance()-&gt;listeners();    // Adds the leak checker to the end of the test event listener list,    // after the default text output printer and the default XML report    // generator.    //    // The order is important - it ensures that failures generated in the    // leak checker&apos;s OnTestEnd() method are processed by the text and XML    // printers *before* their OnTestEnd() methods are called, such that    // they are attributed to the right test. Remember that a listener    // receives an OnXyzStart event *after* listeners preceding it in the    // list received that event, and receives an OnXyzEnd event *before*    // listeners preceding it.    //    // We don&apos;t need to worry about deleting the new listener later, as    // Google Test will do it.    listeners.Append(new LeakChecker);  }  return RUN_ALL_TESTS();}</code></pre><h2 id="Google-Mock"><a href="#Google-Mock" class="headerlink" title="Google Mock"></a>Google Mock</h2><p><a href="https://www.cnblogs.com/jycboy/p/gmock_summary.html" title="https://www.cnblogs.com/jycboy/p/gmock_summary.html" target="_blank" rel="noopener">https://www.cnblogs.com/jycboy/p/gmock_summary.html</a></p><p><a href="https://blog.csdn.net/noahzuo/article/details/60136467" title="https://blog.csdn.net/noahzuo/article/details/60136467" target="_blank" rel="noopener">https://blog.csdn.net/noahzuo/article/details/60136467</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md" title="https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md" target="_blank" rel="noopener">https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md" title="https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md" target="_blank" rel="noopener">https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md</a></p><p><a href="http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html" title="http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html" target="_blank" rel="noopener">http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html</a></p><h3 id="CookBook"><a href="#CookBook" class="headerlink" title="CookBook"></a>CookBook</h3><h4 id="Mocking-Private-or-Protected-Methods"><a href="#Mocking-Private-or-Protected-Methods" class="headerlink" title="Mocking Private or Protected Methods"></a>Mocking Private or Protected Methods</h4><pre><code>class Foo { public:  ...  virtual bool Transform(Gadget* g) = 0; protected:  virtual void Resume(); private:  virtual int GetTimeOut();};class MockFoo : public Foo { public:  ...  MOCK_METHOD1(Transform, bool(Gadget* g));  // The following must be in the public section, even though the  // methods are protected or private in the base class.  MOCK_METHOD0(Resume, void());  MOCK_METHOD0(GetTimeOut, int());};</code></pre><h4 id="Mocking-Overloaded-Methods"><a href="#Mocking-Overloaded-Methods" class="headerlink" title="Mocking Overloaded Methods"></a>Mocking Overloaded Methods</h4><pre><code>class Foo {  ...  // Must be virtual as we&apos;ll inherit from Foo.  virtual ~Foo();  // Overloaded on the types and/or numbers of arguments.  virtual int Add(Element x);  virtual int Add(int times, Element x);  // Overloaded on the const-ness of this object.  virtual Bar&amp; GetBar();  virtual const Bar&amp; GetBar() const;};class MockFoo : public Foo {  ...  MOCK_METHOD1(Add, int(Element x));  MOCK_METHOD2(Add, int(int times, Element x);  MOCK_METHOD0(GetBar, Bar&amp;());  MOCK_CONST_METHOD0(GetBar, const Bar&amp;());};</code></pre><h4 id="Mocking-Class-Templates"><a href="#Mocking-Class-Templates" class="headerlink" title="Mocking Class Templates"></a>Mocking Class Templates</h4><pre><code>template &lt;typename Elem&gt;class StackInterface {  ...  // Must be virtual as we&apos;ll inherit from StackInterface.  virtual ~StackInterface();  virtual int GetSize() const = 0;  virtual void Push(const Elem&amp; x) = 0;};template &lt;typename Elem&gt;class MockStack : public StackInterface&lt;Elem&gt; {  ...  MOCK_CONST_METHOD0_T(GetSize, int());  MOCK_METHOD1_T(Push, void(const Elem&amp; x));};</code></pre><h4 id="Mocking-Nonvirtual-Methods"><a href="#Mocking-Nonvirtual-Methods" class="headerlink" title="Mocking Nonvirtual Methods"></a>Mocking Nonvirtual Methods</h4><pre><code>// A simple packet stream class.  None of its members is virtual.class ConcretePacketStream { public:  void AppendPacket(Packet* new_packet);  const Packet* GetPacket(size_t packet_number) const;  size_t NumberOfPackets() const;  ...};// A mock packet stream class.  It inherits from no other, but defines// GetPacket() and NumberOfPackets().class MockPacketStream { public:  MOCK_CONST_METHOD1(GetPacket, const Packet*(size_t packet_number));  MOCK_CONST_METHOD0(NumberOfPackets, size_t());  ...};</code></pre><h1 id="Boost-Test"><a href="#Boost-Test" class="headerlink" title="Boost.Test"></a>Boost.Test</h1><p><a href="https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html" title="https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html" target="_blank" rel="noopener">https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html</a></p><p><a href="https://www.cnblogs.com/moon1992/p/7482033.html" title="https://www.cnblogs.com/moon1992/p/7482033.html" target="_blank" rel="noopener">https://www.cnblogs.com/moon1992/p/7482033.html</a></p><p><a href="https://ask.helplib.com/c++/post_1311306" title="https://ask.helplib.com/c++/post_1311306" target="_blank" rel="noopener">https://ask.helplib.com/c++/post_1311306</a></p><p><a href="https://blogs.msdn.microsoft.com/c/2018/01/12/boost-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8A%A8%E6%80%81%E5%BA%93%E6%94%AF%E6%8C%81%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/" title="https://blogs.msdn.microsoft.com/c/2018/01/12/boost-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8A%A8%E6%80%81%E5%BA%93%E6%94%AF%E6%8C%81%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">Boost.Test单元测试：动态库支持和新项目模板</a></p><h1 id="UnitTest-CppUnitTestFramework"><a href="#UnitTest-CppUnitTestFramework" class="headerlink" title="UnitTest CppUnitTestFramework"></a>UnitTest CppUnitTestFramework</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/hh419385.aspx" title="https://msdn.microsoft.com/zh-cn/library/hh419385.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/hh419385.aspx</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396" title="https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396</a></p><ul><li>Assert.Inconclusive()//表示一个未验证的测试；</li><li>Assert.AreEqual() //测试指定的值是否相等，如果相等，则测试通过；</li><li>AreSame() //用于验证指定的两个对象变量是指向相同的对象，否则认为是错误</li><li>AreNotSame() //用于验证指定的两个对象变量是指向不同的对象，否则认为是错误</li><li>Assert.IsTrue() //测试指定的条件是否为True，如果为True，则测试通过；</li><li>Assert.IsFalse() //测试指定的条件是否为False，如果为False，则测试通过；</li><li>Assert.IsNull() //测试指定的对象是否为空引用，如果为空，则测试通过；</li><li>Assert.IsNotNull() //测试指定的对象是否为非空，如果不为空，则测试通过；</li></ul><h2 id="simple"><a href="#simple" class="headerlink" title="simple:"></a>simple:</h2><pre><code>#include &quot;stdafx.h&quot;#include &quot;CppUnitTest.h&quot;using namespace Microsoft::VisualStudio::CppUnitTestFramework;namespace MyUnitTest{            TEST_CLASS(UnitTest1)    {    public:        TEST_METHOD(TestMethod1)        {            // TODO: 在此输入测试代码        }    };}namespace MyTest{    TEST_CLASS(MyTests)    {    public:        TEST_METHOD(MyTestMethod)        {            Assert::AreEqual(6, 6);        }    };}#include &quot;stdafx.h&quot;#include &quot;CppUnitTest.h&quot; using namespace Microsoft::VisualStudio::CppUnitTestFramework;BEGIN_TEST_MODULE_ATTRIBUTE()TEST_MODULE_ATTRIBUTE(L&quot;Date&quot;, L&quot;2010/6/12&quot;)END_TEST_MODULE_ATTRIBUTE()TEST_MODULE_INITIALIZE(ModuleInitialize){    Logger::WriteMessage(&quot;In Module Initialize&quot;);}TEST_MODULE_CLEANUP(ModuleCleanup){    Logger::WriteMessage(&quot;In Module Cleanup&quot;);}TEST_CLASS(Class1){public:    Class1()    {        Logger::WriteMessage(&quot;In Class1&quot;);    }    ~Class1()    {        Logger::WriteMessage(&quot;In ~Class1&quot;);    }    TEST_CLASS_INITIALIZE(ClassInitialize)    {        Logger::WriteMessage(&quot;In Class Initialize&quot;);    }    TEST_CLASS_CLEANUP(ClassCleanup)    {        Logger::WriteMessage(&quot;In Class Cleanup&quot;);    }    BEGIN_TEST_METHOD_ATTRIBUTE(Method1)        TEST_OWNER(L&quot;OwnerName&quot;)        TEST_PRIORITY(1)        END_TEST_METHOD_ATTRIBUTE()        TEST_METHOD(Method1)    {        Logger::WriteMessage(&quot;In Method1&quot;);        Assert::AreEqual(0, 0);    }    TEST_METHOD(Method2)    {        Assert::Fail(L&quot;Fail&quot;);    }};</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://docs.microsoft.com/en-us/visualstudio/test/writing-unit-tests-for-c-cpp" title="https://docs.microsoft.com/en-us/visualstudio/test/writing-unit-tests-for-c-cpp" target="_blank" rel="noopener">编写 单元测试 用于 C / C + + 在 Visual Studio</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" title="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cppunit&quot;&gt;&lt;a href=&quot;#cppunit&quot; class=&quot;headerlink&quot; title=&quot;cppunit&quot;&gt;&lt;/a&gt;cppunit&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://caojingyou.github.io/2018/01/18/c
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="CppUnit" scheme="https://caojingyou.github.io/tags/CppUnit/"/>
    
      <category term="单元测试" scheme="https://caojingyou.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="CppUTest" scheme="https://caojingyou.github.io/tags/CppUTest/"/>
    
      <category term="Google Test" scheme="https://caojingyou.github.io/tags/Google-Test/"/>
    
      <category term="Google Mock" scheme="https://caojingyou.github.io/tags/Google-Mock/"/>
    
      <category term="Boost.Test" scheme="https://caojingyou.github.io/tags/Boost-Test/"/>
    
      <category term="MicrosoftCppUnitTest" scheme="https://caojingyou.github.io/tags/MicrosoftCppUnitTest/"/>
    
  </entry>
  
  <entry>
    <title>目录监控</title>
    <link href="https://caojingyou.github.io/2018/04/27/%E7%9B%AE%E5%BD%95%E7%9B%91%E6%8E%A7/"/>
    <id>https://caojingyou.github.io/2018/04/27/目录监控/</id>
    <published>2018-04-27T08:03:00.000Z</published>
    <updated>2018-04-27T08:44:58.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileSystemWatcher"><a href="#FileSystemWatcher" class="headerlink" title="FileSystemWatcher"></a>FileSystemWatcher</h1><pre><code>// &lt;https://msdn.microsoft.com/zh-cn/library/chzww271.aspx&gt;// monitor_fs.cpp// compile with: /clr#using &lt;system.dll&gt;using namespace System;using namespace System::IO;ref class FSEventHandler{public:    void OnChanged (Object ^source, FileSystemEventArgs ^e)    {        Console::WriteLine(&quot;File: {0} {1}&quot;,                           e-&gt;FullPath, e-&gt;ChangeType);    }    void OnRenamed(Object ^source, RenamedEventArgs ^e)    {        Console::WriteLine(&quot;File: {0} renamed to {1}&quot;,                           e-&gt;OldFullPath, e-&gt;FullPath);    }};int main(){    array&lt;String ^&gt; ^args = Environment::GetCommandLineArgs();    if(args-&gt;Length &lt; 2)    {        Console::WriteLine(&quot;Usage: Watcher.exe &lt;directory&gt;&quot;);        return -1;    }    FileSystemWatcher ^fsWatcher = gcnew FileSystemWatcher( );    fsWatcher-&gt;Path = args[1];    fsWatcher-&gt;NotifyFilter = static_cast&lt;NotifyFilters&gt;                              (NotifyFilters::FileName |                               NotifyFilters::Attributes |                               NotifyFilters::LastAccess |                               NotifyFilters::LastWrite |                               NotifyFilters::Security |                               NotifyFilters::Size );    FSEventHandler ^handler = gcnew FSEventHandler();    fsWatcher-&gt;Changed += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Created += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Deleted += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Renamed += gcnew RenamedEventHandler(                              handler, &amp;FSEventHandler::OnRenamed);    fsWatcher-&gt;EnableRaisingEvents = true;    Console::WriteLine(&quot;Press Enter to quit the sample.&quot;);    Console::ReadLine( );}</code></pre><h1 id="目录监视器-Directory-Monitor"><a href="#目录监视器-Directory-Monitor" class="headerlink" title="目录监视器(Directory Monitor)"></a>目录监视器(Directory Monitor)</h1><p>使用Boost.Asio扩展<br><a href="http://www.highscore.de/boost/dir_monitor.zip" title="http://www.highscore.de/boost/dir_monitor.zip" target="_blank" rel="noopener">http://www.highscore.de/boost/dir_monitor.zip</a></p><h1 id="SHChangeNotifyRegister"><a href="#SHChangeNotifyRegister" class="headerlink" title="SHChangeNotifyRegister"></a>SHChangeNotifyRegister</h1><p>Win SDK Samples 下 ChangeNotifyWatcher 项目，使用<code>SHChangeNotifyRegister</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FileSystemWatcher&quot;&gt;&lt;a href=&quot;#FileSystemWatcher&quot; class=&quot;headerlink&quot; title=&quot;FileSystemWatcher&quot;&gt;&lt;/a&gt;FileSystemWatcher&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="boost" scheme="https://caojingyou.github.io/tags/boost/"/>
    
      <category term="目录监控" scheme="https://caojingyou.github.io/tags/%E7%9B%AE%E5%BD%95%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cryptlib</title>
    <link href="https://caojingyou.github.io/2018/04/18/Cryptlib/"/>
    <id>https://caojingyou.github.io/2018/04/18/Cryptlib/</id>
    <published>2018-04-18T09:28:00.000Z</published>
    <updated>2018-04-18T09:29:33.323Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cs.auckland.ac.nz/~pgut001/cryptlib/" title="https://www.cs.auckland.ac.nz/~pgut001/cryptlib/" target="_blank" rel="noopener">https://www.cs.auckland.ac.nz/~pgut001/cryptlib/</a></p><p><a href="http://www.cypherpunks.to/~peter/cl344.zip" title="http://www.cypherpunks.to/~peter/cl344.zip" target="_blank" rel="noopener">http://www.cypherpunks.to/~peter/cl344.zip</a></p><p><a href="http://www.cypherpunks.to/~peter/manual.pdf" title="http://www.cypherpunks.to/~peter/manual.pdf" target="_blank" rel="noopener">http://www.cypherpunks.to/~peter/manual.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cs.auckland.ac.nz/~pgut001/cryptlib/&quot; title=&quot;https://www.cs.auckland.ac.nz/~pgut001/cryptlib/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="密码" scheme="https://caojingyou.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="Cryptlib" scheme="https://caojingyou.github.io/tags/Cryptlib/"/>
    
  </entry>
  
  <entry>
    <title>插件框架</title>
    <link href="https://caojingyou.github.io/2018/04/18/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    <id>https://caojingyou.github.io/2018/04/18/插件框架/</id>
    <published>2018-04-18T06:48:00.000Z</published>
    <updated>2018-04-18T07:11:03.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件框架"><a href="#插件框架" class="headerlink" title="插件框架"></a>插件框架</h1><p><a href="pluma-framework" title="http://pluma-framework.sourceforge.net">pluma-framework</a></p><p><a href="https://www.devbean.net/category/plugin/" title="https://www.devbean.net/category/plugin/" target="_blank" rel="noopener">自己动手写插件框架</a></p><p><a href="http://files.devbean.net/code/plugin.zip" target="_blank" rel="noopener">自己动手写插件框架-源代码</a></p><p><a href="https://github.com/sld666666/cptf" target="_blank" rel="noopener">cpp plugin template framework</a></p><p><a href="https://download.csdn.net/download/zhouxuguang236/7466253" target="_blank" rel="noopener">C++跨平台插件实例</a></p><p><a href="https://github.com/linuxzjh/traditionalDevelopment" target="_blank" rel="noopener">traditionalDevelopment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插件框架&quot;&gt;&lt;a href=&quot;#插件框架&quot; class=&quot;headerlink&quot; title=&quot;插件框架&quot;&gt;&lt;/a&gt;插件框架&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;pluma-framework&quot; title=&quot;http://pluma-framework.source
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="插件框架" scheme="https://caojingyou.github.io/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>CEF</title>
    <link href="https://caojingyou.github.io/2018/04/16/CEF/"/>
    <id>https://caojingyou.github.io/2018/04/16/CEF/</id>
    <published>2018-04-16T01:53:00.000Z</published>
    <updated>2018-04-16T09:28:06.898Z</updated>
    
    <content type="html"><![CDATA[<p>主页：<a href="http://opensource.spotify.com/cefbuilds/index.html" target="_blank" rel="noopener">http://opensource.spotify.com/cefbuilds/index.html</a></p><p>CEF 全称是 Chromium Embedded Framework（Chromium 嵌入式框架），它主要目的是开发一个基于 Google Chromium 的 Webbrowser 控件。CEF 支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。</p><p>它的设计思想政治就是易用且兼顾性能。CEF 基本的框架包含 C/C++ 程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和 Chromium &amp; Webkit 的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，JavaScript 对象以及 javascript 扩展，宿主程序可以随意地控件资源下载，导航，下下文内容和打印等，并且可以跟 Google Chrome 浏览器一起，支持高性能和 HTML5 技术。</p><p>CEF3文档：<a href="http://magpcss.org/ceforum/apidocs3/" title="http://magpcss.org/ceforum/apidocs3/" target="_blank" rel="noopener">http://magpcss.org/ceforum/apidocs3/</a></p><p>二进制发布包目录结构大致如下:</p><pre><code>[解压目录]  |-include -- 头文件目录  |-Debug   -- 编译好的CEF库，Debug版  |-Release -- 编译好的CEF库，Release版  |-Resources   -- CEF库需要的资源文件  |-libcef_dll  -- CEF的C++包装类库源代码，需要手动编译  |-tests   -- 包含了一些测试工程  |-CMakeLists.txt  --CMake工程文件</code></pre><p>参考：</p><p><a href="https://github.com/fanfeilong/cefutil" title="https://github.com/fanfeilong/cefutil" target="_blank" rel="noopener">https://github.com/fanfeilong/cefutil</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主页：&lt;a href=&quot;http://opensource.spotify.com/cefbuilds/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://opensource.spotify.com/cefbuilds/in
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="CEF" scheme="https://caojingyou.github.io/tags/CEF/"/>
    
  </entry>
  
  <entry>
    <title>ATL与WTL</title>
    <link href="https://caojingyou.github.io/2018/04/12/ATL%E4%B8%8EWTL/"/>
    <id>https://caojingyou.github.io/2018/04/12/ATL与WTL/</id>
    <published>2018-04-12T01:53:00.000Z</published>
    <updated>2018-04-13T07:22:35.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATL"><a href="#ATL" class="headerlink" title="ATL"></a>ATL</h1><p>ATL中所使用的基本技术包括以下几个方面：</p><ul><li>COM技术</li><li>C++模板类技术（Template)</li><li>C++多继承技术（Multi-Inheritance)</li></ul><p><a href="https://msdn.microsoft.com/zh-cn/library/hh967573.aspx" target="_blank" rel="noopener">MFC 和 ATL</a></p><h1 id="WTL"><a href="#WTL" class="headerlink" title="WTL"></a>WTL</h1><p><a href="https://sourceforge.net/projects/wtl/" target="_blank" rel="noopener">https://sourceforge.net/projects/wtl/</a></p><p>AppWizard目录执行</p><pre><code>wscript Setup.js</code></pre><p><a href="https://sourceforge.net/projects/visualfc/" title="https://sourceforge.net/projects/visualfc/" target="_blank" rel="noopener">visualfc</a></p><p><a href="http://www.winmsg.com/cn/orbit.htm" title="http://www.winmsg.com/cn/orbit.htm" target="_blank" rel="noopener">WTL for MFC programmer 系列文章(翻译)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ATL&quot;&gt;&lt;a href=&quot;#ATL&quot; class=&quot;headerlink&quot; title=&quot;ATL&quot;&gt;&lt;/a&gt;ATL&lt;/h1&gt;&lt;p&gt;ATL中所使用的基本技术包括以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COM技术&lt;/li&gt;
&lt;li&gt;C++模板类技术（Templat
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="c++" scheme="https://caojingyou.github.io/tags/c/"/>
    
      <category term="ATL" scheme="https://caojingyou.github.io/tags/ATL/"/>
    
      <category term="WTL" scheme="https://caojingyou.github.io/tags/WTL/"/>
    
  </entry>
  
  <entry>
    <title>duilib</title>
    <link href="https://caojingyou.github.io/2018/04/12/duilib/"/>
    <id>https://caojingyou.github.io/2018/04/12/duilib/</id>
    <published>2018-04-12T01:53:00.000Z</published>
    <updated>2018-04-13T07:20:15.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="duilib"><a href="#duilib" class="headerlink" title="duilib"></a>duilib</h1><p><a href="https://github.com/duilib/duilib" target="_blank" rel="noopener">https://github.com/duilib/duilib</a></p><h2 id="设计器："><a href="#设计器：" class="headerlink" title="设计器："></a>设计器：</h2><p>DuiDesigner</p><h2 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h2><p><a href="www.cnblogs.com/Alberl/category/520438.html">2013 duilib入门简明教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;duilib&quot;&gt;&lt;a href=&quot;#duilib&quot; class=&quot;headerlink&quot; title=&quot;duilib&quot;&gt;&lt;/a&gt;duilib&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/duilib/duilib&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="ATL" scheme="https://caojingyou.github.io/tags/ATL/"/>
    
      <category term="duilib" scheme="https://caojingyou.github.io/tags/duilib/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://caojingyou.github.io/2018/04/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/04/03/正则表达式/</id>
    <published>2018-04-03T01:53:00.000Z</published>
    <updated>2018-04-13T07:16:03.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-regex"><a href="#c-regex" class="headerlink" title="c regex"></a>c regex</h1><ol><li>编译正则表达式 <code>regcomp()</code></li><li>匹配正则表达式 <code>regexec()</code></li><li>释放正则表达式 <code>regfree()</code></li><li>错误处理 <code>regerror()</code></li></ol><pre><code>#include &lt;stdio.h&gt;#include &lt;regex.h&gt;  //标准c不支持，Linux常带有此文件int main(){    regex_t reg;    //定义一个正则实例    const char* pattern = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$&quot;; //定义模式串    regcomp(&amp;reg, pattern, REG_EXTENDED);    //编译正则模式串    char* buf = &quot;david19842003@gmail.com&quot;;   //定义待匹配串    const size_t nmatch = 1;    //定义匹配结果最大允许数    regmatch_t pmatch[1];   //定义匹配结果在待匹配串中的下标范围    int status = regexec(&amp;reg, buf, nmatch, pmatch, 0); //匹配他    if (status == REG_NOMATCH){ //如果没匹配上        printf(&quot;No Match\n&quot;);    }    else if (status == 0){  //如果匹配上了        printf(&quot;Match\n&quot;);        for (int i = pmatch[0].rm_so; i &lt; pmatch[0].rm_eo; i++){    //遍历输出匹配范围的字符串            printf(&quot;%c&quot;, buf[i]);        }        printf(&quot;\n&quot;);    }    regfree(&amp;reg);  //释放正则表达式    return 0;}</code></pre><p>1.<code>int regcomp (regex_t *compiled, const char *pattern, int cflags)</code></p><ul><li><code>regex_t</code> 是一个结构体数据类型，用来存放编译后的正则表达式<ul><li><code>regex_t</code> 的成员<code>re_nsub</code> 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式</li></ul></li><li><code>pattern</code> 是指向我们写好的正则表达式的指针</li><li><code>cflags</code> 有如下4个值或者是它们或运算(|)后的值：<ul><li>REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。</li><li>REG_ICASE 匹配字母时忽略大小写。</li><li>REG_NOSUB 不用存储匹配后的结果。</li><li>REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配</li></ul></li></ul><p>2.<code>int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)</code></p><ul><li>如果在编译正则表达式的时候没有指定cflags的参数为REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回0<ul><li><code>regmatch_t</code> 是一个结构体数据类型，在regex.h中定义：<code>typedef struct{regoff_t rm_so;regoff_t rm_eo;} regmatch_t;</code></li><li>成员<code>rm_so</code> 存放匹配文本串在目标串中的开始位置，<code>rm_eo</code>存放结束位置</li><li>通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置</li></ul></li><li><code>compiled</code> 是已经用<code>regcomp</code>函数编译好的正则表达式</li><li><code>string</code> 是目标文本串</li><li><code>nmatch</code> 是<code>regmatch_t</code>结构体数组的长度</li><li><code>matchptr regmatch_t</code>类型的结构体数组，存放匹配文本串的位置信息</li><li><code>eflags</code> 有两个值<ul><li><code>REG_NOTBOL</code> 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义</li><li><code>REG_NOTEOL</code> 和上边那个作用差不多，不过这个指定结束<code>end of line</code></li></ul></li></ul><p>3.<code>void regfree (regex_t *compiled)</code></p><ul><li>清空compiled指向的regex_t结构体的内容</li><li>如果是重新编译的话，一定要先清空regex_t结构体c</li></ul><p>4.<code>size_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)</code></p><ul><li><code>当执行regcomp</code> 或者<code>regexec</code> 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串</li><li><code>errcode</code> <code>是由regcomp</code> 和 <code>regexec</code> 函数返回的错误代号</li><li><code>compiled</code> 是已经用<code>regcomp</code>函数编译好的正则表达式，这个值可以为<code>NULL</code></li><li><code>buffer</code> 指向用来存放错误信息的字符串的内存空间</li><li><code>length</code> 指明<code>buffer</code>的长度，如果这个错误信息的长度大于这个值，则<code>regerror</code> 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。</li></ul><pre><code>`size_t length = regerror (errcode, compiled, NULL, 0);`</code></pre><p>转载：<br><a href="http://www.yingzinanfei.com/2017/02/06/c-regex-yongfa/" target="_blank" rel="noopener">c regex 用法</a></p><h1 id="C-regex"><a href="#C-regex" class="headerlink" title="C++ regex"></a>C++ regex</h1><p><a href="https://msdn.microsoft.com/en-us/library/bb982382.aspx" target="_blank" rel="noopener">regex头文件</a></p><p><a href="https://msdn.microsoft.com/en-us/library/bb982727.aspx" target="_blank" rel="noopener">Regular Expressions (C++)</a></p><p><a href="https://msdn.microsoft.com/zh-cn/ch/library/bb982727.aspx" target="_blank" rel="noopener">正则表达式 (C++)</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regular-expressions-cpp" target="_blank" rel="noopener">正则表达式 (C++)</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regex" target="_blank" rel="noopener">微软regex</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regex-typedefs" target="_blank" rel="noopener">regex typedefs</a></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><code>basic_regex</code>    包装正则表达式。</li><li><code>match_results</code>    包含一系列子匹配项。</li><li><code>regex_constants</code>    包含各种类型的常量。</li><li><code>regex_error</code>    报告错误的正则表达式。</li><li><code>regex_iterator</code>    循环访问匹配结果。</li><li><code>regex_traits</code>    描述用于匹配的元素的特征。</li><li><code>regex_traits&lt;char&gt;</code>    描述用于匹配的 <code>char</code> 的特征。</li><li><code>regex_traits&lt;wchar_t&gt;</code>    描述用于匹配的 <code>wchar_t</code> 的特征。</li><li><code>regex_token_iterator</code>    循环访问子匹配项。</li><li><code>sub_match</code>    介绍子匹配项。</li></ul><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><ul><li><code>cmatch</code>    <code>char match_results</code> 的类型定义。</li><li><code>cregex_iterator</code>    <code>char regex_iterator</code> 的类型定义。</li><li><code>cregex_token_iterator</code>    <code>char regex_token_iterator</code> 的类型定义。</li><li><code>csub_match</code>    <code>char sub_match</code> 的类型定义。</li><li><code>regex</code>    <code>char basic_regex</code> 的类型定义。</li><li><code>smatch</code>    <code>string match_results</code> 的类型定义。</li><li><code>sregex_iterator</code>    <code>string regex_iterator</code> 的类型定义。</li><li><code>sregex_token_iterator</code>    <code>string regex_token_iterator</code> 的类型定义。</li><li><code>ssub_match</code>    <code>string sub_match</code> 的类型定义。</li><li><code>wcmatch</code>    <code>wchar_t match_results</code> 的类型定义。</li><li><code>wcregex_iterator</code>    <code>wchar_t regex_iterator</code> 的类型定义。</li><li><code>wcregex_token_iterator</code>    <code>wchar_t regex_token_iterator</code> 的类型定义。</li><li><code>wcsub_match</code>    <code>wchar_t sub_match</code> 的类型定义。</li><li><code>wregex</code>    <code>wchar_t basic_regex</code> 的类型定义。</li><li><code>wsmatch</code>    <code>wstring match_results</code> 的类型定义。</li><li><code>wsregex_iterator</code>    <code>wstring regex_iterator</code> 的类型定义。</li><li><code>wsregex_token_iterator</code>    <code>wstring regex_token_iterator</code> 的类型定义。</li><li><code>wssub_match</code>    <code>wstring sub_match</code> 的类型定义。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><code>regex_match</code>    与正则表达式完全匹配。</li><li><code>regex_replace</code>    替换匹配正则表达式。</li><li><code>regex_search</code>    搜索正则表达式匹配项。</li><li><code>swap</code>    交换 <code>basic_regex</code> 或 <code>match_results</code> 对象。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><code>operator==</code>    比较各种对象，相等。</li><li><code>operator!=</code>    比较各种对象，不相等。</li><li><code>operator&lt;</code>    比较各种对象，小于。</li><li><code>operator&lt;=</code>    比较各种对象，小于或等于。</li><li><code>operator&gt;</code>    比较各种对象，大于。</li><li><code>operator&gt;=</code>    比较各种对象，大于或等于。</li><li><code>operator&lt;&lt;</code>    将 sub_match 插入流中。</li></ul><h2 id="regex-match"><a href="#regex-match" class="headerlink" title="regex_match"></a><code>regex_match</code></h2><pre><code>#include &quot;stdafx.h&quot;  #include &lt;regex&gt;   #include &lt;iostream&gt;   using namespace std;  int _tmain(int argc, _TCHAR* argv[])  {      // (1) with char*      // Note how const char* requires cmatch and regex      const char *first = &quot;abc&quot;;      const char *last = first + strlen(first);      cmatch narrowMatch;      regex rx(&quot;a(b)c&quot;);      bool found = regex_match(first, last, narrowMatch, rx);      // (1) with std::wstring      // Note how wstring requires wsmatch and wregex.      // Note use of const iterators cbegin() and cend().      wstring target(L&quot;Hello&quot;);      wsmatch wideMatch;      wregex wrx(L&quot;He(l+)o&quot;);      if (regex_match(target.cbegin(), target.cend(), wideMatch, wrx))          wcout &lt;&lt; L&quot;The matching text is:&quot; &lt;&lt; wideMatch.str() &lt;&lt; endl;       // (2) with std::string      string target2(&quot;Drizzle&quot;);      regex rx2(R&quot;(D\w+e)&quot;); // no double backslashes with raw string literal      found = regex_match(target2.cbegin(), target2.cend(), rx2);      // (3) with wchar_t*      const wchar_t* target3 = L&quot;2014-04-02&quot;;      wcmatch wideMatch2;      // LR&quot;(...)&quot; is a  raw wide-string literal. Open and close parens      // are delimiters, not string elements.      wregex wrx2(LR&quot;(\d{4}(-|/)\d{2}(-|/)\d{2})&quot;);       if (regex_match(target3, wideMatch2, wrx2))      {          wcout &lt;&lt; L&quot;Matching text: &quot; &lt;&lt; wideMatch2.str() &lt;&lt; endl;      }       return 0;  }</code></pre><h2 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace"></a><code>regex_replace</code></h2><pre><code>// std__regex__regex_replace.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       char buf[20];       const char *first = &quot;axayaz&quot;;       const char *last = first + strlen(first);       std::regex rx(&quot;a&quot;);       std::string fmt(&quot;A&quot;);       std::regex_constants::match_flag_type fonly =           std::regex_constants::format_first_only;    *std::regex_replace(&amp;buf[0], first, last, rx, fmt) = &apos;\0&apos;;       std::cout &lt;&lt; &quot;replacement == &quot; &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;    *std::regex_replace(&amp;buf[0], first, last, rx, fmt, fonly) = &apos;\0&apos;;       std::cout &lt;&lt; &quot;replacement == &quot; &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;       std::string str(&quot;adaeaf&quot;);       std::cout &lt;&lt; &quot;replacement == &quot;           &lt;&lt; std::regex_replace(str, rx, fmt) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;replacement == &quot;           &lt;&lt; std::regex_replace(str, rx, fmt, fonly) &lt;&lt; std::endl;       return (0);       }</code></pre><p>结果：</p><pre><code>replacement == AxAyAz  replacement == Axayaz  replacement == AdAeAf  replacement == Adaeaf </code></pre><h2 id="regex-search"><a href="#regex-search" class="headerlink" title="regex_search"></a><code>regex_search</code></h2><pre><code>// std__regex__regex_search.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       const char *first = &quot;abcd&quot;;       const char *last = first + strlen(first);       std::cmatch mr;       std::regex rx(&quot;abc&quot;);       std::regex_constants::match_flag_type fl =           std::regex_constants::match_default;       std::cout &lt;&lt; &quot;search(f, f+1, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(first, first + 1, rx, fl) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(f, l, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(first, last, mr, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(\&quot;a\&quot;, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(&quot;a&quot;, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(\&quot;xabcd\&quot;, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(&quot;xabcd&quot;, mr, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(string, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(std::string(&quot;a&quot;), rx) &lt;&lt; std::endl;       std::string str(&quot;abcabc&quot;);       std::match_results&lt;std::string::const_iterator&gt; mr2;       std::cout &lt;&lt; &quot;search(string, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(str, mr2, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr2.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       return (0);   }</code></pre><h2 id="match-results"><a href="#match-results" class="headerlink" title="match_results"></a><code>match_results</code></h2><pre><code>// std__regex__match_results_begin.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex rx(&quot;c(a*)|(b)&quot;);       std::cmatch mr;       std::regex_search(&quot;xcaaay&quot;, mr, rx);       std::cout &lt;&lt; &quot;prefix: matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; mr.prefix().matched           &lt;&lt; &quot;, value == &quot; &lt;&lt; mr.prefix() &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;whole match: &quot; &lt;&lt; mr.length() &lt;&lt; &quot; chars, value == &quot;           &lt;&lt; mr.str() &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;suffix: matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; mr.suffix().matched           &lt;&lt; &quot;, value == &quot; &lt;&lt; mr.suffix() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;       std::string fmt(&quot;\&quot;c(a*)|(b)\&quot; matched \&quot;$0\&quot;\n&quot;           &quot;\&quot;(a*)\&quot; matched \&quot;$1\&quot;\n&quot;           &quot;\&quot;(b)\&quot; matched \&quot;$2\&quot;\n&quot;);       std::cout &lt;&lt; mr.format(fmt) &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // index through submatches       for (size_t n = 0; n &lt; mr.size(); ++n)           {           std::cout &lt;&lt; &quot;submatch[&quot; &lt;&lt; n &lt;&lt; &quot;]: matched == &quot; &lt;&lt; std::boolalpha               &lt;&lt; mr[n].matched &lt;&lt;               &quot; at position &quot; &lt;&lt; mr.position(n) &lt;&lt; std::endl;           std::cout &lt;&lt; &quot;  &quot; &lt;&lt; mr.length(n)               &lt;&lt; &quot; chars, value == &quot; &lt;&lt; mr[n] &lt;&lt; std::endl;           }       std::cout &lt;&lt; std::endl;   // iterate through submatches       for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)           {           std::cout &lt;&lt; &quot;next submatch: matched == &quot; &lt;&lt; std::boolalpha               &lt;&lt; it-&gt;matched &lt;&lt; std::endl;           std::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;length()               &lt;&lt; &quot; chars, value == &quot; &lt;&lt; *it &lt;&lt; std::endl;           }       std::cout &lt;&lt; std::endl;   // other members       std::cmatch mr1(mr);       mr = mr1;       mr.swap(mr1);       char buf[10];    *mr.format(&amp;buf[0], &quot;&lt;$0&gt;&quot;) = &apos;\0&apos;;       std::cout &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;empty == &quot; &lt;&lt; std::boolalpha &lt;&lt; mr.empty() &lt;&lt; std::endl;       std::cmatch::allocator_type al = mr.get_allocator();       std::cmatch::string_type str = std::string(&quot;x&quot;);       std::cmatch::size_type maxsiz = mr.max_size();       std::cmatch::char_type ch = &apos;x&apos;;       std::cmatch::difference_type dif = mr.begin() - mr.end();       std::cmatch::const_iterator cit = mr.begin();       std::cmatch::value_type val = *cit;       std::cmatch::const_reference cref = val;       std::cmatch::reference ref = val;       maxsiz = maxsiz;  // to quiet &quot;unused&quot; warnings       if (ref == cref)           ch = ch;       dif = dif;       return (0);       }</code></pre><h2 id="sub-match"><a href="#sub-match" class="headerlink" title="sub_match"></a><code>sub_match</code></h2><pre><code>// std__regex__sub_match_compare.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex rx(&quot;c(a*)|(b)&quot;);       std::cmatch mr;       std::regex_search(&quot;xcaaay&quot;, mr, rx);       std::csub_match sub = mr[1];       std::cout &lt;&lt; &quot;matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; sub.matched &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;length == &quot; &lt;&lt; sub.length() &lt;&lt; std::endl;       std::csub_match::difference_type dif = std::distance(sub.first, sub.second);       std::cout &lt;&lt; &quot;difference == &quot; &lt;&lt; dif &lt;&lt; std::endl;       std::csub_match::iterator first = sub.first;       std::csub_match::iterator last = sub.second;       std::cout &lt;&lt; &quot;range == &quot; &lt;&lt; std::string(first, last)           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;string == &quot; &lt;&lt; sub &lt;&lt; std::endl;       std::csub_match::value_type *ptr = &quot;aab&quot;;       std::cout &lt;&lt; &quot;compare(\&quot;aab\&quot;) == &quot;           &lt;&lt; sub.compare(ptr) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;compare(string) == &quot;           &lt;&lt; sub.compare(std::string(&quot;AAA&quot;)) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;compare(sub) == &quot;           &lt;&lt; sub.compare(sub) &lt;&lt; std::endl;       return (0);       }</code></pre><h2 id="regex-error"><a href="#regex-error" class="headerlink" title="regex_error"></a><code>regex_error</code></h2><pre><code>// std__regex__regex_error_code.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex_error paren(std::regex_constants::error_paren);       try           {           std::regex rx(&quot;(a&quot;);           }       catch (const std::regex_error&amp; rerr)           {           std::cout &lt;&lt; &quot;regex error: &quot;               &lt;&lt; (rerr.code() == paren.code()                    &quot;unbalanced parentheses&quot; : &quot;&quot;)               &lt;&lt; std::endl;           }       catch (...)           {           std::cout &lt;&lt; &quot;unknown exception&quot; &lt;&lt; std::endl;           }       return (0);       }</code></pre><h2 id="regex-iterator"><a href="#regex-iterator" class="headerlink" title="regex_iterator"></a><code>regex_iterator</code></h2><pre><code>// std__regex__regex_iterator_difference_type.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_iterator&lt;const char *&gt; Myiter;   int main()       {       const char *pat = &quot;axayaz&quot;;       Myiter::regex_type rx(&quot;a&quot;);       Myiter next(pat, pat + strlen(pat), rx);       Myiter end;       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;   // other members       Myiter it1(pat, pat + strlen(pat), rx);       Myiter it2(it1);       next = it1;       Myiter::iterator_category cat = std::forward_iterator_tag();       Myiter::difference_type dif = -3;       Myiter::value_type mr = *it1;       Myiter::reference ref = mr;       Myiter::pointer ptr = &amp;ref;       dif = dif; // to quiet &quot;unused&quot; warnings       ptr = ptr;       return (0);       }</code></pre><h2 id="regex-token-iterator"><a href="#regex-token-iterator" class="headerlink" title="regex_token_iterator"></a><code>regex_token_iterator</code></h2><pre><code>#include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_token_iterator&lt;const char *&gt; Myiter;   int main()       {       const char *pat = &quot;aaxaayaaz&quot;;       Myiter::regex_type rx(&quot;(a)a&quot;);       Myiter next(pat, pat + strlen(pat), rx);       Myiter end;   // show whole match       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefix before match       next = Myiter(pat, pat + strlen(pat), rx, -1);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show (a) submatch only       next = Myiter(pat, pat + strlen(pat), rx, 1);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefixes and submatches       std::vector&lt;int&gt; vec;       vec.push_back(-1);       vec.push_back(1);       next = Myiter(pat, pat + strlen(pat), rx, vec);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefixes and whole matches       int arr[] = {-1, 0};       next = Myiter(pat, pat + strlen(pat), rx, arr);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // other members       Myiter it1(pat, pat + strlen(pat), rx);       Myiter it2(it1);       next = it1;       Myiter::iterator_category cat = std::forward_iterator_tag();       Myiter::difference_type dif = -3;       Myiter::value_type mr = *it1;       Myiter::reference ref = mr;       Myiter::pointer ptr = &amp;ref;       dif = dif; // to quiet &quot;unused&quot; warnings       ptr = ptr;       return (0);       }</code></pre><h2 id="regex-traits"><a href="#regex-traits" class="headerlink" title="regex_traits"></a><code>regex_traits</code></h2><pre><code>// std__regex__regex_traits_char_class_type.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_traits&lt;char&gt; Mytr;   int main()       {       Mytr tr;       Mytr::char_type ch = tr.translate(&apos;a&apos;);       std::cout &lt;&lt; &quot;translate(&apos;a&apos;) == &apos;a&apos; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (ch == &apos;a&apos;) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;nocase &apos;a&apos; == &apos;A&apos; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (tr.translate_nocase(&apos;a&apos;) == tr.translate_nocase(&apos;A&apos;))           &lt;&lt; std::endl;       const char *lbegin = &quot;abc&quot;;       const char *lend = lbegin + strlen(lbegin);       Mytr::size_type size = tr.length(lbegin);       std::cout &lt;&lt; &quot;length(\&quot;abc\&quot;) == &quot; &lt;&lt; size &lt;&lt;std::endl;       Mytr::string_type str = tr.transform(lbegin, lend);       std::cout &lt;&lt; &quot;transform(\&quot;abc\&quot;) &lt; \&quot;abc\&quot; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (str &lt; &quot;abc&quot;) &lt;&lt; std::endl;       const char *ubegin = &quot;ABC&quot;;       const char *uend = ubegin + strlen(ubegin);       std::cout &lt;&lt; &quot;primary \&quot;ABC\&quot; &lt; \&quot;abc\&quot; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (tr.transform_primary(ubegin, uend) &lt;               tr.transform_primary(lbegin, lend))           &lt;&lt; std::endl;       const char *dig = &quot;digit&quot;;       Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);       std::cout &lt;&lt; &quot;class digit == d == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (cl == tr.lookup_classname(dig, dig + 1))           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;&apos;3&apos; is digit == &quot; &lt;&lt;std::boolalpha           &lt;&lt; tr.isctype(&apos;3&apos;, tr.lookup_classname(dig, dig + 5))           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;hex C == &quot; &lt;&lt; tr.value(&apos;C&apos;, 16) &lt;&lt; std::endl;   // other members       str = tr.lookup_collatename(dig, dig + 5);       Mytr::locale_type loc = tr.getloc();       tr.imbue(loc);       return (0);       }</code></pre><h2 id="C-正则表达式库"><a href="#C-正则表达式库" class="headerlink" title="C++正则表达式库"></a>C++正则表达式库</h2><p><a href="http://zh.cppreference.com/w/cpp/regex" target="_blank" rel="noopener">C++正则表达式库</a></p><pre><code>#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;string&gt;#include &lt;regex&gt;int main(){    std::string s = &quot;Some people, when confronted with a problem, think &quot;        &quot;\&quot;I know, I&apos;ll use regular expressions.\&quot; &quot;        &quot;Now they have two problems.&quot;;    std::regex self_regex(&quot;REGULAR EXPRESSIONS&quot;,            std::regex_constants::ECMAScript | std::regex_constants::icase);    if (std::regex_search(s, self_regex)) {        std::cout &lt;&lt; &quot;Text contains the phrase &apos;regular expressions&apos;\n&quot;;    }    std::regex word_regex(&quot;(\\S+)&quot;);    auto words_begin =         std::sregex_iterator(s.begin(), s.end(), word_regex);    auto words_end = std::sregex_iterator();    std::cout &lt;&lt; &quot;Found &quot;              &lt;&lt; std::distance(words_begin, words_end)              &lt;&lt; &quot; words\n&quot;;    const int N = 6;    std::cout &lt;&lt; &quot;Words longer than &quot; &lt;&lt; N &lt;&lt; &quot; characters:\n&quot;;    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {        std::smatch match = *i;        std::string match_str = match.str();        if (match_str.size() &gt; N) {            std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match_str &lt;&lt; &apos;\n&apos;;        }    }    std::regex long_word_regex(&quot;(\\w{7,})&quot;);    std::string new_s = std::regex_replace(s, long_word_regex, &quot;[$&amp;]&quot;);    std::cout &lt;&lt; new_s &lt;&lt; &apos;\n&apos;;}</code></pre><h2 id="ECMA与POSIX区别"><a href="#ECMA与POSIX区别" class="headerlink" title="ECMA与POSIX区别"></a>ECMA与POSIX区别</h2><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;int main(){    std::string str = &quot;zzxayyzz&quot;;    std::regex re1(&quot;.*(a|xayy)&quot;); // ECMA    std::regex re2(&quot;.*(a|xayy)&quot;, std::regex::extended); // POSIX    std::cout &lt;&lt; &quot;Searching for .*(a|xayy) in zzxayyzz:\n&quot;;    std::smatch m;    std::regex_search(str, m, re1);    std::cout &lt;&lt; &quot; ECMA (depth first search) match: &quot; &lt;&lt; m[0] &lt;&lt; &apos;\n&apos;;    std::regex_search(str, m, re2);    std::cout &lt;&lt; &quot; POSIX (leftmost longest)  match: &quot; &lt;&lt; m[0] &lt;&lt; &apos;\n&apos;;}</code></pre><h1 id="boost-regex"><a href="#boost-regex" class="headerlink" title="boost regex"></a>boost regex</h1><p>1 boost::regex_match</p><p>正则表达式匹配</p><p>2 boost::regex_replace</p><p>正则表达式替换</p><p>3 boost::regex_search</p><p>正则表达式检索</p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;void main(){    std::string str = &quot;chinaen 8Glish&quot;;    boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);    //+ 用来表示重复一或多次    //d-digit 任何0-9之间的数字    //s-space 任何空格字符    //u-upper A-Z之间的大写字母。如果设置了地域的话，可能包含其他字符    //w-word 任何单词字符-字母数字下划线    std::cout &lt;&lt; boost::regex_match(str, expr) &lt;&lt; std::endl;//匹配1，不匹配0    boost::smatch what;    if (boost::regex_search(str, what, expr))//正则表达式检索    {        std::cout &lt;&lt; what[0] &lt;&lt; std::endl;        std::cout &lt;&lt; what[1] &lt;&lt; std::endl;        std::cout &lt;&lt; what[2] &lt;&lt; std::endl;        std::cout &lt;&lt; what[3] &lt;&lt; std::endl;    }    else    {        std::cout &lt;&lt; &quot;检索失败&quot; &lt;&lt; std::endl;    }}</code></pre><p>boost::regex_replace</p><p>正则表达式替换</p><p>//s-space 任何空格字符</p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;void main(){    std::string str = &quot;chinaen 8Glish&quot;;    boost::regex expr(&quot;\\s&quot;);//s-space 任何空格字符    std::string tihuan = &quot;____&quot;;    std::cout &lt;&lt; boost::regex_replace(str, expr, tihuan) &lt;&lt; std::endl;//把expr替换}</code></pre><p>以上内容转载：<a href="https://www.cnblogs.com/denggelin/p/5769624.html" target="_blank" rel="noopener">https://www.cnblogs.com/denggelin/p/5769624.html</a></p><p><a href="https://yq.aliyun.com/articles/75580" target="_blank" rel="noopener">Boost学习之正则表达式–regex</a></p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;using namespace std;int main(int argc, char* argv[]){        //( 1 )   ((  3  )  2 )((  5 )4)(    6    )       //(\w+)://((\w+\.)*\w+)((/\w*)*)(/\w+\.\w+)?    //^协议://网址(x.x...x)/路径(n个\字串)/网页文件(xxx.xxx)    const char *szReg = &quot;(\\w+)://((\\w+\\.)*\\w+)((/\\w*)*)(/\\w+\\.\\w+)?&quot;;    const char *szStr = &quot;http://www.cppprog.com/2009/0112/48.html&quot;;    {    //字符串匹配        boost::regex reg( szReg );        bool r=boost::regex_match( szStr , reg);        assert(r);    }    {    //提取子串        boost::cmatch mat;        boost::regex reg( szReg );        bool r=boost::regex_match( szStr, mat, reg);        if(r) //如果匹配成功        {            //显示所有子串            for(boost::cmatch::iterator itr=mat.begin(); itr!=mat.end(); ++itr)            {                //       指向子串对应首位置        指向子串对应尾位置          子串内容                cout &lt;&lt; itr-&gt;first-szStr &lt;&lt; &apos; &apos; &lt;&lt; itr-&gt;second-szStr &lt;&lt; &apos; &apos; &lt;&lt; *itr &lt;&lt; endl;            }        }        //也可直接取指定位置信息        if(mat[4].matched) cout &lt;&lt; &quot;Path is&quot; &lt;&lt; mat[4] &lt;&lt; endl;    }    { //查找        boost::cmatch mat;        boost::regex reg( &quot;\\d+&quot; );    //查找字符串里的数字        if(boost::regex_search(szStr, mat, reg))        {            cout &lt;&lt; &quot;searched:&quot; &lt;&lt; mat[0] &lt;&lt; endl;        }    }    { //替换        boost::regex reg( szReg );        string s = boost::regex_replace( string(szStr), reg, &quot;ftp://$2$5&quot;);        cout &lt;&lt; &quot;ftp site:&quot;&lt;&lt; s &lt;&lt; endl;    }    { //替换2，把&lt;&gt;&amp;转换成网页字符        string s1 = &quot;(&lt;)|(&gt;)|(&amp;)&quot;;        string s2 = &quot;(?1&lt;)(?2&gt;)(?3&amp;)&quot;;        boost::regex reg( s1 );        string s = boost::regex_replace( string(&quot;cout &lt;&lt; a&amp;b &lt;&lt; endl;&quot;), reg, s2, boost::match_default | boost::format_all);        cout &lt;&lt; &quot;HTML:&quot;&lt;&lt; s &lt;&lt; endl;    }    { //使用迭代器找出所有数字        boost::regex reg( &quot;\\d+&quot; );    //查找字符串里的数字        boost::cregex_iterator itrBegin = make_regex_iterator(szStr,reg); //(szStr, szStr+strlen(szStr), reg);        boost::cregex_iterator itrEnd;        for(boost::cregex_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            //       指向子串对应首位置        指向子串对应尾位置          子串内容            cout &lt;&lt; (*itr)[0].first-szStr &lt;&lt; &apos; &apos; &lt;&lt; (*itr)[0].second-szStr &lt;&lt; &apos; &apos; &lt;&lt; *itr &lt;&lt; endl;        }    }    { //使用迭代器拆分字符串        boost::regex reg(&quot;/&quot;);  //按/符拆分字符串        boost::cregex_token_iterator itrBegin = make_regex_token_iterator(szStr,reg,-1); //使用-1参数时拆分，使用其它数字时表示取第几个子串，可使用数组取多个串        boost::cregex_token_iterator itrEnd;        for(boost::cregex_token_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            cout &lt;&lt; *itr &lt;&lt; endl;        }    }    { //使用迭代器拆分字符串2        boost::regex reg(&quot;(.)/(.)&quot;);  //取/的前一字符和后一字符（这个字符串形象貌似有点邪恶-_-）        int subs[] = {1,2};        // 第一子串和第二子串        boost::cregex_token_iterator itrBegin = make_regex_token_iterator(szStr,reg,subs); //使用-1参数时拆分，使用其它数字时表示取第几个子串，可使用数组取多个串        boost::cregex_token_iterator itrEnd;        for(boost::cregex_token_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            cout &lt;&lt; *itr &lt;&lt; endl;        }    }    cin.get();    return 0;}</code></pre><p><a href="https://blog.csdn.net/leonardwang/article/details/6035171?spm=a2c4e.11153940.blogcont75580.15.3a02b5f4uSDlxO" target="_blank" rel="noopener">正则表达式 boost Regex</a></p><h1 id="NET-正则表达式"><a href="#NET-正则表达式" class="headerlink" title=".NET 正则表达式"></a>.NET 正则表达式</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions</a></p><p><a href="http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx" target="_blank" rel="noopener">http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference" target="_blank" rel="noopener">正则表达式语言 - 快速参考</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx" target="_blank" rel="noopener">Regex 类</a></p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="http://www.zjmainstay.cn/regexp-lookaround" target="_blank" rel="noopener">深入理解正则表达式环视的概念与用法</a></p><p><a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">表达式全集</a></p><p><a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></p><p><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="noopener">揭开正则表达式的神秘面纱</a></p><p><a href="http://blog.jobbole.com/96708/" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a></p><p><a href="http://blog.jobbole.com/75188/" target="_blank" rel="noopener">Python正则表达式指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-regex&quot;&gt;&lt;a href=&quot;#c-regex&quot; class=&quot;headerlink&quot; title=&quot;c regex&quot;&gt;&lt;/a&gt;c regex&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;编译正则表达式 &lt;code&gt;regcomp()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配正则
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="正则表达式" scheme="https://caojingyou.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="regex" scheme="https://caojingyou.github.io/tags/regex/"/>
    
      <category term="Boost" scheme="https://caojingyou.github.io/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>zlib</title>
    <link href="https://caojingyou.github.io/2018/04/01/zlib/"/>
    <id>https://caojingyou.github.io/2018/04/01/zlib/</id>
    <published>2018-04-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:18:53.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="http://www.zlib.net/" title="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a></p><p><a href="https://github.com/madler/zlib" title="https://github.com/madler/zlib" target="_blank" rel="noopener">https://github.com/madler/zlib</a></p><p><a href="http://www.zlib.net/fossils/" title="http://www.zlib.net/fossils/" target="_blank" rel="noopener">http://www.zlib.net/fossils/</a></p><p><a href="https://github.com/madler/zlib/archive/v1.2.11.zip" title="https://github.com/madler/zlib/archive/v1.2.11.zip" target="_blank" rel="noopener">zlib1.2.11.zip</a></p><h2 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h2><p>可从此处直接下载：</p><p><a href="http://www.winimage.com/zLibDll" title="http://www.winimage.com/zLibDll" target="_blank" rel="noopener">http://www.winimage.com/zLibDll</a></p><p>解压后，进入到zlib-1.2.11/contrib/masmx86目录，执行bld_ml32.bat。（同理，64位的电脑进入masmx64目录，执行bld_ml64.bat）。这一步运行bld_ml32批处理文件，里面调用ml命令编译inffas32.asm和match686.asm，生成inffas32.obj和match686.obj（生成在本目录下）。这两个文件在zlibvc中用到。</p><p>实际已提供了在vc下编译的工程，目录为：zlib-1.2.11\contrib\vstudio.此项目的生成事件中已经执行了bld_ml32.bat</p><p>  其中的zlibstat是编译为静态库，zlibvc是编译为动态库。</p><p>如果报错：</p><p>fatal error LNK1281: 无法生成 SAFESEH 映像。</p><p>修改配置-连接器-高级-映像具有安全异常处理程序，改成“否(/SAFESEH:NO)”</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="使用zlib静态库：zlibstat-lib"><a href="#使用zlib静态库：zlibstat-lib" class="headerlink" title="使用zlib静态库：zlibstat.lib"></a>使用zlib静态库：zlibstat.lib</h3><ol><li><p>包含头文件</p><p> 属性–C/C++–常规–附加包含目录（添加包含.h文件的目录）</p></li><li><p>定义宏</p><p> 属性–C/C++–预处理器–预处理器定义：添加 ZLIB_WINAPI ASMV ASMINF</p></li><li><p>项目包含.lib文件所在的目录：</p><p> 属性–链接器–常规–附加库目录</p></li><li><p>项目包含.lib文件</p><p> 属性–链接器–输入–附加依赖项（libstat.lib）</p></li><li><p>项目代码中 #include “zlib.h”</p></li></ol><p>编译生成.exe即可使用。</p><h3 id="使用动态库-zlibwapi-lib"><a href="#使用动态库-zlibwapi-lib" class="headerlink" title="使用动态库 zlibwapi.lib"></a>使用动态库 zlibwapi.lib</h3><ol><li><p>包含头文件</p><p> 属性–C/C++–常规–附加包含目录（添加包含.h的目录）</p></li><li><p>定义宏</p><p> 属性–C/C++–预处理器–预处理器定义：添加 ZLIB_WINAPI</p></li><li><p>项目包含.lib文件所在的目录：</p><p> 属性–链接器–常规–附加库目录</p></li><li><p>项目包含.lib文件</p><p> 属性–链接器–输入–附加依赖项（zlibwapi.lib）</p></li><li><p>项目代码中 #include “zlib.h”</p></li></ol><p>编译生成.exe文件需要.dll文件支持（动态加载）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zlib&quot;&gt;&lt;a href=&quot;#zlib&quot; class=&quot;headerlink&quot; title=&quot;zlib&quot;&gt;&lt;/a&gt;zlib&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=&quot;下载：&quot;&gt;&lt;/a&gt;下载
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="zlib" scheme="https://caojingyou.github.io/tags/zlib/"/>
    
      <category term="解压缩" scheme="https://caojingyou.github.io/tags/%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>tesseract-ocr</title>
    <link href="https://caojingyou.github.io/2018/03/26/tesseract-ocr/"/>
    <id>https://caojingyou.github.io/2018/03/26/tesseract-ocr/</id>
    <published>2018-03-26T09:01:00.000Z</published>
    <updated>2018-03-26T09:52:57.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中文OCR"><a href="#Python-中文OCR" class="headerlink" title="Python 中文OCR"></a>Python 中文OCR</h1><p><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></p><p><a href="https://digi.bib.uni-mannheim.de/tesseract/doc/" target="_blank" rel="noopener">https://digi.bib.uni-mannheim.de/tesseract/doc/</a></p><p><a href="https://blog.csdn.net/wwj_748/article/details/78109680?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Python 中文OCR</a></p><p>Tesseract的OCR引擎目前已作为开源项目发布在Google Project，其项目主页在这里查看<a href="https://github.com/tesseract-ocr" target="_blank" rel="noopener">https://github.com/tesseract-ocr</a>，<br>它支持中文OCR，并提供了一个命令行工具。python中对应的包是pytesseract. 通过这个工具我们可以识别图片上的文字。</p><h1 id="tesseract安装"><a href="#tesseract安装" class="headerlink" title="tesseract安装"></a>tesseract安装</h1><p><a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki</a></p><p><a href="https://github.com/UB-Mannheim/tesseract/wiki" target="_blank" rel="noopener">https://github.com/UB-Mannheim/tesseract/wiki</a></p><p><a href="https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html</a></p><p>需要把安装路径设置到环境变量中</p><h1 id="运行-Tesseract"><a href="#运行-Tesseract" class="headerlink" title="运行 Tesseract"></a>运行 Tesseract</h1><p>Tesseract 是 命令行 程序 ， 那么 第一 终端 或者 打开 一个 命令 提示 。 在 命令 使用 过程 是 这样 的 ：</p><pre><code>tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</code></pre><p>结果 保存 到  out.txt </p><pre><code>tesseract myscan.png out</code></pre><p> 用于 多个 语言</p><pre><code>tesseract myscan.png out -l eng+deu</code></pre><p><a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc" target="_blank" rel="noopener">其他各种选项</a></p><p>1.jpg是当前目录中的1.jpg图片</p><p>1.txt是指定结果输出到文本文件</p><p>-l是指定使用的包</p><p>chi_sim是中文识别包，equ是数学公式包，eng是英文包</p><pre><code>tesseract 1.jpg 1.txt -l chi_sim+equ+eng</code></pre><h1 id="其他-语言"><a href="#其他-语言" class="headerlink" title="其他 语言"></a>其他 语言</h1><p><a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">语言 tessdata 储存库 </a></p><h1 id="训练语言"><a href="#训练语言" class="headerlink" title="训练语言"></a>训练语言</h1><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract</a></p><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00</a></p><p><a href="https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/" title="jTessBoxEditor" target="_blank" rel="noopener">jTessBoxEditor</a></p><p><a href="https://blog.csdn.net/cn_wk/article/details/52280567" target="_blank" rel="noopener">https://blog.csdn.net/cn_wk/article/details/52280567</a></p><p><a href="http://www.bkjia.com/Pythonjc/1131343.html" target="_blank" rel="noopener">http://www.bkjia.com/Pythonjc/1131343.html</a></p><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/AddOns" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/AddOns</a></p><p><a href="http://zdenop.github.io/qt-box-editor/" target="_blank" rel="noopener">http://zdenop.github.io/qt-box-editor/</a></p><p><a href="https://www.cnblogs.com/cnlian/p/5765871.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnlian/p/5765871.html</a></p><p>大体流程为：安装jTessBoxEditor -&gt; 获取样本文件 -&gt; Merge样本文件 –&gt; 生成BOX文件 -&gt; 定义字符配置文件 -&gt; 字符矫正 -&gt; 执行批处理文件 -&gt; 将生成的traineddata放入tessdata中</p><p><a href="https://jingyan.baidu.com/article/cdddd41c90544f53cb00e1c3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/cdddd41c90544f53cb00e1c3.html</a></p><p><a href="https://blog.csdn.net/woaipangruimao/article/details/78741022" target="_blank" rel="noopener">https://blog.csdn.net/woaipangruimao/article/details/78741022</a></p><h1 id="python-pytesseract"><a href="#python-pytesseract" class="headerlink" title="python pytesseract"></a>python pytesseract</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014320027235877860c87af5544f25a8deeb55141d60c5000" target="_blank" rel="noopener">Pillow</a></p><p><a href="https://pillow.readthedocs.org/" target="_blank" rel="noopener">https://pillow.readthedocs.org/</a></p><p><a href="https://pypi.python.org/pypi/pytesseract" target="_blank" rel="noopener">https://pypi.python.org/pypi/pytesseract</a></p><pre><code>pip install pytesseractpip install pillow</code></pre><p>code:</p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-import pytesseractfrom PIL import Imagepytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos;# open imageimage = Image.open(&apos;test.png&apos;)code = pytesseract.image_to_string(image, lang=&apos;chi_sim&apos;)print(code)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-中文OCR&quot;&gt;&lt;a href=&quot;#Python-中文OCR&quot; class=&quot;headerlink&quot; title=&quot;Python 中文OCR&quot;&gt;&lt;/a&gt;Python 中文OCR&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/te
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
      <category term="tesseract" scheme="https://caojingyou.github.io/tags/tesseract/"/>
    
      <category term="ocr" scheme="https://caojingyou.github.io/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>C#调用C++</title>
    <link href="https://caojingyou.github.io/2018/03/21/CShap%E8%B0%83%E7%94%A8C++/"/>
    <id>https://caojingyou.github.io/2018/03/21/CShap调用C++/</id>
    <published>2018-03-21T01:53:00.000Z</published>
    <updated>2018-04-13T07:21:38.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="互操作"><a href="#互操作" class="headerlink" title="互操作"></a>互操作</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms177552(v=vs.90" target="_blank" rel="noopener">互操作</a>.aspx)<br>包含以下内容：</p><ul><li>CLR/本机互操作性</li><li>C++ Interop</li><li>COM 互操作</li><li>P/Invoke</li><li>C++ 支持库</li><li>在 MFC 中使用 Windows 窗体</li></ul><h1 id="P-Invoke"><a href="#P-Invoke" class="headerlink" title="P/Invoke"></a>P/Invoke</h1><p><a href="https://baike.baidu.com/item/P%2FInvoke/9872691?fr=aladdin" target="_blank" rel="noopener">P/Invoke</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/aa686045.aspx" title="https://msdn.microsoft.com/zh-cn/library/aa686045.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/aa686045.aspx</a></p><p><a href="https://www.zhihu.com/question/55901875" title="https://www.zhihu.com/question/55901875" target="_blank" rel="noopener">https://www.zhihu.com/question/55901875</a></p><h1 id="C-CLI"><a href="#C-CLI" class="headerlink" title="C++/CLI"></a>C++/CLI</h1><p><a href="https://baike.baidu.com/item/C++%2FCLI/8375456?fr=aladdin" target="_blank" rel="noopener">C++/CLI</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx</a>.aspx “<a href="https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx</a>“)</p><p><a href="http://www.cnblogs.com/TianFang/p/4946049.html" title="http://www.cnblogs.com/TianFang/p/4946049.html" target="_blank" rel="noopener">http://www.cnblogs.com/TianFang/p/4946049.html</a></p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/2x8kf7zx(v=vs.120" target="_blank" rel="noopener">使用 C++ 互操作（隐式 PInvoke）</a>.aspx “使用 C++ 互操作（隐式 PInvoke）”)</p><p><a href="https://msdn.microsoft.com/zh-cn/library/eyzhw3s8(v=vs.120" target="_blank" rel="noopener">在 C++ 中使用显式 PInvoke（DllImport 特性）</a>.aspx)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;互操作&quot;&gt;&lt;a href=&quot;#互操作&quot; class=&quot;headerlink&quot; title=&quot;互操作&quot;&gt;&lt;/a&gt;互操作&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/ms177552(v=vs.90
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Photoshop插件开发</title>
    <link href="https://caojingyou.github.io/2018/03/20/Adobe%20Photoshop%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/03/20/Adobe Photoshop插件开发/</id>
    <published>2018-03-20T01:53:00.000Z</published>
    <updated>2018-04-13T07:23:15.537Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.adobe.com/devnet/photoshop/sdk.html" title="https://www.adobe.com/devnet/photoshop/sdk.html" target="_blank" rel="noopener">Photoshop SDK</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.adobe.com/devnet/photoshop/sdk.html&quot; title=&quot;https://www.adobe.com/devnet/photoshop/sdk.html&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Photoshop插件" scheme="https://caojingyou.github.io/tags/Photoshop%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins</title>
    <link href="https://caojingyou.github.io/2018/03/02/Jenkins/"/>
    <id>https://caojingyou.github.io/2018/03/02/Jenkins/</id>
    <published>2018-03-02T01:53:00.000Z</published>
    <updated>2018-04-13T07:19:36.684Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a></p><p><a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/solutions/c/</a></p><p><a href="https://www.cnblogs.com/huangenai/p/7416322.html" target="_blank" rel="noopener">记密码解决方法</a></p><h1 id="安装-MSBuild-plugin"><a href="#安装-MSBuild-plugin" class="headerlink" title="安装 MSBuild plugin"></a>安装 MSBuild plugin</h1><p>在 Jenkins 管理页面中，点击[插件管理]进入插件管理页面，切换到[可选插件]页签，在右上角搜索框中输入 MSBuild 找到 MSBuild Plugin，点击[直接安装]按钮开始安装</p><p>安装好之后，就会在[已安装]页签找到 MSBuild Plugin。<br>回到 Jenkins 管理页面中，点击[Global Tool Configuration]，进入全局工具设置页面。</p><p>找到[MSBuild]栏目，点击[新增MSBuild]按钮，[Name]随意填写，使用MSBuild 14.0。[Path to MSBuild]填写MSBuild.exe所在的实际路径。</p><p>.\build\src\AppName.sln</p><p>/t:rebuild /p:configuration=”Release”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Jenkins" scheme="https://caojingyou.github.io/tags/Jenkins/"/>
    
      <category term="自动构建" scheme="https://caojingyou.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>WPF读写config配置文件</title>
    <link href="https://caojingyou.github.io/2018/03/01/WPF%E8%AF%BB%E5%86%99config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2018/03/01/WPF读写config配置文件/</id>
    <published>2018-03-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:08:08.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h1><p>在引用里添加</p><pre><code>System.Configuration</code></pre><p>如果你想给程序配置一些参数，就在app.config文件<configuration>标签中添加<appsettings>.例如下面：</appsettings></configuration></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;  &lt;configuration&gt;    &lt;appSettings&gt;      &lt;add key=&quot;Path&quot; value=&quot;D:\&quot;/&gt;      &lt;add key=&quot;NAME&quot; value=&quot;123&quot;/&gt;    &lt;/appSettings&gt;  &lt;/configuration&gt;</code></pre><p>读操作：</p><pre><code>string strPath = ConfigurationManager.AppSettings[&quot;Path&quot;]; </code></pre><p>写操作：</p><pre><code>Configuration cfa = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); cfa.AppSettings.Settings[&quot;NAME&quot;].Value = &quot;WANGLICHAO&quot;; cfa.Save(); </code></pre><p>是配置立刻起作用：</p><pre><code>Save()</code></pre><p>后加</p><pre><code>ConfigurationManager.RefreshSection(&quot;appSettings&quot;);</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://www.cnblogs.com/fei12/p/3331100.html" target="_blank" rel="noopener">WPF读写config配置文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设置：&quot;&gt;&lt;a href=&quot;#设置：&quot; class=&quot;headerlink&quot; title=&quot;设置：&quot;&gt;&lt;/a&gt;设置：&lt;/h1&gt;&lt;p&gt;在引用里添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.Configuration
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你想给程序
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="WPF" scheme="https://caojingyou.github.io/tags/WPF/"/>
    
      <category term="配置文件" scheme="https://caojingyou.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>VA Snippet 与 代码片段管理器</title>
    <link href="https://caojingyou.github.io/2018/02/21/VA%20Snippet%20%E4%B8%8E%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>https://caojingyou.github.io/2018/02/21/VA Snippet 与 代码片段管理器/</id>
    <published>2018-02-21T08:03:00.000Z</published>
    <updated>2018-04-12T06:24:19.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VA-Snippet"><a href="#VA-Snippet" class="headerlink" title="VA Snippet"></a>VA Snippet</h1><p><a href="http://docs.wholetomato.com/default.asp?W171" target="_blank" rel="noopener">Introduction to VA Snippets</a></p><h2 id="备份VA-Snippet-tpl文件"><a href="#备份VA-Snippet-tpl文件" class="headerlink" title="备份VA Snippet.tpl文件"></a>备份VA Snippet.tpl文件</h2><p>Backup your current VA Snippets, for the programming languages of interest. You can find your VA Snippets in .tpl files in:</p><pre><code>%APPDATA%\VisualAssist\Autotext\</code></pre><h1 id="代码片段管理器"><a href="#代码片段管理器" class="headerlink" title="代码片段管理器"></a>代码片段管理器</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VA-Snippet&quot;&gt;&lt;a href=&quot;#VA-Snippet&quot; class=&quot;headerlink&quot; title=&quot;VA Snippet&quot;&gt;&lt;/a&gt;VA Snippet&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://docs.wholetomato.com/d
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VS" scheme="https://caojingyou.github.io/tags/VS/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="代码片段" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>C#用到的库</title>
    <link href="https://caojingyou.github.io/2018/02/15/CShap%E7%94%A8%E5%88%B0%E8%BF%87%E7%9A%84%E5%BA%93/"/>
    <id>https://caojingyou.github.io/2018/02/15/CShap用到过的库/</id>
    <published>2018-02-15T08:03:00.000Z</published>
    <updated>2018-05-17T02:24:21.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扁平化界面"><a href="#扁平化界面" class="headerlink" title="扁平化界面"></a>扁平化界面</h1><p>MahApps.Metro</p><p>MahApps.Metro.IconPacks</p><p>MahApps.Metro.Resources</p><h1 id="系统托盘图标"><a href="#系统托盘图标" class="headerlink" title="系统托盘图标"></a>系统托盘图标</h1><p>WPF NotifyIcon</p><h1 id="Json-NET"><a href="#Json-NET" class="headerlink" title="Json.NET"></a>Json.NET</h1><p>Json.NET可序列化和反序列化、可以转成xml</p><h1 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h1><p>Entity Framework</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Nlog</p><p>log4net</p><h1 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h1><p>MailKit<br>与<br>MimeKit</p><h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p>EasyHttp</p><p>httplib好用</p><h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><p>Epplus</p><p>NPIO</p><h1 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h1><p>TaskScheduler</p><p>TaskSchedulerEditor</p><h1 id="待研究的库"><a href="#待研究的库" class="headerlink" title="待研究的库"></a>待研究的库</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>NUnit</p><h2 id="界面库"><a href="#界面库" class="headerlink" title="界面库"></a>界面库</h2><p>MaterialDesignInXamlToolkit</p><p>Fluent.Ribbon</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扁平化界面&quot;&gt;&lt;a href=&quot;#扁平化界面&quot; class=&quot;headerlink&quot; title=&quot;扁平化界面&quot;&gt;&lt;/a&gt;扁平化界面&lt;/h1&gt;&lt;p&gt;MahApps.Metro&lt;/p&gt;
&lt;p&gt;MahApps.Metro.IconPacks&lt;/p&gt;
&lt;p&gt;MahApp
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
      <category term="扁平化" scheme="https://caojingyou.github.io/tags/%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    
      <category term="Json.NET" scheme="https://caojingyou.github.io/tags/Json-NET/"/>
    
      <category term="log4net" scheme="https://caojingyou.github.io/tags/log4net/"/>
    
      <category term="Nlog" scheme="https://caojingyou.github.io/tags/Nlog/"/>
    
      <category term="MailKit" scheme="https://caojingyou.github.io/tags/MailKit/"/>
    
      <category term="EasyHttp" scheme="https://caojingyou.github.io/tags/EasyHttp/"/>
    
      <category term="httplib" scheme="https://caojingyou.github.io/tags/httplib/"/>
    
      <category term="Epplus" scheme="https://caojingyou.github.io/tags/Epplus/"/>
    
      <category term="NPIO" scheme="https://caojingyou.github.io/tags/NPIO/"/>
    
      <category term="TaskScheduler" scheme="https://caojingyou.github.io/tags/TaskScheduler/"/>
    
      <category term="NUnit" scheme="https://caojingyou.github.io/tags/NUnit/"/>
    
      <category term="MaterialDesignInXamlToolkit" scheme="https://caojingyou.github.io/tags/MaterialDesignInXamlToolkit/"/>
    
      <category term="Fluent.Ribbon" scheme="https://caojingyou.github.io/tags/Fluent-Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>libcur</title>
    <link href="https://caojingyou.github.io/2018/02/12/libcur%E4%BD%BF%E7%94%A8/"/>
    <id>https://caojingyou.github.io/2018/02/12/libcur使用/</id>
    <published>2018-02-12T08:03:00.000Z</published>
    <updated>2018-04-12T06:48:47.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h1><p><code>curl-curl-7_54_0.zip</code></p><p><a href="https://curl.haxx.se/download.html" title="https://curl.haxx.se/download.html" target="_blank" rel="noopener">https://curl.haxx.se/download.html</a></p><h1 id="github"><a href="#github" class="headerlink" title="github:"></a>github:</h1><p><a href="https://github.com/curl/curl" title="https://github.com/curl/curl" target="_blank" rel="noopener">https://github.com/curl/curl</a></p><h1 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h1><p>运行：curl\projects\generate.bat，生成vs工具可以打开的文件。</p><h2 id="需要用到其他库："><a href="#需要用到其他库：" class="headerlink" title="需要用到其他库："></a>需要用到其他库：</h2><p><a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>, <a href="https://www.wolfssl.com/wolfSSL/Home.html" target="_blank" rel="noopener">wolfSSL</a> and <a href="https://www.libssh2.org/" target="_blank" rel="noopener">SSH2</a></p><h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><p>预处理器定义添加：<code>CURL_STATICLIB</code></p><p>附加依赖项：</p><pre><code>libcurl.libws2_32.libwinmm.libwldap32.lib</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://blog.csdn.net/huyiyang2010/article/details/7664201" title="http://blog.csdn.net/huyiyang2010/article/details/7664201" target="_blank" rel="noopener">http://blog.csdn.net/huyiyang2010/article/details/7664201</a></p><p><a href="http://blog.csdn.net/fengshuiyue/article/details/39530093/" title="http://blog.csdn.net/fengshuiyue/article/details/39530093/" target="_blank" rel="noopener">http://blog.csdn.net/fengshuiyue/article/details/39530093/</a></p><p><a href="http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html" title="http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html" target="_blank" rel="noopener">http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html</a></p><p><a href="http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq" title="http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq" target="_blank" rel="noopener">http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq</a></p><p><a href="https://curl.haxx.se/libcurl/c/libcurl-tutorial.html" title="https://curl.haxx.se/libcurl/c/libcurl-tutorial.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/libcurl-tutorial.html</a></p><p><a href="https://curl.haxx.se/libcurl/c/example.html" title="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/example.html</a></p><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p><a href="http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html" title="http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html" target="_blank" rel="noopener">http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=&quot;下载：&quot;&gt;&lt;/a&gt;下载：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;curl-curl-7_54_0.zip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.hax
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="libcur" scheme="https://caojingyou.github.io/tags/libcur/"/>
    
      <category term="网络" scheme="https://caojingyou.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SVN版本号</title>
    <link href="https://caojingyou.github.io/2018/02/08/SVN%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://caojingyou.github.io/2018/02/08/SVN版本号/</id>
    <published>2018-02-08T07:24:00.000Z</published>
    <updated>2018-03-07T06:05:11.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVN获取版本号"><a href="#SVN获取版本号" class="headerlink" title="SVN获取版本号"></a>SVN获取版本号</h1><h2 id="version-template-h"><a href="#version-template-h" class="headerlink" title="version_template.h"></a>version_template.h</h2><pre><code>#ifndef _VERSION_H_#define _VERSION_H_#define VER_MAJOR 1#define VER_MINOR 0#define VER_REVISION $WCREV$#define SVN_REVISION&quot;$WCMIXED?$WCRANGE$:$WCREV$$&quot;#define SVN_RANGE   $WCRANGE$#define SVN_REV $WCREV$#define SVN_REVISION&quot;$WCMIXED?SVN_RANGE:SVN_REV$&quot;#endif //!_VERSION_H_// Test file for SubWCRevchar *Revision  = &quot;$WCREV$&quot;;char *Revision16= &quot;$WCREV&amp;0xFF$&quot;;char *Revisionp100  = &quot;$WCREV+100$&quot;;char *Revisionm100  = &quot;$WCREV-100$&quot;;char *Modified  = &quot;$WCMODS?Modified:Not modified$&quot;;char *Unversioned   = &quot;$WCUNVER?Unversioned items found:no unversioned items$&quot;;char *Date  = &quot;$WCDATE$&quot;;char *CustDate  = &quot;$WCDATE=%a, %d %B %Y$&quot;;char *DateUTC   = &quot;$WCDATEUTC$&quot;;char *CustDateUTC   = &quot;$WCDATEUTC=%a, %d %B %Y$&quot;;char *TimeNow   = &quot;$WCNOW$&quot;;char *TimeNowUTC= &quot;$WCNOWUTC$&quot;;char *RevRange  = &quot;$WCRANGE$&quot;;char *Mixed = &quot;$WCMIXED?Mixed revision WC:Not mixed$&quot;;char *ExtAllFixed   = &quot;$WCEXTALLFIXED?All externals fixed:Not all externals fixed$&quot;;char *IsTagged  = &quot;$WCISTAGGED?Tagged:Not tagged$&quot;;char *URL   = &quot;$WCURL$&quot;;char *isInSVN   = &quot;$WCINSVN?versioned:not versioned$&quot;;char *needslck  = &quot;$WCNEEDSLOCK?TRUE:FALSE$&quot;;char *islocked  = &quot;$WCISLOCKED?locked:not locked$&quot;;char *lockdateutc   = &quot;$WCLOCKDATEUTC$&quot;;char *lockdate  = &quot;$WCLOCKDATE$&quot;;char *lockcustutc   = &quot;$WCLOCKDATEUTC=%a, %d %B %Y$&quot;;char *lockcust  = &quot;$WCLOCKDATE=%a, %d %B %Y$&quot;;char *lockown   = &quot;$WCLOCKOWNER$&quot;;char *lockcmt   = &quot;$WCLOCKCOMMENT$&quot;;#if $WCMODS?1:0$#error Source is modified#endif// End of file</code></pre><h2 id="运行bat"><a href="#运行bat" class="headerlink" title="运行bat"></a>运行bat</h2><pre><code>setlocal::设置svn客户端安装目录set SVN_PATH=D:\Program Files\TortoiseSVN\bin ::设置工作目录，即工程目录set WORK_DIR=E:\code\C++\Demo::设置版本模版文件，对应第一步中新建的模板文件set VERSION_TEMPLATE=E:\code\C++\Demo\version_template.h::设置版本号生成文件，生成的文件就是我们需要使用的版本文件set VERSION_RELEASE=E:\code\C++\Demo\version.h::进入svn客户端安装目录cd %SVN_PATH%::执行更新版本号操作&quot;%SVN_PATH%\SubWCRev.exe&quot; &quot;%WORK_DIR%&quot; &quot;%VERSION_TEMPLATE%&quot; &quot;%VERSION_RELEASE%&quot;endlocal</code></pre><h2 id="生成version-h"><a href="#生成version-h" class="headerlink" title="生成version.h"></a>生成version.h</h2><pre><code>#ifndef _VERSION_H_#define _VERSION_H_#define VER_MAJOR 1#define VER_MINOR 0#define VER_REVISION 6185#define SVN_REVISION&quot;4620&quot;#define SVN_RANGE   4620:6185#define SVN_REV 6185#define SVN_REVISION&quot;SVN_RANGE&quot;#endif //!_VERSION_H_// Test file for SubWCRevchar *Revision  = &quot;6185&quot;;char *Revision16= &quot;41&quot;;char *Revisionp100  = &quot;6285&quot;;char *Revisionm100  = &quot;6085&quot;;char *Modified  = &quot;Modified&quot;;char *Unversioned   = &quot;Unversioned items found&quot;;char *Date  = &quot;2018/02/07 10:00:58&quot;;char *CustDate  = &quot;Wed, 07 February 2018&quot;;char *DateUTC   = &quot;2018/02/07 02:00:58&quot;;char *CustDateUTC   = &quot;Wed, 07 February 2018&quot;;char *TimeNow   = &quot;2018/02/08 14:56:08&quot;;char *TimeNowUTC= &quot;2018/02/08 06:56:08&quot;;char *RevRange  = &quot;4620:6185&quot;;char *Mixed = &quot;Mixed revision WC&quot;;char *ExtAllFixed   = &quot;All externals fixed&quot;;char *IsTagged  = &quot;Not tagged&quot;;char *URL   = &quot;http://xxx&quot;;char *isInSVN   = &quot;versioned&quot;;char *needslck  = &quot;FALSE&quot;;char *islocked  = &quot;not locked&quot;;char *lockdateutc   = &quot;1970/01/01 00:00:00&quot;;char *lockdate  = &quot;1970/01/01 08:00:00&quot;;char *lockcustutc   = &quot;Thu, 01 January 1970&quot;;char *lockcust  = &quot;Thu, 01 January 1970&quot;;char *lockown   = &quot;&quot;;char *lockcmt   = &quot;&quot;;#if 1#error Source is modified#endif// End of file</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>在VS2005的项目属性页-&gt;预生成事件-&gt;命令行中添加一句：</p><pre><code>$(SolutionDir)\subwcrev.exe $(SolutionDir) $(SolutionDir)\src\qmlv\version_template.h $(SolutionDir)\src\qmlv\version.h</code></pre><p>SubWCRev 调用语法:</p><pre><code>SubWCRev WorkingCopyPath [SrcVersionFile DstVersionFile]</code></pre><h1 id="svn版本日志"><a href="#svn版本日志" class="headerlink" title="svn版本日志"></a>svn版本日志</h1><p>Apache-Subversion-1.9.7：</p><pre><code>&quot;svn.exe&quot; log --incremental -r4620&quot;svn.exe&quot; log --incremental -r4522</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html" title="https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html</a></p><p><a href="http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html" title="http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html</a></p><p><a href="https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html" title="https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html</a></p><p><a href="http://blog.csdn.net/yangxiao2shi/article/details/50719286/" title="http://blog.csdn.net/yangxiao2shi/article/details/50719286/" target="_blank" rel="noopener">http://blog.csdn.net/yangxiao2shi/article/details/50719286/</a></p><p><a href="https://www.visualsvn.com/support/svnbook/ref/svn/" title="https://www.visualsvn.com/support/svnbook/ref/svn/" target="_blank" rel="noopener">https://www.visualsvn.com/support/svnbook/ref/svn/</a></p><p><a href="https://www.visualsvn.com/support/svnbook/ref/svn/c/log/" title="https://www.visualsvn.com/support/svnbook/ref/svn/c/log/" target="_blank" rel="noopener">https://www.visualsvn.com/support/svnbook/ref/svn/c/log/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SVN获取版本号&quot;&gt;&lt;a href=&quot;#SVN获取版本号&quot; class=&quot;headerlink&quot; title=&quot;SVN获取版本号&quot;&gt;&lt;/a&gt;SVN获取版本号&lt;/h1&gt;&lt;h2 id=&quot;version-template-h&quot;&gt;&lt;a href=&quot;#version-tem
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="svn" scheme="https://caojingyou.github.io/tags/svn/"/>
    
      <category term="版本号" scheme="https://caojingyou.github.io/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL</title>
    <link href="https://caojingyou.github.io/2018/02/02/OpenSSL/"/>
    <id>https://caojingyou.github.io/2018/02/02/OpenSSL/</id>
    <published>2018-02-02T08:03:00.000Z</published>
    <updated>2018-04-12T06:25:41.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h1><p><a href="https://www.openssl.org/" title="https://www.openssl.org/" target="_blank" rel="noopener">https://www.openssl.org/</a></p><p><a href="https://github.com/openssl/openssl" title="https://github.com/openssl/openssl" target="_blank" rel="noopener">https://github.com/openssl/openssl</a></p><h1 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h1><p>安装<code>ActiveState Perl</code> </p><p><a href="https://www.perl.org/" title="https://www.perl.org/" target="_blank" rel="noopener">https://www.perl.org/</a></p><p><a href="https://www.activestate.com/activeperl/downloads/thank-you?dl=http://downloads.activestate.com/ActivePerl/releases/5.24.1.2402/ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe" title="https://www.activestate.com/activeperl/downloads/thank-you?dl=http://downloads.activestate.com/ActivePerl/releases/5.24.1.2402/ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe" target="_blank" rel="noopener">ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe</a></p><p>Perl 在 Window 平台上有 ActiveStatePerl 和 Strawberry Perl 编译器。</p><p>ActiveState Perl和 Strawberry Perl最大的区别是 Strawberry Perl 里面有多包含一些 CPAN 里的模块， 所以Strawberry Perl 下载的安装文件有 80多M, 而ActiveState Perl 只有20M 左右。</p><p>使用libcur中的<code>build-openssl.bat</code>编译</p><p><a href="http://files.cnblogs.com/files/yhcao/build-openssl.rar" title="http://files.cnblogs.com/files/yhcao/build-openssl.rar" target="_blank" rel="noopener">build-openssl.rar</a></p><h2 id="需要文件："><a href="#需要文件：" class="headerlink" title="需要文件："></a>需要文件：</h2><pre><code>$ copy /b inc32\openssl\*       c:\openssl\include\openssl$ copy /b out32dll\ssleay32.lib c:\openssl\lib$ copy /b out32dll\libeay32.lib c:\openssl\lib$ copy /b out32dll\ssleay32.dll c:\openssl\bin$ copy /b out32dll\libeay32.dll c:\openssl\bin$ copy /b out32dll\openssl.exe  c:\openssl\bin</code></pre><p><a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p><h1 id="安装程序："><a href="#安装程序：" class="headerlink" title="安装程序："></a>安装程序：</h1><p>或到此处下载：</p><p><a href="http://slproweb.com/products/Win32OpenSSL.html" title="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenSSL&quot;&gt;&lt;a href=&quot;#OpenSSL&quot; class=&quot;headerlink&quot; title=&quot;OpenSSL&quot;&gt;&lt;/a&gt;OpenSSL&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.openssl.org/&quot; title=&quot;https://
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OpenSSL" scheme="https://caojingyou.github.io/tags/OpenSSL/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://caojingyou.github.io/2018/02/02/C++%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8exe%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/02/02/C++获取外部exe程序的返回值，判断图片颜色模式/</id>
    <published>2018-02-02T03:31:11.040Z</published>
    <updated>2018-01-05T08:47:18.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-获取外部exe程序的返回值"><a href="#C-获取外部exe程序的返回值" class="headerlink" title="C++获取外部exe程序的返回值"></a>C++获取外部exe程序的返回值</h1><pre><code>#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;iostream&gt;using namespace std;int _tmain(int argc, _TCHAR *argv[]){    STARTUPINFOA si;    PROCESS_INFORMATION pi;    ZeroMemory(&amp;pi,   sizeof(pi));    ZeroMemory(&amp;si,   sizeof(si));    si.cb = sizeof(STARTUPINFOA);    TCHAR cmd[256] = _T(&quot;D:\\7za.exe a D:\\nv1.zip D:\\test\\*.*&quot;);    BOOL working = ::CreateProcess(NULL, cmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS , NULL, NULL, &amp;si, &amp;pi);    if (working == 0)    {        DWORD error = GetLastError();        cout &lt;&lt; &quot;CreateProcess Error : &quot; &lt;&lt; error &lt;&lt; endl;        getchar();        return 0;    }    WaitForSingleObject(pi.hProcess, INFINITE);    unsigned long Result;    GetExitCodeProcess(pi.hProcess, &amp;Result);    cout &lt;&lt; &quot;Exit Code : &quot; &lt;&lt; Result &lt;&lt; endl;    getchar();    return 0;}</code></pre><h1 id="调用命令行程序并获取返回信息"><a href="#调用命令行程序并获取返回信息" class="headerlink" title="调用命令行程序并获取返回信息"></a>调用命令行程序并获取返回信息</h1><pre><code>CString ExeCmd(CString pszCmd){    //创建匿名管道    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};    HANDLE hRead, hWrite;    if (!CreatePipe(&amp;hRead, &amp;hWrite, &amp;sa, 0))    {        return _T(&quot;&quot;);    }    //设置命令行进程启动信息(以隐藏方式启动命令并定位其输出到hWrite)    STARTUPINFO si = {sizeof(STARTUPINFO)};    GetStartupInfo(&amp;si);    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;    si.wShowWindow = SW_HIDE;    si.hStdError = hWrite;    si.hStdOutput = hWrite;    //启动命令行    PROCESS_INFORMATION pi;    if (!CreateProcess(NULL, (LPWSTR)(LPCWSTR)pszCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &amp;si, &amp;pi))    {        return _T(&quot;&quot;);    }    //立即关闭hWrite    CloseHandle(hWrite);    //读取命令行返回值    char buff[1024] = {0};    DWORD dwRead = 0;    while (ReadFile(hRead, buff, 1024, &amp;dwRead, NULL))    {    }    CString strRet(buff);    CloseHandle(hRead);    return strRet;}</code></pre><p>使用：</p><pre><code>ExeCmd(_T(&quot;ping baidu.com&quot;));ExeCmd(_T(&quot;identify -format &quot;%[colorspace]&quot; E:\\P70306-163226.jpg&quot;));</code></pre><h1 id="其他参考："><a href="#其他参考：" class="headerlink" title="其他参考："></a>其他参考：</h1><pre><code>BOOL    Start(LPCTSTR lpszTaskInfo){    if (!lpszTaskInfo)    {        return FALSE;    }    if (m_hRenderProcess)    {        if (Wait(0))        {            m_nProgress = 0;            SAFE_CLOSE_HANDLE(m_hRenderProcess);            m_dwRenderThreadId = 0;        }        else        {            return FALSE;        }    }    BOOL bRet = FALSE;    HANDLE hDebugInfo = NULL;    do    {        TCHAR szDebugLog[MAX_PATH];        _tcscpy(szDebugLog, m_szFastRenderExPath);        _tcscat(szDebugLog, _T(&quot;.debug&quot;));        SECURITY_ATTRIBUTES sa;        sa.nLength = sizeof(sa);        sa.lpSecurityDescriptor = NULL;        sa.bInheritHandle = TRUE;        hDebugInfo = CreateFile(szDebugLog, FILE_WRITE_DATA, FILE_SHARE_READ, &amp;sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);        STARTUPINFO si;        PROCESS_INFORMATION pi;        ZeroMemory( &amp;si, sizeof(si) );        si.cb = sizeof(si);        ZeroMemory( &amp;pi, sizeof(pi) );        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;        si.hStdInput = NULL;        si.hStdOutput = hDebugInfo;        si.hStdError = hDebugInfo;        si.wShowWindow = SW_HIDE;        TCHAR szCmdline[MAX_PATH * 2];        _sntprintf(szCmdline, ARRAYSIZE(szCmdline), _T(&quot; -i \&quot;%s\&quot;&quot;), lpszTaskInfo); // 第一个空格非常重要        // Start the child process.        if( !CreateProcess( m_szFastRenderExPath,   // Module name                            szCmdline,      // Command line                            NULL,           // Process handle not inheritable                            NULL,           // Thread handle not inheritable                            TRUE,          // Set handle inheritance to FALSE                            0,              // No creation flags                            NULL,           // Use parent&apos;s environment block                            NULL,           // Use parent&apos;s starting directory                            &amp;si,            // Pointer to STARTUPINFO structure                            &amp;pi )           // Pointer to PROCESS_INFORMATION structure          )        {            break;        }        // Close process and thread handles.        m_hRenderProcess = pi.hProcess;        CloseHandle( pi.hThread );        m_dwRenderThreadId = pi.dwThreadId;        // Start the message receive thread        if (!m_dwReceiveThreadId)        {            HANDLE hThread = (HANDLE) _beginthreadex(NULL,    0, ThreadFn, this, 0, &amp;m_dwReceiveThreadId);            if (hThread == NULL)            {                break;            }            CloseHandle(hThread);        }        if (!m_hMsgEvent)        {            m_hMsgEvent = CreateEvent(NULL, FALSE, FALSE, NULL);        }        else        {            ResetEvent(m_hMsgEvent);        }        bRet = TRUE;    }    while (FALSE);    SAFE_CLOSE_HANDLE(hDebugInfo);    if (!bRet)    {        if (m_hRenderProcess)        {            TerminateProcess(m_hRenderProcess, -1);            SAFE_CLOSE_HANDLE(m_hRenderProcess);        }        m_dwRenderThreadId = 0;        SAFE_CLOSE_HANDLE(m_hMsgEvent);    }    return bRet;}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://blog.csdn.net/lgh1700/article/details/7713500" title="http://blog.csdn.net/lgh1700/article/details/7713500" target="_blank" rel="noopener">C++获取外部exe程序的返回值 </a></li><li><a href="http://www.cnblogs.com/acloud/archive/2012/08/30/2663395.html" target="_blank" rel="noopener">调用命令行程序并获取返回信息</a></li><li><a href="http://dahua2.blog.163.com/blog/static/1748435142015317633489/" target="_blank" rel="noopener">ImageMagick–identify详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-获取外部exe程序的返回值&quot;&gt;&lt;a href=&quot;#C-获取外部exe程序的返回值&quot; class=&quot;headerlink&quot; title=&quot;C++获取外部exe程序的返回值&quot;&gt;&lt;/a&gt;C++获取外部exe程序的返回值&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#include
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VS工具</title>
    <link href="https://caojingyou.github.io/2018/02/01/VS%E5%B7%A5%E5%85%B7/"/>
    <id>https://caojingyou.github.io/2018/02/01/VS工具/</id>
    <published>2018-02-01T08:03:00.000Z</published>
    <updated>2018-05-09T08:29:40.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Conan"><a href="#Conan" class="headerlink" title="Conan"></a>Conan</h1><p>C/C++包管理开发工具</p><p><a href="https://conan.io/" title="https://conan.io/" target="_blank" rel="noopener">https://conan.io/</a></p><p><a href="https://docs.conan.io/en/latest/introduction.html" title="https://docs.conan.io/en/latest/introduction.html" target="_blank" rel="noopener">https://docs.conan.io/en/latest/introduction.html</a></p><h1 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h1><p>C++包管理开发工具</p><p><a href="https://github.com/Microsoft/vcpkg" title="https://github.com/Microsoft/vcpkg" target="_blank" rel="noopener">https://github.com/Microsoft/vcpkg</a></p><p><a href="https://blog.csdn.net/cjmqas/article/details/79282847" title="https://blog.csdn.net/cjmqas/article/details/79282847" target="_blank" rel="noopener">https://blog.csdn.net/cjmqas/article/details/79282847</a></p><p><a href="https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/" title="https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/</a></p><h1 id="nuget"><a href="#nuget" class="headerlink" title="nuget"></a>nuget</h1><p>.net包管理开发工具</p><p><a href="https://www.nuget.org/downloads" title="https://www.nuget.org/downloads" target="_blank" rel="noopener">https://www.nuget.org/downloads</a></p><h1 id="MSDN-Code-Gallery"><a href="#MSDN-Code-Gallery" class="headerlink" title="MSDN Code Gallery"></a>MSDN Code Gallery</h1><p><a href="https://code.msdn.microsoft.com/" title="https://code.msdn.microsoft.com/" target="_blank" rel="noopener">https://code.msdn.microsoft.com/</a></p><h1 id="Visual-Studio-Gallery"><a href="#Visual-Studio-Gallery" class="headerlink" title="Visual Studio Gallery"></a>Visual Studio Gallery</h1><p><a href="https://visualstudiogallery.msdn.microsoft.com/" title="https://visualstudiogallery.msdn.microsoft.com/" target="_blank" rel="noopener">https://visualstudiogallery.msdn.microsoft.com/</a></p><h1 id="cppcheck"><a href="#cppcheck" class="headerlink" title="cppcheck"></a>cppcheck</h1><p><a href="http://cppcheck.sourceforge.net/" title="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">http://cppcheck.sourceforge.net/</a></p><p><a href="https://github.com/danmar/cppcheck" title="https://github.com/danmar/cppcheck" target="_blank" rel="noopener">https://github.com/danmar/cppcheck</a></p><p><a href="http://cppcheck.sourceforge.net/manual.html" title="http://cppcheck.sourceforge.net/manual.html" target="_blank" rel="noopener">http://cppcheck.sourceforge.net/manual.html</a></p><h1 id="Resharper"><a href="#Resharper" class="headerlink" title="Resharper"></a>Resharper</h1><p>深度代码分析，智能代码协助，实时错误代码高亮显示，解决方案范围内代码分析，快速代码更正，一步完成代码格式化和清理，业界领先的自动代码重构，高级的集成单元测试方案，和强大的解决方案内导航和搜索</p><p><a href="https://www.jetbrains.com/resharper/" title="https://www.jetbrains.com/resharper/" target="_blank" rel="noopener">https://www.jetbrains.com/resharper/</a></p><h1 id="CodeMaid"><a href="#CodeMaid" class="headerlink" title="CodeMaid"></a>CodeMaid</h1><p>整理代码</p><p><a href="https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid" title="https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid</a></p><h1 id="ClaudiaIDE"><a href="#ClaudiaIDE" class="headerlink" title="ClaudiaIDE"></a>ClaudiaIDE</h1><p>vs背景</p><p><a href="https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE" title="https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE</a></p><h1 id="VSColorOutput"><a href="#VSColorOutput" class="headerlink" title="VSColorOutput"></a>VSColorOutput</h1><p>vs彩色输出信息</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput" title="https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput</a></p><h1 id="VS10x-Comments-Extender"><a href="#VS10x-Comments-Extender" class="headerlink" title="VS10x Comments Extender"></a>VS10x Comments Extender</h1><p>更改代码注释样式</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender</a></p><h1 id="VS10x-CodeMAP"><a href="#VS10x-CodeMAP" class="headerlink" title="VS10x CodeMAP"></a>VS10x CodeMAP</h1><p>可视化代码</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP</a></p><h1 id="VS10x-Editor-View-Enhancer"><a href="#VS10x-Editor-View-Enhancer" class="headerlink" title="VS10x Editor View Enhancer"></a>VS10x Editor View Enhancer</h1><p>增强 代码 编辑器 突出 显示 类 和 成员 名称</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer</a></p><h1 id="Atomineer-Pro-Documentation"><a href="#Atomineer-Pro-Documentation" class="headerlink" title="Atomineer Pro Documentation"></a>Atomineer Pro Documentation</h1><p>生成Doxygen注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation" title="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation</a></p><h1 id="Atomineer-Pro-Documentation-Trial"><a href="#Atomineer-Pro-Documentation-Trial" class="headerlink" title="Atomineer Pro Documentation Trial"></a>Atomineer Pro Documentation Trial</h1><p>生成Doxygen注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial" title="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial</a></p><h1 id="DoxygenComments"><a href="#DoxygenComments" class="headerlink" title="DoxygenComments"></a>DoxygenComments</h1><p>Doxygen注释高亮</p><p><a href="https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments" title="https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments</a></p><h1 id="XML-Comments"><a href="#XML-Comments" class="headerlink" title="XML Comments"></a>XML Comments</h1><p>xml注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments" title="https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments</a></p><h1 id="Go-To-Definition"><a href="#Go-To-Definition" class="headerlink" title="Go To Definition"></a>Go To Definition</h1><p>转到定义</p><p><a href="https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition" title="https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition</a></p><h1 id="AnkhSVN"><a href="#AnkhSVN" class="headerlink" title="AnkhSVN"></a>AnkhSVN</h1><p>svn</p><p><a href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider" title="https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider</a></p><h1 id="Code-Compare"><a href="#Code-Compare" class="headerlink" title="Code Compare"></a>Code Compare</h1><p>代码对比</p><p><a href="https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare" title="https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare</a></p><h1 id="Indent-Guides"><a href="#Indent-Guides" class="headerlink" title="Indent Guides"></a>Indent Guides</h1><p>花括号虚线</p><p><a href="https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides" title="https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides</a></p><h1 id="Hide-Main-Menu"><a href="#Hide-Main-Menu" class="headerlink" title="Hide Main Menu"></a>Hide Main Menu</h1><p>隐藏主菜单</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu" title="https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Conan&quot;&gt;&lt;a href=&quot;#Conan&quot; class=&quot;headerlink&quot; title=&quot;Conan&quot;&gt;&lt;/a&gt;Conan&lt;/h1&gt;&lt;p&gt;C/C++包管理开发工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://conan.io/&quot; title=&quot;htt
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Doxygen" scheme="https://caojingyou.github.io/tags/Doxygen/"/>
    
      <category term="VS工具" scheme="https://caojingyou.github.io/tags/VS%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Conan" scheme="https://caojingyou.github.io/tags/Conan/"/>
    
      <category term="vcpkg" scheme="https://caojingyou.github.io/tags/vcpkg/"/>
    
      <category term="nuget" scheme="https://caojingyou.github.io/tags/nuget/"/>
    
      <category term="cppcheck" scheme="https://caojingyou.github.io/tags/cppcheck/"/>
    
      <category term="Resharper" scheme="https://caojingyou.github.io/tags/Resharper/"/>
    
      <category term="CodeMaid" scheme="https://caojingyou.github.io/tags/CodeMaid/"/>
    
  </entry>
  
  <entry>
    <title>bypy</title>
    <link href="https://caojingyou.github.io/2018/01/25/bypy/"/>
    <id>https://caojingyou.github.io/2018/01/25/bypy/</id>
    <published>2018-01-25T08:03:00.000Z</published>
    <updated>2018-04-12T06:49:09.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bypy"><a href="#bypy" class="headerlink" title="bypy"></a>bypy</h1><p><a href="https://github.com/houtianze/bypy" title="https://github.com/houtianze/bypy" target="_blank" rel="noopener">https://github.com/houtianze/bypy</a></p><p>TL;DR: <code>pip install bypy</code>. <code>Run bypy</code></p><p>安装配置完毕后可用命令行直接上传文件</p><pre><code>@echo offbypy -v upload E:\图片\Aatrox_Splash_0.jpg test/2.jpgpause</code></pre><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><ol><li>第一次运行要授权，打开命令行中的提示网站，复制授权码到命令行中</li></ol><ol><li><p>可能会由于百度权限问题，使用百度云备份需要差不多一个月跟新一次授权，否则报错</p><p> OpenShift server failed, authorizing/refreshing with the Heroku server …</p></li></ol><p>或者不小心删除了</p><p><code>Hash Cache File &#39;/home/pipi/.bypy/bypy.hashcache.json&#39; not found, no caching</code><br><code>Note: Skip saving Hash Cache since it has not been updated.</code></p><p>这个应该不是错误，而是没有再次更新授权的提示吧。</p><p>更新(重新)授权办法如下：</p><p>运行</p><p><code>bypy.py -c</code></p><p>删除令牌文件，然后重新授权一次。如果还不行，去百度应用授权里删除bypy再重新授权。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bypy&quot;&gt;&lt;a href=&quot;#bypy&quot; class=&quot;headerlink&quot; title=&quot;bypy&quot;&gt;&lt;/a&gt;bypy&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/houtianze/bypy&quot; title=&quot;https://git
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
      <category term="bypy" scheme="https://caojingyou.github.io/tags/bypy/"/>
    
      <category term="百度云盘" scheme="https://caojingyou.github.io/tags/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CppUnit</title>
    <link href="https://caojingyou.github.io/2018/01/18/cppunit/"/>
    <id>https://caojingyou.github.io/2018/01/18/cppunit/</id>
    <published>2018-01-18T08:03:00.000Z</published>
    <updated>2018-04-12T06:28:32.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CppUnit"><a href="#CppUnit" class="headerlink" title="CppUnit"></a>CppUnit</h1><p><a href="https://sourceforge.net/projects/cppunit/?source=directory" target="_blank" rel="noopener">CppUnit - C++ port of JUnit</a></p><p><a href="https://www.freedesktop.org/wiki/Software/cppunit/" target="_blank" rel="noopener">cppunit-freedesktop.org</a></p><p><a href="http://cppunit.sourceforge.net/doc/lastest/index.html" target="_blank" rel="noopener">CppUnit Documentation</a></p><p><a href="https://baike.baidu.com/item/CppUnit/2218302?fr=aladdin" target="_blank" rel="noopener">CppUnit百度百科</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cppunit/" target="_blank" rel="noopener">便利的开发工具 CppUnit 快速使用指南</a></p><p><a href="https://wenku.baidu.com/view/b7fcad4bcf84b9d528ea7ae1.html" target="_blank" rel="noopener">CppUnit源码解读</a></p><p><a href="http://morningspace.51.net/resource/cppunit/cppunit_anno.html" target="_blank" rel="noopener">晨光（Morning）CppUnit源码解读</a></p><p><a href="http://blog.csdn.net/eplanet/article/details/1844456" target="_blank" rel="noopener">C++——测试工具CppUnit的安装和配置</a></p><p><a href="http://blog.csdn.net/x_iya/article/details/8433716" target="_blank" rel="noopener">CppUnit在VS2010上的正确使用</a></p><p><a href="https://wenku.baidu.com/view/0997c8a30b1c59eef9c7b47f.html" target="_blank" rel="noopener">[vs2010 配置与实例] CppUnit快速入门</a></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="http://dev-www.libreoffice.org/src/cppunit-1.14.0.tar.gz" target="_blank" rel="noopener">cppunit-1.14.0.tar.gz</a></p><p><a href="https://sourceforge.net/projects/cppunit/files/cppunit/1.12.1/cppunit-1.12.1.tar.gz/download" target="_blank" rel="noopener">cppunit-1.12.1.tar.gz</a></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>在CppUnit的源代码中，包含了几个测试工程的例子。</p><ul><li>CppUnitTestMain：一个实际的测试包（test suite）用来测试CppUnit。使用了TextTestRunner（文本方式的单元测试环境），利用CompilterOutputter进行post-build testing（即在编译结束之后紧跟着进行测试）。在配置中设定连接了cppunit的静态库和动态库。</li></ul><ul><li>CppUnitTestApp：包含了与CppUnitTestMain相同的测试包，但使用了MFC TestRunner（GUI方式的单元测试环境）</li></ul><ul><li>Hierarchy：一个演示如何子类化测试的例子（你也许更愿意使用HelperMacros.h以及宏CPPUNIT_TEST_SUB_SUITE，这种方式更为简洁清晰。本示例已经很久没有更新了）。</li></ul><ul><li>HostApp ：一个用MFC TestRunner演示各种失败测试的例子。也演示了MFC Unicode TestRunner。</li></ul><ul><li>TestPlugIn：一个演示如何为TestPlugInRunner编写TestPlugIn的例子（实验性的）。</li></ul><h1 id="判断宏"><a href="#判断宏" class="headerlink" title="判断宏"></a>判断宏</h1><p><code>CPPUNIT_ASSERT</code>是一个宏，判断后面的参数是否正确，CPPUNIT还有很多宏，如</p><pre><code>CPPUNIT_ASSERT(condition)                      // 确信condition为真CPPUNIT_ASSERT_MESSAGE(message, condition)     // 当condition为假时失败, 并打印messageCPPUNIT_FAIL(message)                          // 当前测试失败, 并打印messageCPPUNIT_ASSERT_EQUAL(expected, actual)         // 确信两者相等CPPUNIT_ASSERT_EQUAL_MESSAGE(message, expected, actual) // 失败的同时打印messageCPPUNIT_ASSERT_DOUBLES_EQUAL(expected, actual, delta)   // 当expected和actual之间差大于delta时失败</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CppUnit&quot;&gt;&lt;a href=&quot;#CppUnit&quot; class=&quot;headerlink&quot; title=&quot;CppUnit&quot;&gt;&lt;/a&gt;CppUnit&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/cppunit/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="CppUnit" scheme="https://caojingyou.github.io/tags/CppUnit/"/>
    
      <category term="单元测试" scheme="https://caojingyou.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo yilia主题</title>
    <link href="https://caojingyou.github.io/2018/01/10/Hexo%20yilia%E4%B8%BB%E9%A2%98/"/>
    <id>https://caojingyou.github.io/2018/01/10/Hexo yilia主题/</id>
    <published>2018-01-10T08:03:00.000Z</published>
    <updated>2018-04-12T06:19:37.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h1><ul><li><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></li><li><a href="http://litten.me/" title="http://litten.me/" target="_blank" rel="noopener">http://litten.me/</a></li><li><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></li><li><a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" title="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5</a></li></ul><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>关于SEO与RSS，需要在博客根目录（注意不是yilia根目录）安装这三个node_modules:</p><pre><code>npm install hexo-generator-feed --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save</code></pre><p>分别对应：rss、百度爬虫sitemap、通用搜索引擎sitemap</p><h1 id="不显示标签："><a href="#不显示标签：" class="headerlink" title="不显示标签："></a>不显示标签：</h1><p>缺失模块。<br>1、在博客根目录（注意不是yilia根目录）执行以下命令：</p><p>npm i hexo-generator-json-content –save</p><p>2、在根目录_config.yml里添加配置：</p><pre><code>jsonContent:  meta: false  pages: false  posts:    title: true    date: true    path: true    text: true    raw: false    content: false    slug: false    updated: false    comments: false    link: false    permalink: false    excerpt: false    categories: false    tags: true</code></pre><h1 id="【Hexo】Hexo-Github构建个人博客-（五）：错误集"><a href="#【Hexo】Hexo-Github构建个人博客-（五）：错误集" class="headerlink" title="【Hexo】Hexo+Github构建个人博客 （五）：错误集"></a>【Hexo】Hexo+Github构建个人博客 （五）：错误集</h1><ul><li><a href="http://www.cnblogs.com/arvin0/p/6664239.html" title="http://www.cnblogs.com/arvin0/p/6664239.html" target="_blank" rel="noopener">http://www.cnblogs.com/arvin0/p/6664239.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网址：&quot;&gt;&lt;a href=&quot;#网址：&quot; class=&quot;headerlink&quot; title=&quot;网址：&quot;&gt;&lt;/a&gt;网址：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Hexo" scheme="https://caojingyou.github.io/tags/Hexo/"/>
    
      <category term="yilia主题" scheme="https://caojingyou.github.io/tags/yilia%E4%B8%BB%E9%A2%98/"/>
    
      <category term="博客" scheme="https://caojingyou.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>SQLite NET</title>
    <link href="https://caojingyou.github.io/2018/01/09/SQLite%20NET/"/>
    <id>https://caojingyou.github.io/2018/01/09/SQLite NET/</id>
    <published>2018-01-09T08:03:00.000Z</published>
    <updated>2018-04-12T06:24:45.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-程序中使用-SQLite-数据库"><a href="#C-程序中使用-SQLite-数据库" class="headerlink" title="C# 程序中使用 SQLite 数据库"></a>C# 程序中使用 SQLite 数据库</h1><pre><code>using System;using System.Data;using System.Data.SQLite;//C# 使用 SQLite 数据测试程序public class Program{    public static void Main(string[] args)    {        using (SQLiteConnection con = new SQLiteConnection(&quot;Data Source=c:\\test.db3;Pooling=true;FailIfMissing=false&quot;))        {            //打开数据库文件 c:\\test.db3，不存在则创建            con.Open();            using (SQLiteCommand cmd = new SQLiteCommand())            {                cmd.Connection = con;                //检查是否存在表 test，不存在则创建                Boolean testTableExists = false;                cmd.CommandText = &quot;SELECT * FROM sqlite_master WHERE type=&apos;table&apos; and name=&apos;test&apos;&quot;;                using(SQLiteDataReader dr = cmd.ExecuteReader())                {                    if (dr.Read())                    {                        testTableExists = true;                    }                }                if (!testTableExists)                {                    cmd.CommandText = &quot;CREATE TABLE [test] (id int, name nvarchar(20))&quot;;                    cmd.ExecuteNonQuery();                }                //清空 test 表                cmd.CommandText = &quot;DELETE FROM [test]&quot;;                cmd.ExecuteNonQuery();                //插入测试数据                for (int i = 1; i &lt;= 5; i++)                {                    cmd.CommandText = string.Format(&quot;INSERT INTO [test] VALUES ({0}, &apos;中文测试&apos;)&quot;, i);                    cmd.ExecuteNonQuery();                }                //读取数据                cmd.CommandText = &quot;SELECT * FROM [test]&quot;;                using (SQLiteDataReader dr = cmd.ExecuteReader(CommandBehavior.CloseConnection))                {                    while (dr.Read())                    {                        Console.WriteLine(&quot;第{0} 条：{1}&quot;, dr.GetValue(0), dr.GetString(1));                    }                }            }        }        Console.WriteLine(&quot;Press any key to continue...&quot;);        Console.ReadKey();    }}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://unmi.cc/csharp-use-sqlite-db/" title="http://unmi.cc/csharp-use-sqlite-db/" target="_blank" rel="noopener">http://unmi.cc/csharp-use-sqlite-db/</a></li><li><a href="http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/" title="http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/" target="_blank" rel="noopener">http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/</a></li><li><a href="http://www.sqlite.org/lang_keywords.html" title="http://www.sqlite.org/lang_keywords.html" target="_blank" rel="noopener">http://www.sqlite.org/lang_keywords.html</a></li><li><a href="http://www.sqlite.org/lang_corefunc.html" title="http://www.sqlite.org/lang_corefunc.html" target="_blank" rel="noopener">http://www.sqlite.org/lang_corefunc.html</a></li><li><a href="http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes" title="http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes</a></li><li><a href="http://www.sqlite.org/cvstrac/wiki?p=ManagementTools" title="http://www.sqlite.org/cvstrac/wiki?p=ManagementTools" target="_blank" rel="noopener">http://www.sqlite.org/cvstrac/wiki?p=ManagementTools</a></li><li><a href="http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html" title="http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html" target="_blank" rel="noopener">http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html</a></li><li><a href="http://www.jb51.net/article/26381.htm" title="http://www.jb51.net/article/26381.htm" target="_blank" rel="noopener">http://www.jb51.net/article/26381.htm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-程序中使用-SQLite-数据库&quot;&gt;&lt;a href=&quot;#C-程序中使用-SQLite-数据库&quot; class=&quot;headerlink&quot; title=&quot;C# 程序中使用 SQLite 数据库&quot;&gt;&lt;/a&gt;C# 程序中使用 SQLite 数据库&lt;/h1&gt;&lt;pre&gt;&lt;c
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="SQLite NET" scheme="https://caojingyou.github.io/tags/SQLite-NET/"/>
    
  </entry>
  
  <entry>
    <title>wolfSSL</title>
    <link href="https://caojingyou.github.io/2018/01/08/wolfSSL/"/>
    <id>https://caojingyou.github.io/2018/01/08/wolfSSL/</id>
    <published>2018-01-08T08:03:00.000Z</published>
    <updated>2018-04-12T06:23:51.676Z</updated>
    
    <content type="html"><![CDATA[<p>下载：</p><p><a href="https://github.com/wolfSSL/wolfssl" title="https://github.com/wolfSSL/wolfssl" target="_blank" rel="noopener">https://github.com/wolfSSL/wolfssl</a></p><p><a href="https://www.wolfssl.com/wolfSSL/Home.html" title="https://www.wolfssl.com/wolfSSL/Home.html" target="_blank" rel="noopener">https://www.wolfssl.com/wolfSSL/Home.html</a></p><p><a href="http://www.updatestar.com/directdownload/wolfssl/2264982" title="http://www.updatestar.com/directdownload/wolfssl/2264982" target="_blank" rel="noopener">http://www.updatestar.com/directdownload/wolfssl/2264982</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wolfSSL/wolfssl&quot; title=&quot;https://github.com/wolfSSL/wolfssl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="wolfSSL" scheme="https://caojingyou.github.io/tags/wolfSSL/"/>
    
  </entry>
  
  <entry>
    <title>个人喜欢的电脑软件</title>
    <link href="https://caojingyou.github.io/2018/01/01/%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2018/01/01/个人喜欢的电脑软件/</id>
    <published>2018-01-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:04:41.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美化桌面"><a href="#美化桌面" class="headerlink" title="美化桌面"></a>美化桌面</h1><p>wallpaperengine</p><p>火萤视频桌面</p><p>雨滴桌面</p><p>Win10BGChanger1.2.1</p><p>StartIsBack</p><p>LiveDesktop</p><p>牛牛桌面</p><p>Fences</p><p>Q+</p><p>360安全桌面</p><h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>Listary</p><p>Rolan</p><p>Launchy</p><p>Wox</p><p>音速启动</p><p>CLaunch</p><p>ALTRun</p><p>Executor</p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><p>FreeFileSync</p><p>FastCopy</p><h1 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h1><p>Snipaste</p><p>ShareX-portable</p><p>Greenshot</p><h1 id="图片整理"><a href="#图片整理" class="headerlink" title="图片整理"></a>图片整理</h1><p>picasa</p><h1 id="RSS阅读"><a href="#RSS阅读" class="headerlink" title="RSS阅读"></a>RSS阅读</h1><p>feeddemon</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美化桌面&quot;&gt;&lt;a href=&quot;#美化桌面&quot; class=&quot;headerlink&quot; title=&quot;美化桌面&quot;&gt;&lt;/a&gt;美化桌面&lt;/h1&gt;&lt;p&gt;wallpaperengine&lt;/p&gt;
&lt;p&gt;火萤视频桌面&lt;/p&gt;
&lt;p&gt;雨滴桌面&lt;/p&gt;
&lt;p&gt;Win10BGChange
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="电脑软件" scheme="https://caojingyou.github.io/tags/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="个人喜欢" scheme="https://caojingyou.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2/"/>
    
      <category term="美化桌面" scheme="https://caojingyou.github.io/tags/%E7%BE%8E%E5%8C%96%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>MSBuild</title>
    <link href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/"/>
    <id>https://caojingyou.github.io/2017/12/21/MSBuild (Visual C++)/</id>
    <published>2017-12-21T08:03:00.000Z</published>
    <updated>2018-04-12T06:26:11.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-文档"><a href="#Visual-Studio-文档" class="headerlink" title="Visual Studio 文档"></a>Visual Studio 文档</h1><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/</a></p><h1 id="MSBuild-Visual-C"><a href="#MSBuild-Visual-C" class="headerlink" title="MSBuild (Visual C++)"></a>MSBuild (Visual C++)</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/dd293626.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd293626.aspx</a></p><p>可以使用 MSBuild 工具从命令提示符处生成 Visual C++ 应用程序。 该生成过程由您可以创建和编辑的项目文件 (.vcxproj) 中的信息来控制。 该项目文件基于生成阶段、条件和事件指定生成选项</p><h1 id="MSBuild-Visual-C-概述"><a href="#MSBuild-Visual-C-概述" class="headerlink" title="MSBuild (Visual C++) 概述"></a>MSBuild (Visual C++) 概述</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ee662426.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ee662426.aspx</a></p><p>用户目标和属性</p><p>若要在命令行上最有效地使用 MSBuild，最好先了解哪些属性和目标是有用且相关。 大多数属性和目标可以帮助实施 Visual c + + 生成系统，并因此不与用户相关。 本部分介绍一些值得面向用户的属性和目标。</p><p>PlatformToolset 属性</p><p>PlatformToolset 属性确定在生成中使用的 Visual c + + 工具集。 属性的值与字符串组合成包含生成用于特定平台的项目所需的属性和目标文件的目录路径串联。</p><p>设置 PlatformToolset 属性设置为 v110 使用 Visual Studio 2012 中的 Visual C++ 工具和库来构建您的应用程序。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v110</p><p>设置 PlatformToolset 属性设置为 v100 使用 Visual C++ 2010 工具和库来构建您的应用程序。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v100</p><p>设置 PlatformToolset 属性设置为 v90 使用 Visual c + + 2008年工具和库来生成你的应用程序。 此属性才有效在计算机上必须已安装的 Visual c + + 2008年工具集。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v90</p><p>PreferredToolArchitecture 属性</p><p>PreferredToolArchitecture 属性确定是否在生成中使用 32 位或 64 位编译器和工具。 此属性不影响输出的平台体系结构或配置。 默认情况下，MSBuild 使用 x86 版本的编译器和工具，如果此属性未设置，或为设置为任何值以外 x64。</p><p>设置 PreferredToolArchitecture 属性设置为 x64 以使用 64 位编译器和工具来生成应用程序。</p><p>msbuild myProject.vcxproj /p:PreferredToolArchitecture=x64</p><p>UseEnv 属性</p><p>默认情况下，当前项目的特定于平台的设置重写路径、 INCLUDE、 LIB、 LIBPATH、 配置和平台环境变量。 设置 UseEnv 属性设置为 true 若要确保环境变量不重写。</p><p>msbuild myProject.vcxproj /p:UseEnv=true</p><p>目标</p><p>有数百个 Visual c + + 支持文件中的目标。 但是，大多数都是用户可忽略的面向系统的目标。 大多数系统目标前缀是下划线 (_)，或具有”PrepareFor”，”计算”，以”Before”，”After”，”之前”或”Post”开头的名称。</p><p>下表列出了几个值得面向用户的目标。</p><h1 id="MSBuild-命令行参考"><a href="#MSBuild-命令行参考" class="headerlink" title="MSBuild 命令行参考"></a>MSBuild 命令行参考</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms164311.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms164311.aspx</a></p><p><code>MSBuild.exe [Switches] [ProjectFile]</code> </p><pre><code>语法:                             MSBuild.exe [选项] [项目文件]描述:                    在项目文件中生成指定的目标。如果                     未指定项目文件，MSBuild 将搜索                     当前工作目录来查找文件扩展名                     以“proj”结尾的文件并使用该文件。开关:  /target:&lt;targets&gt;  在此项目中生成这些目标。使用                     分号或逗号分隔多个目标，或者分别指定                     每个目标。(缩写: /t)                     示例:                       /target:Resources;Compile  /property:&lt;n&gt;=&lt;v&gt;  设置或重写这些项目级属性。&lt;n&gt; 是                     属性名，&lt;v&gt; 为属性值。请使用                     分号或逗号分隔多个属性，或者                     分别指定每个属性。(缩写: /p)                     示例:                       /property:WarningLevel=2;OutDir=bin\Debug\  /maxcpucount[:n]   指定用于生成的最大                     并发进程数。如果未使用开关，则使用的默认值                     为 1。如果使用开关时不带值，                     MSBuild 将最多使用计算机上的                     处理器数。(缩写: /m[:n])  /toolsversion:&lt;version&gt;                     要在生成过程中使用的 MSBuild 工具集                     (任务、目标等) 的版本。此版本将重写                     个别项目指定的版本。(缩写:                     /tv)                     示例:                       /toolsversion:3.5  /verbosity:&lt;level&gt; 在事件日志中显示此级别的信息量。                     可用的详细级别有: q[uiet]、 m[inimal]、                     n[ormal]、d[etailed] 和 diag[nostic]。(缩写: /v)                     示例:                       /verbosity:quiet  /consoleloggerparameters:&lt;parameters&gt;                     控制台记录器的参数。(缩写: /clp)                     可用的参数有:                        PerformanceSummary -- 显示在任务、目标和项目上                            花费的时间。                        Summary -- 结束时显示错误和警告的摘要。                        NoSummary -- 结束时不显示错误和警告                            的摘要。                        ErrorsOnly -- 仅显示错误。                        WarningsOnly -- 仅显示警告。                        NoItemAndPropertyList -- 在开始生成每个项目时不显示                            项和属性的列表。                        ShowCommandLine -- 显示 TaskCommandLineEvent 消息                        ShowTimestamp -- 将时间戳作为所有消息的前缀                            显示。                        ShowEventId -- 显示已开始事件、已完成事件和消息                            的事件 ID。                        ForceNoAlign -- 不将文本与控制台缓冲区的大小                            匹配。                        DisableConsoleColor -- 将默认控制台颜色                            用于所有记录消息。                        DisableMPLogging -- 在非多处理器                            模式下运行时，禁用输出的多处理器                            日志记录样式。                        EnableMPLogging -- 即使在非多处理器                            模式下运行，也启用多处理器                            日志记录样式。默认情况下启用此日志记录样式。                        Verbosity -- 重写此记录器的  /verbosity                            设置。                     示例:                        /consoleloggerparameters:PerformanceSummary;NoSummary;                                                 Verbosity=minimal  /noconsolelogger   禁用默认控制台记录器，并且不将事件                     记录到控制台。(缩写:  /noconlog)  /fileLogger[n]     将生成输出记录到文件中。默认情况下，                     该文件在当前目录中，名称为                     “msbuild[n].log”。所有节点中的事件合并到                     单个日志中。fileLogger 的文件和                     其他参数的位置可以通过添加                     “/fileLoggerParameters[n]”开关来指定。                     “n”(如果存在)可以为 1-9 的数字，允许最多附加                     10 个文件记录器。(缩写:  /fl[n])  /fileloggerparameters[n]:&lt;parameters&gt;                     为文件记录器提供任何额外的参数。                     存在此开关意味着                     存在对应的 /filelogger[n] 开关。                    “n”(如果存在)可以为 1-9 的数字。                     任何分布式文件记录器也可以使用                     /fileloggerparameters，具体可参阅 /distributedFileLogger 的说明。                     (缩写: /flp[n])                     为控制台记录器列出的相同参数                     可用。某些其他可用参数有:                        LogFile -- 生成日志将写入其中的                            日志文件的路径。                        Append -- 确定是将生成日志附加到日志文件，                            还是覆盖日志文件。如果设置此                            开关，则会将生成日志附加到日志文件；                            如果不设置此开关，则会覆盖                            现有日志文件的内容。                            默认值为不附加到日志文件。                        Encoding -- 指定文件的编码，                            例如，UTF-8、Unicode 或 ASCII                     默认的详细级别为 Detailed。                     示例:                       /fileLoggerParameters:LogFile=MyLog.log;Append;                                           Verbosity=diagnostic;Encoding=UTF-8                       /flp:Summary;Verbosity=minimal;LogFile=msbuild.sum                       /flp1:warningsonly;logfile=msbuild.wrn                       /flp2:errorsonly;logfile=msbuild.err  /distributedlogger:&lt;central logger&gt;*&lt;forwarding logger&gt;                     使用此记录器来记录 MSBuild 中的事件，向每个节点                     附加不同的记录器实例。若要指定                     多个记录器，请分别指定每个记录器。                     (缩写 /dl)                     &lt;logger&gt; 语法为:                       [&lt;logger class&gt;,]&lt;logger assembly&gt;[;&lt;logger parameters&gt;]                     &lt;logger class&gt; 语法为:                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;                     &lt;logger assembly&gt; 语法为:                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}                     &lt;logger parameters&gt; 是可选的，并且按键入的                     形式原样传递给记录器。(缩写: /l)                     示例:                       /dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral                       /dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll  /distributedFileLogger                     将生成输出记录到多个日志文件，每个 MSBuild 节点                     一个日志文件。这些文件的初始位置为                     当前目录。默认情况下，这些文件名为                     “MSBuild&lt;nodeid&gt;.log”。可通过添加                     “/fileLoggerParameters”开关来指定                     这些文件的位置和 fileLogger 的其他参数。                     如果日志文件名是通过 fileLoggerParameters                     开关设置的，分布式记录器将使用 fileName 作为                     模板并将节点 ID 附加到此 fileName                     以便为每个节点创建一个日志文件。  /logger:&lt;logger&gt;   使用此记录器来记录 MSBuild 中的事件。若要指定                     多个记录器，请分别指定每个记录器。                     &lt;logger&gt; 语法为:                       [&lt;logger class&gt;,]&lt;logger assembly&gt;[;&lt;logger parameters&gt;]                    &lt;logger class&gt; 语法为:                        [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;                   &lt;logger assembly&gt; 语法为:                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}                     &lt;logger parameters&gt; 是可选的，并按键入的                    形式原样传递给记录器。(缩写: /l)                     示例:                       /logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral                       /logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML  /validate          依据默认架构验证项目。(缩写:                     /val)  /validate:&lt;schema&gt; 依据指定的架构验证项目。 (缩写:                     /val)                     示例:                       /validate:MyExtendedBuildSchema.xsd  /ignoreprojectextensions:&lt;扩展名&gt;                     确定要生成的项目文件时要忽略的                     扩展名的列表。使用分号或逗号来分隔                     多个扩展名。                     (缩写: /ignore)                     示例:                       /ignoreprojectextensions:.sln  /nodeReuse:&lt;parameters&gt;                     允许或禁止重复使用 MSBuild 节点。                     参数包括:                     True -- 生成完成后节点将保留，                             并且将由后面的生成重复使用(默认)                     False -- 生成完成后节点将不会保留                     (缩写: /nr)                     示例:                       /nr:true  /preprocess[:file]                     通过嵌入将在生成过程中导入的                     所有文件并标记其边界，                     创建一个聚合的项目文件。这对于                     了解导入什么文件、从何处导入以及                     这些文件在生成中的构成                     非常有用。默认情况下，输出将写入                     控制台窗口。如果提供输出文件的路径，                     则将改用该路径。                     (缩写: /pp)                      示例:                       /pp:out.txt  /detailedsummary                     在生成的结尾显示有关                     所生成的配置以及如何向节点安排                     这些配置的详细信息。                     (缩写:  /ds)  @&lt;file&gt;            从文本文件插入命令行设置。若要指定                     多个响应文件，请分别指定每个响应                     文件。                     自动从以下位置使用任何                     名为“msbuild.rsp”的响应文件:                     (1) msbuild.exe 的目录                     (2) 生成的第一个项目或解决方案的目录  /noautoresponse    不自动包括任何 MSBuild.rsp 文件。(缩写:                     /noautorsp)  /nologo            不显示启动版权标志和版权消息。  /version           仅显示版本信息。(缩写:  /ver)  /help              显示此用法消息。(缩写: /? 或 /h)示例:        MSBuild MyApp.sln /t:Rebuild /p:Configuration=Release        MSBuild MyApp.csproj /t:Clean                             /p:Configuration=Debug;TargetFrameworkVersion=v3.5</code></pre><p>示例</p><pre><code>MSBuild.exe MyProject.proj /t:rebuild </code></pre><h1 id="演练：使用-MSBuild-创建-Visual-C-项目"><a href="#演练：使用-MSBuild-创建-Visual-C-项目" class="headerlink" title="演练：使用 MSBuild 创建 Visual C++ 项目"></a>演练：使用 MSBuild 创建 Visual C++ 项目</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/dd293607.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd293607.aspx</a></p><pre><code>msbuild myproject.vcxproj /p:configuration=debugmsbuild myproject.vcxproj /t:clean</code></pre><h2 id="将-MSBuild-与生成目标结合使用"><a href="#将-MSBuild-与生成目标结合使用" class="headerlink" title="将 MSBuild 与生成目标结合使用"></a>将 MSBuild 与生成目标结合使用</h2><p>生成目标是指定的一组预定义命令或用户定义的命令，这组命令可在生成期间执行。 使用目标命令行选项 (/t) 可以指定生成目标。 对于 myproject 示例项目，预定义的 clean 目标将删除调试文件夹中的所有文件并创建新日志文件。<br>在命令提示符处，键入以下命令以清理 myproject。<br>    msbuild myproject.vcxproj /t:clean</p><h2 id="将-MSBuild-与生成属性结合使用"><a href="#将-MSBuild-与生成属性结合使用" class="headerlink" title="将 MSBuild 与生成属性结合使用"></a>将 MSBuild 与生成属性结合使用</h2><p>通过使用属性命令行选项 (/p)，您可以在项目生成文件中重写属性。 在 myproject 示例项目中，发布版本配置或调试版本配置是由 Configuration 属性指定的。 用来运行生成的应用程序的操作系统是由 Platform 属性指定的。<br>在命令提示符处，键入以下命令，以创建打算在 32 位 Windows 上运行的 myproject 应用程序的调试版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=debug /p:platform=win32</code></pre><p>假设 myproject 示例项目也为 64 位 Windows 定义了配置，并为名为 myplatform 的自定义操作系统定义了另一个配置。<br>在命令提示符处，键入以下命令，以创建在 64 位 Windows 上运行的发布版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=release /p:platform=x64</code></pre><p>在命令提示符处，键入以下命令以为 myplatform 创建发布版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=release /p:platform=myplatform</code></pre><h1 id="个人写的例子："><a href="#个人写的例子：" class="headerlink" title="个人写的例子："></a>个人写的例子：</h1><p>vs2005:</p><pre><code>call &quot;D:\Program Files (x86)\Microsoft Visual Studio 8\VC\vcvarsall.bat&quot; x86</code></pre><p>vs2010:</p><pre><code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\vcvarsall.bat&quot; x86</code></pre><p>vs2012:</p><pre><code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\vcvarsall.bat&quot; x86</code></pre><p>重新编译：</p><pre><code>MSBuild %~dp0..\Project\VC10\pro.sln /t:rebuild /p:configuration=&quot;Release&quot;</code></pre><h1 id="在命令行上生成"><a href="#在命令行上生成" class="headerlink" title="在命令行上生成"></a>在命令行上生成</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/f35ctcxw.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/f35ctcxw.aspx</a></p><h1 id="为命令行生成设置路径和环境变量"><a href="#为命令行生成设置路径和环境变量" class="headerlink" title="为命令行生成设置路径和环境变量"></a>为命令行生成设置路径和环境变量</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/f2ccy3wt.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/f2ccy3wt.aspx</a></p><h1 id="生成应用程序"><a href="#生成应用程序" class="headerlink" title="生成应用程序"></a>生成应用程序</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms181709.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms181709.aspx</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/ms244359.aspx" target="_blank" rel="noopener">Team Foundation Build 参考</a></p><h1 id="vcvars-bat-设置命令行编译环境"><a href="#vcvars-bat-设置命令行编译环境" class="headerlink" title="vcvars.bat 设置命令行编译环境"></a>vcvars.bat 设置命令行编译环境</h1><pre><code>@echo offif defined VSINSTALLDIR (    echo already installedgoto eof)set &quot;_ARG_=%1&quot;rem helpif &quot;%_ARG_%&quot; EQU &quot;&quot; (    echo syntax: %0 [2005 ^| 2008 ^| 2010 ^| 2012 ^| 2013 ^| 2015] [64]    goto eof)if &quot;%_ARG_%&quot; EQU &quot;2005&quot; set &quot;ProgramFiles(x86)=%VS80COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2008&quot; set &quot;ProgramFiles(x86)=%VS90COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2010&quot; set &quot;ProgramFiles(x86)=%VS100COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2012&quot; set &quot;ProgramFiles(x86)=%VS110COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2013&quot; set &quot;ProgramFiles(x86)=%VS120COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2015&quot; set &quot;ProgramFiles(x86)=%VS140COMNTOOLS%..\..\&quot;echo &quot;%ProgramFiles(x86)%&quot;if NOT DEFINED ProgramFiles(x86) set ProgramFiles(x86)=C:\Program Files (x86)if NOT DEFINED VS80COMNTOOLS set VS80COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 8\Common7\Tools\if NOT DEFINED VS90COMNTOOLS set VS90COMNTOOLS=c:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\Tools\rem VS100COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\Tools\rem VS110COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 11.0\Common7\Tools\rem VS120COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\rem VS140COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Tools\rem VS80COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 8\Common7\Tools\rem VS90COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\Tools\rem VSSDK140Install=D:\Program Files (x86)\Microsoft Visual Studio 14.0\VSSDK\set &quot;_OPT_=%2&quot;if NOT DEFINED _OPT_ set _OPT_=64if &quot;%_OPT_%&quot; EQU &quot;x64&quot; set &quot;_OPT_=64&quot;if &quot;%_ARG_%&quot; EQU &quot;2005&quot; (  if &quot;%_OPT_%&quot; EQU &quot;64&quot; (pushd &quot;%ProgramFiles(x86)%\VC\bin\amd64\&quot;call vcvarsamd64.batset PROCESSOR_ARCHITECTURE=AMD64  ) else (pushd &quot;%ProgramFiles(x86)%\VC\bin&quot;call vcvars32.batset PROCESSOR_ARCHITECTURE=x86  )  popd  goto eof)rem set the variable _VC_set _VC_=if &quot;%_ARG_%&quot; EQU &quot;2008&quot; set &quot;_VC_=9.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2010&quot; set &quot;_VC_=10.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2012&quot; set &quot;_VC_=11.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2013&quot; set &quot;_VC_=12.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2015&quot; set &quot;_VC_=14.0&quot;if DEFINED _VC_ (  echo &quot;%ProgramFiles(x86)%\VC\&quot;  pushd &quot;%ProgramFiles(x86)%\VC\&quot;  if &quot;%_OPT_%&quot; EQU &quot;64&quot; (vcvarsall.bat x86_amd64set PROCESSOR_ARCHITECTURE=AMD64  ) else (vcvarsall.bat x86set PROCESSOR_ARCHITECTURE=x86  )  if errorlevel 1 (      echo.*** error - failed ***  ) else (      echo Success Environment for Visual Studio %_VC_% = %*  )  popd) else (  echo unknown version of Visual Studio %*  set _ARG_=  call:help)remrem That&apos;s all Folks!:eof</code></pre><h1 id="devenv"><a href="#devenv" class="headerlink" title="devenv"></a>devenv</h1><pre><code>@echo offcd /d %~dp0set BUILD_TARGET=%CD%\MyProject.slnecho.if &quot;&quot;==&quot;%VS80COMNTOOLS%&quot; (   echo environment variable &apos;VS80COMNTOOLS%&apos; has not been set   goto Exit_Fail)set DEVENV=%VS80COMNTOOLS%\..\IDE\devenv.comif not exist &quot;%DEVENV%&quot; (   echo file &quot;%DEVENV%&quot; can not be found   goto Exit_Fail)@echo on&quot;%DEVENV%&quot; &quot;%BUILD_TARGET%&quot; /Build Release:Exit_Failpause</code></pre><p><code>Build</code>可换成<code>Rebuild</code></p><p><a href="https://www.cnblogs.com/songxingzhu/p/5242159.html" target="_blank" rel="noopener">使用devenv/MSBuild在命令行编译sln或csproj</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Visual-Studio-文档&quot;&gt;&lt;a href=&quot;#Visual-Studio-文档&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio 文档&quot;&gt;&lt;/a&gt;Visual Studio 文档&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MSBuild" scheme="https://caojingyou.github.io/tags/MSBuild/"/>
    
      <category term="VS" scheme="https://caojingyou.github.io/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>Log4Net</title>
    <link href="https://caojingyou.github.io/2017/12/15/Log4Net/"/>
    <id>https://caojingyou.github.io/2017/12/15/Log4Net/</id>
    <published>2017-12-15T08:03:00.000Z</published>
    <updated>2018-05-17T03:25:51.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Log4Net"><a href="#Log4Net" class="headerlink" title="Log4Net"></a>Log4Net</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>[assembly: log4net.Config.XmlConfigurator(Watch = true)]namespace APP02{    class Program    {        static void Main(string[] args)        {            ILog log = log4net.LogManager.GetLogger(&quot;Test&quot;);            log.Error(&quot;错误&quot;, new Exception(&quot;发生了一个异常&quot;));//错误            log.Fatal(&quot;严重错误&quot;, new Exception(&quot;发生了一个致命错误&quot;));//严重错误            log.Info(&quot;信息&quot;); //记录一般信息            log.Debug(&quot;调试信息&quot;);//记录调试信息            log.Warn(&quot;警告&quot;);//记录警告信息            Console.WriteLine(&quot;日志记录完毕。&quot;);            Console.Read();        }    }}</code></pre><p>或：</p><pre><code>ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);            //记录错误日志            log.Info(&quot;error&quot;);</code></pre><h2 id="App-config文件配置："><a href="#App-config文件配置：" class="headerlink" title="App.config文件配置："></a>App.config文件配置：</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt;  &lt;configSections&gt;    &lt;section name=&quot;log4net&quot; type=&quot;System.Configuration.IgnoreSectionHandler&quot;/&gt;  &lt;/configSections&gt;  &lt;log4net&gt;    &lt;appender name=&quot;控制台输出&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d [%t] %-5p %c [%x] - %m%n&quot;  /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;logger name=&quot;Test&quot;&gt;      &lt;level value=&quot;ALL&quot;/&gt;      &lt;appender-ref ref=&quot;控制台输出&quot; /&gt;    &lt;/logger&gt;  &lt;/log4net&gt;&lt;/configuration&gt;</code></pre><p>或：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt;  &lt;configSections&gt;    &lt;section name=&quot;log4net&quot; type=&quot;System.Configuration.IgnoreSectionHandler&quot;/&gt;  &lt;/configSections&gt;  &lt;appSettings&gt;  &lt;/appSettings&gt;  &lt;log4net&gt;    &lt;!--定义输出到文件中--&gt;    &lt;appender name=&quot;LogFileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt;      &lt;!--定义文件存放位置--&gt;      &lt;file value=&quot;D:/log4netfile.txt&quot; /&gt;      &lt;appendToFile value=&quot;true&quot; /&gt;      &lt;rollingStyle value=&quot;Date&quot; /&gt;      &lt;datePattern value=&quot;yyyyMMdd-HH:mm:ss&quot; /&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;!--每条日志末尾的文字说明--&gt;        &lt;footer value=&quot;by 周公&quot; /&gt;        &lt;!--输出格式--&gt;        &lt;!--样例：2008-03-26 13:42:32,111 [10] INFO  Log4NetDemo.MainClass [(null)] - info--&gt;        &lt;conversionPattern value=&quot;记录时间：%date 线程ID:[%thread] 日志级别：%-5level 出错类：%logger property:[%property{NDC}] - 错误描述：%message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到控制台命令行中--&gt;    &lt;appender name=&quot;ConsoleAppender&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到windows事件中--&gt;    &lt;appender name=&quot;EventLogAppender&quot; type=&quot;log4net.Appender.EventLogAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到数据库中，这里举例输出到Access数据库中，数据库为C盘的log4net.mdb--&gt;    &lt;appender name=&quot;AdoNetAppender_Access&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&gt;      &lt;connectionString value=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:log4net.mdb&quot; /&gt;      &lt;commandText value=&quot;INSERT INTO LogDetails ([LogDate],[Thread],[Level],[Logger],[Message]) VALUES (@logDate, @thread, @logLevel, @logger,@message)&quot; /&gt;      &lt;!--定义各个参数--&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logDate&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%date&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@thread&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%thread&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logLevel&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%level&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logger&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%logger&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@message&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%message&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;    &lt;/appender&gt;    &lt;!--定义日志的输出媒介，下面定义日志以四种方式输出。也可以下面的按照一种类型或其他类型输出。--&gt;    &lt;root&gt;      &lt;!--文件形式记录日志--&gt;      &lt;appender-ref ref=&quot;LogFileAppender&quot; /&gt;      &lt;!--控制台控制显示日志--&gt;      &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;      &lt;!--Windows事件日志--&gt;      &lt;appender-ref ref=&quot;EventLogAppender&quot; /&gt;      &lt;!-- 如果不启用相应的日志记录，可以通过这种方式注释掉      &lt;appender-ref ref=&quot;AdoNetAppender_Access&quot; /&gt;      --&gt;    &lt;/root&gt;  &lt;/log4net&gt;&lt;/configuration&gt;</code></pre><h2 id="appender配置使用示例"><a href="#appender配置使用示例" class="headerlink" title="appender配置使用示例"></a>appender配置使用示例</h2><pre><code>&lt;appender name=&quot;文件输出&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;      &lt;file value=&quot;F:\log\Log.txt&quot; /&gt;      &lt;appendToFile value=&quot;true&quot; /&gt;      &lt;rollingStyle value=&quot;Size&quot; /&gt;      &lt;maxSizeRollBackups value=&quot;10&quot; /&gt;      &lt;maximumFileSize value=&quot;5MB&quot; /&gt;      &lt;staticLogFileName value=&quot;true&quot; /&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %m %exception %n&quot;  /&gt;      &lt;/layout&gt;&lt;/appender&gt;</code></pre><h2 id="Log4Net结构"><a href="#Log4Net结构" class="headerlink" title="Log4Net结构"></a>Log4Net结构</h2><p>(1)Log4Net核心组件</p><pre><code>Log4net主要分为5个核心组件: Logger, Appender, Filter, Layout, Object Render。</code></pre><p>(2)Logger介绍</p><pre><code>Logger是负责日志的记录者，假设我们需要记录一些正常的运行时日志和出现异常时的错误日志，那么我们可以通过在配置文件当中添加两个Logger实现。Logger主要用于记录日志的分类和控制日志的级别。它可以以多种格式输出日志信息，同时它也可以控制日志的输出级别。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。</code></pre><p>(3)Appender介绍</p><pre><code>Appender提供记录的介质，我们可能要将日志输出到控制台，文本文件，windows 日志事件查看器中，包括数据库，邮件等等位置。我们可以通过Appender配置实现，而且Log4Net当中已经默认提供了一些常用的Appender，我们可以简单地修改一些配置文件就实现同时向数据库和同时向文件中写入的功能。</code></pre><p>(4)Filter介绍</p><pre><code>Filter就是过滤器，使用过滤器可以过滤掉Appender输出的部分内容，只输出感兴趣的日志。</code></pre><p>(5)Layout介绍</p><pre><code>Layout用于控制Appender的输出格式，可以使线性的也可以使XML。一个Appender只能有一个Layout配置。</code></pre><p>(6)Object Render介绍</p><pre><code>Object Render将告诉logger如何把一个对象转化为一个字符串记录到日志里。ILog中定义的记录日志的方法接收的参数是Object，而不是String。例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它。这时logger就会知道如何把Orange记录到日志中了。</code></pre><h2 id="配置文件结构图"><a href="#配置文件结构图" class="headerlink" title="配置文件结构图"></a>配置文件结构图</h2><p><img src="https://images0.cnblogs.com/blog/601464/201503/060905536956904.png" alt=""></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://logging.apache.org/log4net/release/config-examples.html" title="http://logging.apache.org/log4net/release/config-examples.html" target="_blank" rel="noopener">http://logging.apache.org/log4net/release/config-examples.html</a></p><ul><li><a href="http://www.cnblogs.com/LiZhiW/p/4317198.html" target="_blank" rel="noopener">Log4Net使用详解</a></li><li><a href="http://blog.csdn.net/zhoufoxcn/article/details/2220533" title="http://blog.csdn.net/zhoufoxcn/article/details/2220533" target="_blank" rel="noopener">http://blog.csdn.net/zhoufoxcn/article/details/2220533</a></li><li><a href="http://blog.csdn.net/zhoufoxcn/article/details/6029021" title="http://blog.csdn.net/zhoufoxcn/article/details/6029021" target="_blank" rel="noopener">http://blog.csdn.net/zhoufoxcn/article/details/6029021</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Log4Net&quot;&gt;&lt;a href=&quot;#Log4Net&quot; class=&quot;headerlink&quot; title=&quot;Log4Net&quot;&gt;&lt;/a&gt;Log4Net&lt;/h1&gt;&lt;h2 id=&quot;代码：&quot;&gt;&lt;a href=&quot;#代码：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Log4Net" scheme="https://caojingyou.github.io/tags/Log4Net/"/>
    
  </entry>
  
  <entry>
    <title>程序只能启动一次</title>
    <link href="https://caojingyou.github.io/2017/12/01/%E7%A8%8B%E5%BA%8F%E5%8F%AA%E8%83%BD%E5%90%AF%E5%8A%A8%E4%B8%80%E6%AC%A1/"/>
    <id>https://caojingyou.github.io/2017/12/01/程序只能启动一次/</id>
    <published>2017-12-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序只能启动一次"><a href="#程序只能启动一次" class="headerlink" title="程序只能启动一次"></a>程序只能启动一次</h1><pre><code>BOOL CIMServerApp::InitInstance(){    HANDLE hMutex=::CreateMutex(NULL,TRUE,&quot;NAME&quot;);//NAME随便写个    if (hMutex!=NULL)    {        if (GetLastError()==ERROR_ALREADY_EXISTS)        {            AfxMessageBox(&quot;已经有一个程序运行.&quot;);            return FALSE;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序只能启动一次&quot;&gt;&lt;a href=&quot;#程序只能启动一次&quot; class=&quot;headerlink&quot; title=&quot;程序只能启动一次&quot;&gt;&lt;/a&gt;程序只能启动一次&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;BOOL CIMServerApp::InitInstance()
{
  
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>libssh2</title>
    <link href="https://caojingyou.github.io/2017/11/24/libssh2/"/>
    <id>https://caojingyou.github.io/2017/11/24/libssh2/</id>
    <published>2017-11-24T08:03:00.000Z</published>
    <updated>2018-04-12T06:26:52.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="libssh2"><a href="#libssh2" class="headerlink" title="libssh2"></a>libssh2</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="https://www.libssh2.org/" title="https://www.libssh2.org/" target="_blank" rel="noopener">https://www.libssh2.org/</a></p><p><a href="https://github.com/libssh2/libssh2" title="https://github.com/libssh2/libssh2" target="_blank" rel="noopener">https://github.com/libssh2/libssh2</a></p><h2 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h2><p>需要<a href="https://www.openssl.org/" target="_blank" rel="noopener">openssl</a>以及<a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a></p><p>修改libssh下的win32目录下config.mk,修改openssl与zlib路径</p><p>在source根目录下nmake /f NMakefile</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;libssh2&quot;&gt;&lt;a href=&quot;#libssh2&quot; class=&quot;headerlink&quot; title=&quot;libssh2&quot;&gt;&lt;/a&gt;libssh2&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="libssh2" scheme="https://caojingyou.github.io/tags/libssh2/"/>
    
  </entry>
  
  <entry>
    <title>C++与浏览器交互</title>
    <link href="https://caojingyou.github.io/2017/11/15/C++%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E4%BA%92/"/>
    <id>https://caojingyou.github.io/2017/11/15/C++与浏览器交互/</id>
    <published>2017-11-15T08:03:00.000Z</published>
    <updated>2018-04-12T06:29:23.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebBrowser"><a href="#WebBrowser" class="headerlink" title="WebBrowser"></a>WebBrowser</h1><ul><li><a href="http://blog.csdn.net/charlessimonyi/article/details/18447471" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/18447471</a></li><li><a href="http://blog.csdn.net/charlessimonyi/article/details/18450783" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/18450783</a></li><li><a href="http://blog.csdn.net/charlessimonyi/article/details/50984903" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/50984903</a></li><li><a href="https://www.codeproject.com/articles/2352/javascript-call-from-c" target="_blank" rel="noopener">https://www.codeproject.com/articles/2352/javascript-call-from-c</a></li></ul><h1 id="CEF"><a href="#CEF" class="headerlink" title="CEF"></a>CEF</h1><ul><li><a href="https://www.codeproject.com/Articles/1105945/Embedding-a-Chromium-browser-in-an-MFC-application" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1105945/Embedding-a-Chromium-browser-in-an-MFC-application</a></li><li><a href="http://blog.csdn.net/daoxwj/article/details/8783629/" target="_blank" rel="noopener">http://blog.csdn.net/daoxwj/article/details/8783629/</a></li><li><a href="http://blog.csdn.net/daoxwj/article/details/8786911" target="_blank" rel="noopener">http://blog.csdn.net/daoxwj/article/details/8786911</a></li><li><a href="http://mariusbancila.ro/blog/2016/05/05/building-the-64-bit-version-of-chromium-embedded-framework-on-windows/" target="_blank" rel="noopener">http://mariusbancila.ro/blog/2016/05/05/building-the-64-bit-version-of-chromium-embedded-framework-on-windows/</a></li><li><a href="https://www.codeproject.com/Tips/785840/A-Simple-Windows-Example-Using-the-Chromium-Embedd" target="_blank" rel="noopener">https://www.codeproject.com/Tips/785840/A-Simple-Windows-Example-Using-the-Chromium-Embedd</a></li><li><a href="https://bitbucket.org/chromiumembedded/cef" target="_blank" rel="noopener">https://bitbucket.org/chromiumembedded/cef</a></li><li><a href="http://blog.csdn.net/mfcing/article/details/43953433" target="_blank" rel="noopener">http://blog.csdn.net/mfcing/article/details/43953433</a></li><li><a href="http://blog.csdn.net/mfcing/article/details/52066579" target="_blank" rel="noopener">http://blog.csdn.net/mfcing/article/details/52066579</a></li></ul><ol><li>CefClient：回调管理类，包含5个接口用于创建其它的回调类的对象</li><li>CefLifeSpanHandler: 回调类，用于控制popup对话框的创建和关闭等操作</li><li>CefLoadHandler: 回调类，可以用来监听frame的加载开始，完成，错误等信息</li><li>CefRequestHandler: 回调类，用于监听资源加载，重定向等信息</li><li>CefDisplayHandler: 回调类，用于监听页面加载状态，地址变化，标题等得信息</li><li>CefGeolocationHandler: 回调类，用于CEF3向嵌入者申请geolocation的权限</li><li>CefApp: 与进程，命令行参数，代理，资源管理相关的回调类，用于让CEF3的调用者们定制自己的逻辑</li><li>CefBrowser: renderer进程中执行浏览相关的类，例如前进，后退等</li><li>CefBrowserHost: browser进程中的执行浏览相关的类，其会把请求发送给CefBrowser</li><li>CefFrame: 表示的是页面中的一个Frame，可以加载特定url，在该运行环境下执行JavaScript代码等得。</li><li>V8：CEF3提供支持V8extension的接口，但是这有两个限制，第一，v8 extension仅在Renderer进程使用；第二，仅在沙箱模型关闭时使用</li></ol><p>需要安装cmake</p><ul><li><a href="https://cmake.org/" target="_blank" rel="noopener">https://cmake.org/</a></li><li><a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a></li><li></li></ul><h1 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h1><ul><li><a href="https://github.com/v8/v8/wiki" target="_blank" rel="noopener">https://github.com/v8/v8/wiki</a></li></ul><h1 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h1><p>SWIG 是一个非常优秀的开源工具，支持您将 C/C++ 代码与任何主流脚本语言相集成。此外，它向更广泛的受众公开了基本代码，改善了可测试性，让您的 Ruby 代码库某部分能快速写出高性能的 C/C++ 模块。</p><ul><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-swig/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/aix/library/au-swig/</a></li><li><a href="https://github.com/swig/swig" target="_blank" rel="noopener">https://github.com/swig/swig</a></li><li><a href="http://www.swig.org/download.html?cm_mc_uid=85410804137714897351221&amp;cm_mc_sid_50200000=1489735122" target="_blank" rel="noopener">http://www.swig.org/download.html?cm_mc_uid=85410804137714897351221&amp;cm_mc_sid_50200000=1489735122</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebBrowser&quot;&gt;&lt;a href=&quot;#WebBrowser&quot; class=&quot;headerlink&quot; title=&quot;WebBrowser&quot;&gt;&lt;/a&gt;WebBrowser&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ch
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="浏览器" scheme="https://caojingyou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CEF" scheme="https://caojingyou.github.io/tags/CEF/"/>
    
  </entry>
  
  <entry>
    <title>gitbook</title>
    <link href="https://caojingyou.github.io/2017/11/05/gitbook/"/>
    <id>https://caojingyou.github.io/2017/11/05/gitbook/</id>
    <published>2017-11-05T08:03:00.000Z</published>
    <updated>2018-04-12T06:27:40.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h1><p><a href="https://github.com/GitbookIO/gitbook" title="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">https://github.com/GitbookIO/gitbook</a></p><p><a href="https://toolchain.gitbook.com/ebook.html" title="https://toolchain.gitbook.com/ebook.html" target="_blank" rel="noopener">https://toolchain.gitbook.com/ebook.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gitbook&quot;&gt;&lt;a href=&quot;#gitbook&quot; class=&quot;headerlink&quot; title=&quot;gitbook&quot;&gt;&lt;/a&gt;gitbook&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/GitbookIO/gitbook&quot; tit
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="gitbook" scheme="https://caojingyou.github.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>wxWidgets</title>
    <link href="https://caojingyou.github.io/2017/11/01/wxWidgets/"/>
    <id>https://caojingyou.github.io/2017/11/01/wxWidgets/</id>
    <published>2017-11-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wxWidgets"><a href="#wxWidgets" class="headerlink" title="wxWidgets"></a>wxWidgets</h1><h2 id="Code-Blocks环境"><a href="#Code-Blocks环境" class="headerlink" title="Code::Blocks环境"></a>Code::Blocks环境</h2><h3 id="Code-Blocks下载："><a href="#Code-Blocks下载：" class="headerlink" title="Code::Blocks下载："></a>Code::Blocks下载：</h3><p>Code::Blocks使用：</p><p><a href="https://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe/download" target="_blank" rel="noopener">codeblocks-16.01mingw-setup.exe</a></p><p>它的gcc版本为4.9.2，也可在设置中对其进行更改</p><h3 id="wxMSW-3-1-0-gcc492下载："><a href="#wxMSW-3-1-0-gcc492下载：" class="headerlink" title="## wxMSW-3.1.0_gcc492下载： ##"></a>## wxMSW-3.1.0_gcc492下载： ##</h3><ul><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_gcc492TDM_Dev.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_gcc492TDM\_Dev.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0\\_gcc492TDM\\_ReleaseDLL.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_gcc492TDM\_ReleaseDLL.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxWidgets-3.1.0-headers.7z" target="_blank" rel="noopener">wxWidgets-3.1.0-headers.7z</a></li></ul><h3 id="Code-Blocks配置："><a href="#Code-Blocks配置：" class="headerlink" title="Code::Blocks配置："></a>Code::Blocks配置：</h3><p>解压wxMSW-3.1.0_gcc492TDM_Dev.7z与wxWidgets-3.1.0-headers.7z到同一目录：X:\wxMSW-3.1.0_gcc492TDM</p><p>在环境变量里添加一个wxWidgets根目录环境变量，新增的用户变量命名为wxwin，值为X:\wxMSW-3.1.0_gcc492TDM</p><p>打开Code::Blocks，选择菜单Settings-&gt;Global Variables…，在设置default下新建立一个wx变量，在Build-in fields:下，base中填入“${wxwin}”（wxwin是刚才设置好的一个变量），include中填入“${wxwin}\include”，lib中填入“${wxwin}\lib”</p><h3 id="新建项目："><a href="#新建项目：" class="headerlink" title="新建项目："></a>新建项目：</h3><h4 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h4><h4 id="建立项目的过程"><a href="#建立项目的过程" class="headerlink" title="建立项目的过程"></a>建立项目的过程</h4><p>通过菜单“File”-&gt;“New”-&gt;“Project…”，选择“Empty project”建一个项目。</p><p>点击菜单File-&gt;New-&gt;File…为项目新建一个源程序文件,main.cpp:</p><pre><code>#include &lt;wx/wx.h&gt;class Simple : public wxFrame{    public:    Simple(const wxString &amp; title);};Simple::Simple(const wxString &amp; title): wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(250, 150)){    Centre();}class MyApp : public wxApp{    public:    virtual bool OnInit();};IMPLEMENT_APP(MyApp)bool MyApp::OnInit(){    Simple * simple = new Simple(wxT(&quot;Simple&quot;));    simple-&gt;Show(true);    return true;}</code></pre><p>选菜单Project-&gt;Build options…，在选项卡Search directories中，设置Compiler。通过“Add”增加目录X:\wxMSW-3.1.0_gcc492TDM\include和X:\wxMSW-3.1.0_gcc492TDM\lib\gcc_dll\mswud，最好include在上mswud在下。(debug版用mswud，release版用mswu)</p><p>选菜单Project-&gt;Build options…，在选项卡Linker settings中，需要加入要连接的“目标文件”。如图所示，通过Add按钮加入X:\wxMSW-3.1.0_gcc492TDM\lib\gcc_dll文件夹中的所有.a文件</p><p>此时编译即可通过。</p><h4 id="利用Code-Blocks的向导建立"><a href="#利用Code-Blocks的向导建立" class="headerlink" title="利用Code::Blocks的向导建立"></a>利用Code::Blocks的向导建立</h4><p>使用向导建一个“wxWidgets project”项目。</p><ul><li><p>GUI设计工具和程序类型，用wxSmith和Dialog based。如果设置了“Code::Blocks配置”，wxWidgets’location直接填入“$(#wx)”就可以了,否则设置为X:\wxMSW-3.1.0_gcc492TDM目录。</p></li><li><p>wxWidgets Library Settings选择Enable unicode</p></li><li><p>选择Configure Advanced Options</p></li><li><p>选择Use _WXDEBUG_ and Debug wxWidgets lib</p></li><li><p>选择GUI Mode Application</p></li></ul><p>生成的程序源码：</p><p><a href="http://files.cnblogs.com/files/yhcao/wxTest3.1.0.rar" target="_blank" rel="noopener">wxTest3.1.0.rar</a></p><h3 id="程序运行："><a href="#程序运行：" class="headerlink" title="程序运行："></a>程序运行：</h3><p>程序运行时需要一些dll,到wxMSW-3.1.0_gcc492TDM_ReleaseDLL.7z中寻找，放到程序目录即可启动。</p><h2 id="VS2010环境"><a href="#VS2010环境" class="headerlink" title="VS2010环境"></a>VS2010环境</h2><h3 id="wxMSW-3-1-0-vc100下载："><a href="#wxMSW-3-1-0-vc100下载：" class="headerlink" title="wxMSW-3.1.0_vc100下载："></a>wxMSW-3.1.0_vc100下载：</h3><ul><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_vc100_Dev.7z" target="_blank" rel="noopener">wxMSW-3.1.0_vc100\_Dev.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_vc100_ReleaseDLL.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_vc100\_ReleaseDLL.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxWidgets-3.1.0-headers.7z" target="_blank" rel="noopener">wxWidgets-3.1.0-headers.7z</a></li></ul><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>把wxMSW-3.1.0_vc100_Dev.7z与wxWidgets-3.1.0-headers.7z解压到 X:\wxMSW-3.1.0_vc100_Dev</p><p>新建win32项目 windows应用程序 空项目</p><p>附加包含目录</p><ul><li>X:\wxMSW-3.1.0_vc100_Dev\include</li><li>X:\wxMSW-3.1.0_vc100_Dev\lib\vc_lib\mswud(debug)</li><li>X:\wxMSW-3.1.0_vc100_Dev\lib\vc_lib\mswu(release)</li></ul><p>添加附加依赖项：</p><pre><code>wxbase31ud_net.libwxmsw31ud_html.libwxbase31ud_xml.libwxmsw31ud_adv.libwxmsw31ud_aui.libwxmsw31ud_gl.libwxmsw31ud_media.libwxmsw31ud_propgrid.libwxmsw31ud_qa.libwxmsw31ud_ribbon.libwxmsw31ud_richtext.libwxmsw31ud_stc.libwxmsw31ud_xrc.libwxscintillad.libwxmsw31ud_core.libwxbase31ud.libwxtiffd.libwxjpegd.libwxpngd.libwxzlibd.libwxexpatd.libwinmm.libcomctl32.librpcrt4.libwsock32.libodbc32.lib</code></pre><p>头文件：</p><pre><code>#include &lt;wx/wx.h&gt;class wxMyApp:public wxApp{public:    virtual bool OnInit();};class wxMyFrame:public wxFrame{public:    wxMyFrame(const wxString&amp; title);};</code></pre><p>源文件：</p><pre><code>#include &quot;头文件.h&quot;bool wxMyApp::OnInit(){    wxMyFrame *pMyFrame=new wxMyFrame(_(&quot;myframe&quot;));    pMyFrame-&gt;Show(TRUE);    return TRUE;}wxMyFrame::wxMyFrame(const wxString&amp; title):wxFrame(NULL,NULL,title){}DECLARE_APP(wxMyApp);IMPLEMENT_APP(wxMyApp);</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://docs.wxwidgets.org/3.1/" target="_blank" rel="noopener">wxwidgets文档</a></li><li><a href="http://zetcode.com/gui/wxwidgets/" target="_blank" rel="noopener">wxWidgets教程</a></li><li><a href="http://wiki.codeblocks.org/index.php/User_documentation" target="_blank" rel="noopener">wxWidgets wiki</a></li><li><a href="http://wiki.codeblocks.org/index.php/WxSmith_tutorials" target="_blank" rel="noopener">WxSmith tutorials</a></li><li>C<a href="http://www.wxwidgets.org/docs/book/" target="_blank" rel="noopener">ross-Platform GUI Programming with wxWidgets</a></li><li><a href="http://blog.csdn.net/sxhelijian/article/details/26164181" target="_blank" rel="noopener">wxWidgets应用程序初体验</a></li><li><a href="http://blog.csdn.net/sxhelijian/article/details/26165237" target="_blank" rel="noopener">用wxSmith进行可视化设计 </a></li><li><a href="http://shiningray.cn/windows-shang-pei-zhi-codeblocks-wxwidgets.html" target="_blank" rel="noopener">Windows上配置Code::Blocks + wxWidgets</a></li><li><a href="http://blog.csdn.net/hitwhzhongqiu/article/details/44682359" target="_blank" rel="noopener">VS2010下新建wxWidgets空白工程</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wxWidgets&quot;&gt;&lt;a href=&quot;#wxWidgets&quot; class=&quot;headerlink&quot; title=&quot;wxWidgets&quot;&gt;&lt;/a&gt;wxWidgets&lt;/h1&gt;&lt;h2 id=&quot;Code-Blocks环境&quot;&gt;&lt;a href=&quot;#Code-Blocks环
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="wxWidgets" scheme="https://caojingyou.github.io/tags/wxWidgets/"/>
    
      <category term="Code::Blocks" scheme="https://caojingyou.github.io/tags/Code-Blocks/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen</title>
    <link href="https://caojingyou.github.io/2017/10/15/Doxygen/"/>
    <id>https://caojingyou.github.io/2017/10/15/Doxygen/</id>
    <published>2017-10-15T08:03:00.000Z</published>
    <updated>2018-03-06T05:51:35.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h1><h2 id="doxygen"><a href="#doxygen" class="headerlink" title="doxygen"></a>doxygen</h2><p>doxygen-1.8.13-setup.exe</p><h2 id="graphviz"><a href="#graphviz" class="headerlink" title="graphviz"></a>graphviz</h2><p>graphviz-2.38.msi</p><p>Graphviz软件是开源的图形可视化。可视化是图表的结构信息作为表示方式的抽象网络的示图和曲线图。有重要的应用在网络、生物信息学、软件工程、数据库、网页设计、机器学习、视觉界面中的其它技术领域。</p><h2 id="htmlhelp"><a href="#htmlhelp" class="headerlink" title="htmlhelp"></a>htmlhelp</h2><p>htmlhelp1.3.exe</p><h1 id="Doxygen配置方法"><a href="#Doxygen配置方法" class="headerlink" title="Doxygen配置方法"></a>Doxygen配置方法</h1><p>打开doxywizard.exe</p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen1.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen2.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen3.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen4.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen5.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen6.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen7.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen8.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen9.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen10.gif" alt=""></p><p>项目文件：</p><p><a href="http://files.cnblogs.com/files/yhcao/Doxyfile.rar" target="_blank" rel="noopener">Doxyfile.rar</a></p><h1 id="doxygen-的注释规范"><a href="#doxygen-的注释规范" class="headerlink" title="doxygen 的注释规范"></a>doxygen 的注释规范</h1><h2 id="标记的块的详细描述"><a href="#标记的块的详细描述" class="headerlink" title="标记的块的详细描述"></a>标记的块的详细描述</h2><h3 id="JavaDoc-style-C-style"><a href="#JavaDoc-style-C-style" class="headerlink" title="JavaDoc style,C-style"></a>JavaDoc style,C-style</h3><pre><code>/** * ... text ... */</code></pre><h3 id="Qt-style"><a href="#Qt-style" class="headerlink" title="Qt style"></a>Qt style</h3><pre><code>/*! * ... text ... */</code></pre><p>中间*可以省略</p><pre><code>/*! ... text ...*/</code></pre><h3 id="至少两个C-注释行，每一行都有一个附加斜线或感叹号"><a href="#至少两个C-注释行，每一行都有一个附加斜线或感叹号" class="headerlink" title="至少两个C++注释行，每一行都有一个附加斜线或感叹号"></a>至少两个C++注释行，每一行都有一个附加斜线或感叹号</h3><pre><code>////// ... text ...///</code></pre><p>或</p><pre><code>//!//!... text ...//!</code></pre><p>注意这种情况下需要一个单独的空行来结束注释。</p><h3 id="多行块注释"><a href="#多行块注释" class="headerlink" title="多行块注释"></a>多行块注释</h3><pre><code>/********************************************//** *  ... text ***********************************************/</code></pre><p>(note the 2 slashes to end the normal comment block and start a special comment block).</p><pre><code>//////////////////////////////////////////////////// ... text .../////////////////////////////////////////////////</code></pre><h2 id="简要描述"><a href="#简要描述" class="headerlink" title="简要描述"></a>简要描述</h2><h3 id="使用-brief"><a href="#使用-brief" class="headerlink" title="使用\brief"></a>使用<code>\brief</code></h3><pre><code>/*! \brief Brief description. *         Brief description continued. * *  Detailed description starts here. */</code></pre><h3 id="JAVADOC-AUTOBRIEF设置为YES-Javadoc风格"><a href="#JAVADOC-AUTOBRIEF设置为YES-Javadoc风格" class="headerlink" title="JAVADOC_AUTOBRIEF设置为YES,Javadoc风格"></a>JAVADOC_AUTOBRIEF设置为YES,Javadoc风格</h3><pre><code>/** Brief description which ends at this dot. Details follow *  here. */</code></pre><p>C++ comments:</p><pre><code>/// Brief description which ends at this dot. Details follow/// here.</code></pre><h3 id="用特殊的C-风格的注释"><a href="#用特殊的C-风格的注释" class="headerlink" title="用特殊的C++风格的注释"></a>用特殊的C++风格的注释</h3><pre><code>/// Brief description./** Detailed description. */</code></pre><p>或<br>    //! Brief description.</p><pre><code>//! Detailed description //! starts here.</code></pre><h3 id="多个详细的描述"><a href="#多个详细的描述" class="headerlink" title="多个详细的描述"></a>多个详细的描述</h3><pre><code>//! Brief description, which is//! really a detailed description since it spans multiple lines./*! Another detailed description! */</code></pre><h3 id="If-you-want-to-document-the-members-of-a-file-struct-union-class-or-enum-it-is-sometimes-desired-to-place-the-documentation-block-after-the-member-instead-of-before-For-this-purpose-you-have-to-put-an-additional-lt-marker-in-the-comment-block-Note-that-this-also-works-for-the-parameters-of-a-function"><a href="#If-you-want-to-document-the-members-of-a-file-struct-union-class-or-enum-it-is-sometimes-desired-to-place-the-documentation-block-after-the-member-instead-of-before-For-this-purpose-you-have-to-put-an-additional-lt-marker-in-the-comment-block-Note-that-this-also-works-for-the-parameters-of-a-function" class="headerlink" title="If you want to document the members of a file, struct, union, class, or enum, it is sometimes desired to place the documentation block after the member instead of before. For this purpose you have to put an additional &lt; marker in the comment block. Note that this also works for the parameters of a function"></a>If you want to document the members of a file, struct, union, class, or enum, it is sometimes desired to place the documentation block after the member instead of before. For this purpose you have to put an additional &lt; marker in the comment block. Note that this also works for the parameters of a function</h3><p>Qt style</p><pre><code>int var; /**&lt; Detailed description after the member */</code></pre><p>或</p><pre><code>int var; /*!&lt; Detailed description after the member */</code></pre><p>或</p><pre><code>int var; //!&lt; Detailed description after the member         //!&lt; </code></pre><p>或</p><pre><code>int var; ///&lt; Detailed description after the member         ///&lt; </code></pre><h3 id="Most-often-one-only-wants-to-put-a-brief-description-after-a-member"><a href="#Most-often-one-only-wants-to-put-a-brief-description-after-a-member" class="headerlink" title="Most often one only wants to put a brief description after a member"></a>Most often one only wants to put a brief description after a member</h3><pre><code>int var; //!&lt; Brief description after the member</code></pre><p>或</p><pre><code>int var; ///&lt; Brief description after the member</code></pre><h3 id="For-functions-one-can-use-the-param-command-to-document-the-parameters-and-then-use-in-out-in-out-to-document-the-direction-For-inline-documentation-this-is-also-possible-by-starting-with-the-direction-attribute-e-g"><a href="#For-functions-one-can-use-the-param-command-to-document-the-parameters-and-then-use-in-out-in-out-to-document-the-direction-For-inline-documentation-this-is-also-possible-by-starting-with-the-direction-attribute-e-g" class="headerlink" title="For functions one can use the @param command to document the parameters and then use [in], [out], [in,out] to document the direction. For inline documentation this is also possible by starting with the direction attribute, e.g."></a>For functions one can use the @param command to document the parameters and then use [in], [out], [in,out] to document the direction. For inline documentation this is also possible by starting with the direction attribute, e.g.</h3><pre><code>void foo(int v /**&lt; [in] docs for input parameter v. */);</code></pre><h3 id="Here-is-an-example-of-the-use-of-these-comment-blocks"><a href="#Here-is-an-example-of-the-use-of-these-comment-blocks" class="headerlink" title="Here is an example of the use of these comment blocks:"></a>Here is an example of the use of these comment blocks:</h3><pre><code>*! A test class */class Afterdoc_Test{  public:    /** An enum type.      *  The documentation block cannot be put after the enum!      */    enum EnumType    {      int EVal1,     /**&lt; enum value 1 */      int EVal2      /**&lt; enum value 2 */    };    void member();   //!&lt; a member function.  protected:    int value;       /*!&lt; an integer value */};</code></pre><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><h3 id="Qt-style-1"><a href="#Qt-style-1" class="headerlink" title="Qt style"></a>Qt style</h3><pre><code>//!  A test class. /*!  A more elaborate class description.*/class QTstyle_Test{  public:    //! An enum.    /*! More detailed enum description. */    enum TEnum {                  TVal1, /*!&lt; Enum value TVal1. */                   TVal2, /*!&lt; Enum value TVal2. */                   TVal3  /*!&lt; Enum value TVal3. */                 }          //! Enum pointer.         /*! Details. */         *enumPtr,          //! Enum variable.         /*! Details. */         enumVar;      //! A constructor.    /*!      A more elaborate description of the constructor.    */    QTstyle_Test();    //! A destructor.    /*!      A more elaborate description of the destructor.    */   ~QTstyle_Test();    //! A normal member taking two arguments and returning an integer value.    /*!      \param a an integer argument.      \param s a constant character pointer.      \return The test results      \sa QTstyle_Test(), ~QTstyle_Test(), testMeToo() and publicVar()    */    int testMe(int a,const char *s);    //! A pure virtual member.    /*!      \sa testMe()      \param c1 the first argument.      \param c2 the second argument.    */    virtual void testMeToo(char c1,char c2) = 0;    //! A public variable.    /*!      Details.    */    int publicVar;    //! A function variable.    /*!      Details.    */    int (*handler)(int a,int b);};</code></pre><h3 id="JavaDoc-style"><a href="#JavaDoc-style" class="headerlink" title="JavaDoc style"></a>JavaDoc style</h3><pre><code>/** *  A test class. A more elaborate class description. */class Javadoc_Test{  public:    /**      * An enum.     * More detailed enum description.     */    enum TEnum {           TVal1, /**&lt; enum value TVal1. */            TVal2, /**&lt; enum value TVal2. */            TVal3  /**&lt; enum value TVal3. */           }        *enumPtr, /**&lt; enum pointer. Details. */       enumVar;  /**&lt; enum variable. Details. */      /**       * A constructor.       * A more elaborate description of the constructor.       */      Javadoc_Test();      /**       * A destructor.       * A more elaborate description of the destructor.       */     ~Javadoc_Test();      /**       * a normal member taking two arguments and returning an integer value.       * @param a an integer argument.       * @param s a constant character pointer.       * @see Javadoc_Test()       * @see ~Javadoc_Test()       * @see testMeToo()       * @see publicVar()       * @return The test results       */       int testMe(int a,const char *s);      /**       * A pure virtual member.       * @see testMe()       * @param c1 the first argument.       * @param c2 the second argument.       */       virtual void testMeToo(char c1,char c2) = 0;      /**        * a public variable.       * Details.       */       int publicVar;      /**       * a function variable.       * Details.       */       int (*handler)(int a,int b);};</code></pre><h2 id="使用指令时需要在前面加上“-”或者“-”（JavaDoc风格）符号"><a href="#使用指令时需要在前面加上“-”或者“-”（JavaDoc风格）符号" class="headerlink" title="使用指令时需要在前面加上“\”或者“@”（JavaDoc风格）符号"></a>使用指令时需要在前面加上“\”或者“@”（JavaDoc风格）符号</h2><p><a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html" target="_blank" rel="noopener">特殊命令</a></p><ul><li>\class is used to indicate that the comment block contains documentation for the class</li><li>\struct to document a C-struct.</li><li>\union to document a union.</li><li>\enum to document an enumeration type.</li><li>\fn to document a function.</li><li>\var to document a variable or typedef or enum value.</li><li>\def to document a #define.</li><li>\typedef to document a type definition.</li><li>\file to document a file.</li><li>\namespace to document a namespace.</li><li>\package to document a Java package.</li><li>\interface to document an IDL interface.</li></ul><h2 id="Here-is-an-example-of-a-C-header-named-structcmd-h-that-is-documented-using-structural-commands"><a href="#Here-is-an-example-of-a-C-header-named-structcmd-h-that-is-documented-using-structural-commands" class="headerlink" title="Here is an example of a C header named structcmd.h that is documented using structural commands:"></a>Here is an example of a C header named structcmd.h that is documented using structural commands:</h2><pre><code>/*! \file structcmd.h    \brief A Documented file.    Details.*//*! \def MAX(a,b)    \brief A macro that returns the maximum of \a a and \a b.    Details.*//*! \var typedef unsigned int UINT32    \brief A type definition for a .    Details.*//*! \var int errno    \brief Contains the last error code.    \warning Not thread safe!*//*! \fn int open(const char *pathname,int flags)    \brief Opens a file descriptor.    \param pathname The name of the descriptor.    \param flags Opening flags.*//*! \fn int close(int fd)    \brief Closes the file descriptor \a fd.    \param fd The descriptor to close.*//*! \fn size_t write(int fd,const char *buf, size_t count)    \brief Writes \a count bytes from \a buf to the filedescriptor \a fd.    \param fd The descriptor to write to.    \param buf The data buffer to write.    \param count The number of bytes to write.*//*! \fn int read(int fd,char *buf,size_t count)    \brief Read bytes from a file descriptor.    \param fd The descriptor to read from.    \param buf The buffer to read into.    \param count The number of bytes to read.*/#define MAX(a,b) (((a)&gt;(b))?(a):(b))typedef unsigned int UINT32;int errno;int open(const char *,int);int close(int);size_t write(int,const char *, size_t);int read(int,char *,size_t);</code></pre><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><pre><code>/*** @file       filename* @brief      This is a brief description.* @details This is the detail description.* @author     author* @date       date* @version A001* @par Copyright (c):*      XXX公司* @par History:        *   version: author, date, desc\n*/</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><pre><code>/** 下面是一个含有两个参数的函数的注释说明（简述）  *  *     这里写该函数的详述信息  *     @param a 被测试的变量（param描述参数）  *     @param s 指向描述测试信息的字符串  *     @return    测试结果 （return描述返回值）  *     @see    Test()    （本函数参考其它的相关的函数，这里作一个链接）  *     @note    (note描述需要注意的问题)  */int testMe(int a,const char *s);</code></pre><h2 id="数据结构注释"><a href="#数据结构注释" class="headerlink" title="数据结构注释"></a>数据结构注释</h2><pre><code>/** * The brief description. * The detail description. */typedef struct{    int var1;///&lt;Description of the member variable}XXXX;或者typedef struct box {    成员变量注释（enum的各个值也如此注释）：    double length; ///&lt; The length of the box    double width; ///&lt; The width of the box    double height; ///&lt; The height of the box};</code></pre><h2 id="宏定义注释"><a href="#宏定义注释" class="headerlink" title="宏定义注释"></a>宏定义注释</h2><pre><code>/** Description of the macro */#define XXXX_XXX_XX      ox7fffffff或者#define XXXX_XXX_XX      0 ///&lt; Description of the macro.</code></pre><h2 id="全局和静态变量注释"><a href="#全局和静态变量注释" class="headerlink" title="全局和静态变量注释"></a>全局和静态变量注释</h2><pre><code>/**  Description of global variable  */int g_xxx = 0;static int s_xxx = 0; ///&lt;  Description of static variable</code></pre><h1 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h1><p><a href="http://www.doxygen.nl/helpers.html" title="http://www.doxygen.nl/helpers.html" target="_blank" rel="noopener">http://www.doxygen.nl/helpers.html</a></p><p><a href="https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET" title="https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET" target="_blank" rel="noopener">https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET</a></p><p><a href="https://www.atomineerutils.com/products.php" title="https://www.atomineerutils.com/products.php" target="_blank" rel="noopener">https://www.atomineerutils.com/products.php</a></p><p><a href="http://doxycomment.sourceforge.net/" title="http://doxycomment.sourceforge.net/" target="_blank" rel="noopener">http://doxycomment.sourceforge.net/</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.stack.nl/~dimitri/doxygen/download.html" title="http://www.stack.nl/~dimitri/doxygen/download.html" target="_blank" rel="noopener">http://www.stack.nl/~dimitri/doxygen/download.html</a></li><li><a href="http://www.stack.nl/~dimitri/doxygen/helpers.html" title="http://www.stack.nl/~dimitri/doxygen/helpers.html" target="_blank" rel="noopener">http://www.stack.nl/~dimitri/doxygen/helpers.html</a></li><li><a href="http://www.graphviz.org/" title="http://www.graphviz.org/" target="_blank" rel="noopener">http://www.graphviz.org/</a></li><li><a href="http://www.graphviz.org/Download..php" title="http://www.graphviz.org/Download..php" target="_blank" rel="noopener">http://www.graphviz.org/Download..php</a></li><li><a href="http://www.cnblogs.com/chenyang920/p/5732643.html" title="http://www.cnblogs.com/chenyang920/p/5732643.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenyang920/p/5732643.html</a></li><li><a href="http://blog.csdn.net/fly542/article/details/7164633" title="http://blog.csdn.net/fly542/article/details/7164633" target="_blank" rel="noopener">http://blog.csdn.net/fly542/article/details/7164633</a></li><li><a href="http://blog.csdn.net/bigpudding24/article/details/45247357" title="http://blog.csdn.net/bigpudding24/article/details/45247357" target="_blank" rel="noopener">http://blog.csdn.net/bigpudding24/article/details/45247357</a></li><li><a href="http://blog.csdn.net/hujian2008/article/details/16343489" title="http://blog.csdn.net/hujian2008/article/details/16343489" target="_blank" rel="noopener">http://blog.csdn.net/hujian2008/article/details/16343489</a></li><li><a href="http://blog.csdn.net/wenrenhua08/article/details/39591239" title="http://blog.csdn.net/wenrenhua08/article/details/39591239" target="_blank" rel="noopener">http://blog.csdn.net/wenrenhua08/article/details/39591239</a></li><li><a href="http://blog.csdn.net/augusdi/article/details/6749845" title="http://blog.csdn.net/augusdi/article/details/6749845" target="_blank" rel="noopener">http://blog.csdn.net/augusdi/article/details/6749845</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装工具&quot;&gt;&lt;a href=&quot;#安装工具&quot; class=&quot;headerlink&quot; title=&quot;安装工具&quot;&gt;&lt;/a&gt;安装工具&lt;/h1&gt;&lt;h2 id=&quot;doxygen&quot;&gt;&lt;a href=&quot;#doxygen&quot; class=&quot;headerlink&quot; title=&quot;dox
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Doxygen" scheme="https://caojingyou.github.io/tags/Doxygen/"/>
    
  </entry>
  
  <entry>
    <title>VC程序获取管理员权限</title>
    <link href="https://caojingyou.github.io/2017/10/01/VC%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"/>
    <id>https://caojingyou.github.io/2017/10/01/VC程序获取管理员权限/</id>
    <published>2017-10-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h1><p>编译程序的时候设置一下<br>在项目属性–连接器–清单文件–UAC执行级别改为requireAdministrator</p><h1 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h1><pre><code>void GainAdminPrivileges(CString strApp, UINT idd){    CString         strCmd;    strCmd.Format (_T(&quot;/adminoption %d&quot;), idd);    SHELLEXECUTEINFO execinfo;    memset(&amp;execinfo, 0, sizeof(execinfo));    execinfo.lpFile         = strApp;    execinfo.cbSize         = sizeof(execinfo);    execinfo.lpVerb         = _T(&quot;runas&quot;);    execinfo.fMask          = SEE_MASK_NO_CONSOLE;    execinfo.nShow          = SW_SHOWDEFAULT;    execinfo.lpParameters   = strCmd;    ShellExecuteEx(&amp;execinfo);}  </code></pre><p>strApp是应用程序的路径idd我传的是1，但好像传几都没问题</p><pre><code>BOOL ElevateCurrentProcess(CString sCmdLine){    TCHAR szPath[MAX_PATH] = {0};    if (::GetModuleFileName(NULL, szPath, MAX_PATH))    {        // Launch itself as administrator.        SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO) };        sei.lpVerb = _T(&quot;runas&quot;);        sei.lpFile = szPath;        sei.lpParameters = (LPCTSTR)sCmdLine;        //     sei.hwnd = hWnd;        sei.nShow = SW_SHOWNORMAL;        if (!ShellExecuteEx(&amp;sei))        {            DWORD dwStatus = GetLastError();            if (dwStatus == ERROR_CANCELLED)            {                // The user refused to allow privileges elevation.                return FALSE;            }            else if (dwStatus == ERROR_FILE_NOT_FOUND)            {                // The file defined by lpFile was not found and                // an error message popped up.                return FALSE;            }            return FALSE;        }        return TRUE;    }    return FALSE;}</code></pre><h1 id="如何获取正确的文件路径"><a href="#如何获取正确的文件路径" class="headerlink" title="如何获取正确的文件路径"></a>如何获取正确的文件路径</h1><p>当我们那些在Windows 7之前设计的应用程序遇到UAC Virtualization问题的时候，我们需要从新设计我们的代码，将文件写入到合适的位置。在改善既有代码，使之可以与Windows 7兼容的时候，我们应该确保以下几点：</p><p>　　——在运行的时候，应用程序只会将数据保存到每个用户预先定义的位置或者是%alluserprofile% 中定义的普通用户拥有访问权限的位置。</p><p>　　——确定你要写入数据的“已知文件夹”(Knownfolders)。通常，所有用户共用的公共数据文件应该写入到一个全局的公共的位置，这样所有用户都可以访问到。而其它数据则应该写入每个用户自己的文件夹。</p><p>　　1 公共数据文件包括日志文件，配置文件(通常是INI或者XML文件)，应用程序状态文件，比如保存的游戏进程等等。</p><p>　　2 而属于每个用户的文档，则应该保持在文档目录下，或者是用户自己指定的目录。</p><p>　　——当你确定合适的文件保存位置后，不要在代码中明文写出(Hard-code)你选择的路径。为了更好地保持兼容性，我们应该采用下面这些API来获得操作系统“已知文件夹(Knownfolders)”的正确路径。</p><p>　　1 C/C++非托管代码: 使用SHGetKnownFolderPath函数，通过指定“已知文件夹”的KNOWNFOLDERID作为参数来获得正确的文件夹路径。</p><pre><code>　　FOLDERID_ProgramData –所有用户都可以访问的应用程序数据适合放置在这个目录下。　　FOLDERID_LocalAppData – 每个用户单独访问的应用程序数据适合放置在这个目录下。　　FOLDERID_RoamingAppData – 每个用户单独访问的应用程序数据适合放置在这个目录下。 与上面一个目录不同的是，放置在这个目录下的文件会随着用户迁移，当一个用户在同一个域中的其他计算机登录的时候，这些文件会被复制到当前登录的机器上，就像用户随身携带的公文包一样。</code></pre><p>下面这段代码演示了在非托管代码中如何调用shell函数，SHGetKnownFolderPath函数获得正确的文件保存路径(SHGetFolderLocation, SHGetFolderPath, SHGetSpecialFolderLocation, SHGetSpecialFolderPath)：</p><pre><code>#include &quot;shlobj.h&quot;#include &quot;shlwapi.h&quot;//…#define AppFolderName _T(&quot;YourApp&quot;)#define DataFileName _T(&quot;SomeFile.txt&quot;)// 构造一个数据文件路径// dataFilePath指向一个长度为MAX_PATH，类型为TCHAR的字符串数值// hwndDlg是消息对话框的父窗口句柄// 当有错误发生的时候用于显示错误提示// includeFileName用于表示是否在路径后面扩展文件名BOOL MakeDataFilePath(TCHAR *dataFilePath,                       HWND hwndDlg, BOOL includeFileName){    // 初始化工作    memset(dataFilePath, 0, MAX_PATH * sizeof(TCHAR));    PWSTR pszPath = NULL;    // SHGetKnownFolderPath函数可以返回一个已知文件见的路径，    // 例如我的文档(My Documents)，桌面(Desktop)，       // 应用程序文件夹(Program Files)等等。     // 对于数据文件来说，FOLDERID_ProgramFiles并不是一个合适的位置    // 使用FOLDERID_ProgramFiles保存所有用户共享的数据文件    // 使用FOLDERID_LocalAppData保存属于每个用户自己的文件(non-roaming).    // 使用FOLDERID_RoamingAppData保存属于每个用户自己的文件(roaming).// 对于“随身文件”(Roaming files)，// 当一个用户在一个域中的其他计算机登陆的时候，    // 这些文件会被复制到当前登录的机器上，就像用户随身携带的公文包一样        // 获取文件夹路径    if (FAILED(SHGetKnownFolderPath(FOLDERID_ProgramData,               0, NULL, &amp;pszPath)))    // 错误的做法： if (FAILED(SHGetKnownFolderPath(FOLDERID_ProgramFiles,       // 0, NULL, &amp;pszPath)))    {        // 提示错误        MessageBox(hwndDlg, _T(&quot;SHGetKnownFolderPath无法获取文件路径&quot;),            _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);        return FALSE;    }    // 复制路径到目标变量    _tcscpy_s(dataFilePath, MAX_PATH, pszPath);    ::CoTaskMemFree(pszPath);    //错误的做法: _tcscpy_s(dataFilePath, MAX_PATH, _T(&quot;C:\\&quot;));    // 在路径后面扩展应用程序所在文件夹    if (!::PathAppend(dataFilePath, AppFolderName))    {        // 提示错误        MessageBox(hwndDlg, _T(&quot;PathAppend无法扩展路径&quot;),            _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);        return FALSE;    }    // 是否添加文件名    if (includeFileName)    {        // 在路径后扩展文件名        if (!::PathAppend(dataFilePath, DataFileName))        {            // 提示错误            MessageBox(hwndDlg, _T(&quot;PathAppend无法扩展文件名&quot;),                _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);            return FALSE;        }    }    return TRUE;}</code></pre><p>2 托管代码: 使用System.Environment.GetFolderPath函数，通过指定我们想要获取的“已知文件夹”为参数，从而获取相应的文件夹的正确路径。</p><pre><code>　　Environment.SpecialFolder.CommonApplicationData – 所有用户都可以访问的应用程序数据适合放置在这个目录下。　　Environment.SpecialFolder.LocalApplicationData – 每个用户单独访问的应用程序数据适合放置在这个目录下。　　Environment.SpecialFolder.ApplicationData – 每个用户单独访问的应用程序数据适合放置在这个目录下。这是“随身文件夹”。</code></pre><p>下面这段代码展示了如何在托管代码中获取正确的文件路径：</p><pre><code>internal class FileIO    {        private const string AppFolderName = &quot;YourApp&quot;;        private const string DataFileName = &quot;SomeFile.txt&quot;;        private static string _dataFilePath;        /// &lt;summary&gt;        /// 构建路径        /// &lt;/summary&gt;        static FileIO()        {            // Environment.GetFolderPath返回一个“已知文件夹”的路径            // Path.Combine可以合并两个路径成一个合法的路径            // …            _dataFilePath = Path.Combine(Environment.GetFolderPath(                  Environment.SpecialFolder.ProgramFiles), AppFolderName);            //错误的做法：            //_dataFilePath = Path.Combine(Environment.GetFolderPath(             Environment.SpecialFolder.CommonApplicationData), AppFolderName);            // 扩展文件名            _dataFilePath = Path.Combine(_dataFilePath, DataFileName);        }         public static void Save(string text)        {            // 检查要保存的字符串是否为空            if (String.IsNullOrEmpty(text))            {                MessageBox.Show(&quot;字符串为空，无法保持.&quot;, &quot;空字符串&quot;,                     MessageBoxButtons.OK, MessageBoxIcon.Error);                return;            }            try            {                // 获取文件保存的路径                string dirPath = Path.GetDirectoryName(_dataFilePath);                // 检查文件夹是否存在                if (!Directory.Exists(dirPath))                    Directory.CreateDirectory(dirPath); // 创建文件夹            }            catch (Exception ex)            {                MessageBox.Show(ex.Message, &quot;文件夹创建失败&quot;,                    MessageBoxButtons.OK, MessageBoxIcon.Error);                return;            }            try            {                // 保存字符串到文件                StreamWriter sw = new StreamWriter(_dataFilePath);                try                {                    sw.Write(text);                }                finally                {                    // 关闭文件                    sw.Close();                }            }            catch (Exception ex)            {                MessageBox.Show(ex.Message, &quot;文件写入失败&quot;,                    MessageBoxButtons.OK, MessageBoxIcon.Error);            }        }        // …   }}</code></pre><p>如果上面的方法都不适合你，你还可以使用环境变量，使用getenv()或GetEnvironmentVariable()获取相应的文件夹路径：</p><pre><code>　　%ALLUSERSPROFILE% – 所有用户都可以访问的应用程序数据适合放置在这个目录下。　　%LOCALAPPDATA% – 每个用户单独访问的应用程序数据适合放置在这个目录下。 - (Windows Vista 或者Windows 7)　　%APPDATA% – 每个用户单独访问的应用程序数据适合放置在这个目录下。这是“随身文件夹”。- (Windows Vista 或者Windows 7)</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://blog.csdn.net/zhangyulin54321/article/details/8802023" target="_blank" rel="noopener">vc++MCF/C++/C中怎样让应用程序获得或以管理员权限运行 ，ShellExecuteEX编程 — 获取管理员权限</a> </li><li><a href="http://blog.csdn.net/suixiangzhe/article/details/50503047" target="_blank" rel="noopener">VS2010与Win7共舞：UAC与数据重定向 </a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb762494(v=vs.85" target="_blank" rel="noopener">CSIDL</a>.aspx)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：&quot;&gt;&lt;a href=&quot;#一：&quot; class=&quot;headerlink&quot; title=&quot;一：&quot;&gt;&lt;/a&gt;一：&lt;/h1&gt;&lt;p&gt;编译程序的时候设置一下&lt;br&gt;在项目属性–连接器–清单文件–UAC执行级别改为requireAdministrator&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VC" scheme="https://caojingyou.github.io/tags/VC/"/>
    
      <category term="管理员权限" scheme="https://caojingyou.github.io/tags/%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Crypto++</title>
    <link href="https://caojingyou.github.io/2017/09/15/Crypto++/"/>
    <id>https://caojingyou.github.io/2017/09/15/Crypto++/</id>
    <published>2017-09-15T08:03:00.000Z</published>
    <updated>2018-04-19T07:48:45.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Crypto-学习"><a href="#Crypto-学习" class="headerlink" title="Crypto++学习"></a>Crypto++学习</h1><pre><code>// MyTest.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iomanip&gt;//setw与setfill头文件#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1#include &quot;cryptlib.h&quot;#include &quot;md5.h&quot;#include &quot;filters.h&quot;#include &quot;hex.h&quot;#include &quot;base64.h&quot;#include &quot;files.h&quot;#include &quot;sha.h&quot;#include &quot;crc.h&quot;#include &quot;ripemd.h&quot;USING_NAMESPACE(CryptoPP)USING_NAMESPACE(std)int _tmain(int argc, _TCHAR *argv[]){    /************************************************************************/    /* 散列算法                                                                     */    /************************************************************************/    /************************************************************************/    /* MD5                                                                     */    /************************************************************************/    printf(&quot;MD5开始\n&quot;);    byte message[] = &quot;HelloWorld!&quot;;    int mesLen = strlen((char *)message - 1);    byte mres[16];//MD5 128 bits=16bytes    Weak::MD5 md5;    md5.Update(message, mesLen);    md5.Final(mres);    /************************************************************************/    /* md5转换到string                                                                     */    /************************************************************************/    string digest3;    StringSource ss3(mres, sizeof(mres), true,        new HexEncoder(new StringSink(digest3))        );    cout &lt;&lt; digest3 &lt;&lt; endl;    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* md5转换到byte数组                                                                     */    /************************************************************************/    for(int i = 0; i &lt; 16; i++)        printf(&quot;%02x&quot;, mres[i]);    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* 使用SecByteBlock                                                                     */    /************************************************************************/    char *inputCh = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    const byte *input = (byte *)inputCh;    SecByteBlock digest(md5.DigestSize());    //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句    md5.Update(input, strlen(inputCh));    md5.Final(digest);    for(int i = 0; i &lt; md5.DigestSize(); i++)        printf(&quot;%02x&quot;, digest[i]);    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    for (unsigned j = 0; j &lt; md5.DigestSize(); j++)        cout &lt;&lt; setw(2) &lt;&lt; setfill(&apos;0&apos;) &lt;&lt; hex &lt;&lt; (int)digest[j];    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    string src = &quot;123&quot;;    string digest1;    /************************************************************************/    /* 另一种方法转换md5                                                                     */    /************************************************************************/    Weak::MD5 md51;    StringSource(src, true,        new HashFilter(md51,        new HexEncoder(new StringSink(digest1))        )        );    cout &lt;&lt; digest1 &lt;&lt; endl;    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* MD5对文件产生签名                                                                     */    /************************************************************************/    {        std::locale loc1 = std::locale::global(std::locale(&quot;.936&quot;)); //解决中文文件名问题        Weak::MD5 md5;        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            md5, new HexEncoder(new StringSink(digest4))            )            );        std::locale::global(std::locale(loc1));        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;    }    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    printf(&quot;MD5结束\n&quot;);    /************************************************************************/    /* 二进制数组编码                                                                     */    /************************************************************************/    /************************************************************************/    /* 将一个byte数组按16进制编码后输出                                                                     */    /************************************************************************/    string encoded;    byte m[] = &quot;HelloWorld!&quot;;    StringSource ss(m, sizeof(m), true,        new HexEncoder(new StringSink(encoded))        );    cout &lt;&lt; encoded &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* 将一个string按16进制编码后输出                                                                     */    /************************************************************************/    string encoded1;    string ms = &quot;HelloWorld!&quot;;    StringSource ss1(ms, true,        new HexEncoder(new StringSink(encoded1))        );    cout &lt;&lt; encoded1 &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* 将一个byte数组按base64编码后输出                                                                     */    /************************************************************************/    string encoded2;    StringSource s(m, sizeof(m), true,        new Base64Encoder(new StringSink(encoded2))        );    cout &lt;&lt; encoded2 &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* SHA-1对字符串签名                                                                     */    /************************************************************************/    {        SHA1 sha1;        string digest5;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha1,            new HexEncoder(new StringSink(digest5))            )            );        cout &lt;&lt; &quot;SHA-1:    &quot; &lt;&lt; digest5 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha1, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA256 sha256;        string digest246;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha256,            new HexEncoder(new StringSink(digest246))            )            );        cout &lt;&lt; &quot;SHA-256:    &quot; &lt;&lt; digest246 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha256, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA384 sha384;        string digest384;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha384,            new HexEncoder(new StringSink(digest384))            )            );        cout &lt;&lt; &quot;SHA-384:    &quot; &lt;&lt; digest384 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha384, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA512 sha512;        string digest512;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha512,            new HexEncoder(new StringSink(digest512))            )            );        cout &lt;&lt; &quot;SHA-512:    &quot; &lt;&lt; digest512 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha512, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* CRC32跟MD5类似                                                                     */    /************************************************************************/    {        CRC32 crc;        string src = &quot;HelloWorld!&quot;;        string digestcrc;        char *inputCh = &quot;HelloWorld!&quot;;        const byte *input = (byte *)inputCh;        SecByteBlock digest(crc.DigestSize());        //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句        crc.Update(input, strlen(inputCh));        crc.Final(digest);        cout &lt;&lt; &quot;CRC-32:    &quot;;        for(int i = 0; i &lt; crc.DigestSize(); i++)            printf(&quot;%02x&quot;, digest[i]);        printf(&quot;\n&quot;);        StringSource(src, true,            new HashFilter(crc,            new HexEncoder(new StringSink(digestcrc))            )            );        cout &lt;&lt; &quot;CRC-32:    &quot; &lt;&lt; digestcrc &lt;&lt; endl;        printf(&quot;\n&quot;);        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            crc, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* RIPEMD160                                                                   */    /************************************************************************/    {        RIPEMD160 md160;        string src = &quot;HelloWorld!&quot;;        string digestcrc;        char *inputCh = &quot;HelloWorld!&quot;;        const byte *input = (byte *)inputCh;        SecByteBlock digest(md160.DigestSize());        //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句        md160.Update(input, strlen(inputCh));        md160.Final(digest);        cout &lt;&lt; &quot;RIPEMD-160:    &quot;;        for(int i = 0; i &lt; md160.DigestSize(); i++)            printf(&quot;%02x&quot;, digest[i]);        printf(&quot;\n&quot;);        StringSource(src, true,            new HashFilter(md160,            new HexEncoder(new StringSink(digestcrc))            )            );        cout &lt;&lt; &quot;RIPEMD-160:    &quot; &lt;&lt; digestcrc &lt;&lt; endl;        printf(&quot;\n&quot;);        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            md160, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* 对称加密算法 DES AES                                                                     */    /************************************************************************/    /************************************************************************/    /* DES    ValidateDES();                                                                     */    /************************************************************************/    /************************************************************************/    /* AES ValidateRijndael();                                                                     */    /************************************************************************/    /************************************************************************/    /* 非对称加密算法                                                                     */    /************************************************************************/    /************************************************************************/    /* RSA GenerateRSAKey、RSAEncryptString、RSADecryptString、RSASignFile、RSAVerifyFile                                                                     */    /************************************************************************/    system(&quot;pause&quot;);    //http://www.cppblog.com/ArthasLee/archive/2010/12/01/135186.html    return 0;}</code></pre><p>ChannelSwitch</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cryptopp/channels.h&gt; #include &lt;cryptopp/filters.h&gt; #include &lt;cryptopp/sha.h&gt; #include &lt;cryptopp/hex.h&gt;int main(int argc, char *argv[]) {std::string message = &quot;Now is the time for all good men to come to the aide of their country&quot;;// Allow user to override default message from command line arg.if(argc == 2 &amp;&amp; argv[1] != NULL)     message = std::string(argv[1]);// Set hash variablesstd::string s1, s2, s3, s4;CryptoPP::SHA1 sha1; CryptoPP::SHA224 sha224; CryptoPP::SHA256 sha256; CryptoPP::SHA512 sha512;// Run hash functionsCryptoPP::HashFilter f1(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s1)));CryptoPP::HashFilter f2(sha224, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s2)));CryptoPP::HashFilter f3(sha256, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s3)));CryptoPP::HashFilter f4(sha512, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s4)));// Set route to defaultCryptoPP::ChannelSwitch cs;cs.AddDefaultRoute(f1);cs.AddDefaultRoute(f2);cs.AddDefaultRoute(f3);cs.AddDefaultRoute(f4);CryptoPP::StringSource ss(message, true /*pumpAll*/, new CryptoPP::Redirector(cs));std::cout &lt;&lt; &quot;Message: &quot; &lt;&lt; message &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-1: &quot; &lt;&lt; s1 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-224: &quot; &lt;&lt; s2 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-256: &quot; &lt;&lt; s3 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-512: &quot; &lt;&lt; s4 &lt;&lt; std::endl;}</code></pre><p>文档：</p><ul><li><a href="https://www.cryptopp.com/docs/ref/index.html" title="https://www.cryptopp.com/docs/ref/index.html" target="_blank" rel="noopener">https://www.cryptopp.com/docs/ref/index.html</a></li><li><a href="https://www.cryptopp.com/wiki/Main_Page" title="https://www.cryptopp.com/wiki/Main_Page" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Main_Page</a></li><li><a href="https://www.cryptopp.com/wiki/Special:AllPages" title="https://www.cryptopp.com/wiki/Special:AllPages" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Special:AllPages</a></li><li><a href="https://www.cryptopp.com/wiki/Category:Class" title="https://www.cryptopp.com/wiki/Category:Class" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Category:Class</a><br>-<a href="https://www.cryptopp.com/wiki/Category:Sample" title="https://www.cryptopp.com/wiki/Category:Sample" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Category:Sample</a></li><li><a href="https://www.cryptopp.com/wiki/ChannelSwitch" title="https://www.cryptopp.com/wiki/ChannelSwitch" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/ChannelSwitch</a></li><li><a href="https://www.cryptopp.com/wiki/Recommended_Books" title="https://www.cryptopp.com/wiki/Recommended_Books" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Recommended_Books</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Crypto-学习&quot;&gt;&lt;a href=&quot;#Crypto-学习&quot; class=&quot;headerlink&quot; title=&quot;Crypto++学习&quot;&gt;&lt;/a&gt;Crypto++学习&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// MyTest.cpp : 定义控制台应用程序的入口点。
/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="Crypto++" scheme="https://caojingyou.github.io/tags/Crypto/"/>
    
      <category term="密码" scheme="https://caojingyou.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本编程30分钟入门</title>
    <link href="https://caojingyou.github.io/2017/09/01/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://caojingyou.github.io/2017/09/01/Shell脚本编程30分钟入门/</id>
    <published>2017-09-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本编程30分钟入门"><a href="#Shell脚本编程30分钟入门" class="headerlink" title="Shell脚本编程30分钟入门"></a>Shell脚本编程30分钟入门</h1><p>转载地址：<br><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">Shell脚本编程30分钟入门</a></p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>看个例子吧：</p><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><ul><li>第1行：指定脚本解释器，这里是用/bin/sh做解释器的</li><li>第2行：切换到当前用户的home目录</li><li>第3行：创建一个目录shell_tut</li><li>第4行：切换到shell_tut目录</li><li>第5行：循环条件，一共循环10次</li><li>第6行：创建一个test_1…10.txt文件</li><li>第7行：循环体结束</li></ul><p>cd, mkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。</p><h3 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h3><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>shell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux默认安装就带了shell解释器。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p><h4 id="Windows上的模拟器"><a href="#Windows上的模拟器" class="headerlink" title="Windows上的模拟器"></a>Windows上的模拟器</h4><p>windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p><ul><li><a href="http://www.cygwin.com" target="_blank" rel="noopener">cygwin</a></li><li><a href="http://www.mingw.org" target="_blank" rel="noopener">mingw</a></li></ul><h3 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h3><h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。</p><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h4 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h4><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><p>如下是一个PHP Shell Script示例（假设文件名叫test.php）：</p><pre><code>#!/usr/bin/php&lt;?phpfor ($i=0; $i &lt; 10; $i++)        echo $i . &quot;\n&quot;;</code></pre><p>执行：</p><pre><code>/usr/bin/php test.php</code></pre><p>或者：</p><pre><code>chmod +x test.php./test.php</code></pre><h2 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h2><h3 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h3><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h3 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h3><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><ul><li>它的函数只能返回字串，无法返回数组</li><li>它不支持面向对象，你无法实现一些优雅的设计模式</li><li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li></ul><h3 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h3><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p><p>输入一些代码，第一行一般是这样：</p><pre><code>#!/bin/bash#!/usr/bin/php</code></pre><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行Shell脚本有两种方法：</p><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h3 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h3><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以“#”开头的行就是注释，会被解释器忽略。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>sh里没有多行注释，只能每一行加一个#号。就像这样：</p><pre><code>#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><pre><code>str=&apos;this is a string&apos;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h4 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h4><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><pre><code>string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#输出：8，这个语句的意思是：找出单词is在这名话中的位置</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>参见本文档末尾的参考资料中<a href="http://tldp.org/LDP/abs/html/string-manipulation.html" target="_blank" rel="noopener">Advanced Bash-Scripting Guid Chapter 10.1</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和cd, ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code>if conditionthen    command1     command2    ...    commandN fi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h4 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h4><pre><code>if conditionthen    command1     command2    ...    commandNelse    commandfi</code></pre><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h3 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h4 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h4><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><pre><code>while conditiondo    commanddone</code></pre><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><pre><code>. ./function.sh</code></pre><p>不可以写作：</p><pre><code>. function.sh</code></pre><p>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h2><h3 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h3><h3 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h3><h3 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h3><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看进程列表</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h4 id="排除grep自身"><a href="#排除grep自身" class="headerlink" title="排除grep自身"></a>排除grep自身</h4><h4 id="查找与target相邻的结果"><a href="#查找与target相邻的结果" class="headerlink" title="查找与target相邻的结果"></a>查找与target相邻的结果</h4><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">Advanced Bash-Scripting Guide</a>，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</li><li><a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">Unix Shell Programming</a></li><li><a href="http://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">Linux Shell Scripting Tutorial - A Beginner’s handbook</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shell脚本编程30分钟入门&quot;&gt;&lt;a href=&quot;#Shell脚本编程30分钟入门&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本编程30分钟入门&quot;&gt;&lt;/a&gt;Shell脚本编程30分钟入门&lt;/h1&gt;&lt;p&gt;转载地址：&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Shell" scheme="https://caojingyou.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://caojingyou.github.io/2017/08/21/Python/"/>
    <id>https://caojingyou.github.io/2017/08/21/Python/</id>
    <published>2017-08-21T08:03:00.000Z</published>
    <updated>2018-04-12T06:25:16.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.python.org/" title="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p><h2 id="第三方包安装方法"><a href="#第三方包安装方法" class="headerlink" title="第三方包安装方法"></a>第三方包安装方法</h2><h3 id="第一种方法（不使用pip或者easy-install-："><a href="#第一种方法（不使用pip或者easy-install-：" class="headerlink" title="第一种方法（不使用pip或者easy_install)："></a>第一种方法（不使用pip或者easy_install)：</h3><p>Step1:在网上找到的需要的包，下载下来。<code>eg. rsa-3.1.4.tar.gz</code></p><p>Step2:解压缩该文件。</p><p>Step3:命令行工具cd切换到所要安装的包的目录，找到<code>setup.py</code>文件，然后输入<code>python setup.py install</code></p><h3 id="第二种方法（使用pip或者easy-install）："><a href="#第二种方法（使用pip或者easy-install）：" class="headerlink" title="第二种方法（使用pip或者easy_install）："></a>第二种方法（使用pip或者easy_install）：</h3><p>直接打开cmd，敲<code>pip install rsa</code>。</p><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><h3 id="安装python插件"><a href="#安装python插件" class="headerlink" title="安装python插件"></a>安装python插件</h3><p>打开VScode，Ctrl+p<br>输入 “ext install python”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/&quot; title=&quot;https://www.python.org/&quot; targ
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>获取所有本机IP</title>
    <link href="https://caojingyou.github.io/2017/08/15/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E6%9C%AC%E6%9C%BAIP/"/>
    <id>https://caojingyou.github.io/2017/08/15/获取所有本机IP/</id>
    <published>2017-08-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.082Z</updated>
    
    <content type="html"><![CDATA[<pre><code>#include &lt;WinSock2.h&gt;#include &lt;Iphlpapi.h&gt;#pragma comment(lib,&quot;iphlpapi.lib&quot;)// 获得本机的IP地址void CIOCPModel::GetLocalIP(CStringArray &amp;arrIp){    //PIP_ADAPTER_INFO结构体指针存储本机网卡信息    PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();    //得到结构体大小,用于GetAdaptersInfo参数    unsigned long stSize = sizeof(IP_ADAPTER_INFO);    //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量    int nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);    if (ERROR_BUFFER_OVERFLOW == nRel)    {        //如果函数返回的是ERROR_BUFFER_OVERFLOW        //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小        //这也是说明为什么stSize既是一个输入量也是一个输出量        //释放原来的内存空间        delete pIpAdapterInfo;        //重新申请内存空间用来存储所有网卡信息        pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];        //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量        nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);    }    if (ERROR_SUCCESS == nRel)    {        //输出网卡信息        while (pIpAdapterInfo)        {            IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);            do            {                CString strTemp = pIpAddrString-&gt;IpAddress.String;                arrIp.Add(strTemp);                pIpAddrString = pIpAddrString-&gt;Next;            }            while (pIpAddrString);            pIpAdapterInfo = pIpAdapterInfo-&gt;Next;        }    }    //释放内存空间    if (pIpAdapterInfo)    {        delete pIpAdapterInfo;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;#include &amp;lt;WinSock2.h&amp;gt;
#include &amp;lt;Iphlpapi.h&amp;gt;
#pragma comment(lib,&amp;quot;iphlpapi.lib&amp;quot;)

// 获得本机的IP地址
void CIOCPMod
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="IP" scheme="https://caojingyou.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>MFC背景透明</title>
    <link href="https://caojingyou.github.io/2017/08/01/MFC%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E/"/>
    <id>https://caojingyou.github.io/2017/08/01/MFC背景透明/</id>
    <published>2017-08-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h1><pre><code>typedef BOOL (WINAPI *lpfnSetLayeredWindowAttributes)(HWND hWnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);lpfnSetLayeredWindowAttributes SetLayeredWindowAttributes;   //设置成边缘透明COLORREF maskColor = RGB(240, 240, 240);HMODULE hUser32 = GetModuleHandle(_T(&quot;user32.dll&quot;)); //加载动态链接库SetLayeredWindowAttributes = (lpfnSetLayeredWindowAttributes)GetProcAddress(hUser32, &quot;SetLayeredWindowAttributes&quot;);            //取得SetLayeredWindowAttributes函数指针            //为窗口加入WS_EX_LAYERED扩展属性SetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE, GetWindowLong(GetSafeHwnd(), GWL_EXSTYLE)^WS_EX_LAYERED);             //调用SetLayeredWinowAttributes函数/*SetLayeredWindowAttributes(this-&gt;GetSafeHwnd(), maskColor, 192, LWA_COLORKEY);  */SetLayeredWindowAttributes(this-&gt;GetSafeHwnd(), maskColor, 255, LWA_ALPHA | LWA_COLORKEY);FreeLibrary(hUser32);   //释放动态链//LWA_ALPHA时：crKey参数无效，bAlpha参数有效；//LWA_COLORKEY：窗体中的所有颜色为crKey的地方将变为透明，bAlpha参数无效。//LWA_ALPHA | LWA_COLORKEY：crKey的地方将变为全透明，而其它地方根据bAlpha参数确定透明度。</code></pre><h1 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h1><pre><code>COLORREF m_bgcolor = RGB(0, 0, 0);BOOL m_bTransparent = ToggleTransparent(m_bgcolor, 100, LWA_ALPHA);BOOL ToggleTransparent(COLORREF crKey, BYTE bAlpha, DWORD dwFlags){    BOOL bResult;    LONG dwExStyle;    dwExStyle = GetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE);    if (dwExStyle &amp; WS_EX_LAYERED)    {        dwExStyle &amp;= ~(WS_EX_LAYERED);        bResult = FALSE;    }    else    {        dwExStyle |= (WS_EX_LAYERED);        bResult = TRUE;    }    SetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE, dwExStyle);    SetLayeredWindowAttributes( crKey, bAlpha, dwFlags);    return bResult;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：&quot;&gt;&lt;a href=&quot;#一：&quot; class=&quot;headerlink&quot; title=&quot;一：&quot;&gt;&lt;/a&gt;一：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;typedef BOOL (WINAPI *lpfnSetLayeredWindowAttributes)(HWND hWn
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="MFC" scheme="https://caojingyou.github.io/tags/MFC/"/>
    
      <category term="背景透明" scheme="https://caojingyou.github.io/tags/%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>boost</title>
    <link href="https://caojingyou.github.io/2017/07/15/boost/"/>
    <id>https://caojingyou.github.io/2017/07/15/boost/</id>
    <published>2017-07-15T08:03:00.000Z</published>
    <updated>2018-05-02T01:19:52.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Visual-Studio-IDE构建"><a href="#使用Visual-Studio-IDE构建" class="headerlink" title="使用Visual Studio IDE构建"></a>使用Visual Studio IDE构建</h1><ul><li><p>From Visual Studio’s File menu, select New &gt; Project…</p></li><li><p>In the left-hand pane of the resulting New Project dialog, select Visual C++ &gt; Win32.</p></li><li><p>In the right-hand pane, select Win32 Console Application (VS8.0) or Win32 Console Project (VS7.1).</p></li><li><p>In the name field, enter “example”</p></li><li><p>Right-click example in the Solution Explorer pane and select Properties from the resulting pop-up menu</p></li><li><p>In Configuration Properties &gt; C/C++ &gt; General &gt; Additional Include Directories, enter the path to the Boost root directory, for example</p><p>  C:\Program Files\boost\boost_1_63_0</p></li><li><p>In Configuration Properties &gt; C/C++ &gt; Precompiled Headers, change Use Precompiled Header (/Yu) to Not Using Precompiled Headers.</p></li><li><p>Replace the contents of the example.cpp generated by the IDE with the example code above.</p><pre><code>#include &lt;boost/lambda/lambda.hpp&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main(){    using namespace boost::lambda;    typedef std::istream_iterator&lt;int&gt; in;    std::for_each(        in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; &quot; &quot; );}</code></pre></li><li><p>From the Build menu, select Build Solution.</p></li></ul><h1 id="头文件与库"><a href="#头文件与库" class="headerlink" title="头文件与库"></a>头文件与库</h1><p>Nothing to Build?</p><p>Most Boost libraries are header-only: they consist entirely of header files containing templates and inline functions, and require no separately-compiled library binaries or special treatment when linking.</p><p>The only Boost libraries that must be built separately are:</p><pre><code>Boost.ChronoBoost.ContextBoost.FilesystemBoost.GraphParallelBoost.IOStreamsBoost.LocaleBoost.Log (see build documentation)Boost.MPIBoost.ProgramOptionsBoost.Python (see the Boost.Python build documentation before building and installing it)Boost.RegexBoost.SerializationBoost.SignalsBoost.SystemBoost.ThreadBoost.TimerBoost.Wave</code></pre><p>A few libraries have optional separately-compiled binaries:</p><pre><code>Boost.DateTime has a binary component that is only needed if you&apos;re using its to_string/from_string or serialization features, or if you&apos;re targeting Visual C++ 6.x or Borland.Boost.Graph also has a binary component that is only needed if you intend to parse GraphViz files.Boost.Math has binary components for the TR1 and C99 cmath functions.Boost.Random has a binary component which is only needed if you&apos;re using random_device.Boost.Test can be used in “header-only” or “separately compiled” mode, although separate compilation is recommended for serious use.Boost.Exception provides non-intrusive implementation of exception_ptr for 32-bit _MSC_VER==1310 and _MSC_VER==1400 which requires a separately-compiled binary. This is enabled by #define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR.</code></pre><h1 id="从源代码构建"><a href="#从源代码构建" class="headerlink" title="从源代码构建"></a>从源代码构建</h1><p>使用Visual Studio命令提示</p><p>If you wish to build from source with Visual C++, you can use a simple build procedure described in this section. Open the command prompt and change your current directory to the Boost root directory. Then, type the following commands:</p><pre><code>bootstrap.\b2</code></pre><p>The first command prepares the Boost.Build system for use. The second command invokes Boost.Build to build the separately-compiled Boost libraries. Please consult the <a href="http://www.boost.org/build/doc/html/bbv2/overview/invocation.html" target="_blank" rel="noopener">Boost.Build documentation</a> for a list of allowed options.</p><h2 id="构建动态库、静态库"><a href="#构建动态库、静态库" class="headerlink" title="构建动态库、静态库"></a>构建动态库、静态库</h2><p>编译，可以简单的使用b2 install，也可以指定存放目录，或者寻找网上其它帮助文章。</p><p>查看帮助可以输入：.\b2 –help</p><p>比如要开启多线程编译：b2 install threading=multi</p><p>设置生成的是debug或者release</p><p>备注：如果是使用VS2013，请指定输出库类型，否则会缺一个lib文件：</p><p>“无法打开文件 libboost_thread_vc120_mt_sgd-1_55.lib”。</p><p>在2013时，我是使用下面的语句进行编译：</p><pre><code>// 如果要获取动态库：bjam install stage --toolset=msvc-12.0 --stagedir=&quot;C:\Boost\boost_vc_120&quot; link=shared runtime-link=shared threading=multi debug release  // 如果是要获取静态库：bjam install stage --toolset=msvc-12.0 --stagedir=&quot;C:\Boost\boost_vc_120&quot; link=static runtime-link=static threading=multi debug release  </code></pre><p>其中，注意修改–toolset=msvc-12.0，将12.0修改成对应的vs版本号，12.0是VS2013的版本号。</p><p>目标地址也要修改成你所需的。</p><p>注意，不要漏了install，它会帮你把头文件集合到一个文件夹中。</p><p>编译过程有一个复制过程，编译需要的时间比较长，本次编译过程中，会在C盘根目录下生成一个boost文件夹，然后包含include和lib文件夹，这就是我们将要使用的头文件和库文件。</p><h2 id="出现“boost-此时不应有-Microsoft。”的问题："><a href="#出现“boost-此时不应有-Microsoft。”的问题：" class="headerlink" title="出现“boost 此时不应有 \Microsoft。”的问题："></a>出现“boost 此时不应有 \Microsoft。”的问题：</h2><p><a href="http://blog.csdn.net/poem_qianmo/article/details/26048697" target="_blank" rel="noopener">解决VS命令提示符 “Setting environment for using Microsoft Visual Studio. 此时不应有”系列错误</a></p><h1 id="使用预编译的二进制文件boost库"><a href="#使用预编译的二进制文件boost库" class="headerlink" title="使用预编译的二进制文件boost库"></a>使用预编译的二进制文件boost库</h1><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/boost_1_63_0-msvc-14.0-32.exe/download" target="_blank" rel="noopener">boost_1_63_0-msvc-14.0-32.exe</a></p><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/boost_1_63_0-msvc-10.0-64.exe/download" target="_blank" rel="noopener">boost_1_63_0-msvc-14.0-64.exe</a></p><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/" target="_blank" rel="noopener">https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/</a></p><h1 id="boost-jam"><a href="#boost-jam" class="headerlink" title="boost-jam"></a>boost-jam</h1><p>可使用<a href="https://sourceforge.net/projects/boost/files/boost-jam/3.1.18/" target="_blank" rel="noopener">boost-jam</a>编译boost</p><p>为了编译 bjam 本身，要执行一个名为 build 的简单脚本，它也为不同的操作系统提供了源代码。 对于 Windows，它是批处理文件 build.bat。 对于 Linux，文件名为 build.sh。</p><p>要用 Visual Studio 2008 的C++编译器同时生成 Boost C++ 库的调试版和发布版，并将它们安装在目录 D:\Boost 中，应执行的命令是 bjam –toolset=msvc-9.0 –build-type=complete –prefix=D:\Boost install. 要在 Linux 中使用缺省目录创建它们，则要执行的命令是 bjam –toolset=gcc –build-type=complete install.</p><h1 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h1><p>Boost C++  库    C++ 标准    简要说明</p><p><code>Boost.Any</code>        Boost.Any 提供了一个名为 boost::any 的数据类型，可以存放任意的类型。 例如，一个类型为 boost::any 的变量可以先存放一个 int 类型的值，然后替换为一个 std::string 类型的字符串。</p><p><code>Boost.Array</code>    TR1    Boost.Array 可以把 C++ 数组视同 C++ 标准的容器。</p><p><code>Boost.Asio</code>    TR2    Boost.Asio 可用于开发异步处理数据的应用，如网络应用。</p><p><code>Boost.Bimap</code>        Boost.Bimap 提供了一个名为 boost::bimap 的类，它类似于 std::map. 主要的差别在于 boost::bimap 可以同时从键和值进行搜索。</p><p><code>Boost.Bind</code>    TR1    Boost.Bind 是一种适配器，可以将函数作为模板参数，即使该函数的签名与模板参数不兼容。</p><p><code>Boost.Conversion</code>        Boost.Conversion 提供了三个转型操作符，分别执行向下转型、交叉转型，以及不同数字类型间的值转换。</p><p><code>Boost.DateTime</code>        Boost.DateTime 可用于以灵活的格式处理、读入和写出日期及时间值。</p><p><code>Boost.Exception</code>        Boost.Exception 可以在抛出的异常中加入额外的数据，以便在 catch 处理中提供更多的信息。 这有助于更容易地调试，以及对异常情况更好地作出反应。</p><p><code>Boost.Filesystem</code>    TR2    Boost.Filesystem 提供了一个类来处理路径信息，还包含了几个访问文件和目录的函数。</p><p><code>Boost.Format</code>        Boost.Format 以一个类型安全且可扩展的 boost::format 类替代了 std::printf() 函数。</p><p><code>Boost.Function</code>    TR1    Boost.Function 简化了函数指针的定义。</p><p><code>Boost.Interprocess</code>        Boost.Interprocess 允许多个应用通过共享内存以快速、高效的方式进行通信。</p><p><code>Boost.Lambda</code>        Boost.Lambda 可以定义匿名的函数。 代码被内联地声明和执行，避免了单独的函数调用。</p><p><code>Boost.Multiindex</code>        Boost.Multiindex 定义了一些新的容器，它们可以同时支持多个接口，如 std::vector 和 std::map 的接口。</p><p><code>Boost.NumericConversion</code>        Boost.NumericConversion 提供了一个转型操作符，可以安全地在不同的数字类型间进行值转换，不会生成上溢出或下溢出的条件。</p><p><code>Boost.PointerContainer</code>        Boost.PointerContainer 提供了专门为动态分配对象进行优化的容器。</p><p><code>Boost.Ref</code>    TR1    Boost.Ref 的适配器可以将不可复制对象的引用传给需要复制的函数。</p><p><code>Boost.Regex</code>    TR1    Boost.Regex 提供了通过正则表达式进行文本搜索的函数。</p><p><code>Boost.Serialization</code>        通过 Boost.Serialization，对象可以被序列化，如保存在文件中，并在以后重新导入。</p><p><code>Boost.Signals</code>        Boost.Signal 是一个事件处理的框架，基于所谓的 signal/slot 概念。 函数与信号相关联并在信号被触发时自动被调用。</p><p><code>Boost.SmartPoiners</code>    TR1    Boost.SmartPoiners 提供了多个智能指针，简化了动态分配对象的管理。</p><p><code>Boost.Spirit</code>        Boost.Spirit 可以用类似于 EBNF (扩展巴科斯范式)的语法生成词法分析器。</p><p><code>Boost.StringAlgorithms</code>        Boost.StringAlgorithms 提供了多个独立的函数，以方便处理字符串。</p><p><code>Boost.System</code>    TR2    Boost.System 提供了一个处理系统相关或应用相关错误代码的框架。</p><p><code>Boost.Thread</code>    C++0x    Boost.Thread 可用于开发多线程应用。</p><p><code>Boost.Tokenizer</code>        Boost.Tokenizer 可以对一个字符串的各个组件进行迭代。</p><p><code>Boost.Tuple</code>    TR1    Boost.Tuple 提供了泛化版的 std::pair，可以将任意数量的数据组在一起。</p><p><code>Boost.Unordered</code>    TR1    Boost.Unordered 扩展了 C++ 标准的容器，增加了boost::unordered_set 和 boost::unordered_map.</p><p><code>Boost.Variant</code>        Boost.Variant 可以定义多个数据类型，类似于 union, 将多个数据类型组在一起。 Boost.Variant 比 union 优胜的地方在于它可以使用类。</p><h1 id="highscore代码"><a href="#highscore代码" class="headerlink" title="highscore代码"></a>highscore代码</h1><pre><code>#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2010, 1, 30);   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day_of_week() &lt;&lt; std::endl;   std::cout &lt;&lt; d.end_of_month() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d = boost::gregorian::day_clock::universal_day();   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl;   d = boost::gregorian::date_from_iso_string(&quot;20100131&quot;);   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2008, 1, 31);   boost::gregorian::date d2(2008, 8, 31);   boost::gregorian::date_duration dd = d2 - d1;   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date_duration dd(4);   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl;   boost::gregorian::weeks ws(4);   std::cout &lt;&lt; ws.days() &lt;&lt; std::endl;   boost::gregorian::months ms(4);   std::cout &lt;&lt; ms.number_of_months() &lt;&lt; std::endl;   boost::gregorian::years ys(4);   std::cout &lt;&lt; ys.number_of_years() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 31);   boost::gregorian::months ms(1);   boost::gregorian::date d2 = d + ms;   std::cout &lt;&lt; d2 &lt;&lt; std::endl;   boost::gregorian::date d3 = d2 - ms;   std::cout &lt;&lt; d3 &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 30);   boost::gregorian::months ms(1);   boost::gregorian::date d2 = d + ms;   std::cout &lt;&lt; d2 &lt;&lt; std::endl;   boost::gregorian::date d3 = d2 - ms;   std::cout &lt;&lt; d3 &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2009, 1, 30);   boost::gregorian::date d2(2009, 10, 31);   boost::gregorian::date_period dp(d1, d2);   boost::gregorian::date_duration dd = dp.length();   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2009, 1, 30);   boost::gregorian::date d2(2009, 10, 31);   boost::gregorian::date_period dp(d1, d2);   std::cout &lt;&lt; dp.contains(d1) &lt;&lt; std::endl;   std::cout &lt;&lt; dp.contains(d2) &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 5);   boost::gregorian::day_iterator it(d);   std::cout &lt;&lt; *++it &lt;&lt; std::endl;   std::cout &lt;&lt; boost::date_time::next_weekday(*it, boost::gregorian::greg_weekday(boost::date_time::Friday)) &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::gregorian::date d = pt.date();   std::cout &lt;&lt; d &lt;&lt; std::endl;   boost::posix_time::time_duration td = pt.time_of_day();   std::cout &lt;&lt; td &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt = boost::posix_time::second_clock::universal_time();   std::cout &lt;&lt; pt.date() &lt;&lt; std::endl;   std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl;   pt = boost::posix_time::from_iso_string(&quot;20090105T120000&quot;);   std::cout &lt;&lt; pt.date() &lt;&lt; std::endl;   std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::time_duration td(16, 30, 0);   std::cout &lt;&lt; td.hours() &lt;&lt; std::endl;   std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl;   std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl;   std::cout &lt;&lt; td.total_seconds() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0));   boost::posix_time::time_duration td = pt2 - pt1;   std::cout &lt;&lt; td.hours() &lt;&lt; std::endl;   std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl;   std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::time_duration td(6, 30, 0);   boost::posix_time::ptime pt2 = pt1 + td;   std::cout &lt;&lt; pt2.time_of_day() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0));   boost::posix_time::time_period tp(pt1, pt2);   std::cout &lt;&lt; tp.contains(pt1) &lt;&lt; std::endl;   std::cout &lt;&lt; tp.contains(pt2) &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::time_iterator it(pt, boost::posix_time::time_duration(6, 30, 0));   std::cout &lt;&lt; *++it &lt;&lt; std::endl;   std::cout &lt;&lt; *++it &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;));   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt(pt, tz);   std::cout &lt;&lt; dt.utc_time() &lt;&lt; std::endl;   std::cout &lt;&lt; dt &lt;&lt; std::endl;   std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl;   std::cout &lt;&lt; dt.zone_name() &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;));   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt(pt, tz);   std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl;   boost::local_time::time_zone_ptr tz2(new boost::local_time::posix_time_zone(&quot;EET+2&quot;));   std::cout &lt;&lt; dt.local_time_in(tz2).local_time() &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+0&quot;));   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt1(pt1, tz);   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(18, 0, 0));   boost::local_time::local_date_time dt2(pt2, tz);   boost::local_time::local_time_period tp(dt1, dt2);   std::cout &lt;&lt; tp.contains(dt1) &lt;&lt; std::endl;   std::cout &lt;&lt; tp.contains(dt2) &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; #include &lt;locale&gt; int main() {   boost::gregorian::date d(2009, 1, 7);   boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d %B %Y&quot;);   std::cout.imbue(std::locale(std::cout.getloc(), df));   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; #include &lt;locale&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string months[12] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; };   std::string weekdays[7] = { &quot;Sonntag&quot;, &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot; };   boost::gregorian::date d(2009, 1, 7);   boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d. %B %Y&quot;);   df-&gt;long_month_names(std::vector&lt;std::string&gt;(months, months + 12));   df-&gt;long_weekday_names(std::vector&lt;std::string&gt;(weekdays, weekdays + 7));   std::cout.imbue(std::locale(std::cout.getloc(), df));   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;iostream&gt; int main() {   boost::archive::text_oarchive oa(std::cout);   int i = 1;   oa &lt;&lt; i; } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; void save() {   std::ofstream file(&quot;archiv.txt&quot;);   boost::archive::text_oarchive oa(file);   int i = 1;   oa &lt;&lt; i; } void load() {   std::ifstream file(&quot;archiv.txt&quot;);   boost::archive::text_iarchive ia(file);   int i = 0;   ia &gt;&gt; i;   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   int i = 1;   oa &lt;&lt; i; } void load() {   boost::archive::text_iarchive ia(ss);   int i = 0;   ia &gt;&gt; i;   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_; } void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age, const std::string &amp;name)     : age_(age), name_(name)   {   }   int age() const   {     return age_;   }   std::string name() const   {     return name_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_;   std::string name_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_;   ar &amp; p.name_; } void save() {   boost::archive::text_oarchive oa(ss);   person p(31, &quot;Boris&quot;);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl;   std::cout &lt;&lt; p.name() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age, const std::string &amp;name)     : age_(age), name_(name)   {   }   int age() const   {     return age_;   }   std::string name() const   {     return name_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_;   std::string name_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_;   if (version &gt; 0)     ar &amp; p.name_; } BOOST_CLASS_VERSION(person, 1) void save() {   boost::archive::text_oarchive oa(ss);   person p(31, &quot;Boris&quot;);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl;   std::cout &lt;&lt; p.name() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person *p = new person(31);   oa &lt;&lt; p;   std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/scoped_ptr.hpp&gt; #include &lt;boost/scoped_ptr.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   boost::scoped_ptr&lt;person&gt; p(new person(31));   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   boost::scoped_ptr&lt;person&gt; p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   person &amp;pp = p;   oa &lt;&lt; pp; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   person &amp;pp = p;   ia &gt;&gt; pp;   std::cout &lt;&lt; pp.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; void save() {   boost::archive::text_oarchive oa(ss);   developer d(31, &quot;C++&quot;);   oa &lt;&lt; d; } void load() {   boost::archive::text_iarchive ia(ss);   developer d;   ia &gt;&gt; d;   std::cout &lt;&lt; d.age() &lt;&lt; std::endl;   std::cout &lt;&lt; d.language() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;boost/serialization/export.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   virtual int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; BOOST_CLASS_EXPORT(developer) void save() {   boost::archive::text_oarchive oa(ss);   person *p = new developer(31, &quot;C++&quot;);   oa &lt;&lt; p;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;boost/serialization/export.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   virtual int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; void save() {   boost::archive::text_oarchive oa(ss);   oa.register_type&lt;developer&gt;();   person *p = new developer(31, &quot;C++&quot;);   oa &lt;&lt; p;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   ia.register_type&lt;developer&gt;();   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   boost::array&lt;int, 3&gt; a = { 0, 1, 2 };   oa &lt;&lt; a; } void load() {   boost::archive::text_iarchive ia(ss);   boost::array&lt;int, 3&gt; a;   ia &gt;&gt; a;   std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/array.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   boost::array&lt;int, 3&gt; a = { 0, 1, 2 };   oa &lt;&lt; boost::serialization::make_array(a.data(), a.size()); } void load() {   boost::archive::text_iarchive ia(ss);   boost::array&lt;int, 3&gt; a;   ia &gt;&gt; boost::serialization::make_array(a.data(), a.size());   std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/spirit.hpp&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main() { } #include &lt;boost/spirit.hpp&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/spirit.hpp&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   struct print   {     void operator()(const char *begin, const char *end) const     {       std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl;     }   };   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/spirit.hpp&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   struct print   {     void operator()(const char *begin, const char *end) const     {       std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl;     }     void operator()(const double d) const     {       std::cout &lt;&lt; d &lt;&lt; std::endl;     }   };   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | str_p(&quot;true&quot;)[print()] | &quot;false&quot; | &quot;null&quot;;       number = real_p[print()];       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; int main() {   typedef boost::array&lt;std::string, 3&gt; array;   array a;   a[0] = &quot;Boris&quot;;   a.at(1) = &quot;Anton&quot;;   *a.rbegin() = &quot;Caesar&quot;;   std::sort(a.begin(), a.end());   for (array::const_iterator it = a.begin(); it != a.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl;   std::cout &lt;&lt; a.size() &lt;&lt; std::endl;   std::cout &lt;&lt; a.max_size() &lt;&lt; std::endl; } #include &lt;boost/array.hpp&gt; #include &lt;string&gt; int main() {   typedef boost::array&lt;std::string, 3&gt; array;   array a = { &quot;Boris&quot;, &quot;Anton&quot;, &quot;Caesar&quot; }; } #include &lt;boost/unordered_set.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::unordered_set&lt;std::string&gt; unordered_set;   unordered_set set;   set.insert(&quot;Boris&quot;);   set.insert(&quot;Anton&quot;);   set.insert(&quot;Caesar&quot;);   for (unordered_set::iterator it = set.begin(); it != set.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl;   std::cout &lt;&lt; set.size() &lt;&lt; std::endl;   std::cout &lt;&lt; set.max_size() &lt;&lt; std::endl;   std::cout &lt;&lt; (set.find(&quot;David&quot;) != set.end()) &lt;&lt; std::endl;   std::cout &lt;&lt; set.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/unordered_map.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::unordered_map&lt;std::string, int&gt; unordered_map;   unordered_map map;   map.insert(unordered_map::value_type(&quot;Boris&quot;, 31));   map.insert(unordered_map::value_type(&quot;Anton&quot;, 35));   map.insert(unordered_map::value_type(&quot;Caesar&quot;, 25));   for (unordered_map::iterator it = map.begin(); it != map.end(); ++it)     std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;   std::cout &lt;&lt; map.size() &lt;&lt; std::endl;   std::cout &lt;&lt; map.max_size() &lt;&lt; std::endl;   std::cout &lt;&lt; (map.find(&quot;David&quot;) != map.end()) &lt;&lt; std::endl;   std::cout &lt;&lt; map.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/unordered_set.hpp&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   }   bool operator==(const person &amp;p) const   {     return name == p.name &amp;&amp; age == p.age;   } }; std::size_t hash_value(person const &amp;p) {   std::size_t seed = 0;   boost::hash_combine(seed, p.name);   boost::hash_combine(seed, p.age);   return seed; } int main() {   typedef boost::unordered_set&lt;person&gt; unordered_set;   unordered_set set;   set.insert(person(&quot;Boris&quot;, 31));   set.insert(person(&quot;Anton&quot;, 35));   set.insert(person(&quot;Caesar&quot;, 25)); } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 35));   persons.insert(person(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.count(&quot;Boris&quot;) &lt;&lt; std::endl;   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(25) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; void set_age(person &amp;p) {   p.age = 32; } int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 35));   persons.insert(person(&quot;Caesar&quot;, 25));   person_multi::iterator it = persons.find(&quot;Boris&quot;);   persons.modify(it, set_age);   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(32) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 31));   persons.insert(person(&quot;Caesar&quot;, 25));   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(31) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/sequenced_index.hpp&gt; #include &lt;boost/multi_index/ordered_index.hpp&gt; #include &lt;boost/multi_index/random_access_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::sequenced&lt;&gt;,     boost::multi_index::ordered_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;,     boost::multi_index::random_access&lt;&gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.push_back(person(&quot;Boris&quot;, 31));   persons.push_back(person(&quot;Anton&quot;, 31));   persons.push_back(person(&quot;Caesar&quot;, 25));   const person_multi::nth_index&lt;1&gt;::type &amp;ordered_index = persons.get&lt;1&gt;();   person_multi::nth_index&lt;1&gt;::type::iterator lower = ordered_index.lower_bound(30);   person_multi::nth_index&lt;1&gt;::type::iterator upper = ordered_index.upper_bound(40);   for (; lower != upper; ++lower)     std::cout &lt;&lt; lower-&gt;name &lt;&lt; std::endl;   const person_multi::nth_index&lt;2&gt;::type &amp;random_access_index = persons.get&lt;2&gt;();   std::cout &lt;&lt; random_access_index[2].name &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/ordered_index.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/identity.hpp&gt; #include &lt;boost/multi_index/mem_fun.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; class person { public:   person(const std::string &amp;n, int a)     : name(n), age(a)   {   }   bool operator&lt;(const person &amp;p) const   {     return age &lt; p.age;   }   std::string get_name() const   {     return name;   } private:   std::string name;   int age; }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::ordered_unique&lt;       boost::multi_index::identity&lt;person&gt;     &gt;,     boost::multi_index::hashed_unique&lt;       boost::multi_index::const_mem_fun&lt;         person, std::string, &amp;person::get_name       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 31));   persons.insert(person(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.begin()-&gt;get_name() &lt;&lt; std::endl;   const person_multi::nth_index&lt;1&gt;::type &amp;hashed_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; hashed_index.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, int&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, int&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   for (bimap::iterator it = persons.begin(); it != persons.end(); ++it)     std::cout &lt;&lt; it-&gt;left &lt;&lt; &quot; is &quot; &lt;&lt; it-&gt;right &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::set_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;boost/bimap/multiset_of.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::multiset_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;boost/bimap/unconstrained_set_of.hpp&gt; #include &lt;boost/bimap/support/lambda.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, boost::bimaps::unconstrained_set_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   bimap::left_map::iterator it = persons.left.find(&quot;Boris&quot;);   persons.left.modify_key(it, boost::bimaps::_key = &quot;Doris&quot;);   std::cout &lt;&lt; it-&gt;first &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string&gt; person;   person p(&quot;Boris&quot;, &quot;Schaeling&quot;);   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; boost::tuple&lt;std::string, int&gt; func() {   return boost::make_tuple(&quot;Error message&quot;, 2009); }int main() {   std::string errmsg;   int errcode;   boost::tie(errmsg, errcode) = func();   std::cout &lt;&lt; errmsg &lt;&lt; &quot;: &quot; &lt;&lt; errcode &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   std::string s = &quot;Boris&quot;;   std::cout &lt;&lt; boost::make_tuple(boost::ref(s), &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   std::cout &lt;&lt; p.get&lt;0&gt;() &lt;&lt; std::endl;   std::cout &lt;&lt; boost::get&lt;0&gt;(p) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   p.get&lt;1&gt;() = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_comparison.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p1 = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   person p2 = boost::make_tuple(&quot;Boris&quot;, &quot;Becker&quot;, 43);   std::cout &lt;&lt; (p1 != p2) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person;   std::string firstname = &quot;Boris&quot;;   std::string surname = &quot;Schaeling&quot;;   int shoesize = 43;   person p = boost::tie(firstname, surname, shoesize);   surname = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person;   std::string firstname = &quot;Boris&quot;;   std::string surname = &quot;Schaeling&quot;;   int shoesize = 43;   person p = boost::make_tuple(boost::ref(firstname), boost::ref(surname), boost::ref(shoesize));   surname = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/any.hpp&gt; int main() {   boost::any a = 1;   a = 3.14;   a = true; } #include &lt;boost/any.hpp&gt; #include &lt;string&gt; int main() {   boost::any a = 1;   a = 3.14;   a = true;   a = std::string(&quot;Hello, world!&quot;); } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl;   a = 3.14;   std::cout &lt;&lt; boost::any_cast&lt;double&gt;(a) &lt;&lt; std::endl;   a = true;   std::cout &lt;&lt; boost::any_cast&lt;bool&gt;(a) &lt;&lt; std::endl; } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::any a = 1;     std::cout &lt;&lt; boost::any_cast&lt;float&gt;(a) &lt;&lt; std::endl;   }   catch (boost::bad_any_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/any.hpp&gt; #include &lt;typeinfo&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   if (!a.empty())   {     const std::type_info &amp;ti = a.type();     std::cout &lt;&lt; ti.name() &lt;&lt; std::endl;   } } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   int *i = boost::any_cast&lt;int&gt;(&amp;a);   std::cout &lt;&lt; *i &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; int main() {   boost::variant&lt;double, char&gt; v;   v = 3.14;   v = &apos;A&apos;; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   v = &apos;A&apos;;   v = &quot;Hello, world!&quot;; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl;   v = &apos;A&apos;;   std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl;   v = &quot;Hello, world!&quot;;   std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   std::cout &lt;&lt; v &lt;&lt; std::endl;   v = &apos;A&apos;;   std::cout &lt;&lt; v &lt;&lt; std::endl;   v = &quot;Hello, world!&quot;;   std::cout &lt;&lt; v &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; #include &lt;boost/any.hpp&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; std::vector&lt;boost::any&gt; vector; struct output :   public boost::static_visitor&lt;&gt; {   void operator()(double &amp;d) const   {     vector.push_back(d);   }   void operator()(char &amp;c) const   {     vector.push_back(c);   }   void operator()(std::string &amp;s) const   {     vector.push_back(s);   } }; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   boost::apply_visitor(output(), v);   v = &apos;A&apos;;   boost::apply_visitor(output(), v);   v = &quot;Hello, world!&quot;;   boost::apply_visitor(output(), v); } #include &lt;boost/variant.hpp&gt; #include &lt;boost/any.hpp&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; std::vector&lt;boost::any&gt; vector; struct output :   public boost::static_visitor&lt;&gt; {   template &lt;typename T&gt;   void operator()(T &amp;t) const   {     vector.push_back(t);   } }; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   boost::apply_visitor(output(), v);   v = &apos;A&apos;;   boost::apply_visitor(output(), v);   v = &quot;Hello, world!&quot;;   boost::apply_visitor(output(), v); } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; class application_category :   public boost::system::error_category { public:   const char *name() const { return &quot;application&quot;; }   std::string message(int ev) const { return &quot;error message&quot;; } }; application_category cat; int main() {   boost::system::error_code ec(14, cat);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   boost::system::error_condition ecnd = ec.default_error_condition();   std::cout &lt;&lt; ecnd.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ecnd.category().name() &lt;&lt; std::endl; } #include &lt;boost/asio.hpp&gt; #include &lt;boost/system/system_error.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::asio::ip::host_name() &lt;&lt; std::endl;   }   catch (boost::system::system_error &amp;e)   {     boost::system::error_code ec = e.code();     std::cerr &lt;&lt; ec.value() &lt;&lt; std::endl;     std::cerr &lt;&lt; ec.category().name() &lt;&lt; std::endl;   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public boost::exception,   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     throw allocation_failed(size);   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; boost::diagnostic_information(e);   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     BOOST_THROW_EXCEPTION(allocation_failed(size));   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; boost::diagnostic_information(e);   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     BOOST_THROW_EXCEPTION(allocation_failed(size));   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; *boost::get_error_info&lt;errmsg_info&gt;(e);   } } struct father {   virtual ~father() { }; }; struct mother {   virtual ~mother() { }; }; struct child :   public father,   public mother { }; void func(father *f) {   child *c = dynamic_cast&lt;child*&gt;(f); } int main() {   child *c = new child;   func(c);   father *f = new child;   mother *m = dynamic_cast&lt;mother*&gt;(f); } #include &lt;boost/cast.hpp&gt; struct father {   virtual ~father() { }; }; struct mother {   virtual ~mother() { }; }; struct child :   public father,   public mother { }; void func(father *f) {   child *c = boost::polymorphic_downcast&lt;child*&gt;(f); } int main() {   child *c = new child;   func(c);   father *f = new child;   mother *m = boost::polymorphic_cast&lt;mother*&gt;(f); } #include &lt;boost/lexical_cast.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   std::string s = boost::lexical_cast&lt;std::string&gt;(169);   std::cout &lt;&lt; s &lt;&lt; std::endl;   double d = boost::lexical_cast&lt;double&gt;(s);   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/lexical_cast.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   try   {     int i = boost::lexical_cast&lt;int&gt;(&quot;abc&quot;);     std::cout &lt;&lt; i &lt;&lt; std::endl;   }   catch (boost::bad_lexical_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;iostream&gt; int main() {   int i = 0x10000;   short s = i;   std::cout &lt;&lt; s &lt;&lt; std::endl; } #include &lt;boost/numeric/conversion/cast.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     int i = 0x10000;     short s = boost::numeric_cast&lt;short&gt;(i);     std::cout &lt;&lt; s &lt;&lt; std::endl;   }   catch (boost::numeric::bad_numeric_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/numeric/conversion/cast.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     int i = -0x10000;     short s = boost::numeric_cast&lt;short&gt;(i);     std::cout &lt;&lt; s &lt;&lt; std::endl;   }   catch (boost::numeric::negative_overflow &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;windows.h&gt; class windows_handle {   public:     windows_handle(HANDLE h)       : handle_(h)     {     }     ~windows_handle()     {       CloseHandle(handle_);     }     HANDLE handle() const     {       return handle_;     }   private:     HANDLE handle_; }; int main() {   windows_handle h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()));   SetPriorityClass(h.handle(), HIGH_PRIORITY_CLASS); } #include &lt;boost/scoped_ptr.hpp&gt; int main() {   boost::scoped_ptr&lt;int&gt; i(new int);   *i = 1;   *i.get() = 2;   i.reset(new int); } #include &lt;boost/scoped_array.hpp&gt; int main() {   boost::scoped_array&lt;int&gt; i(new int[2]);   *i.get() = 1;   i[1] = 2;   i.reset(new int[3]); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;vector&gt; int main() {   std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v;   v.push_back(boost::shared_ptr&lt;int&gt;(new int(1)));   v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); } #include &lt;boost/shared_ptr.hpp&gt; int main() {   boost::shared_ptr&lt;int&gt; i1(new int(1));   boost::shared_ptr&lt;int&gt; i2(i1);   i1.reset(new int(2)); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;windows.h&gt; int main() {   boost::shared_ptr&lt;void&gt; h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()), CloseHandle);   SetPriorityClass(h.get(), HIGH_PRIORITY_CLASS); } #include &lt;boost/shared_array.hpp&gt; #include &lt;iostream&gt; int main() {   boost::shared_array&lt;int&gt; i1(new int[2]);   boost::shared_array&lt;int&gt; i2(i1);   i1[0] = 1;   std::cout &lt;&lt; i2[0] &lt;&lt; std::endl; } #include &lt;windows.h&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; #include &lt;iostream&gt; DWORD WINAPI reset(LPVOID p) {   boost::shared_ptr&lt;int&gt; *sh = static_cast&lt;boost::shared_ptr&lt;int&gt;*&gt;(p);   sh-&gt;reset();   return 0; } DWORD WINAPI print(LPVOID p) {   boost::weak_ptr&lt;int&gt; *w = static_cast&lt;boost::weak_ptr&lt;int&gt;*&gt;(p);   boost::shared_ptr&lt;int&gt; sh = w-&gt;lock();   if (sh)     std::cout &lt;&lt; *sh &lt;&lt; std::endl;   return 0; } int main() {   boost::shared_ptr&lt;int&gt; sh(new int(99));   boost::weak_ptr&lt;int&gt; w(sh);   HANDLE threads[2];   threads[0] = CreateThread(0, 0, reset, &amp;sh, 0, 0);   threads[1] = CreateThread(0, 0, print, &amp;w, 0, 0);   WaitForMultipleObjects(2, threads, TRUE, INFINITE); } #include &lt;boost/intrusive_ptr.hpp&gt; #include &lt;atlbase.h&gt; #include &lt;iostream&gt; void intrusive_ptr_add_ref(IDispatch *p) {   p-&gt;AddRef(); } void intrusive_ptr_release(IDispatch *p) {   p-&gt;Release(); } void check_windows_folder() {   CLSID clsid;   CLSIDFromProgID(CComBSTR(&quot;Scripting.FileSystemObject&quot;), &amp;clsid);   void *p;   CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, __uuidof(IDispatch), &amp;p);   boost::intrusive_ptr&lt;IDispatch&gt; disp(static_cast&lt;IDispatch*&gt;(p));   CComDispatchDriver dd(disp.get());   CComVariant arg(&quot;C:\\Windows&quot;);   CComVariant ret(false);   dd.Invoke1(CComBSTR(&quot;FolderExists&quot;), &amp;arg, &amp;ret);   std::cout &lt;&lt; (ret.boolVal != 0) &lt;&lt; std::endl; } void main() {   CoInitialize(0);   check_windows_folder();   CoUninitialize(); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;vector&gt; int main() {   std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v;   v.push_back(boost::shared_ptr&lt;int&gt;(new int(1)));   v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); } #include &lt;boost/ptr_container/ptr_vector.hpp&gt; int main() {   boost::ptr_vector&lt;int&gt; v;   v.push_back(new int(1));   v.push_back(new int(2)); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void print(int i) {   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), print); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; class add   : public std::binary_function&lt;int, int, void&gt; { public:   void operator()(int i, int j) const   {     std::cout &lt;&lt; i + j &lt;&lt; std::endl;   } }; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), std::bind1st(add(), 10)); } #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void add(int i, int j) {   std::cout &lt;&lt; i + j &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1)); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), boost::bind(compare, _1, _2)); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), compare); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), boost::bind(compare, _2, _1)); } #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void add(int i, int j, std::ostream &amp;os) {   os &lt;&lt; i + j &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1, boost::ref(std::cout))); } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int main() {   boost::function&lt;int (const char*)&gt; f = std::atoi;   std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl;   f = std::strlen;   std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl; } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::function&lt;int (const char*)&gt; f;     f(&quot;&quot;);   }   catch (boost::bad_function_call &amp;ex)   {     std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; struct world {   void hello(std::ostream &amp;os)   {     os &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;   } }; int main() {   boost::function&lt;void (world*, std::ostream&amp;)&gt; f = &amp;world::hello;   world w;   f(&amp;w, boost::ref(std::cout)); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void print(int i) {   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), print); } #include &lt;boost/lambda/lambda.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;); } #include &lt;boost/lambda/lambda.hpp&gt; #include &lt;boost/lambda/if.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(),     boost::lambda::if_then(boost::lambda::_1 &gt; 1,     std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;)); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func);   s(); } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::function&lt;void ()&gt; f;   f = func;   f(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(1, func2);   s.connect(0, func1);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   s.disconnect(func2);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   if (!s.empty())     s();   s.disconnect_all_slots(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; int func1() {   return 1; } int func2() {   return 2; } int main() {   boost::signal&lt;int ()&gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s() &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; int func1() {   return 1; } int func2() {   return 2; } template &lt;typename T&gt; struct min_element {   typedef T result_type;   template &lt;typename InputIterator&gt;   T operator()(InputIterator first, InputIterator last) const   {     return *std::min_element(first, last);   } }; int main() {   boost::signal&lt;int (), min_element&lt;int&gt; &gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s() &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int func1() {   return 1; } int func2() {   return 2; } template &lt;typename T&gt; struct min_element {   typedef T result_type;   template &lt;typename InputIterator&gt;   T operator()(InputIterator first, InputIterator last) const   {     return T(first, last);   } }; int main() {   boost::signal&lt;int (), min_element&lt;std::vector&lt;int&gt; &gt; &gt; s;   s.connect(func1);   s.connect(func2);   std::vector&lt;int&gt; v = s();   std::cout &lt;&lt; *std::min_element(v.begin(), v.end()) &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   boost::signals::connection c = s.connect(func);   s();   c.disconnect(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   boost::signals::connection c = s.connect(func);   c.block();   s();   c.unblock();   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   {     boost::signals::scoped_connection c = s.connect(func);   }   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;memory&gt; class world {   public:     void hello() const     {       std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;     } }; int main() {   boost::signal&lt;void ()&gt; s;   {     std::auto_ptr&lt;world&gt; w(new world());     s.connect(boost::bind(&amp;world::hello, w.get()));   }   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;memory&gt; class world :   public boost::signals::trackable {   public:     void hello() const     {       std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;     } }; int main() {   boost::signal&lt;void ()&gt; s;   {     std::auto_ptr&lt;world&gt; w(new world());     s.connect(boost::bind(&amp;world::hello, w.get()));   }   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   s(); } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German_Switzerland&quot;));   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; int main() {   std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl;   std::locale::global(std::locale(&quot;German&quot;));   std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;clocale&gt; int main() {   std::setlocale(LC_ALL, &quot;German&quot;);   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::starts_with(s, &quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::ends_with(s, &quot;Schäling&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::contains(s, &quot;is&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::lexicographical_compare(s, &quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::vector&lt;std::string&gt; v;   boost::algorithm::split(v, s, boost::algorithm::is_space());   std::cout &lt;&lt; v.size() &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;boost/algorithm/string/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_regex(s, boost::regex(&quot;\\w\\s\\w&quot;));   std::cout &lt;&lt; r &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::erase_first_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, &quot;i&quot;, 0) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_last_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_all_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_head_copy(s, 5) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_tail_copy(s, 8) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_first(s, &quot;Boris&quot;);   std::cout &lt;&lt; r &lt;&lt; std::endl;   r = boost::algorithm::find_first(s, &quot;xyz&quot;);   std::cout &lt;&lt; r &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::vector&lt;std::string&gt; v;   v.push_back(&quot;Boris&quot;);   v.push_back(&quot;Schäling&quot;);   std::cout &lt;&lt; boost::algorithm::join(v, &quot; &quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::replace_first_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_nth_copy(s, &quot;B&quot;, 0, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_last_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_all_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_head_copy(s, 5, &quot;Doris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_tail_copy(s, 8, &quot;Becker&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;\t Boris Schäling \t&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;--Boris Schäling--&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;123456789Boris Schäling123456789&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;\\w+\\s\\w+&quot;);   std::cout &lt;&lt; boost::regex_match(s, expr) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   boost::smatch what;   if (boost::regex_search(s, what, expr))   {     std::cout &lt;&lt; what[0] &lt;&lt; std::endl;     std::cout &lt;&lt; what[1] &lt;&lt; &quot; &quot; &lt;&lt; what[2] &lt;&lt; std::endl;   } } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot; Boris Schäling &quot;;   boost::regex expr(&quot;\\s&quot;);   std::string fmt(&quot;_&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   std::string fmt(&quot;\\2 \\1&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   std::string fmt(&quot;\\2 \\1&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt, boost::regex_constants::format_literal) &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   tokenizer tok(s);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;, boost::keep_empty_tokens);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;wchar_t&gt;, std::wstring::const_iterator, std::wstring&gt; tokenizer;   std::wstring s = L&quot;Boost C++ libraries&quot;;   boost::char_separator&lt;wchar_t&gt; sep(L&quot; &quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::wcout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::escaped_list_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost,\&quot;C++ libraries\&quot;&quot;;   tokenizer tok(s);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::offset_separator&gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   int offsets[] = { 5, 5, 9 };   boost::offset_separator sep(offsets, offsets + 3);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%1%.%2%.%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%2%/%1%/%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%1% %2% %1%&quot;) % boost::io::group(std::showpos, 99) % 100 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::format(&quot;%|+| %2% %1%&quot;) % 99 % 100 &lt;&lt; std::endl;   }   catch (boost::io::format_error &amp;ex)   {     std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%|+| %|| %||&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%+d %d %d&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%+s %s %s&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     std::cout &lt;&lt; i &lt;&lt; std::endl;   } } int main() {   boost::thread t(thread);   t.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } void thread() {   try   {     for (int i = 0; i &lt; 5; ++i)     {       wait(1);       std::cout &lt;&lt; i &lt;&lt; std::endl;     }   }   catch (boost::thread_interrupted&amp;)   {   } } int main() {   boost::thread t(thread);   wait(3);   t.interrupt();   t.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;   std::cout &lt;&lt; boost::thread::hardware_concurrency() &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     mutex.lock();     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;     mutex.unlock();   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     boost::lock_guard&lt;boost::mutex&gt; lock(mutex);     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::timed_mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     boost::unique_lock&lt;boost::timed_mutex&gt; lock(mutex, boost::try_to_lock);     if (!lock.owns_lock())       lock.timed_lock(boost::get_system_time() + boost::posix_time::seconds(1));     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;     boost::timed_mutex *m = lock.release();     m-&gt;unlock();   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::shared_mutex mutex; std::vector&lt;int&gt; random_numbers; void fill() {   std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::shared_mutex&gt; lock(mutex);     random_numbers.push_back(std::rand());     lock.unlock();     wait(1);   } } void print() {   for (int i = 0; i &lt; 3; ++i)   {     wait(1);     boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);     std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;   } } int sum = 0; void count() {   for (int i = 0; i &lt; 3; ++i)   {     wait(1);     boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);     sum += random_numbers.back();   } } int main() {   boost::thread t1(fill);   boost::thread t2(print);   boost::thread t3(count);   t1.join();   t2.join();   t3.join();   std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; boost::mutex mutex; boost::condition_variable_any cond; std::vector&lt;int&gt; random_numbers; void fill() {   std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::mutex&gt; lock(mutex);     random_numbers.push_back(std::rand());     cond.notify_all();     cond.wait(mutex);   } } void print() {   std::size_t next_size = 1;   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::mutex&gt; lock(mutex);     while (random_numbers.size() != next_size)       cond.wait(mutex);     std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;     ++next_size;     cond.notify_all();   } } int main() {   boost::thread t1(fill);   boost::thread t2(print);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void init_number_generator() {   static bool done = false;   if (!done)   {     done = true;     std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   } } boost::mutex mutex; void random_number_generator() {   init_number_generator();   int i = std::rand();   boost::lock_guard&lt;boost::mutex&gt; lock(mutex);   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   boost::thread t[3];   for (int i = 0; i &lt; 3; ++i)     t[i] = boost::thread(random_number_generator);   for (int i = 0; i &lt; 3; ++i)     t[i].join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void init_number_generator() {   static boost::thread_specific_ptr&lt;bool&gt; tls;   if (!tls.get())     tls.reset(new bool(false));   if (!*tls)   {     *tls = true;     std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   } } boost::mutex mutex; void random_number_generator() {   init_number_generator();   int i = std::rand();   boost::lock_guard&lt;boost::mutex&gt; lock(mutex);   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   boost::thread t[3];   for (int i = 0; i &lt; 3; ++i)     t[i] = boost::thread(random_number_generator);   for (int i = 0; i &lt; 3; ++i)     t[i].join(); } #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; void handler(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } int main() {   boost::asio::io_service io_service;   boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));   timer.async_wait(handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;10 s.&quot; &lt;&lt; std::endl; } int main() {   boost::asio::io_service io_service;   boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(10));   timer2.async_wait(handler2);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } boost::asio::io_service io_service; void run() {   io_service.run(); } int main() {   boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5));   timer2.async_wait(handler2);   boost::thread thread1(run);   boost::thread thread2(run);   thread1.join();   thread2.join(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } boost::asio::io_service io_service1; boost::asio::io_service io_service2; void run1() {   io_service1.run(); } void run2() {   io_service2.run(); } int main() {   boost::asio::deadline_timer timer1(io_service1, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service2, boost::posix_time::seconds(5));   timer2.async_wait(handler2);   boost::thread thread1(run1);   boost::thread thread2(run2);   thread1.join();   thread2.join(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; boost::asio::io_service io_service; boost::asio::ip::tcp::resolver resolver(io_service); boost::asio::ip::tcp::socket sock(io_service); boost::array&lt;char, 4096&gt; buffer; void read_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) {   if (!ec)   {     std::cout &lt;&lt; std::string(buffer.data(), bytes_transferred) &lt;&lt; std::endl;     sock.async_read_some(boost::asio::buffer(buffer), read_handler);   } } void connect_handler(const boost::system::error_code &amp;ec) {   if (!ec)   {     boost::asio::write(sock, boost::asio::buffer(&quot;GET / HTTP 1.1\r\nHost: highscore.de\r\n\r\n&quot;));     sock.async_read_some(boost::asio::buffer(buffer), read_handler);   } } void resolve_handler(const boost::system::error_code &amp;ec, boost::asio::ip::tcp::resolver::iterator it) {   if (!ec)   {     sock.async_connect(*it, connect_handler);   } } int main() {   boost::asio::ip::tcp::resolver::query query(&quot;www.highscore.de&quot;, &quot;80&quot;);   resolver.async_resolve(query, resolve_handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;string&gt; boost::asio::io_service io_service; boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 80); boost::asio::ip::tcp::acceptor acceptor(io_service, endpoint); boost::asio::ip::tcp::socket sock(io_service); std::string data = &quot;HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, world!&quot;; void write_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) { } void accept_handler(const boost::system::error_code &amp;ec) {   if (!ec)   {     boost::asio::async_write(sock, boost::asio::buffer(data), write_handler);   } } int main() {   acceptor.listen();   acceptor.async_accept(sock, accept_handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;cstddef&gt; template &lt;typename Service&gt; class basic_timer   : public boost::asio::basic_io_object&lt;Service&gt; {   public:     explicit basic_timer(boost::asio::io_service &amp;io_service)       : boost::asio::basic_io_object&lt;Service&gt;(io_service)     {     }     void wait(std::size_t seconds)     {       return this-&gt;service.wait(this-&gt;implementation, seconds);     }     template &lt;typename Handler&gt;     void async_wait(std::size_t seconds, Handler handler)     {       this-&gt;service.async_wait(this-&gt;implementation, seconds, handler);     } }; #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/scoped_ptr.hpp&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; #include &lt;boost/system/error_code.hpp&gt; template &lt;typename TimerImplementation = timer_impl&gt; class basic_timer_service   : public boost::asio::io_service::service {   public:     static boost::asio::io_service::id id;     explicit basic_timer_service(boost::asio::io_service &amp;io_service)       : boost::asio::io_service::service(io_service),       async_work_(new boost::asio::io_service::work(async_io_service_)),       async_thread_(boost::bind(&amp;boost::asio::io_service::run, &amp;async_io_service_))     {     }     ~basic_timer_service()     {       async_work_.reset();       async_io_service_.stop();       async_thread_.join();     }     typedef boost::shared_ptr&lt;TimerImplementation&gt; implementation_type;     void construct(implementation_type &amp;impl)     {       impl.reset(new TimerImplementation());     }     void destroy(implementation_type &amp;impl)     {       impl-&gt;destroy();       impl.reset();     }     void wait(implementation_type &amp;impl, std::size_t seconds)     {       boost::system::error_code ec;       impl-&gt;wait(seconds, ec);       boost::asio::detail::throw_error(ec);     }     template &lt;typename Handler&gt;     class wait_operation     {       public:         wait_operation(implementation_type &amp;impl, boost::asio::io_service &amp;io_service, std::size_t seconds, Handler handler)           : impl_(impl),           io_service_(io_service),           work_(io_service),           seconds_(seconds),           handler_(handler)         {         }         void operator()() const         {           implementation_type impl = impl_.lock();           if (impl)           {               boost::system::error_code ec;               impl-&gt;wait(seconds_, ec);               this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, ec));           }           else           {               this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, boost::asio::error::operation_aborted));           }       }       private:         boost::weak_ptr&lt;TimerImplementation&gt; impl_;         boost::asio::io_service &amp;io_service_;         boost::asio::io_service::work work_;         std::size_t seconds_;         Handler handler_;     };     template &lt;typename Handler&gt;     void async_wait(implementation_type &amp;impl, std::size_t seconds, Handler handler)     {       this-&gt;async_io_service_.post(wait_operation&lt;Handler&gt;(impl, this-&gt;get_io_service(), seconds, handler));     }   private:     void shutdown_service()     {     }     boost::asio::io_service async_io_service_;     boost::scoped_ptr&lt;boost::asio::io_service::work&gt; async_work_;     boost::thread async_thread_; }; template &lt;typename TimerImplementation&gt; boost::asio::io_service::id basic_timer_service&lt;TimerImplementation&gt;::id; #include &lt;boost/system/error_code.hpp&gt; #include &lt;cstddef&gt; #include &lt;windows.h&gt; class timer_impl {   public:     timer_impl()       : handle_(CreateEvent(NULL, FALSE, FALSE, NULL))     {     }     ~timer_impl()     {       CloseHandle(handle_);     }     void destroy()     {       SetEvent(handle_);     }     void wait(std::size_t seconds, boost::system::error_code &amp;ec)     {       DWORD res = WaitForSingleObject(handle_, seconds * 1000);       if (res == WAIT_OBJECT_0)         ec = boost::asio::error::operation_aborted;       else         ec = boost::system::error_code();     } private:     HANDLE handle_; }; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &quot;basic_timer.hpp&quot; #include &quot;timer_impl.hpp&quot; #include &quot;basic_timer_service.hpp&quot; void wait_handler(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } typedef basic_timer&lt;basic_timer_service&lt;&gt; &gt; timer; int main() {   boost::asio::io_service io_service;   timer t(io_service);   t.async_wait(5, wait_handler);   io_service.run(); } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   std::cout &lt;&lt; shdmem.get_name() &lt;&lt; std::endl;   boost::interprocess::offset_t size;   if (shdmem.get_size(size))     std::cout &lt;&lt; size &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region.get_address() &lt;&lt; std::endl;   std::cout &lt;&lt; std::dec &lt;&lt; region.get_size() &lt;&lt; std::endl;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region2.get_address() &lt;&lt; std::endl;   std::cout &lt;&lt; std::dec &lt;&lt; region2.get_size() &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   int *i1 = static_cast&lt;int*&gt;(region.get_address());   *i1 = 99;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   int *i2 = static_cast&lt;int*&gt;(region2.get_address());   std::cout &lt;&lt; *i2 &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;iostream&gt; int main() {   bool removed = boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   std::cout &lt;&lt; removed &lt;&lt; std::endl; } #include &lt;boost/interprocess/windows_shared_memory.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::windows_shared_memory shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write, 1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   int *i1 = static_cast&lt;int*&gt;(region.get_address());   *i1 = 99;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   int *i2 = static_cast&lt;int*&gt;(region2.get_address());   std::cout &lt;&lt; *i2 &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   if (p.first)     std::cout &lt;&lt; *p.first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[10](99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   if (p.first)   {     std::cout &lt;&lt; *p.first &lt;&lt; std::endl;     std::cout &lt;&lt; p.second &lt;&lt; std::endl;   } } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);     boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);     int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[4096](99);   }   catch (boost::interprocess::bad_alloc &amp;ex)   {     std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   managed_shm.destroy&lt;int&gt;(&quot;Integer&quot;);   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   std::cout &lt;&lt; p.first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/allocators/allocator.hpp&gt; #include &lt;boost/interprocess/containers/string.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   typedef boost::interprocess::allocator&lt;char, boost::interprocess::managed_shared_memory::segment_manager&gt; CharAllocator;   typedef boost::interprocess::basic_string&lt;char, std::char_traits&lt;char&gt;, CharAllocator&gt; string;   string *s = managed_shm.find_or_construct&lt;string&gt;(&quot;String&quot;)(&quot;Hello!&quot;, managed_shm.get_segment_manager());   s-&gt;insert(5, &quot;, world&quot;);   std::cout &lt;&lt; *s &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; void construct_objects(boost::interprocess::managed_shared_memory &amp;managed_shm) {   managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99);   managed_shm.construct&lt;float&gt;(&quot;Float&quot;)(3.14); } int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   managed_shm.atomic_func(boost::bind(construct_objects, boost::ref(managed_shm)));   std::cout &lt;&lt; *managed_shm.find&lt;int&gt;(&quot;Integer&quot;).first &lt;&lt; std::endl;   std::cout &lt;&lt; *managed_shm.find&lt;float&gt;(&quot;Float&quot;).first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/named_mutex.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)();   boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;);   named_mtx.lock();   ++(*i);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   named_mtx.unlock(); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)();   boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)();   mtx-&gt;lock();   ++(*i);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   mtx-&gt;unlock(); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/named_mutex.hpp&gt; #include &lt;boost/interprocess/sync/named_condition.hpp&gt; #include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0);   boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;);   boost::interprocess::named_condition named_cnd(boost::interprocess::open_or_create, &quot;cnd&quot;);   boost::interprocess::scoped_lock&lt;boost::interprocess::named_mutex&gt; lock(named_mtx);   while (*i &lt; 10)   {     if (*i % 2 == 0)     {       ++(*i);       named_cnd.notify_all();       named_cnd.wait(lock);     }     else     {       std::cout &lt;&lt; *i &lt;&lt; std::endl;       ++(*i);       named_cnd.notify_all();       named_cnd.wait(lock);     }   }   named_cnd.notify_all();   boost::interprocess::shared_memory_object::remove(&quot;shm&quot;);   boost::interprocess::named_mutex::remove(&quot;mtx&quot;);   boost::interprocess::named_condition::remove(&quot;cnd&quot;); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt; #include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);     int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0);     boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)();     boost::interprocess::interprocess_condition *cnd = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_condition&gt;(&quot;cnd&quot;)();     boost::interprocess::scoped_lock&lt;boost::interprocess::interprocess_mutex&gt; lock(*mtx);     while (*i &lt; 10)     {       if (*i % 2 == 0)       {         ++(*i);         cnd-&gt;notify_all();         cnd-&gt;wait(lock);       }       else       {         std::cout &lt;&lt; *i &lt;&lt; std::endl;         ++(*i);         cnd-&gt;notify_all();         cnd-&gt;wait(lock);       }     }     cnd-&gt;notify_all();   }   catch (...)   {   }   boost::interprocess::shared_memory_object::remove(&quot;shm&quot;); } #include &lt;boost/filesystem.hpp&gt; int main() {   boost::filesystem::path p1(&quot;C:\\&quot;);   boost::filesystem::path p2(&quot;C:\\Windows&quot;);   boost::filesystem::path p3(&quot;C:\\Program Files&quot;); } #include &lt;boost/filesystem.hpp&gt; int main() {   boost::filesystem::path p1(&quot;...&quot;);   boost::filesystem::path p2(&quot;\\&quot;);   boost::filesystem::path p3(&quot;@:&quot;); } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   std::cout &lt;&lt; p.string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;/&quot;);   std::cout &lt;&lt; p.string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   std::cout &lt;&lt; p.root_name() &lt;&lt; std::endl;   std::cout &lt;&lt; p.root_directory() &lt;&lt; std::endl;   std::cout &lt;&lt; p.root_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.relative_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.parent_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.filename() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;photo.jpg&quot;);   std::cout &lt;&lt; p.stem() &lt;&lt; std::endl;   std::cout &lt;&lt; p.extension() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   for (boost::filesystem::path::iterator it = p.begin(); it != p.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   p /= &quot;Windows\\System&quot;;   std::cout &lt;&lt; p.string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   try   {     boost::filesystem::file_status s = boost::filesystem::status(p);     std::cout &lt;&lt; boost::filesystem::is_directory(s) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;);   try   {     std::cout &lt;&lt; boost::filesystem::file_size(p) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; #include &lt;ctime&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;);   try   {     std::time_t t = boost::filesystem::last_write_time(p);     std::cout &lt;&lt; std::ctime(&amp;t) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   try   {     boost::filesystem::space_info s = boost::filesystem::space(p);     std::cout &lt;&lt; s.capacity &lt;&lt; std::endl;     std::cout &lt;&lt; s.free &lt;&lt; std::endl;     std::cout &lt;&lt; s.available &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Test&quot;);   try   {     if (boost::filesystem::create_directory(p))     {       boost::filesystem::rename(p, &quot;C:\\Test2&quot;);       boost::filesystem::remove(&quot;C:\\Test2&quot;);     }   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;, &quot;D:\\&quot;) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;windows.h&gt; #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl;     SetCurrentDirectory(&quot;C:\\&quot;);     std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem/fstream.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;test.txt&quot;);   boost::filesystem::ofstream ofs(p);   ofs &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } </code></pre><h1 id="Boost程序库完全开发指南——深入C-“准”标准库（第3版）"><a href="#Boost程序库完全开发指南——深入C-“准”标准库（第3版）" class="headerlink" title="Boost程序库完全开发指南——深入C++“准”标准库（第3版）"></a>Boost程序库完全开发指南——深入C++“准”标准库（第3版）</h1><p><a href="https://github/chronolaw/boost_guide.git" title="https://github/chronolaw/boost_guide.git" target="_blank" rel="noopener">https://github/chronolaw/boost_guide.git</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.boost.org/" target="_blank" rel="noopener">http://www.boost.org/</a></li><li><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">http://zh.highscore.de/cpp/boost/</a></li><li><a href="http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostChina" target="_blank" rel="noopener">http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostChina</a></li><li><a href="http://www.boost.org/doc/libs/1_63_0/more/getting_started/windows.html" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_63_0/more/getting_started/windows.html</a></li><li><a href="https://sourceforge.net/projects/boost/?source=directory" target="_blank" rel="noopener">https://sourceforge.net/projects/boost/?source=directory</a></li><li><a href="http://jingyan.baidu.com/article/a3aad71aa1ebe7b1fb009681.html" target="_blank" rel="noopener">win7 vs2012/2013 编译boost 1.55</a></li><li><a href="http://www.cnblogs.com/lidabo/p/3782400.html" target="_blank" rel="noopener">Win7+vs2010下安装boost_1_46_1库</a></li><li><a href="http://www.cnblogs.com/lidabo/p/3782193.html" target="_blank" rel="noopener">vs2008编译boost</a></li><li><a href="https://blog.csdn.net/qingyulove/article/details/78863457" target="_blank" rel="noopener">C++ Boost在VS2017中的使用</a></li><li><a href="http://sourceforge.net/projects/boost/files/boost-docs/" target="_blank" rel="noopener">PDF version of this manual is also available.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Visual-Studio-IDE构建&quot;&gt;&lt;a href=&quot;#使用Visual-Studio-IDE构建&quot; class=&quot;headerlink&quot; title=&quot;使用Visual Studio IDE构建&quot;&gt;&lt;/a&gt;使用Visual Studio IDE构建&lt;/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="boost" scheme="https://caojingyou.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>MahApps.Metro使用</title>
    <link href="https://caojingyou.github.io/2017/07/01/MahApps.Metro%E4%BD%BF%E7%94%A8/"/>
    <id>https://caojingyou.github.io/2017/07/01/MahApps.Metro使用/</id>
    <published>2017-07-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MahApps-Metro使用"><a href="#MahApps-Metro使用" class="headerlink" title="MahApps.Metro使用"></a>MahApps.Metro使用</h1><h2 id="下载MahApps-Metro"><a href="#下载MahApps-Metro" class="headerlink" title="下载MahApps.Metro"></a>下载MahApps.Metro</h2><pre><code>PM&gt; Install-Package MahApps.Metro</code></pre><h2 id="MainWindow-xaml中添加"><a href="#MainWindow-xaml中添加" class="headerlink" title="MainWindow.xaml中添加"></a>MainWindow.xaml中添加</h2><pre><code>xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;</code></pre><h2 id="然后将Window标签替换为如下标签"><a href="#然后将Window标签替换为如下标签" class="headerlink" title="然后将Window标签替换为如下标签"></a>然后将Window标签替换为如下标签</h2><pre><code>&lt;Controls:MetroWindow x:Class=&quot;WpfApplication.MainWindow&quot;                  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                  xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;                  Title=&quot;MainWindow&quot;                  Height=&quot;600&quot;                  Width=&quot;800&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><h2 id="MainWindow-xaml-cs添加"><a href="#MainWindow-xaml-cs添加" class="headerlink" title="MainWindow.xaml.cs添加"></a>MainWindow.xaml.cs添加</h2><pre><code>using MahApps.Metro.Controls;namespace WpfApplication{  public partial class MainWindow : MetroWindow  {    public MainWindow()    {      InitializeComponent();    }  }}</code></pre><h2 id="使用内置的样式App-xaml"><a href="#使用内置的样式App-xaml" class="headerlink" title="使用内置的样式App.xaml"></a>使用内置的样式App.xaml</h2><pre><code>&lt;Application x:Class=&quot;WpfApplication.App&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             StartupUri=&quot;MainWindow.xaml&quot;&gt;  &lt;Application.Resources&gt;    &lt;ResourceDictionary&gt;      &lt;ResourceDictionary.MergedDictionaries&gt;        &lt;!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! --&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Colors.xaml&quot; /&gt;        &lt;!-- Accent and AppTheme setting --&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Blue.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;      &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;  &lt;/Application.Resources&gt;&lt;/Application&gt;</code></pre><h2 id="显示标题栏、图标、最大化最小化按钮的显示"><a href="#显示标题栏、图标、最大化最小化按钮的显示" class="headerlink" title="显示标题栏、图标、最大化最小化按钮的显示"></a>显示标题栏、图标、最大化最小化按钮的显示</h2><pre><code>&lt;Controls:MetroWindow x:Class=&quot;WpfApplication.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;600&quot;                      Width=&quot;800&quot;                      Icon=&quot;mahapps.metro.logo2.ico&quot;                      ShowIconOnTitleBar=&quot;True&quot;                      ShowTitleBar=&quot;True&quot;&gt;    &lt;/Controls:MetroWindow&gt;</code></pre><p>WindowButtonCommands are the minimize, maximize/restore, and close buttons. You can hide the buttons with <code>ShowMinButton=&quot;True|False&quot;</code>, <code>ShowMaxRestoreButton=&quot;True|False&quot;</code> and <code>ShowCloseButton=&quot;True|False&quot;</code>.</p><p>The visibility of the minimize and maximize/restore buttons are also effected by the <code>ResizeMode</code>. If <code>ResizeMode=&quot;NoResize&quot;</code> the buttons are collapsed. If <code>ResizeMode=&quot;CanMinimize&quot;</code> the maximize/restore button is collapsed.</p><h2 id="记住窗口位置"><a href="#记住窗口位置" class="headerlink" title="记住窗口位置"></a>记住窗口位置</h2><p>aveWindowPosition=”True|False”(默认False选项）。将此属性设置为True将意味着在下一次发射，将被自动定位和尺寸对它的出口。这种设计为提高ux和速度发展为一个“管道”，UI是定期进行的。</p><h2 id="修改标题栏"><a href="#修改标题栏" class="headerlink" title="修改标题栏"></a>修改标题栏</h2><p>可以添加自己的控制 LeftWindowsCommands 或 RightWindowsCommands</p><pre><code>&lt;MetroWindow&gt; ... &lt;/MetroWindow&gt;</code></pre><p>MainWindow.xaml.cs内添加：</p><pre><code>&lt;Controls:MetroWindow.RightWindowCommands&gt;  &lt;Controls:WindowCommands&gt;    &lt;Button Content=&quot;settings&quot; /&gt;    &lt;Button&gt;      &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;        &lt;Rectangle Width=&quot;20&quot;                   Height=&quot;20&quot;                   Fill=&quot;{Binding RelativeSource={RelativeSource AncestorType=Button}, Path=Foreground}&quot;&gt;          &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot; Visual=&quot;{StaticResource appbar_cupcake}&quot; /&gt;          &lt;/Rectangle.OpacityMask&gt;        &lt;/Rectangle&gt;        &lt;TextBlock Margin=&quot;4 0 0 0&quot;                   VerticalAlignment=&quot;Center&quot;                   Text=&quot;deploy cupcakes&quot; /&gt;      &lt;/StackPanel&gt;    &lt;/Button&gt;  &lt;/Controls:WindowCommands&gt;&lt;/Controls:MetroWindow.RightWindowCommands&gt;</code></pre><p>显示图标需要加载MahApps.Metro.Resources资源</p><h1 id="MahApps-Metro-Resources使用"><a href="#MahApps-Metro-Resources使用" class="headerlink" title="MahApps.Metro.Resources使用"></a>MahApps.Metro.Resources使用</h1><h2 id="下载MahApps-Metro-Resources"><a href="#下载MahApps-Metro-Resources" class="headerlink" title="下载MahApps.Metro.Resources"></a>下载MahApps.Metro.Resources</h2><pre><code>PM&gt; Install-Package MahApps.Metro.Resources</code></pre><h2 id="MainWindow-xaml文件中添加"><a href="#MainWindow-xaml文件中添加" class="headerlink" title="MainWindow.xaml文件中添加"></a>MainWindow.xaml文件中添加</h2><pre><code>&lt;Window.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;/Resources/Icons.xaml&quot; /&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;/ResourceDictionary&gt;    &lt;/Window.Resources&gt;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>&lt;Rectangle&gt;        &lt;Rectangle.Fill&gt;            &lt;VisualBrush Visual=&quot;{StaticResource appbar_add}&quot; /&gt;        &lt;/Rectangle.Fill&gt;    &lt;/Rectangle&gt;</code></pre><p>或者</p><pre><code>&lt;Rectangle Fill=&quot;Black&quot;&gt;    &lt;Rectangle.OpacityMask&gt;        &lt;VisualBrush Visual=&quot;{StaticResource appbar_add}&quot; Stretch=&quot;Fill&quot; /&gt;    &lt;/Rectangle.OpacityMask&gt;&lt;/Rectangle&gt;</code></pre><h1 id="如何改变目前的主题-Styles"><a href="#如何改变目前的主题-Styles" class="headerlink" title="如何改变目前的主题 Styles"></a>如何改变目前的主题 Styles</h1><p>You can choose between these available accents:</p><pre><code>“Red”, “Green”, “Blue”, “Purple”, “Orange”, “Lime”, “Emerald”, “Teal”, “Cyan”, “Cobalt”, “Indigo”, “Violet”, “Pink”, “Magenta”, “Crimson”, “Amber”, “Yellow”, “Brown”, “Olive”, “Steel”, “Mauve”, “Taupe”, “Sienna”</code></pre><p>and these themes:</p><pre><code>“BaseLight”, “BaseDark”</code></pre><h2 id="通过App-xaml，直接修改其中对应的部分"><a href="#通过App-xaml，直接修改其中对应的部分" class="headerlink" title="通过App.xaml，直接修改其中对应的部分"></a>通过App.xaml，直接修改其中对应的部分</h2><pre><code>&lt;Application x:Class=&quot;MahAppsMetroThemesSample.App&quot;         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;         StartupUri=&quot;MainWindow.xaml&quot;&gt;    &lt;Application.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml&quot; /&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml&quot; /&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Colors.xaml&quot; /&gt;                &lt;!-- accent resource --&gt;                &lt;!-- change &quot;Cobalt&quot; to the accent color you want --&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Cobalt.xaml&quot; /&gt;                &lt;!-- theme resource --&gt;                &lt;!-- change &quot;BaseLight&quot; to the theme you want --&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;/ResourceDictionary&gt;    &lt;/Application.Resources&gt;&lt;/Application&gt;</code></pre><h2 id="通过ThemeManager"><a href="#通过ThemeManager" class="headerlink" title="通过ThemeManager"></a>通过ThemeManager</h2><pre><code>public partial class App : Application{    protected override void OnStartup(StartupEventArgs e)    {        // get the current app style (theme and accent) from the application        // you can then use the current theme and custom accent instead set a new theme        Tuple&lt;AppTheme, Accent&gt; appStyle = ThemeManager.DetectAppStyle(Application.Current);        // now set the Green accent and dark theme        ThemeManager.ChangeAppStyle(Application.Current,                                    ThemeManager.GetAccent(&quot;Green&quot;),                                    ThemeManager.GetAppTheme(&quot;BaseDark&quot;)); // or appStyle.Item1        base.OnStartup(e);    }}</code></pre><h2 id="在主窗口中修改"><a href="#在主窗口中修改" class="headerlink" title="在主窗口中修改"></a>在主窗口中修改</h2><h3 id="MainWindow-xaml文件"><a href="#MainWindow-xaml文件" class="headerlink" title="MainWindow.xaml文件"></a>MainWindow.xaml文件</h3><pre><code>&lt;Controls:MetroWindow.Resources&gt;    &lt;ResourceDictionary&gt;       &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;!-- this window should be blue --&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Blue.xaml&quot; /&gt;            &lt;!-- and should use the light theme --&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;&lt;/Controls:MetroWindow.Resources&gt;</code></pre><h3 id="主类MetroWindow中"><a href="#主类MetroWindow中" class="headerlink" title="主类MetroWindow中"></a>主类MetroWindow中</h3><pre><code>public partial class AccentStyleWindow : MetroWindow{    public void ChangeAppStyle()    {        // set the Red accent and dark theme only to the current window        ThemeManager.ChangeAppStyle(this,                                    ThemeManager.GetAccent(&quot;Red&quot;),                                    ThemeManager.GetAppTheme(&quot;BaseDark&quot;));    }}</code></pre><p>还可以自定义主题</p><h2 id="Controls控件"><a href="#Controls控件" class="headerlink" title="Controls控件"></a>Controls控件</h2><h3 id="MetroWindow"><a href="#MetroWindow" class="headerlink" title="MetroWindow"></a>MetroWindow</h3><p>窗口有边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      BorderBrush=&quot;{DynamicResource AccentColorBrush}&quot;                      BorderThickness=&quot;1&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><p>发光的边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      GlowBrush=&quot;{DynamicResource AccentColorBrush}&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><p>有阴影的边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      BorderThickness=&quot;0&quot;                       GlowBrush=&quot;Black&quot;                      ResizeMode=&quot;CanResizeWithGrip&quot;                      WindowTransitionsEnabled=&quot;False&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><h3 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h3><h4 id="Default-look"><a href="#Default-look" class="headerlink" title="Default look"></a>Default look</h4><p><img src="http://mahapps.com/images/08_RegularButton.png" alt=""></p><h4 id="MetroCircleButton"><a href="#MetroCircleButton" class="headerlink" title="MetroCircleButton"></a>MetroCircleButton</h4><pre><code>&lt;Button Style=&quot;{DynamicResource MetroCircleButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/07_CircleButtons.png" alt=""></p><h4 id="SquareButton"><a href="#SquareButton" class="headerlink" title="SquareButton"></a>SquareButton</h4><pre><code>&lt;Button Style=&quot;{DynamicResource SquareButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/square-button.png" alt=""></p><h4 id="AccentedSquareButton"><a href="#AccentedSquareButton" class="headerlink" title="AccentedSquareButton"></a>AccentedSquareButton</h4><pre><code>&lt;Button Style=&quot;{StaticResource AccentedSquareButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/accent-square-button.png" alt=""></p><h4 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h4><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/FlatButton.xaml&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/flatbutton.png" alt=""></p><h3 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h3><p>您可以使用您熟悉的快捷菜单</p><pre><code>&lt;ContextMenu&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.New&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Delete&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Print&quot; /&gt;&lt;/ContextMenu&gt;</code></pre><p>如果你想使用快捷菜单的一部分被声明为资源和共享使用 <code>CompositeCollection</code></p><pre><code>&lt;CompositeCollection x:Key=&quot;ContextMenuBase&quot; x:Shared=&quot;False&quot;&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.New&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Delete&quot; /&gt;  &lt;Separator /&gt;  &lt;StaticResource ResourceKey=&quot;ContextMenuItemRefresh&quot; /&gt;  &lt;Separator /&gt;&lt;/CompositeCollection&gt;&lt;ContextMenu&gt;  &lt;ContextMenu.ItemsSource&gt;&lt;CompositeCollection&gt;  &lt;CollectionContainer Collection=&quot;{StaticResource ContextMenuBase}&quot;&gt;&lt;/CollectionContainer&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Print&quot; /&gt;&lt;/CompositeCollection&gt;  &lt;/ContextMenu.ItemsSource&gt;&lt;/ContextMenu&gt;</code></pre><p>当你运行应用程序的绑定错误:</p><p>System.Windows.Data Error: 4 : Cannot find source for binding with reference ‘RelativeSource FindAncestor, AncestorType=’System.Windows.Controls.ItemsControl’, AncestorLevel=’1’’. BindingExpression:Path=VerticalContentAlignment; DataItem=null; target element is ‘MenuItem’ (Name=’’); target property is ‘VerticalContentAlignment’ (type ‘VerticalAlignment’)</p><p>这是一个已知的问题在WPF和解决方法是创建一个自定义 <code>MenuItem</code> 风格: </p><pre><code>&lt;Style TargetType=&quot;{x:Type MenuItem}&quot;   BasedOn=&quot;{StaticResource MetroMenuItem}&quot;&gt;  &lt;Setter Property=&quot;HorizontalContentAlignment&quot;  Value=&quot;Left&quot; /&gt;  &lt;Setter Property=&quot;VerticalContentAlignment&quot;  Value=&quot;Center&quot; /&gt;  &lt;/Style&gt;</code></pre><h2 id="Data-Grid"><a href="#Data-Grid" class="headerlink" title="Data Grid"></a>Data Grid</h2><p>In order for the style to be applied, you will have to include references to the <code>Styles/Controls</code> resource dictionary in your App.xaml and the namespace <code>xmlns:controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;</code> in the window you are using.</p><p><img src="http://mahapps.com/images/default_datagrid_style.png" alt=""></p><h3 id="Alternative-Style"><a href="#Alternative-Style" class="headerlink" title="Alternative Style"></a>Alternative Style</h3><p>MahApps.Metro also provides an alternative style, <code>AzureDataGrid</code> that attempts to mimic the DataGrid found on Microsoft Azure. To use it instead of the default style, simple set the DataGrid’s <code>Style</code> property to <code>{StaticResource AzureDataGrid</code>. As usual, make sure that you have your references defined.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding People}&quot; Margin=&quot;10,20,10,0&quot;  AutoGenerateColumns=&quot;True&quot;  Style=&quot;{StaticResource AzureDataGrid}&quot;&gt;&lt;/DataGrid&gt; </code></pre><p><img src="http://mahapps.com/images/azure_datagrid_style.png" alt=""></p><h3 id="DataGrid-Numeric-Updown-Control"><a href="#DataGrid-Numeric-Updown-Control" class="headerlink" title="DataGrid Numeric Updown Control"></a>DataGrid Numeric Updown Control</h3><p>In addition to styling the DataGrid, MahApps.Metro also provides a control that allows users to add a <code>NumericUpDown</code> as one of their <code>DataGrid</code>’s columns. To add the custom column to your <code>DataGrid</code>, add <code>DataGridNumericUpDownColumn</code> under the MahApps namespace to your <code>DataGrid.Columns</code> properties. Be sure to set <code>AutoGenerateColumns</code> to <code>False</code> if you have not already done so.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding Path=Albums}&quot;  Grid.Row=&quot;0&quot;  AutoGenerateColumns=&quot;False&quot;&gt;&lt;DataGrid.Columns&gt;&lt;DataGridTextColumn Header=&quot;Genre&quot;Binding=&quot;{Binding Genre.Name}&quot; /&gt;&lt;controls:DataGridNumericUpDownColumn Header=&quot;Price&quot;  Binding=&quot;{Binding Price}&quot;  StringFormat=&quot;C&quot;  Minimum=&quot;0&quot; /&gt;&lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt;</code></pre><p><img src="http://mahapps.com/images/datagrid_numeric_up_down.png" alt=""></p><h3 id="DataGrid-Checkbox"><a href="#DataGrid-Checkbox" class="headerlink" title="DataGrid Checkbox"></a>DataGrid Checkbox</h3><p>Lastly, MahApps.Metro provides an <code>ElementStyle</code> for the <code>DataGridCheckBoxColumn</code>. In order to apply the style, you will have to set the <code>ElementStyle</code> property of the <code>DataGridCheckBoxColumn</code> to <code>{DynamicResource MetroDataGridCheckBox}</code> as shown in the code sample below.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding Path=Albums}&quot;  Grid.Row=&quot;0&quot;  AutoGenerateColumns=&quot;False&quot;&gt;&lt;DataGrid.Columns&gt;&lt;DataGridCheckBoxColumn ElementStyle=&quot;{DynamicResource MetroDataGridCheckBox}&quot;EditingElementStyle=&quot;{DynamicResource MetroDataGridCheckBox}&quot;Header=&quot;IsSelected&quot;Binding=&quot;{Binding RelativeSource={RelativeSource AncestorType=DataGridRow}, Path=IsSelected, Mode=OneWay}&quot;/&gt;&lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt;</code></pre><p><img src="http://mahapps.com/images/datagrid_checkbox.png" alt=""></p><h2 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h2><h3 id="Message-dialog"><a href="#Message-dialog" class="headerlink" title="Message dialog"></a>Message dialog</h3><p>对话框还可以显示简单消息的<code>ShowMessageAsync</code>方法。扩展方法MetroWindow因此，呼叫从它的窗口类。</p><pre><code>await this.ShowMessageAsync(&quot;This is the title&quot;, &quot;Some message&quot;);</code></pre><p>有可选的额外参数的简单的按钮，例如 Ok Cancel 并设置主题颜色和动画选项。</p><h3 id="Progress-dialog"><a href="#Progress-dialog" class="headerlink" title="Progress dialog"></a>Progress dialog</h3><pre><code>var controller = await this.ShowProgressAsync(&quot;Please wait...&quot;, &quot;Progress message&quot;);</code></pre><p>This method returns a ProgressDialogController object that exposes the SetProgress method, use it to set the current progress.</p><p><img src="http://mahapps.com/images/progressdialog.png" alt=""></p><h2 id="FlipView"><a href="#FlipView" class="headerlink" title="FlipView"></a>FlipView</h2><p><img src="http://i.msdn.microsoft.com/dynimg/IC571410.png" alt=""></p><pre><code>&lt;Controls:FlipView Height=&quot;200&quot;    IsBannerEnabled=&quot;True&quot;    SelectionChanged=&quot;FlipView_SelectionChanged&quot;   Margin=&quot;0, 0, 10, 0&quot;&gt;&lt;Controls:FlipView.Items&gt;&lt;Grid Background=&quot;#2E8DEF&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_cupcake}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;Grid Background=&quot;#00A600&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_xbox}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;Grid Background=&quot;#BF1E4B&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_chess_horse}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;/Controls:FlipView.Items&gt;&lt;/Controls:FlipView&gt;</code></pre><h3 id="The-Banner"><a href="#The-Banner" class="headerlink" title="The Banner"></a>The Banner</h3><pre><code>private void FlipView_SelectionChanged(object sender, SelectionChangedEventArgs e){var flipview = ((FlipView)sender);switch (flipview.SelectedIndex){case 0:flipview.BannerText = &quot;Cupcakes!&quot;;break;case 1:flipview.BannerText = &quot;Xbox!&quot;;break;case 2:flipview.BannerText = &quot;Chess!&quot;;break;}}</code></pre><h3 id="The-Control-Buttons"><a href="#The-Control-Buttons" class="headerlink" title="The Control Buttons"></a>The Control Buttons</h3><p>The control buttons (the next and previous buttons) allow the user to flip through the items using their mouse. The buttons can be disabled by calling <code>HideControlButtons</code> and renabled by calling <code>ShowControlButtons</code>.</p><p>The user can also flip through the items using the arrows on their keyboard.</p><h3 id="Automated-scrolling-batteries-not-included"><a href="#Automated-scrolling-batteries-not-included" class="headerlink" title="Automated scrolling (batteries not included)"></a>Automated scrolling (batteries not included)</h3><p>Disabling the control buttons is useful when you want to provide an automated scrolling experience. This can be implemented by using a timer and by incrementing SelectedIndex by 1 until the index is equal to Items.Length - 1. At that point, you would reset SelectedIndex to 0.</p><h2 id="Flyouts"><a href="#Flyouts" class="headerlink" title="Flyouts"></a>Flyouts</h2><p>Add the following code to your MetroWindow:</p><pre><code>&lt;Controls:MetroWindow.Flyouts&gt;&lt;Controls:FlyoutsControl&gt;&lt;/Controls:FlyoutsControl&gt;&lt;/Controls:MetroWindow.Flyouts&gt;</code></pre><p>This is the container for the flyouts. Inside this container add the following:</p><pre><code>&lt;Controls:Flyout Header=&quot;Flyout&quot; Position=&quot;Right&quot; Width=&quot;200&quot;&gt;&lt;!-- Your custom content here --&gt;&lt;/Controls:Flyout&gt;</code></pre><h3 id="Themed-flyouts"><a href="#Themed-flyouts" class="headerlink" title="Themed flyouts"></a>Themed flyouts</h3><p>As of version 0.12, flyouts can have various themes, assignable through the Theme property, those are:</p><pre><code>Adapt,Inverse,Dark,Light,Accent</code></pre><ul><li>Adapt adapts the flyout theme to the host window’s theme.</li><li>Inverse has the inverse theme of the host window’s theme.</li><li>Dark will always be the dark theme, this is also the default value.</li><li>Light will always be the light theme.</li><li>Accent adapts the flyout theme to the host window’s theme, it looks like this for the blue theme</li></ul><h3 id="WindowCommandsOverlayBehaviorn"><a href="#WindowCommandsOverlayBehaviorn" class="headerlink" title="WindowCommandsOverlayBehaviorn"></a>WindowCommandsOverlayBehaviorn</h3><p>MetroWindow has overlay properties for LeftWindowCommands, RightWindowCommands, WindowButtonCommands and the Icon to handle the topmost status, even if a flyout is shown.</p><pre><code>public WindowCommandsOverlayBehavior LeftWindowCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior RightWindowCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior WindowButtonCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior IconOverlayBehavior</code></pre><p>These are the values for WindowCommandsOverlayBehavior</p><pre><code>Never // Doesn&apos;t overlay flyouts nor a hidden TitleBar.Flyouts // Overlays opened Flyout controls.HiddenTitleBar // // Overlays a hidden TitleBar.Always</code></pre><p>WindowCommandsOverlayBehavior.Always</p><p><img src="http://mahapps.com/images/WindowCommandsOverlayBehavior_Always.png" alt=""></p><p>WindowCommandsOverlayBehavior.Never</p><p><img src="http://mahapps.com/images/WindowCommandsOverlayBehavior_Never.png" alt=""></p><h2 id="NumericUpDown"><a href="#NumericUpDown" class="headerlink" title="NumericUpDown"></a>NumericUpDown</h2><p>NumericUpDown控件将用来增大或减小数值。</p><p><img src="http://mahapps.com/images/numeric_up_down.png" alt=""></p><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p><img src="http://mahapps.com/images/progressbar.png" alt=""></p><h3 id="MetroProgressBar"><a href="#MetroProgressBar" class="headerlink" title="MetroProgressBar"></a>MetroProgressBar</h3><p>MetroProgressBar is an alternative and simpler style. Instead of creating a normal ProgressBar use:</p><pre><code>&lt;Controls:MetroProgressBar /&gt;</code></pre><p>Its indeterminate state looks like a ProgressRing but not circular.</p><h2 id="ProgressRing"><a href="#ProgressRing" class="headerlink" title="ProgressRing"></a>ProgressRing</h2><p>The Progress Ring control is styled after a similar control in Windows 8 to indicate activity rather than a percentage of progress completed.</p><pre><code>&lt;Controls:ProgressRing IsActive=&quot;True&quot; /&gt;</code></pre><p><code>IsActive</code> can easily be bound to a viewmodel property.</p><pre><code>&lt;Controls:ProgressRing IsActive=&quot;{Binding IsActive}&quot; /&gt;</code></pre><p>Override Foreground if you wish to change the colour.</p><pre><code>&lt;Controls:ProgressRing Foreground=&quot;{DynamicResource AccentColorBrush}&quot;/&gt;</code></pre><h2 id="RangeSlider"><a href="#RangeSlider" class="headerlink" title="RangeSlider"></a>RangeSlider</h2><p><img src="http://mahapps.com/images/range_slider.PNG" alt=""></p><p>Small Example</p><pre><code>&lt;Сontrols:RangeSlider Style=&quot;{StaticResource RangeSliderCameraCommonStyle}&quot; Minimum=&quot;{Binding Path=MinValue, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}&quot;Maximum=&quot;{Binding Path=MaxValue, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}&quot;LowerValue=&quot;{Binding Path=CurrentMinValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;UpperValue=&quot;{Binding Path=CurrentMaxValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;LowerValueChanged=&quot;OnLowerValueChanged&quot; UpperValueChanged=&quot;OnUpperValueChanged&quot;LowerThumbDragStarted=&quot;OnLowerDragStarted&quot;LowerThumbDragCompleted=&quot;OnLowerDragCompleted&quot;UpperThumbDragStarted=&quot;OnUpperDragStarted&quot; UpperThumbDragCompleted=&quot;OnUpperDragCompleted&quot; AutoToolTipPlacement=&quot;TopLeft&quot; AutoToolTipPrecision=&quot;2&quot; MoveWholeRange=&quot;True&quot;IsSnapToTickEnabled=&quot;True&quot; IsMoveToPointEnabled=&quot;True&quot; ExtendedMode=&quot;True&quot;&gt;&lt;/Сontrols:RangeSlider&gt;</code></pre><h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h2><p><img src="http://mahapps.com/images/slider_standard.png" alt=""></p><p>If you want to base your custom style on that style, you need to add <code>BasedOn=&quot;{StaticResource MetroSlider}&quot;</code></p><h2 id="FlatSlider-style"><a href="#FlatSlider-style" class="headerlink" title="FlatSlider style"></a>FlatSlider style</h2><p><img src="http://mahapps.com/images/slider_cube.png" alt=""></p><p>To use that style you need to load resource dictionary <code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/FlatSlider.xaml&quot; /&gt;</code> and explicitly set the style of the Slider to <code>Style=&quot;{DynamicResource FlatSlider}&quot;</code></p><p>This style could be dynamically changed to:</p><p><img src="http://mahapps.com/images/slider_tick.png" alt=""></p><h2 id="SplitButton-and-DropDownButton"><a href="#SplitButton-and-DropDownButton" class="headerlink" title="SplitButton and DropDownButton"></a>SplitButton and DropDownButton</h2><p><img src="http://mahapps.com/images/splitButton_1.png" alt=""></p><h3 id="SelectedItem-and-SelectedIndex"><a href="#SelectedItem-and-SelectedIndex" class="headerlink" title="SelectedItem and SelectedIndex"></a>SelectedItem and SelectedIndex</h3><p>This properties usage is just like in Listbox or ComboBox. When one of this properties changed, Content of the button will also changed.</p><h3 id="Binding-to-ObservableCollection-or-Dictionary"><a href="#Binding-to-ObservableCollection-or-Dictionary" class="headerlink" title="Binding to ObservableCollection or Dictionary"></a>Binding to ObservableCollection or Dictionary</h3><p>To correctly bind an <code>ObservableCollection</code> or a <code>Dictionary</code> to <code>SplitButton</code>, you need to use <code>ItemsSource</code> and <code>DisplayMemberPath</code> For ex, <code>ItemsSource=&quot;{Binding Albums}&quot; DisplayMemberPath=&quot;Title&quot;</code>In case you bind simple types like an enum or integer, you dont need to use DisplayMemberPath property, only ItemsSource`.</p><h3 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a>Orientation</h3><p>SplitButton supports orientation changing as you can see on the screenshot.</p><h3 id="Button-commands"><a href="#Button-commands" class="headerlink" title="Button commands"></a>Button commands</h3><p>You can use button commands for SplitButton</p><h3 id="Icon-property"><a href="#Icon-property" class="headerlink" title="Icon property"></a>Icon property</h3><p>You can add separate icon to SplitButton to display it independently from its content. It could be bitmap image or vector icon. <code>Icon=&quot;{DynamicResource appbar_alert}&quot;</code></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code>&lt;Controls:SplitButton Icon=&quot;{DynamicResource appbar_alert}&quot;HorizontalContentAlignment=&quot;Left&quot;HorizontalAlignment=&quot;Center&quot;VerticalContentAlignment=&quot;Center&quot;Width=&quot;120&quot;SelectedIndex=&quot;2&quot;ItemsSource=&quot;{Binding Albums}&quot;DisplayMemberPath=&quot;Title&quot;VerticalAlignment=&quot;Center&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/splitButton_2.png" alt=""></p><h3 id="DropDownButton"><a href="#DropDownButton" class="headerlink" title="DropDownButton"></a>DropDownButton</h3><p><img src="http://mahapps.com/images/dropDownButton_1.png" alt=""></p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><pre><code>Controls:DropDownButton VerticalContentAlignment=&quot;Center&quot;Width=&quot;120&quot;Content=&quot;Test&quot;DisplayMemberPath=&quot;Title&quot;Icon=&quot;{DynamicResource appbar_music}&quot;ItemsSource=&quot;{Binding Albums}&quot;&gt;&lt;/Controls:DropDownButton&gt;</code></pre><p><img src="http://mahapps.com/images/dropDownButton_2.png" alt=""></p><h2 id="TabControl"><a href="#TabControl" class="headerlink" title="TabControl"></a>TabControl</h2><p>There are three included tab styles - <code>AnimatedTabControl</code>, <code>SingleRowAnimatedTabControl</code> and the default <code>TabControl</code>. The default TabControl style is included in Controls.xaml, but the other two require specific referencing (make sure to do this after a reference to <code>Controls.xaml</code>)</p><h3 id="Default-look-1"><a href="#Default-look-1" class="headerlink" title="Default look"></a>Default look</h3><p><img src="http://mahapps.com/images/default_tab_control.png" alt=""></p><p>This shows the three states - selected/active tab, hover and inactive.</p><h3 id="AnimatedTabControl"><a href="#AnimatedTabControl" class="headerlink" title="AnimatedTabControl"></a>AnimatedTabControl</h3><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.AnimatedTabControl.xaml&quot; /&gt;</code></pre><p>Functioning just like the regular TabControl, except it animates every tab change by wrapping everything in a MetroContentControl.</p><p><img src="http://mahapps.com/images/animatedtabcontrol.gif" alt=""></p><h3 id="AnimatedSingleRowTabControl"><a href="#AnimatedSingleRowTabControl" class="headerlink" title="AnimatedSingleRowTabControl"></a>AnimatedSingleRowTabControl</h3><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.AnimatedSingleRowTabControl.xaml&quot; /&gt;</code></pre><p>AnimatedSingleRowTabControl functions exactly the same as the AnimatedTabControl except the tabs will only appear on a single line rather than wrapping. Instead of wrapping, arrows (left/right) are presented.</p><p><img src="http://mahapps.com/images/singlerow_tab_control.png" alt=""></p><h2 id="TextBox-MahApps-Metro"><a href="#TextBox-MahApps-Metro" class="headerlink" title="TextBox - MahApps.Metro"></a>TextBox - MahApps.Metro</h2><h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><pre><code>&lt;TextBox Controls:TextBoxHelper.Watermark=&quot;This is a textbox&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/10_textboxstates.png" alt=""></p><h3 id="Clear-button"><a href="#Clear-button" class="headerlink" title="Clear button"></a>Clear button</h3><p>Like the watermark, a simple attached property adds in the functionality</p><pre><code>&lt;TextBox Controls:TextBoxHelper.ClearTextButton=&quot;True&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/11_textboxclearstates.png" alt=""></p><h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><pre><code>&lt;controls:Tile Title=&quot;Hello!&quot; TiltFactor=&quot;2&quot;Width=&quot;100&quot; Height=&quot;100&quot; Count=&quot;1&quot;&gt;&lt;/controls:Tile&gt;</code></pre><p><img src="https://github-camo.global.ssl.fastly.net/4793fa88b9041fb4a1bba21aa2140ee7d0f32b3c/687474703a2f2f7777772e6e63756265642e6e65742f7a2f706963732f6d6168617070732f54696c65436f6e74656e74436f6c6f72732e706e67" alt=""></p><h2 id="ToggleButton"><a href="#ToggleButton" class="headerlink" title="ToggleButton"></a>ToggleButton</h2><p>The default style, available just by placing a ToggleButton control in XAML looks like the default MahApps.Metro button.</p><p><img src="http://mahapps.com/images/toggle-button-normal.png" alt=""></p><pre><code>&lt;Grid&gt;&lt;ToggleButton/&gt;&lt;/Grid&gt;</code></pre><p>Another style, MetroCircleToggleButtonStyle is available by setting the ToggleButton’s style to MetroCircleToggleButtonStyle. This style changes the button’s background to AccentColorBrush when it is checked. To modify this behaviour, you will have to edit a copy of the control template using Blend.</p><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;&lt;/ToggleButton&gt;</code></pre><p><img src="http://mahapps.com/images/toggle-button-circle.png" alt=""></p><h3 id="Using-Glyphs-Within-a-Circle-Toggle-Button"><a href="#Using-Glyphs-Within-a-Circle-Toggle-Button" class="headerlink" title="Using Glyphs Within a Circle Toggle Button"></a>Using Glyphs Within a Circle Toggle Button</h3><p>In order to use glyphs, you will have to add a reference to Icons.xaml.</p><pre><code>`&lt;UserControl.Resources&gt;    &lt;ResourceDictionary&gt;        &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro.Resources;component/Icons.xaml&quot; /&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;&lt;/UserControl.Resources&gt;`</code></pre><ol><li>Nest a Rectangle within the ToggleButton</li><li>Set it’s fill to the color you want the icon to have</li><li>Set Rectangle.OpacityMask to contain a VisualBrush with a Visual using the icon’s value as a reference.</li></ol><h3 id="For-example"><a href="#For-example" class="headerlink" title="For example:"></a>For example:</h3><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;    &lt;Rectangle Width=&quot;20&quot;               Height=&quot;20&quot;               Fill=&quot;{DynamicResource BlackBrush}&quot;&gt;        &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot;                         Visual=&quot;{DynamicResource appbar_city}&quot;/&gt;        &lt;/Rectangle.OpacityMask&gt;    &lt;/Rectangle&gt;&lt;/ToggleButton&gt;</code></pre><h3 id="Syncing-Checked-State-of-ToggleButton-with-Foreground"><a href="#Syncing-Checked-State-of-ToggleButton-with-Foreground" class="headerlink" title="Syncing Checked State of ToggleButton with Foreground"></a>Syncing Checked State of ToggleButton with Foreground</h3><p>By default, any icon you set will retain the same color you set it to even if the ToggleButton is checked. To alter this, you can bind your content’s color to the ToggleButton’s Foreground property which changes to white by default when it is checked.</p><p>An example of how to do the binding can be found below:</p><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;    &lt;Rectangle Width=&quot;20&quot;               Height=&quot;20&quot;               Fill=&quot;{Binding Path=Foreground, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type ToggleButton}}}&quot;&gt;        &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot;                         Visual=&quot;{DynamicResource appbar_city}&quot;/&gt;        &lt;/Rectangle.OpacityMask&gt;    &lt;/Rectangle&gt;&lt;/ToggleButton&gt;</code></pre><h2 id="ToggleSwitch"><a href="#ToggleSwitch" class="headerlink" title="ToggleSwitch"></a>ToggleSwitch</h2><p>The function is very similar to that of a checkbox, but easier to differentiate and easier to use with touch interfaces. Basically though, it can be thought of as a pretty CheckBox:</p><pre><code>&lt;Controls:ToggleSwitch Header=&quot;WiFi rest state&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/09_toggleswitch.png" alt=""></p><p>You can bind to/set IsChecked to switch between the two states. You can change the on and off labels by setting</p><pre><code>&lt;Controls:ToggleSwitch OnLabel=&quot;Yes&quot; OffLabel=&quot;No&quot; /&gt;</code></pre><h2 id="TransitioningContentControl"><a href="#TransitioningContentControl" class="headerlink" title="TransitioningContentControl"></a>TransitioningContentControl</h2><p>Taken from Silverlight (specifically this port), TransitioningContentControl is great for switching content smoothly around. At it’s core, TransitioningContentControl is a ContentControl, so only one child element can be displayed at a time. When you change the content, an animation is played switching the two.</p><pre><code>&lt;Controls:TransitioningContentControl x:Name=&quot;transitioning&quot; Width=&quot;150&quot; Height=&quot;50&quot; Transition=&quot;DownTransition&quot; /&gt;</code></pre><p>Built in there are several transitions:</p><ul><li>Default</li><li>Down</li><li>Up</li><li>Right</li><li>Left</li><li>RightReplace</li><li>LeftReplace</li><li>Custom</li></ul><h2 id="StatusBar"><a href="#StatusBar" class="headerlink" title="StatusBar"></a>StatusBar</h2><pre><code>&lt;StatusBar Grid.Row=&quot;2&quot;&gt;            &lt;StatusBarItem&gt;MahApps.Metro DEMO Application&lt;/StatusBarItem&gt;            &lt;Separator Style=&quot;{StaticResource MetroStatusBarSeparator}&quot; /&gt;            &lt;StatusBarItem&gt;Selected Tab:&lt;/StatusBarItem&gt;            &lt;StatusBarItem Content=&quot;{Binding ElementName=MainTabControl, Path=SelectedItem.Header, Mode=OneWay}&quot; /&gt;        &lt;/StatusBar&gt;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/MahApps/MahApps.Metro.IconPacks" target="_blank" rel="noopener">MahApps.Metro.IconPacks</a></li><li><a href="http://mahapps.com/guides/icons-and-resources.html" target="_blank" rel="noopener">MahApps.Metro.Resources</a> </li><li>NHotkey</li><li>NHotkey.Wpf</li></ul><p>参考：</p><ul><li><a href="http://rehansaeed.com/wpf-metro-part1-modern-ui-for-wpf/" target="_blank" rel="noopener">http://rehansaeed.com/wpf-metro-part1-modern-ui-for-wpf/</a></li><li><a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener">https://github.com/MahApps/MahApps.Metro</a></li><li><a href="http://mahapps.com/guides/quick-start.html" target="_blank" rel="noopener">http://mahapps.com/guides/quick-start.html</a></li><li><a href="http://www.wxzzz.com/1202.html" target="_blank" rel="noopener">http://www.wxzzz.com/1202.html</a></li><li><a href="http://mahapps.com/guides/icons-and-resources.html" target="_blank" rel="noopener">http://mahapps.com/guides/icons-and-resources.html</a></li><li><a href="http://mahapps.com/guides/styles.html" target="_blank" rel="noopener">http://mahapps.com/guides/styles.html</a></li><li><a href="http://mahapps.com/controls/" target="_blank" rel="noopener">http://mahapps.com/controls/</a></li><li><a href="https://github.com/MahApps/MahApps.Metro.IconPacks" target="_blank" rel="noopener">https://github.com/MahApps/MahApps.Metro.IconPacks</a></li><li><a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></li><li><a href="https://materialdesignicons.com/" target="_blank" rel="noopener">https://materialdesignicons.com/</a></li><li><a href="http://www.wxzzz.com/tag/mahapps" title="http://www.wxzzz.com/tag/mahapps" target="_blank" rel="noopener">http://www.wxzzz.com/tag/mahapps</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MahApps-Metro使用&quot;&gt;&lt;a href=&quot;#MahApps-Metro使用&quot; class=&quot;headerlink&quot; title=&quot;MahApps.Metro使用&quot;&gt;&lt;/a&gt;MahApps.Metro使用&lt;/h1&gt;&lt;h2 id=&quot;下载MahApps-Met
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="MahApps.Metro" scheme="https://caojingyou.github.io/tags/MahApps-Metro/"/>
    
  </entry>
  
  <entry>
    <title>获得GetLastError()内容</title>
    <link href="https://caojingyou.github.io/2017/06/15/%E8%8E%B7%E5%BE%97GetLastError()%E5%86%85%E5%AE%B9/"/>
    <id>https://caojingyou.github.io/2017/06/15/获得GetLastError()内容/</id>
    <published>2017-06-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.045Z</updated>
    
    <content type="html"><![CDATA[<pre><code>GetStrError(CString&amp; strError, const DWORD&amp; dwErr){    LPVOID lpMsgBuf;    //DWORD dw = GetLastError();    FormatMessage (        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,        NULL,        dwErr,        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPTSTR) &amp;lpMsgBuf,        0, NULL );    strError = (char *)lpMsgBuf;    LocalFree(lpMsgBuf);}</code></pre><p>个人写的：</p><pre><code>GetStrError(CString &amp;strError, const DWORD &amp;dwErr){    LPVOID lpMsgBuf;    //DWORD dw = GetLastError();    FormatMessage (        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,        NULL,        dwErr,        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPTSTR) &amp;lpMsgBuf,        0, NULL );    strError = (char *)lpMsgBuf;    LocalFree(lpMsgBuf);}MyAfxMessageBox(CString strError){    CString str;    DWORD dwErr = GetLastError();    GetStrError(str, dwErr);    CString strTemp;    strTemp.Format(_T(&quot;程序运行错误!%s\r\n错误码:%lu\r\n错误内容:%s&quot;), strError, dwErr, str);    AfxMessageBox(strTemp);}try{    AfxMessageBox(strMsg, MB_ICONINFORMATION);}catch (CMemoryException *e){    MyAfxMessageBox(_T(&quot;CMemoryException&quot;));}catch (CFileException *e){    MyAfxMessageBox(_T(&quot;CFileException&quot;));}catch (CException *e){    MyAfxMessageBox(_T(&quot;CException&quot;));}catch(...){    MyAfxMessageBox(_T(&quot;其他&quot;));}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;GetStrError(CString&amp;amp; strError, const DWORD&amp;amp; dwErr)
{
    LPVOID lpMsgBuf;
    //DWORD dw = GetLastError();
    FormatMess
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="GetLastError" scheme="https://caojingyou.github.io/tags/GetLastError/"/>
    
  </entry>
  
  <entry>
    <title>C++字符串分割</title>
    <link href="https://caojingyou.github.io/2017/06/01/C++%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/"/>
    <id>https://caojingyou.github.io/2017/06/01/C++字符分割/</id>
    <published>2017-06-01T08:03:00.000Z</published>
    <updated>2018-04-02T10:14:45.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AfxExtractSubString"><a href="#AfxExtractSubString" class="headerlink" title="AfxExtractSubString"></a>AfxExtractSubString</h1><p>表头: <afxwin.h></afxwin.h></p><p>BOOL AFXAPI AfxExtractSubString ( CString&amp; rString, LPCTSTR lpszFullString, int iSubString, TCHAR chSep = ‘\n’);</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>rString 对CString将得到一个单独的子字符串的对象。</p><p>lpszFullString 字符串包含字符串的全文提取自。</p><p>iSubString 提取的子字符串的从零开始的索引从lpszFullString。</p><p>chSep 使用的分隔符分隔子字符串，默认的是’\n’。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>TRUE ，如果函数成功提取了该子字符串中提供的索引;否则， FALSE。</p><h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><pre><code>// 使用AfxExtractSubString分割字符串void CSplitString::SplitString1(){    std::vector&lt;long&gt; arrPic;    CString strContent = _T(&quot;1,2,3,4,5&quot;);    CString strTemp;    int iPos = 0;    while (AfxExtractSubString(strTemp, strContent, iPos, &apos;,&apos;))    {        iPos++;        arrPic.push_back(_wtol(strTemp));    }}</code></pre><h1 id="STL-find-first-of"><a href="#STL-find-first-of" class="headerlink" title="STL find_first_of"></a>STL find_first_of</h1><pre><code>// 利用STL自己实现字符串分割void CSplitString::SplitString2(){    const std::string s(&quot;1,2,3,4,5;6;7;8;9&quot;);    std::vector&lt;std::string&gt; v;    const std::string c(&quot;,;&quot;);//多个分隔符    std::string::size_type pos1, pos2;    pos2 = s.find_first_of(c);    pos1 = 0;    while (std::string::npos != pos2)    {        v.push_back(s.substr(pos1, pos2 - pos1));        pos1 = pos2 + 1;        pos2 = s.find_first_of(c, pos1);    }    if (pos1 != s.length())        v.push_back(s.substr(pos1));}</code></pre><h1 id="tcstok-s"><a href="#tcstok-s" class="headerlink" title="_tcstok_s"></a>_tcstok_s</h1><pre><code>// 使用C的_tcstok分割字符串void CSplitString::SplitString3(){    CString str = _T(&quot;a,b*c,d&quot;);    TCHAR seps[] = _T(&quot;,*&quot;);//可按多个字符来分割    TCHAR *next_token1 = NULL;    TCHAR* token = _tcstok_s((LPTSTR)(LPCTSTR)str, seps,&amp;next_token1);    while (token != NULL)    {        TRACE(&quot;\r\nstr=%s  token=%s\r\n&quot;, str, token);        token = _tcstok_s(NULL, seps, &amp;next_token1);    }}</code></pre><p><a href="http://www.qiezichaodan.com/mfc_cstring_split/" target="_blank" rel="noopener">http://www.qiezichaodan.com/mfc_cstring_split/</a></p><p><a href="http://blog.csdn.net/xjw532881071/article/details/49154911" target="_blank" rel="noopener">http://blog.csdn.net/xjw532881071/article/details/49154911</a></p><p><a href="http://www.cnblogs.com/happykoukou/p/5427268.html" target="_blank" rel="noopener">http://www.cnblogs.com/happykoukou/p/5427268.html</a></p><h1 id="词汇分割器库-Boost-Tokenizer"><a href="#词汇分割器库-Boost-Tokenizer" class="headerlink" title="词汇分割器库 Boost.Tokenizer"></a>词汇分割器库 Boost.Tokenizer</h1><pre><code>#include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;, boost::keep_empty_tokens);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } </code></pre><h1 id="分词Boost-regex"><a href="#分词Boost-regex" class="headerlink" title="分词Boost.regex"></a>分词Boost.regex</h1><pre><code>void TestToken(){    using namespace std;    using namespace boost;    string str(&quot;tengxun@qq.com, aa@tt.com, bb@qq.com&quot;);    regex reg(&quot;\\w+&quot;);    sregex_token_iterator pos(str.begin(), str.end(), reg);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //如果最后一个参数args为-1，则把匹配到的字符串视为分隔符    regex split_reg(&quot;,&quot;);    pos = sregex_token_iterator(str.begin(), str.end(), split_reg, -1);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //如果最后一个参数args为正数，则返回匹配结果的第args个子串    regex split_sub_reg(&quot;(\\w*)@(\\w*).(\\w*)&quot;);    pos = sregex_token_iterator(str.begin(), str.end(), split_sub_reg, 1);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //匹配并指定输出顺序    //从下面字符串中提取日期，并转换成 年月日 的顺序输出    std::string input(&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;);    regex re(&quot;(\\d{2})/(\\d{2})/(\\d{4})&quot;); // find a date    int const sub_matches[] = { 3, 1, 2 }; // year，month， day    sregex_token_iterator begin(input.begin(), input.end(), re, sub_matches), end;    // write all the words to std::cout    std::ostream_iterator&lt; std::string &gt; out_iter(std::cout, &quot;\n&quot;);    std::copy(begin, end, out_iter);}</code></pre><p>参考：</p><ul><li><a href="http://www.cplusplus.com/faq/sequences/strings/split/" target="_blank" rel="noopener">http://www.cplusplus.com/faq/sequences/strings/split/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AfxExtractSubString&quot;&gt;&lt;a href=&quot;#AfxExtractSubString&quot; class=&quot;headerlink&quot; title=&quot;AfxExtractSubString&quot;&gt;&lt;/a&gt;AfxExtractSubString&lt;/h1&gt;&lt;p&gt;表头
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="字符串" scheme="https://caojingyou.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>GUID</title>
    <link href="https://caojingyou.github.io/2017/05/15/GUID/"/>
    <id>https://caojingyou.github.io/2017/05/15/GUID/</id>
    <published>2017-05-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><pre><code>CString CreateNewUid(){    CoInitialize(NULL);    AUTH_TRACE_STACK();    GUID guid;    HRESULT hr = CoCreateGuid(&amp;guid);    if (FAILED(hr))    {        AUTH_LOGMESSAGE1(_T(&quot;Create Guid Failed!&quot;));    }#ifdef _UNICODE    unsigned short* buf = NULL;#else    unsigned char* buf = NULL;#endif    UuidToString((UUID*)&amp;guid, &amp;buf);        CString strUID((LPCTSTR)buf);    RpcStringFree(&amp;buf);    CoUninitialize();    return strUID;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUID&quot;&gt;&lt;a href=&quot;#GUID&quot; class=&quot;headerlink&quot; title=&quot;GUID&quot;&gt;&lt;/a&gt;GUID&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;CString CreateNewUid()
{
    CoInitialize(NULL);

    
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="GUID" scheme="https://caojingyou.github.io/tags/GUID/"/>
    
  </entry>
  
  <entry>
    <title>ImageMagick</title>
    <link href="https://caojingyou.github.io/2017/04/15/ImageMagick/"/>
    <id>https://caojingyou.github.io/2017/04/15/ImageMagick/</id>
    <published>2017-04-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unix-源码安装-Windows-源码安装"><a href="#Unix-源码安装-Windows-源码安装" class="headerlink" title="[ Unix 源码安装 | Windows 源码安装 ]"></a>[ Unix 源码安装 | Windows 源码安装 ]</h1><p>首先检查一下电脑里已经安装的ImageMagick版本，输入：</p><pre><code>convert -version</code></pre><p>除非你想要把对另外的图像格式的支持或升级一个较新的版本，否则你可能不需要ImageMagick的源码安装。 你也可以安装预先编译二进位版本。然而，如果你仍然想要从源码安装，请选择一个平台，Unix 或 Windows。<br>在源码安装之前，你可能要回顾ImageMagick的最近变化。</p><h2 id="Unix-源码安装"><a href="#Unix-源码安装" class="headerlink" title="Unix 源码安装"></a>Unix 源码安装</h2><p>ImageMagick 在多种操作系统 Unix 和包括 Linux，Solaris，FreeBSD，Mac 操作系统 X 和其它的类 Unix 一样的操作系统上建立。 它需要一个编译器，几乎所有现代的 Unix 系统都会有一个。 可以从 ftp.imagemagick.org 或它的镜像网站下载 ImageMagick.tar.gz 并用这个指令解压缩:</p><pre><code>gunzip -c ImageMagick.tar.gz | tar xvf -</code></pre><p>然后配置编译ImageMagick:</p><pre><code>cd ImageMagick-6.?.?</code></pre><p>./configure<br>make</p><p>如果配置编译的ImageMagick没有出现错误，要把它安装到系统里，你需要使用管理员权限，输入：</p><pre><code>make install</code></pre><p>最后，可以测试一下ImageMagick的工作效果：</p><pre><code>/usr/local/bin/convert logo: logo.gif</code></pre><p>恭喜你，你已经有ImageMagick的工作环境了，你可以使用ImageMagick加入新图片，生成缩略图，组合图片……<br>还可以使用其它程序接口 C, C++, Perl, 和其它程序。<br>上述的指导将会使很多的 ImageMagick 使用者满意，但是我们怀疑一些将会有另外的问题或问题考虑。<br>如果 ImageMagick 无法配置或编译，或如果你没有管理员权限或没有将ImageMagick安装到默认目录<br>请点这里了解更多……</p><h2 id="Windows-源码安装"><a href="#Windows-源码安装" class="headerlink" title="Windows 源码安装"></a>Windows 源码安装</h2><p>Windows系统下ImageMagick源码安装需要Microsoft Visual Studio IDE。<br>有的用户也成功的用Borland C++编译。如果你没有编译器，你可以安装二进位发布版本</p><p>从ftp.imagemagick.org或它的镜像网站下载 ImageMagick-windows.zip 文件，然后用 WinZip 解压缩。</p><p>然后运行你的Visual Studio IDE选择Open-&gt;Project从ImageMagick-6.?.?/VisualMagick/configure文件夹里选择configure.dsp文件 Build-&gt;Build编译并执行。</p><p>可以通过以下方法获取图片信息</p><h2 id="安装ImageMagick便携版本"><a href="#安装ImageMagick便携版本" class="headerlink" title="安装ImageMagick便携版本"></a>安装ImageMagick便携版本</h2><h1 id="调用命令行程序并获取返回信息"><a href="#调用命令行程序并获取返回信息" class="headerlink" title="调用命令行程序并获取返回信息"></a>调用命令行程序并获取返回信息</h1><pre><code>CString ExeCmd(CString pszCmd){    //创建匿名管道    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};    HANDLE hRead, hWrite;    if (!CreatePipe(&amp;hRead, &amp;hWrite, &amp;sa, 0))    {        return _T(&quot;&quot;);    }    //设置命令行进程启动信息(以隐藏方式启动命令并定位其输出到hWrite)    STARTUPINFO si = {sizeof(STARTUPINFO)};    GetStartupInfo(&amp;si);    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;    si.wShowWindow = SW_HIDE;    si.hStdError = hWrite;    si.hStdOutput = hWrite;    //启动命令行    PROCESS_INFORMATION pi;    if (!CreateProcess(NULL, (LPWSTR)(LPCWSTR)pszCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &amp;si, &amp;pi))    {        return _T(&quot;&quot;);    }    //立即关闭hWrite    CloseHandle(hWrite);    //读取命令行返回值    char buff[1024] = {0};    DWORD dwRead = 0;    while (ReadFile(hRead, buff, 1024, &amp;dwRead, NULL))    {    }    CString strRet(buff);    CloseHandle(hRead);    return strRet;}</code></pre><p>使用：</p><pre><code>ExeCmd(_T(&quot;ping baidu.com&quot;));ExeCmd(_T(&quot;identify -format &quot;%[colorspace]&quot; E:\\P70306-163226.jpg&quot;));</code></pre><h2 id="安装ImageMagickCOM-对象"><a href="#安装ImageMagickCOM-对象" class="headerlink" title="安装ImageMagickCOM+对象"></a>安装ImageMagickCOM+对象</h2><p>C++程序员应该看一下MagickCMD.cpp命令行实用工具的示例调用该对象的C++。对象变量列表的大小需要BSTR的模仿命令行argc，argv风格的COM组件的调用约定，这是更复杂的C++中然后在VB或VBS。</p><pre><code>#include &lt;iostream&gt;#include &lt;atlbase.h&gt;#include &lt;atlsafe.h&gt;#import &quot;ImageMagickObject.tlb&quot; no_namespaceusing namespace std;typedef enum{  cmdUnknown,  cmdCompare,  cmdComposite,  cmdConvert,  cmdIdentify,  cmdMogrify,  cmdMontage,  cmdStream} CommandType;static struct  Commands  {    char      *name;    CommandType      code;  } Commands[] =  {    { &quot;&quot;,          cmdUnknown   },    { &quot;compare&quot;,   cmdCompare   },    { &quot;composite&quot;, cmdComposite },    { &quot;convert&quot;,   cmdConvert   },    { &quot;identify&quot;,  cmdIdentify  },    { &quot;mogrify&quot;,   cmdMogrify   },    { &quot;montage&quot;,   cmdMontage   },    { &quot;stream&quot;,    cmdStream   }  };int main(int argc, char* argv[]){  int    index,    status = 0;  char    *name;  CommandType    code = cmdUnknown;  // We must have at least a command, input, and output  if (argc &lt; 4)    return 0;  index = 1;  while ((name = Commands[index].name))  {    if (stricmp(name,argv[1]) == 0)    {      code = Commands[index].code;      break;    }    index++;  }  if (code == cmdUnknown)    return 0;  CoInitialize(NULL);  try  {    CComVariant      result;    SAFEARRAY      **ppsa = (SAFEARRAY**) NULL;    IMagickImagePtr pImageProc(__uuidof(MagickImage));    if (pImageProc == NULL)      status = 1;    else    {      {        // Define the array bound structure        CComSafeArrayBound bound[1];        bound[0].SetCount(argc-2);        bound[0].SetLowerBound(0);        CComSafeArray&lt;VARIANT&gt; args(bound);        if( !args )          status = 2;        else        {          for(index = 2; index &lt; argc; ++index)          {            CComVariant vt(argv[index]);            HRESULT hr = vt.Detach(&amp;args[index-2]);          }          switch(code)          {            case cmdCompare:              result = pImageProc-&gt;Compare(args.GetSafeArrayPtr());              break;            case cmdComposite:              result = pImageProc-&gt;Composite(args.GetSafeArrayPtr());              break;            case cmdConvert:              result = pImageProc-&gt;Convert(args.GetSafeArrayPtr());              break;            case cmdIdentify:              result = pImageProc-&gt;Identify(args.GetSafeArrayPtr());              break;            case cmdMogrify:              result = pImageProc-&gt;Mogrify(args.GetSafeArrayPtr());              break;            case cmdMontage:              result = pImageProc-&gt;Montage(args.GetSafeArrayPtr());              break;            case cmdStream:              result = pImageProc-&gt;Stream(args.GetSafeArrayPtr());              break;          }          pImageProc.Release();        }      }    }  }  catch(_com_error ex)  {    HRESULT      res = ex.Error();      _bstr_t      desc = ex.Description();      printf(&quot;Error %s (0x%08x)\n&quot;,(char *)desc,res);    status = 4;  }  CoUninitialize();  return status;}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">http://www.imagemagick.org/script/index.php</a></li><li><a href="http://www.imagemagick.com.cn/" target="_blank" rel="noopener">http://www.imagemagick.com.cn/</a></li><li><a href="http://www.imagemagick.org/script/download.php" target="_blank" rel="noopener">http://www.imagemagick.org/script/download.php</a></li><li><a href="https://github.com/ImageMagick/ImageMagick/tree/master/Magick%2B%2B" target="_blank" rel="noopener">https://github.com/ImageMagick/ImageMagick/tree/master/Magick%2B%2B</a></li><li><a href="https://legacy.imagemagick.org/script/index.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/index.php</a></li><li><a href="https://www.imagemagick.org/Usage/" target="_blank" rel="noopener">https://www.imagemagick.org/Usage/</a></li><li><a href="https://www.imagemagick.org/Usage/color_basics/" target="_blank" rel="noopener">https://www.imagemagick.org/Usage/color_basics/</a></li><li><a href="ftp://ftp.imagemagick.org/pub/ImageMagick/windows/" target="_blank" rel="noopener">ftp://ftp.imagemagick.org/pub/ImageMagick/windows/</a></li><li><a href="https://legacy.imagemagick.org/script/install-source.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/install-source.php</a></li><li><a href="https://legacy.imagemagick.org/script/advanced-windows-installation.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/advanced-windows-installation.php</a></li><li><a href="https://legacy.imagemagick.org/script/download.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/download.php</a></li><li><a href="https://legacy.imagemagick.org/script/ImageMagickObject.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/ImageMagickObject.php</a></li><li><a href="https://legacy.imagemagick.org/script/ImageMagickObject.php" target="_blank" rel="noopener">http://imagemagick.org/Magick++/</a></li><li><a href="https://www.imagemagick.org/discourse-server/" target="_blank" rel="noopener">https://www.imagemagick.org/discourse-server/</a></li><li><a href="http://dahua2.blog.163.com/blog/static/1748435142015317633489/" target="_blank" rel="noopener">http://dahua2.blog.163.com/blog/static/1748435142015317633489/</a></li><li><a href="http://www.tuicool.com/articles/NvYfi2" target="_blank" rel="noopener">http://www.tuicool.com/articles/NvYfi2</a></li><li><a href="http://www.tuicool.com/articles/6fyI7z" target="_blank" rel="noopener">http://www.tuicool.com/articles/6fyI7z</a></li><li><a href="http://www.tuicool.com/articles/NN3M7fv" target="_blank" rel="noopener">http://www.tuicool.com/articles/NN3M7fv</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unix-源码安装-Windows-源码安装&quot;&gt;&lt;a href=&quot;#Unix-源码安装-Windows-源码安装&quot; class=&quot;headerlink&quot; title=&quot;[ Unix 源码安装 | Windows 源码安装 ]&quot;&gt;&lt;/a&gt;[ Unix 源码安装 | 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="图像" scheme="https://caojingyou.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="ImageMagick" scheme="https://caojingyou.github.io/tags/ImageMagick/"/>
    
  </entry>
  
  <entry>
    <title>C++进程间通信</title>
    <link href="https://caojingyou.github.io/2017/04/01/C++%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2017/04/01/C++进程间通信/</id>
    <published>2017-04-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-进程间通信"><a href="#C-进程间通信" class="headerlink" title="C++进程间通信"></a>C++进程间通信</h1><p>进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽</p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><pre><code>//设置剪切板内容CString str;this-&gt;GetDlgItemText(IDC_EDIT1, str);OpenClipboard();//打开剪贴板查看,并防止其他应用程序修改剪贴板的内容.EmptyClipboard();//EmptyClipboard Function该函数清空剪切板并释放剪切板内数据的句柄。函数在之后会将剪切板的所有权指派给当前打开剪切板的窗口。HANDLE hclip = GlobalAlloc(GMEM_MOVEABLE, str.GetLength() + 1);char *pBuf = (char *)GlobalLock(hclip);//WideCharToMultiByte()//字形转换strcpy(pBuf, str.GetBuffer());//memcpy(pBuf, str.GetBuffer(), GetLength()+2);GlobalLock(hclip);SetClipboardData(CF_TEXT, hclip);//SetClipboardData是把指定数据按照指定格式放入剪切板中CloseClipboard();//关闭剪贴板,这使其他窗口或程序能访问剪贴板。//获得剪切板内容OpenClipboard();if (IsClipboardFormatAvailable(CF_TEXT))//是以NULL结尾的ASCII字符的文本格式,则该函数返回值为true,否则为false。{    HANDLE hclip;    hclip = GetClipboardData(CF_TEXT);//用来打开剪贴板并获取剪贴板内容。    char *pBuf =  (char *)GlobalLock(hclip);    GlobalUnlock(hclip);    CString STR;    SetDlgItemText(IDC_EDIT1, pBuf);}CloseClipboard();//参考：//http://bbs.kechuang.org/t/72605//http://www.cnblogs.com/BoyXiao/archive/2010/12/25/1916677.html</code></pre><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><pre><code>//父进程实现//创建匿名管道SECURITY_ATTRIBUTES sa;sa.bInheritHandle = TRUE;sa.lpSecurityDescriptor = NULL;sa.nLength = sizeof(SECURITY_ATTRIBUTES);if (!CreatePipe(&amp;m_hRead, &amp;m_hWrite, &amp;sa, 0)){    AfxMessageBox(_T(&quot;create pipe error&quot;));}//子进程的创建STARTUPINFO sui;PROCESS_INFORMATION pi;sui.cb = sizeof(STARTUPINFO);ZeroMemory(&amp;sui, sizeof(STARTUPINFO));sui.dwFlags = STARTF_USESTDHANDLES;sui.hStdInput = m_hRead;sui.hStdOutput = m_hWrite;sui.hStdError = GetStdHandle(STD_ERROR_HANDLE);if (!CreateProcess(_T(&quot;../debug/child.exe&quot;), NULL , NULL, NULL, TRUE, 0, NULL, NULL, &amp;sui, &amp;pi )){    AfxMessageBox(_T(&quot;创建子进程错误&quot;));}//关闭进程 线程计数器if (pi.hThread){    CloseHandle(pi.hThread);}if (pi.hProcess){    CloseHandle(pi.hProcess);}//发送数据char buf[] = &quot;this is pipe server&quot;;DWORD dwWrite = 0;if (!WriteFile(m_hWrite, buf, strlen(buf) + 1, &amp;dwWrite, NULL)){    AfxMessageBox(_T(&quot;write error parent&quot;));}//接收数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hRead, buf, sizeof(buf), &amp;dwRead, NULL );//子进程实现//获取继承自父进程的匿名管道读写句柄m_hRead = GetStdHandle(STD_INPUT_HANDLE);m_hWrite = GetStdHandle(STD_OUTPUT_HANDLE);//写入数据char buf[] = &quot;this is pipe child&quot;;DWORD dwWrite = 0;if (!WriteFile(m_hWrite, buf, strlen(buf) + 1, &amp;dwWrite, NULL)){    AfxMessageBox(_T(&quot;write error child&quot;));}//读取数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hRead, buf, sizeof(buf), &amp;dwRead, NULL );//参考http://www.cnblogs.com/BoyXiao/archive/2011/01/01/1923828.html</code></pre><h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><pre><code>//服务端//创建命名管m_hPipe = CreateNamedPipe(_T(&quot;\\\\.\\pipe\\mypipe&quot;), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, /*OVERLAPPED是为了满足异步实现非阻塞的工能，当连接上用事件通知*/                          0, 1, 1024, 1024, 0, NULL);if (m_hPipe == INVALID_HANDLE_VALUE){    return;}//创建事件HANDLE hEvent;hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);if (!hEvent){    MessageBox(_T(&quot;创建事件对象失败！&quot;));    CloseHandle(m_hPipe);    m_hPipe = NULL;    return;}OVERLAPPED ovlap;ZeroMemory(&amp;ovlap, sizeof(OVERLAPPED));ovlap.hEvent = hEvent;if (!ConnectNamedPipe(m_hPipe, &amp;ovlap)){    if (ERROR_IO_PENDING != GetLastError())    {        MessageBox(_T(&quot;等待客户连接失败！&quot;));        CloseHandle(m_hPipe);        CloseHandle(hEvent);        m_hPipe = NULL;        return;    }}//重叠操作if (WAIT_FAILED == WaitForSingleObject(hEvent, INFINITE)){    MessageBox(_T(&quot;等待对象失败！&quot;));    CloseHandle(m_hPipe);    CloseHandle(hEvent);    m_hPipe = NULL;    return;}CloseHandle(hEvent);//写数据char buf[] = &quot;this is named pipe server&quot;;DWORD dwWrite = 0;WriteFile(m_hPipe, buf, strlen(buf) + 1, &amp;dwWrite, NULL);//读数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hPipe, buf, 128, &amp;dwRead, NULL);//客户端//连接命名管道if (!WaitNamedPipe(_T(&quot;\\\\.\\pipe\\mypipe&quot;), NMPWAIT_WAIT_FOREVER)){    return;}m_hPipe = CreateFile(_T(&quot;\\\\.\\pipe\\mypipe&quot;), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//写入数据char buf[] = &quot;this is named pipe client&quot;;DWORD dwWrite = 0;WriteFile(m_hPipe, buf, strlen(buf) + 1, &amp;dwWrite, NULL);//读取数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hPipe, buf, 128, &amp;dwRead, NULL);//参考//http://www.cnblogs.com/BoyXiao/archive/2011/01/02/1924188.html</code></pre><h2 id="邮槽"><a href="#邮槽" class="headerlink" title="邮槽"></a>邮槽</h2><pre><code>//服务端HANDLE hMail = CreateMailslot(_T(&quot;\\\\.\\mailslot\\myslot&quot;), 424, MAILSLOT_WAIT_FOREVER, NULL);if (hMail == INVALID_HANDLE_VALUE){    int nRes = GetLastError();    CString str;    str.Format(_T(&quot;%s&quot;), nRes);    AfxMessageBox(str);    return;}char buf[424] = {0};DWORD dwSize = 0;ReadFile(hMail, buf, 424, &amp;dwSize, NULL);CString str;str = buf;MessageBox(str);//客户端HANDLE hMailslot;hMailslot = CreateFile(_T(&quot;\\\\.\\mailslot\\myslot&quot;), GENERIC_WRITE,                       FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);if (INVALID_HANDLE_VALUE == hMailslot){    MessageBox(_T(&quot;打开邮槽失败！&quot;));    return;}char buf[] = &quot;this is mail slot client&quot;;DWORD dwSize = 0;if (!WriteFile(hMailslot, buf, strlen(buf) + 1, &amp;dwSize, NULL)){    MessageBox(_T(&quot;写入邮槽失败！&quot;));}//http://blog.csdn.net/kylin_p/article/details/5146797//http://www.cnblogs.com/BoyXiao/archive/2010/12/31/1923462.html//http://www.cnblogs.com/jzincnblogs/p/5192654.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-进程间通信&quot;&gt;&lt;a href=&quot;#C-进程间通信&quot; class=&quot;headerlink&quot; title=&quot;C++进程间通信&quot;&gt;&lt;/a&gt;C++进程间通信&lt;/h1&gt;&lt;p&gt;进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽&lt;/p&gt;
&lt;h2 id=&quot;剪切板&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#与C++相互发送消息</title>
    <link href="https://caojingyou.github.io/2017/03/01/C++%20%E6%9C%80%E5%B0%8F%E5%8C%96%E5%88%B0%E6%89%98%E7%9B%98(YHCAO--yhcao--2017-04-10-09,18,14)/"/>
    <id>https://caojingyou.github.io/2017/03/01/C++ 最小化到托盘(YHCAO--yhcao--2017-04-10-09,18,14)/</id>
    <published>2017-03-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-最小化到托盘"><a href="#C-最小化到托盘" class="headerlink" title="C++ 最小化到托盘"></a>C++ 最小化到托盘</h1><pre><code>#define  WM_SHOWTASK (WM_USER + 1)void CTestDlg::OnSysCommand(UINT nID, LPARAM lParam){    if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)    {        CAboutDlg dlgAbout;        dlgAbout.DoModal();    }    else    {        //增加关闭时最小化到托盘的函数        if (nID == SC_CLOSE) //SC_MINIMIZE        {            ToTray();            return;        }        CDialog::OnSysCommand(nID, lParam);    }}BEGIN_MESSAGE_MAP(CTestDlg, CDialog)    ON_MESSAGE(WM_SHOWTASK, OnShowTask)    //}}AFX_MSG_MAPEND_MESSAGE_MAP()//在托盘区添加图标 最小化到托盘函数void ToTray(void);void CTestDlg::ToTray(void){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条    Shell_NotifyIcon(NIM_ADD, &amp;nid);//在托盘区添加图标    ShowWindow(SW_HIDE);//隐藏主窗口}//恢复界面函数afx_msg LRESULT OnShowTask(WPARAM wParam, LPARAM lParam);//托盘事件LRESULT CTestDlg::OnShowTask(WPARAM wParam, LPARAM lParam){    if (wParam != IDR_MAINFRAME)    {        return 1;    }    switch(lParam)    {    case WM_RBUTTONUP://右键起来时弹出快捷菜单，这里只有一个关闭    {        LPPOINT lpoint = new tagPOINT;        ::GetCursorPos(lpoint);//得到鼠标位置        CMenu menu;        menu.CreatePopupMenu();//声明一个弹出式菜单        //增加菜单项“关闭”，点击则发送消息WM_DESTROY给主窗口（已        //隐藏），将程序结束。        menu.AppendMenu(MF_STRING, WM_DESTROY, _T(&quot;退出&quot;));        //确定弹出式菜单的位置        menu.TrackPopupMenu(TPM_LEFTALIGN, lpoint-&gt;x, lpoint-&gt;y, this);        //资源回收        HMENU hmenu = menu.Detach();        menu.DestroyMenu();        delete lpoint;    }    break;    case WM_LBUTTONDBLCLK://双击左键的处理    {        this-&gt;ShowWindow(SW_SHOW);//简单的显示主窗口        this-&gt;ShowWindow(SW_RESTORE);        DeleteTray();    }    break;    default:        break;    }    return 0;}//删除托盘中图标void DeleteTray();void CTestlDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}//退出程序需时需要DeleteTray();void CTestDlg::OnDestroy(){    CDialog::OnDestroy();    // TODO: 在此处添加消息处理程序代码    DeleteTray();}//修改风格使得他不在任务栏显示int CTestDlg::OnCreate(LPCREATESTRUCT lpCreateStruct){    if (CDialog::OnCreate(lpCreateStruct) == -1)        return -1;    // TODO:  在此添加您专用的创建代码    //修改风格使得他不在任务栏显示    ModifyStyleEx(WS_EX_APPWINDOW, WS_EX_TOOLWINDOW);    return 0;}</code></pre><p>DeleteTray改为：</p><pre><code>void CTestDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON /*| NIF_MESSAGE | NIF_TIP*/;    //nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    //nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    //wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}</code></pre><p>否则会出现程序退出后，托盘图标还在的情况，鼠标移动到图标上后，图标一闪然后消失的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-最小化到托盘&quot;&gt;&lt;a href=&quot;#C-最小化到托盘&quot; class=&quot;headerlink&quot; title=&quot;C++ 最小化到托盘&quot;&gt;&lt;/a&gt;C++ 最小化到托盘&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#define  WM_SHOWTASK (WM_USER + 1)
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title> C++ 最小化到托盘</title>
    <link href="https://caojingyou.github.io/2017/03/01/C++%20%E6%9C%80%E5%B0%8F%E5%8C%96%E5%88%B0%E6%89%98%E7%9B%98/"/>
    <id>https://caojingyou.github.io/2017/03/01/C++ 最小化到托盘/</id>
    <published>2017-03-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-最小化到托盘"><a href="#C-最小化到托盘" class="headerlink" title="C++ 最小化到托盘"></a>C++ 最小化到托盘</h1><pre><code>#define  WM_SHOWTASK (WM_USER + 1)void CTestDlg::OnSysCommand(UINT nID, LPARAM lParam){    if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)    {        CAboutDlg dlgAbout;        dlgAbout.DoModal();    }    else    {        //增加关闭时最小化到托盘的函数        if (nID == SC_CLOSE) //SC_MINIMIZE        {            ToTray();            return;        }        CDialog::OnSysCommand(nID, lParam);    }}BEGIN_MESSAGE_MAP(CTestDlg, CDialog)    ON_MESSAGE(WM_SHOWTASK, OnShowTask)    //}}AFX_MSG_MAPEND_MESSAGE_MAP()//在托盘区添加图标 最小化到托盘函数void ToTray(void);void CTestDlg::ToTray(void){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条    Shell_NotifyIcon(NIM_ADD, &amp;nid);//在托盘区添加图标    ShowWindow(SW_HIDE);//隐藏主窗口}//恢复界面函数afx_msg LRESULT OnShowTask(WPARAM wParam, LPARAM lParam);//托盘事件LRESULT CTestDlg::OnShowTask(WPARAM wParam, LPARAM lParam){    if (wParam != IDR_MAINFRAME)    {        return 1;    }    switch(lParam)    {    case WM_RBUTTONUP://右键起来时弹出快捷菜单，这里只有一个关闭    {        LPPOINT lpoint = new tagPOINT;        ::GetCursorPos(lpoint);//得到鼠标位置        CMenu menu;        menu.CreatePopupMenu();//声明一个弹出式菜单        //增加菜单项“关闭”，点击则发送消息WM_DESTROY给主窗口（已        //隐藏），将程序结束。        menu.AppendMenu(MF_STRING, WM_DESTROY, _T(&quot;退出&quot;));        //确定弹出式菜单的位置        menu.TrackPopupMenu(TPM_LEFTALIGN, lpoint-&gt;x, lpoint-&gt;y, this);        //资源回收        HMENU hmenu = menu.Detach();        menu.DestroyMenu();        delete lpoint;    }    break;    case WM_LBUTTONDBLCLK://双击左键的处理    {        this-&gt;ShowWindow(SW_SHOW);//简单的显示主窗口        this-&gt;ShowWindow(SW_RESTORE);        DeleteTray();    }    break;    default:        break;    }    return 0;}//删除托盘中图标void DeleteTray();void CTestlDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}//退出程序需时需要DeleteTray();void CTestDlg::OnDestroy(){    CDialog::OnDestroy();    // TODO: 在此处添加消息处理程序代码    DeleteTray();}//修改风格使得他不在任务栏显示int CTestDlg::OnCreate(LPCREATESTRUCT lpCreateStruct){    if (CDialog::OnCreate(lpCreateStruct) == -1)        return -1;    // TODO:  在此添加您专用的创建代码    //修改风格使得他不在任务栏显示    ModifyStyleEx(WS_EX_APPWINDOW, WS_EX_TOOLWINDOW);    return 0;}</code></pre><p>DeleteTray改为：</p><pre><code>void CTestDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON /*| NIF_MESSAGE | NIF_TIP*/;    //nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    //nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    //wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}</code></pre><p>否则会出现程序退出后，托盘图标还在的情况，鼠标移动到图标上后，图标一闪然后消失的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-最小化到托盘&quot;&gt;&lt;a href=&quot;#C-最小化到托盘&quot; class=&quot;headerlink&quot; title=&quot;C++ 最小化到托盘&quot;&gt;&lt;/a&gt;C++ 最小化到托盘&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#define  WM_SHOWTASK (WM_USER + 1)
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中判断某一文件或目录是否存在</title>
    <link href="https://caojingyou.github.io/2017/02/15/C++%E4%B8%AD%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%80%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>https://caojingyou.github.io/2017/02/15/C++中判断某一文件或目录是否存在/</id>
    <published>2017-02-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="ifstream"><a href="#ifstream" class="headerlink" title="ifstream"></a>ifstream</h2><p>在C++中，可以利用ifstream文件输入流，当我们直接使用ifstream来创建文件输入流的时候，如果文件不存在则流创建失败。</p><pre><code>ifstream fin(&quot;hello.txt&quot;);if (!fin){   std::cout &lt;&lt; &quot;can not open this file&quot; &lt;&lt; endl;}</code></pre><h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><pre><code>fstream _file;_file.open(FILENAME,ios::in);if(!_file){ cout&lt;&lt;FILENAME&lt;&lt;&quot;没有被创建&quot;;}else{  cout&lt;&lt;FILENAME&lt;&lt;&quot;已经存在&quot;;}</code></pre><h2 id="taccess"><a href="#taccess" class="headerlink" title="_taccess"></a>_taccess</h2><p>Generic-Text Routine Mappings:</p><pre><code>| TCHAR.H Routine    | _UNICODE &amp; _MBCS Not Defined    | _UNICODE Defined    | _UNICODE Defined    || _taccess            | _access                        | _access            |_waccess            |</code></pre><p>返回值</p><pre><code>mode Value     Checks File For00     Existence only02     Write permission04     Read permission06     Read and write permission</code></pre><p>Example:</p><pre><code>#include  &lt;io.h&gt;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;int main( void ){    // Check for existence.    if( (_access( &quot;crt_ACCESS.C&quot;, 0 )) != -1 )    {        printf_s( &quot;File crt_ACCESS.C exists.\n&quot; );        // Check for write permission.        // Assume file is read-only.        if( (_access( &quot;crt_ACCESS.C&quot;, 2 )) == -1 )            printf_s( &quot;File crt_ACCESS.C does not have write permission.\n&quot; );    }}</code></pre><p><a href="https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22TCHAR%2f_TACCESS%22" target="_blank" rel="noopener">https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22TCHAR%2f_TACCESS%22);k(_TACCESS);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true</a>;k(_TACCESS);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true)</p><h2 id="FindFirstFile"><a href="#FindFirstFile" class="headerlink" title="FindFirstFile"></a>FindFirstFile</h2><pre><code>WIN32_FIND_DATA FindFileData;HANDLE hFind;printf (&quot;Target file is %s. &quot;, argv[1]);hFind = FindFirstFile(strPath.c_str(), &amp;FindFileData);if (hFind == INVALID_HANDLE_VALUE){    printf (&quot;Invalid File Handle. Get Last Error reports %d &quot;, GetLastError ());}else{    printf (&quot;The first file found is %s &quot;, FindFileData.cFileName);    FindClose(hFind);}</code></pre><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="FindFirstFile-1"><a href="#FindFirstFile-1" class="headerlink" title="FindFirstFile"></a>FindFirstFile</h2><pre><code>WIN32_FIND_DATA wfd;bool rValue = false;HANDLE hFind = FindFirstFile(strPath.c_str(), &amp;wfd);if ((hFind != INVALID_HANDLE_VALUE) &amp;&amp; (wfd.dwFileAttributes &amp;FILE_ATTRIBUTE_DIRECTORY)){    std::cout &lt;&lt; &quot;this file exists&quot; &lt;&lt; endl;}FindClose(hFind);</code></pre><h2 id="Tstat"><a href="#Tstat" class="headerlink" title="_Tstat"></a>_Tstat</h2><p>在windows中可以使用_stat() 函数。</p><p>声明：int _stat(const char<em> path, struct _stat</em> buffer);</p><p>这个函数使用起来非常方便，如下：</p><pre><code>struct _stat fileStat;if ((_stat(dir.c_str(), &amp;fileStat) == 0) &amp;&amp; (fileStat.st_mode &amp; _S_IFDIR)){    isExist = true;}</code></pre><p>_S_IFDIR 是一个标志位，如果是目录的话，该位就会被系统设置。</p><p>在linux底下也有相对应的函数stat();</p><p>使用方法基本相同：</p><pre><code>struct stat fileStat;if ((stat(dir.c_str(), &amp;fileStat) == 0) &amp;&amp; S_ISDIR(fileStat.st_mode)){    isExist = true;}</code></pre><p>唯一不同的地方我使用了一个macro， S_ISDIR来判断文件是否存在，原理实际都一样的。</p><p><a href="https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22WCHAR%2f_STAT%22" target="_blank" rel="noopener">https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22WCHAR%2f_STAT%22);k(_STAT);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true</a>;k(_STAT);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true)</p><h2 id="boost的filesystem类库的exists函数"><a href="#boost的filesystem类库的exists函数" class="headerlink" title="boost的filesystem类库的exists函数"></a>boost的filesystem类库的exists函数</h2><pre><code>#include &lt;boost/filesystem/operations.hpp&gt;#include &lt;boost/filesystem/path.hpp&gt;#include &lt;boost/filesystem/convenience.hpp&gt;int GetFilePath(std::string &amp;strFilePath){    string strPath;    int nRes = 0;    //指定路径    strPath = &quot;D:/myTest/Test1/Test2&quot;;    namespace fs = boost::filesystem;    //路径的可移植    fs::path full_path( fs::initial_path() );    full_path = fs::system_complete( fs::path(strPath, fs::native ) );    //判断各级子目录是否存在，不存在则需要创建    if ( !fs::exists( full_path ) )    {        // 创建多层子目录        bool bRet = fs::create_directories(full_path);        if (false == bRet)        {            return -1;        }    }    strFilePath = full_path.native_directory_string();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h1&gt;&lt;h2 id=&quot;ifstream&quot;&gt;&lt;a href=&quot;#ifstream&quot; class=&quot;headerlink&quot; title=&quot;ifstream&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="文件" scheme="https://caojingyou.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C#与C++相互发送消息</title>
    <link href="https://caojingyou.github.io/2017/02/01/CShap%E4%B8%8EC++%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2017/02/01/CShap与C++通信/</id>
    <published>2017-02-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-与C-相互发送消息"><a href="#C-与C-相互发送消息" class="headerlink" title="C#与C++相互发送消息"></a>C#与C++相互发送消息</h1><h2 id="C-端："><a href="#C-端：" class="headerlink" title="C#端："></a>C#端：</h2><pre><code>namespace CshapMessage{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        IntPtr hwnd;        const int WM_COPYDATA = 0x004A;        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        [DllImport(&quot;User32.dll&quot;)]        public static extern int SendMessage(int hwnd, int msg, int wParam, ref COPYDATASTRUCT IParam);        [DllImport(&quot;User32.dll&quot;)]        public static extern int FindWindow(string lpClassName, string lpWindowName);        public MainWindow()        {            InitializeComponent();            this.Title = &quot;CshapMessage&quot;;            this.Loaded += MainWindow_Loaded;            this.Closed += MainWindow_Closed;        }        private void MainWindow_Closed(object sender, EventArgs e)        {            try            {                HwndSource.FromHwnd(hwnd).RemoveHook(WndProc);            }            catch (Exception) { }        }        private void MainWindow_Loaded(object sender, RoutedEventArgs e)        {            hwnd = new WindowInteropHelper(this).Handle;            HwndSource.FromHwnd(hwnd).AddHook(new HwndSourceHook(WndProc));        }        /// &lt;summary&gt;        /// 向C++程序 CshapMessage发送消息        /// &lt;/summary&gt;        /// &lt;param name=&quot;nMessgeId&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;strSend&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        private bool CshapSendMessage(int nMessgeId, String strSend)        {            int WINDOW_HANDLE = FindWindow(null, &quot;VcMessage&quot;);//VcMessage为向C++程序发送的窗口名称            if (WINDOW_HANDLE != 0)            {                COPYDATASTRUCT cdata;                cdata.dwData = (IntPtr)100;//这里可以传入一些自定义的数据，但只能是4字节整数                 cdata.lpData = strSend;//消息字符串                cdata.cData = System.Text.Encoding.Default.GetBytes(strSend).Length+1;//注意，这里的长度是按字节来算的                SendMessage(WINDOW_HANDLE, WM_COPYDATA, 0, ref cdata);            }            else            {                return false;            }            return true;        }        private void button_Click(object sender, RoutedEventArgs e)        {            String strSend = &quot;C#发送的信息&quot;;            int nMessageId = 100;            if (CshapSendMessage(nMessageId,strSend))            {                MessageBox.Show(&quot;发送消息成功&quot;);            }            else            {                MessageBox.Show(&quot;消息发送失败，请打开VcMessage程序&quot;);            }        }        //接收消息。        private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)        {            if (msg == WM_COPYDATA)            {                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)Marshal.PtrToStructure(lParam, mytype);                switch (cdata.dwData.ToInt32())                {                    case 1:                        {                            string strRecv = cdata.lpData;                            break;                        }                    default:                        break;                }            }            return IntPtr.Zero;        }    }}</code></pre><h2 id="C-端：-1"><a href="#C-端：-1" class="headerlink" title="C++端："></a>C++端：</h2><pre><code>BOOL CVcMessageDlg::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct){    // TODO: 在此添加消息处理程序代码和/或调用默认值    //接收C#发送来的数据    switch (pCopyDataStruct-&gt;dwData)    {    case 100:    {        CStringA strRecv = (char*)pCopyDataStruct-&gt;lpData;        break;    }    default:    {        break;    }    }    return CDialogEx::OnCopyData(pWnd, pCopyDataStruct);}void CVcMessageDlg::OnBnClickedButton1(){    // TODO: 在此添加控件通知处理程序代码    CStringA strSend = &quot;VC发送的数据&quot;;    if (VCSendMessage(1,strSend))    {        AfxMessageBox(_T(&quot;消息发送成功&quot;));    }     else    {        AfxMessageBox(_T(&quot;消息发送失败&quot;));    }}//************************************// Method:    VCSendMessage// FullName:  CVcMessageDlg::VCSendMessage// Access:    public // Returns:   BOOL// Qualifier: 向C#程序 CshapMessage发送消息// Parameter: int nMessgeId// Parameter: CStringA strSend//************************************BOOL CVcMessageDlg::VCSendMessage(int nMessgeId,CStringA strSend){    HWND hSendWindow = this-&gt;m_hWnd;    if (hSendWindow == NULL)    {        return FALSE;    }    CWnd *phwnd = FindWindow(NULL, _T(&quot;CshapMessage&quot;));    HWND hRecvWindow = NULL;    if (phwnd == NULL)    {        return FALSE;    }    hRecvWindow = phwnd-&gt;GetSafeHwnd();    if (hRecvWindow == NULL)    {        return FALSE;    }    COPYDATASTRUCT CopyData;    CopyData.dwData = nMessgeId;    CopyData.cbData = strSend.GetLength()+1;    CopyData.lpData = (PVOID)strSend.GetBuffer(CopyData.cbData);    ::SendMessage(hRecvWindow, WM_COPYDATA, (WPARAM)hSendWindow, (LPARAM)&amp;CopyData);    return TRUE;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-与C-相互发送消息&quot;&gt;&lt;a href=&quot;#C-与C-相互发送消息&quot; class=&quot;headerlink&quot; title=&quot;C#与C++相互发送消息&quot;&gt;&lt;/a&gt;C#与C++相互发送消息&lt;/h1&gt;&lt;h2 id=&quot;C-端：&quot;&gt;&lt;a href=&quot;#C-端：&quot; class
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C# 系统托盘图标</title>
    <link href="https://caojingyou.github.io/2017/02/01/CShap%20%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87/"/>
    <id>https://caojingyou.github.io/2017/02/01/CShap 系统托盘图标/</id>
    <published>2017-02-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-系统托盘图标"><a href="#C-系统托盘图标" class="headerlink" title="C# 系统托盘图标"></a>C# 系统托盘图标</h1><h2 id="WPF-NotifyIcon-资料"><a href="#WPF-NotifyIcon-资料" class="headerlink" title="WPF NotifyIcon 资料"></a>WPF NotifyIcon 资料</h2><h3 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h3><p><a href="http://www.codeproject.com/Articles/36468/WPF-NotifyIcon" target="_blank" rel="noopener">http://www.codeproject.com/Articles/36468/WPF-NotifyIcon</a></p><p><a href="http://www.hardcodet.net/" target="_blank" rel="noopener">http://www.hardcodet.net/</a></p><p><a href="https://bitbucket.org/hardcodet/notifyicon-wpf/src" target="_blank" rel="noopener">https://bitbucket.org/hardcodet/notifyicon-wpf/src</a></p><p><a href="https://www.nuget.org/packages/Hardcodet.NotifyIcon.Wpf/" target="_blank" rel="noopener">https://www.nuget.org/packages/Hardcodet.NotifyIcon.Wpf/</a></p><h3 id="NuGet"><a href="#NuGet" class="headerlink" title="NuGet:"></a>NuGet:</h3><pre><code>Install-Package Hardcodet.NotifyIcon.Wpf</code></pre><h3 id="NuGet下载的Package："><a href="#NuGet下载的Package：" class="headerlink" title="NuGet下载的Package："></a>NuGet下载的Package：</h3><p><a href="http://files.cnblogs.com/files/yhcao/Hardcodet.NotifyIcon.Wpf.1.0.8.rar" target="_blank" rel="noopener">Hardcodet.NotifyIcon.Wpf.1.0.8.rar</a></p><h2 id="WPF-NotifyIcon-使用"><a href="#WPF-NotifyIcon-使用" class="headerlink" title="WPF NotifyIcon 使用"></a>WPF NotifyIcon 使用</h2><p>在MainWindow.xaml<window>添加</window></p><pre><code>xmlns:tb=&quot;http://www.hardcodet.net/taskbar&quot;</code></pre><p>在MainWindow.xaml的 <grid\> 修改中添加</grid\></p><pre><code>&lt;tb:TaskbarIcon Name=&quot;MyNotifyIcon&quot;  IconSource=&quot;Founder.ico&quot;&lt;!--托盘显示图标--&gt;  ToolTipText=&quot;Founder 启动本地程序&quot;&gt;&lt;!--鼠标移动到托盘图标显示的文字--&gt;  &lt;tb:TaskbarIcon.ContextMenu&gt;&lt;!--添加菜单--&gt;    &lt;ContextMenu&gt;      &lt;MenuItem Header=&quot;显示&quot; ToolTip=&quot;显示主界面&quot; Click=&quot;MenuItem_Click_Show&quot; /&gt;      &lt;MenuItem Header=&quot;退出&quot; ToolTip=&quot;退出程序&quot; Click=&quot;MenuItem_Click_Close&quot; /&gt;    &lt;/ContextMenu&gt;  &lt;/tb:TaskbarIcon.ContextMenu&gt;&lt;/tb:TaskbarIcon&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-系统托盘图标&quot;&gt;&lt;a href=&quot;#C-系统托盘图标&quot; class=&quot;headerlink&quot; title=&quot;C# 系统托盘图标&quot;&gt;&lt;/a&gt;C# 系统托盘图标&lt;/h1&gt;&lt;h2 id=&quot;WPF-NotifyIcon-资料&quot;&gt;&lt;a href=&quot;#WPF-Notify
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>钩子</title>
    <link href="https://caojingyou.github.io/2017/01/15/%E9%92%A9%E5%AD%90/"/>
    <id>https://caojingyou.github.io/2017/01/15/钩子/</id>
    <published>2017-01-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程内钩子"><a href="#进程内钩子" class="headerlink" title="进程内钩子"></a>进程内钩子</h1><pre><code>//进程内钩子//鼠标钩子过程函数HHOOK g_hHookDm = NULL;HWND g_DestWndH = NULL;LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam){    //此区间内的消息都是鼠标消息    if (WM_MOUSEMOVE &lt;= wParam &amp;&amp; wParam &lt;= WM_MOUSEWHEEL)    {        if (g_DestWndH != NULL)        {            ::SendMessage(g_DestWndH, wParam, wParam, lParam);            //鼠标钩子,lParam是MOUSEHOOKSTRUCT结构指针            PMOUSEHOOKSTRUCT lpMsg = (PMOUSEHOOKSTRUCT)lParam;            lpMsg-&gt;hwnd = NULL;            lpMsg-&gt;dwExtraInfo = 0L;            lpMsg-&gt;pt = CPoint(0, 0);            lpMsg-&gt;wHitTestCode = 0L;        }        return 1;//如果不想让此消息再往下传，返回非0    }    else    {        return ::CallNextHookEx(g_hHookDm, nCode, wParam, lParam);    }}//创建钩子过程if (g_hHookDm == NULL){    //如果dwThreadid指定的线程是由当前进程创建，并且钩子过程在当时进程中，那么hMod必须设置为NULL.    g_hHookDm = ::SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId());    if (g_hHookDm != NULL)    {        g_DestWndH = m_hWnd;//保存目的窗口句柄    }}//消毁进程内钩子if (g_hHookDm != NULL){    UnhookWindowsHookEx(g_hHookDm);    g_DestWndH = NULL;}全局钩子-MFC扩展DLL/新建一个CMouseHook的导出类#pragma once// CMouseHook 命令目标//.hclass AFX_EXT_CLASS CMouseHook : public CObject    //AFX_EXT_CLASS宏声明类为导出类{public:    CMouseHook();    virtual ~CMouseHook();public:    BOOL StartHook(HWND hWnd); //安装钩子函数    BOOL StopHook();//卸载钩子函数};//.cpp#include &lt;afxwin.h&gt;#include &lt;afxdllx.h&gt;#ifdef _DEBUG#define new DEBUG_NEW#endif#define  WM_TOTASK (WM_USER + 2)#pragma data_seg(&quot;SharedDataName&quot;)HHOOK g_mouseHook;HHOOK g_keyboardHook;HWND g_hwnd = NULL;HINSTANCE glhInstance = NULL; //DLL实例句柄#pragma data_seg()#pragma comment(linker,&quot;/section:.SharedDataName,rws&quot;)static AFX_EXTENSION_MODULE MyMouseHookDLL = { NULL, NULL };extern &quot;C&quot; int APIENTRYDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved){    // 如果使用 lpReserved，请将此移除    UNREFERENCED_PARAMETER(lpReserved);    if (dwReason == DLL_PROCESS_ATTACH)    {        TRACE0(&quot;MyMouseHook.DLL 正在初始化!\n&quot;);        // 扩展 DLL 一次性初始化        if (!AfxInitExtensionModule(MyMouseHookDLL, hInstance))            return 0;        // 将此 DLL 插入到资源链中        // 注意: 如果此扩展 DLL 由        //  MFC 规则 DLL (如 ActiveX 控件)隐式链接到，        //  而不是由 MFC 应用程序链接到，则需要        //  将此行从 DllMain 中移除并将其放置在一个        //  从此扩展 DLL 导出的单独的函数中。使用此扩展 DLL 的        //  规则 DLL 然后应显式        //  调用该函数以初始化此扩展 DLL。否则，        //  CDynLinkLibrary 对象不会附加到        //  规则 DLL 的资源链，并将导致严重的        //  问题。        new CDynLinkLibrary(MyMouseHookDLL);        glhInstance = hInstance; //插入保存DLL    }    else if (dwReason == DLL_PROCESS_DETACH)    {        TRACE0(&quot;MyMouseHook.DLL 正在终止!\n&quot;);        // 在调用析构函数之前终止该库        AfxTermExtensionModule(MyMouseHookDLL);    }    return 1;   // 确定}LRESULT CALLBACK MouseProc(    int nCode,      // hook code    WPARAM wParam,  // message identifier    LPARAM lParam   // mouse coordinates) //鼠标钩子过程{    LPMOUSEHOOKSTRUCT pMouseHook = (MOUSEHOOKSTRUCT FAR *)lParam;    if (nCode &gt;= 0)    {        if (WM_LBUTTONDOWN == wParam)        {            //鼠标钩子,lParam是MOUSEHOOKSTRUCT结构指针            PMOUSEHOOKSTRUCT lpMsg = (PMOUSEHOOKSTRUCT)lParam;            CPoint point = lpMsg-&gt;pt;            RECT rect;            ::GetWindowRect(g_hwnd, &amp;rect);    //得到整个窗口在屏幕上的矩形框位置            if ((point.x &lt; rect.left || point.x &gt; rect.right) || (point.y &lt; rect.top || point.y &gt; rect.bottom))            {                ::SendMessage(g_hwnd, WM_SYSCOMMAND, WM_TOTASK, 0);            }        }    }    return CallNextHookEx(g_mouseHook, nCode, wParam, lParam);}LRESULT CALLBACK KeyboardProc(    int code,       // hook code    WPARAM wParam,  // virtual-key code    LPARAM lParam   // keystroke-message information)//键盘钩子过程{    if(VK_F2 == wParam)    {        ::SendMessage(g_hwnd, WM_CLOSE, 0, 0);        ::UnhookWindowsHookEx(g_mouseHook);        ::UnhookWindowsHookEx(g_keyboardHook);    }    else        return 1;}//安装钩子并设定接收显示窗口句柄BOOL CMouseHook::StartHook(HWND hWnd){    BOOL bResult = FALSE;    g_hwnd = hWnd;    g_mouseHook =::SetWindowsHookEx(WH_MOUSE, MouseProc, glhInstance/*::GetModuleHandle(_T(&quot;MyMouseHook.dll&quot;))*/, 0);    g_keyboardHook =::SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, ::GetModuleHandle(_T(&quot;MyMouseHook.dll&quot;)), 0);    /*=================================================================================    HHOOK SetWindowsHookEx( int idHook,HOOKPROC lpfn, INSTANCE hMod,DWORD dwThreadId )    　　参数idHook表示钩子类型，它是和钩子函数类型一一对应的。    比如，WH_KEYBOARD表示安装的是键盘钩子，WH_MOUSE表示是鼠标钩子等等。    　　Lpfn是钩子函数的地址。    　　HMod是钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；    对于系统钩子，该参数为钩子函数所在的DLL句柄。    　　dwThreadId 指定钩子所监视的线程的线程号。对于全局钩子，该参数为NULL。    　　SetWindowsHookEx返回所安装的钩子句柄。    值得注意的是线程钩子和系统钩子的钩子函数的位置有很大的差别。    线程钩子一般在当前线程或者当前线程派生的线程内，    而系统钩子必须放在独立的动态链接库中，实现起来要麻烦一些。    ==================================================================================*/    if(g_mouseHook != NULL)        bResult = TRUE;    if(g_keyboardHook != NULL)        bResult = TRUE;    //设置显示目标窗口标题编辑框的句柄    return bResult;}//卸载钩子BOOL CMouseHook::StopHook(){    BOOL bResult = FALSE;    if(g_mouseHook)    {        bResult = UnhookWindowsHookEx(g_mouseHook);        if(bResult)        {            g_mouseHook = NULL;        }    }    if(g_keyboardHook)    {        bResult = UnhookWindowsHookEx(g_keyboardHook);        if(bResult)        {            g_keyboardHook = NULL;        }    }    return bResult;}</code></pre><h1 id="全局钩子-WIN32-DLL"><a href="#全局钩子-WIN32-DLL" class="headerlink" title="全局钩子-WIN32  DLL"></a>全局钩子-WIN32  DLL</h1><pre><code>#pragma data_seg(&quot;MySec&quot;)HHOOK g_mouseHook;HHOOK g_keyboardHook;HWND g_hwnd = NULL;#pragma data_seg()#pragma comment(linker,&quot;/section:MySec,RWS&quot;)   //设置链接器，使MySec节拥有属性为 RWS (READ WRITE SHARED )LRESULT CALLBACK MouseProc(    int nCode,      // hook code    WPARAM wParam,  // message identifier    LPARAM lParam   // mouse coordinates) //鼠标钩子过程{    return 1;}LRESULT CALLBACK KeyboardProc(    int code,       // hook code    WPARAM wParam,  // virtual-key code    LPARAM lParam   // keystroke-message information)//键盘钩子过程{    if(VK_F2 == wParam)    {        ::SendMessage(g_hwnd, WM_CLOSE, 0, 0);        ::UnhookWindowsHookEx(g_mouseHook);        ::UnhookWindowsHookEx(g_keyboardHook);    }    else        return 1;}void SetHook(HWND hwnd){    g_hwnd = hwnd;    g_mouseHook =::SetWindowsHookEx(WH_MOUSE, MouseProc, ::GetModuleHandle(_T(&quot;dll_hook.dll&quot;)), 0);    g_keyboardHook =::SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, ::GetModuleHandle(_T(&quot;dll_hook.dll&quot;)), 0);}//之后我们添加def文件//或者在def(模块定义文件中 )LIBRARY    &quot;Hook&quot;EXPORTSSetHook @2SECTIONSMySec   READ WRITE SHARED//编译下，编译通过之后可以看到 hook_dll.dll  和  hook_dll.lib文件。//接着我们写一个测试程序，新建MFC工程 选择对话框程序.拷贝hook_dll.dll  和  hook_dll.lib到工程目录下，在链接器命令行加上  hook_dll.lib.//在OnInitDialog()函数之前 定义DLL函数：_declspec(dllimport) void SetHook(HWND hwnd);//在OnInitDialog()内添加SetHook(this-&gt;m_hWnd);</code></pre><p> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程内钩子&quot;&gt;&lt;a href=&quot;#进程内钩子&quot; class=&quot;headerlink&quot; title=&quot;进程内钩子&quot;&gt;&lt;/a&gt;进程内钩子&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//进程内钩子

//鼠标钩子过程函数
HHOOK g_hHookDm = NULL;
HWND g
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="钩子" scheme="https://caojingyou.github.io/tags/%E9%92%A9%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>C#运行外部程序的两种方法</title>
    <link href="https://caojingyou.github.io/2017/01/01/CShap%20ShellExcute%E4%B8%8EProcess/"/>
    <id>https://caojingyou.github.io/2017/01/01/CShap ShellExcute与Process/</id>
    <published>2017-01-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-运行外部程序的两种方法"><a href="#C-运行外部程序的两种方法" class="headerlink" title="C#运行外部程序的两种方法"></a>C#运行外部程序的两种方法</h1><h2 id="ShellExecute"><a href="#ShellExecute" class="headerlink" title="ShellExecute"></a>ShellExecute</h2><pre><code>using System.Runtime.InteropServices;public enum ShowWindowCommands : int{    SW_HIDE = 0,    SW_SHOWNORMAL = 1,    //用最近的大小和位置显示，激活    SW_NORMAL = 1,    SW_SHOWMINIMIZED = 2,    SW_SHOWMAXIMIZED = 3,    SW_MAXIMIZE = 3,    SW_SHOWNOACTIVATE = 4,    SW_SHOW = 5,    SW_MINIMIZE = 6,    SW_SHOWMINNOACTIVE = 7,    SW_SHOWNA = 8,    SW_RESTORE = 9,    SW_SHOWDEFAULT = 10,    SW_MAX = 10}[DllImport(&quot;shell32.dll&quot;)]public static extern IntPtr ShellExecute(    IntPtr hwnd,    string lpszOp,    string lpszFile,    string lpszParams,    string lpszDir,    ShowWindowCommands FsShowCmd);</code></pre><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code>ShellExecute(IntPtr.Zero, &quot;open&quot;, UrlOrPath, null, null, ShowWindowCommands.SW_SHOWNORMAL);</code></pre><p>UrlOrPath可为exe路径或者网页url(使用默认浏览器打开网页url)</p><p>使用ie打开网页url</p><pre><code>ShellExecute(NULL, &quot;open&quot;, &quot;IEXPLORE&quot;, &quot;http://www.csdn.net&quot;, NULL, SW_SHOWMAXIMIZED);</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre><code>using System.Diagnostics;private static string Execute(string exePath, string parameters){    string result = String.Empty;    using (Process p = new Process())    {        p.StartInfo.UseShellExecute = false;        p.StartInfo.CreateNoWindow = true;        p.StartInfo.RedirectStandardOutput = true;        p.StartInfo.FileName = exePath;        p.StartInfo.Arguments = parameters;        p.Start();        p.WaitForExit();        result = p.StandardOutput.ReadToEnd();    }    return result;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-运行外部程序的两种方法&quot;&gt;&lt;a href=&quot;#C-运行外部程序的两种方法&quot; class=&quot;headerlink&quot; title=&quot;C#运行外部程序的两种方法&quot;&gt;&lt;/a&gt;C#运行外部程序的两种方法&lt;/h1&gt;&lt;h2 id=&quot;ShellExecute&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="运行外部程序" scheme="https://caojingyou.github.io/tags/%E8%BF%90%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>制作CAB包</title>
    <link href="https://caojingyou.github.io/2016/12/15/%E5%88%B6%E4%BD%9CCAB%E5%8C%85/"/>
    <id>https://caojingyou.github.io/2016/12/15/制作CAB包/</id>
    <published>2016-12-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制作CAB包"><a href="#制作CAB包" class="headerlink" title="制作CAB包"></a>制作CAB包</h1><h2 id="inf文件"><a href="#inf文件" class="headerlink" title="inf文件"></a>inf文件</h2><p>INF是Device INFormation File的英文缩写，是Microsoft公司为硬件设备制造商发布其驱动程序推出的一种文件格式，INF文件中包含硬件设备的信息或脚本以控制硬件操作。在INF文件中指明了硬件驱动该如何安装到系统中，源文件在哪里、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息等等。</p><h3 id="给硬盘（U盘）DIY一个可爱的图标"><a href="#给硬盘（U盘）DIY一个可爱的图标" class="headerlink" title="给硬盘（U盘）DIY一个可爱的图标"></a>给硬盘（U盘）DIY一个可爱的图标</h3><p>接着打开记事本程序，录入以下内容：</p><pre><code>[autorun]ICON=******.ICO</code></pre><p>其中“<strong>**</strong>”是图标文件的路径及图标文件名，请自行修改为具体的图标文件的路径及图标文件名。录入完毕，另存为“Autorun.inf”,并将其剪切到某一个你欲扮酷的分区的根目录下。</p><h3 id="在命令行下安装INF文件"><a href="#在命令行下安装INF文件" class="headerlink" title="在命令行下安装INF文件"></a>在命令行下安装INF文件</h3><p>通常情况下，我们都是在Windows环境下安装INF文件的，但是假如有一天，你需要在命令行运行INF文件该怎么办呢？</p><p>在命令行提示符后输入“ rundll32 syssetup,SetupInfObjectInstallAction DefaultInstall 128 INF文件所在的路径及文件名.inf ”，回车后即可安装相应的INF文件。</p><p>[pre]再提供两个方法：</p><p>　　方法1. 运行RunDll32 advpack.dll,LaunchINFSection YOUINF.inf,DefaultInstall</p><p>　　方法2.修复右键安装</p><p>　　操作步骤如下：</p><p>　　打开我的电脑，“工具”菜单中的“文件夹选项”。切换至“文件类型”选项卡，在其中找到inf文件，点高级按钮，双击“安装”(如没有“安装”就添加一个)，按如下内容修改</p><p>　　用于执行操作的应用程序:</p><p>　　C:\WINDOWS\System32\rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 %1</p><p>　　点选使用DDE(U)</p><p>　　应用程序(C):</p><p>　　setupapi</p><p>　　主题(T):</p><p>　　System</p><p>　　确认！</p><p>　　然后再次右键点选inf文件安装。</p><h3 id="编写inf文件"><a href="#编写inf文件" class="headerlink" title="编写inf文件"></a>编写inf文件</h3><pre><code>; Sample INF file for IMES.DLL;分号后为注释[version] ; version signature (same for both NT and Win95) do not remove;在该节中如果出现“signature=&quot;$CHICAGO$&quot;”这样的条目则表示该INF文件适用于Windows 98之后的所有操作系统，如果包含“signature=&quot;$Windows NT$&quot;”这样的条目则表示该INF文件适用于Windows 2000/XP/2003操作系统，而且两者必具其一signature=&quot;$CHICAGO$&quot;AdvancedINF=2.0  [Add.Code]Editor.ocx = Editor.ocx; needed DLL[Editor.ocx]file=thiscabclsid={8BB4EE5B-5919-11D1-A01A-0060971932BC}RegisterServer=yesFileVersion=5,0,1,7; end of INF file</code></pre><h2 id="将ActiveX控件进行打包并加数据鉴名的工具集："><a href="#将ActiveX控件进行打包并加数据鉴名的工具集：" class="headerlink" title="将ActiveX控件进行打包并加数据鉴名的工具集："></a>将ActiveX控件进行打包并加数据鉴名的工具集：</h2><ul><li>Cabarc.exe 将ocx打包成cab</li><li>Cert2spc.exe 将cer格式证书转换成spc格式证书， 即PKCS#7证书</li><li>Certmgr.exe 是管理证书用的</li><li>Chktrust.exe 检查签署证书后的ocx是否正确</li><li>Makecat.exe</li><li>Makecert.exe 制作cer格式的证书， 即X.509证书， 同时可以创建私钥和公钥</li><li>Makectl.exe</li><li>Signcode.exe 将证书签署到ocx上</li></ul><p>工具集下载：<a href="http://files.cnblogs.com/files/yhcao/makeCAB.rar" target="_blank" rel="noopener">makeCAB.rar</a></p><h2 id="制作CAB文件"><a href="#制作CAB文件" class="headerlink" title="制作CAB文件"></a>制作CAB文件</h2><ul><li>CMD 输入 iexpress，将启动Iexpress向导</li><li>选中”Create new Self Extraction Directive file”</li><li>选择”Create compressed files only(ActiveX Installs)”</li><li>添加INF文件中所列所有文件（DLL及DEF等）</li><li>单击”下一步(N)”，单击Browse按钮选择RemtCard.CAB文件，同时选中 “Store files using long Name inside Package”checkbx</li><li>选择”Don’t save”</li><li>单击完成按钮将同时生成RemtCard.CAB文件</li></ul><p>或</p><p>执行<br>    CABARC -s 6144 n RemtCard.cab ocx文件.ocx inf文件.INF</p><p>生成RemtCard.CAB文件</p><h2 id="自制数字证书"><a href="#自制数字证书" class="headerlink" title="自制数字证书"></a>自制数字证书</h2><p>用CMD进入到控件所在的目录;</p><p>创建PVK文件(私人密匙文件)，CMD输入makecert  -$ “individual” -r -sk RemtCard RemtCard.pvk -n CN=XXXXXXX</p><p>创建CER文件(公司证书)，CMD输入“makecert -sk RemtCard.pvk RemtCard.cer”，然后回车,在相对目录下会出现一个安全证书</p><p>创建SPC测试软件出版商证明书，CMD输入“cert2spc RemtCard.cer RemtCard.spc”</p><p>或</p><p>执行</p><pre><code>makecert -cy both -d RemtCard -n CN=xxxx有限公司 -sv RemtCard.pvk RemtCard.cerCert2SPC RemtCard.cer RemtCard.spc</code></pre><h2 id="文件数字签名"><a href="#文件数字签名" class="headerlink" title="文件数字签名"></a>文件数字签名</h2><p>在CMD中运行signcode</p><p>选择RemtCard.CAB</p><p>选择好RemtCard.CAB文件后单击”下一步（N）”按钮，在选择想要的签名类型里选择”自定义（C）”按钮</p><p>单击”从文件选择（F）”按钮，选择刚制作的RemtCard.cer</p><p>选择”CSP中的私钥（K）”</p><p>容器密匙选择RemtCard.pvk</p><p>在散列算法中选择”md5”</p><p>“证书路径中的证书”中选择”证书路径中的所有证书，包括根证书（C）”，在”其它证书（可选）”中选择“包括在以下PKCS #7 证书（.p7b）文件中的证书（P）：””，并单击”浏览（R）…”按钮选择RemtCard.spc文件</p><p>“数据描述”窗口中输入公司的名称及网址并单击”</p><p>或</p><p>执行</p><pre><code>signcode.exe -spc RemtCard.spc -v RemtCard.pvk -n RemtCard1.0.0.1 -i www.xxx.com.cn  RemtCard.cab</code></pre><h2 id="activeX插件安装升级"><a href="#activeX插件安装升级" class="headerlink" title="activeX插件安装升级"></a>activeX插件安装升级</h2><pre><code>&lt;object codebase=&quot;http://localhost/RemtCard.cab#version=1,1&quot;CLASSID=&quot;CLSID:8BB4EE5B-5919-11D1-A01A-0060971932BC&quot;…/&gt;    </code></pre><p>参考：</p><ul><li><a href="http://baike.baidu.com/link?url=cCp8mTjGGqdPPJzIfyBi5NIW13Y0jnETjPfegu2BI0K5SCryoFRf4dnk7BdpkMyimDKw8iTuSKAGVSFItXJcIm72x-sU_FrV_41BJS3F09m" target="_blank" rel="noopener">inf文件</a></li><li><a href="http://www.cnblogs.com/sbdx/archive/2006/12/14/whatisinffile.html?login=1" target="_blank" rel="noopener">如何编写 INF 文件</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/bfsktky3(VS.80" target="_blank" rel="noopener">证书创建工具 (Makecert.exe)</a>.aspx)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;制作CAB包&quot;&gt;&lt;a href=&quot;#制作CAB包&quot; class=&quot;headerlink&quot; title=&quot;制作CAB包&quot;&gt;&lt;/a&gt;制作CAB包&lt;/h1&gt;&lt;h2 id=&quot;inf文件&quot;&gt;&lt;a href=&quot;#inf文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="制作CAB包" scheme="https://caojingyou.github.io/tags/%E5%88%B6%E4%BD%9CCAB%E5%8C%85/"/>
    
      <category term="打包" scheme="https://caojingyou.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>C# http</title>
    <link href="https://caojingyou.github.io/2016/12/01/CShap%20http/"/>
    <id>https://caojingyou.github.io/2016/12/01/CShap http/</id>
    <published>2016-12-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minihttpd"><a href="#minihttpd" class="headerlink" title="minihttpd"></a>minihttpd</h1><p>minihttpd：HTTPWeb服务器库</p><p><a href="https://www.codeproject.com/articles/11342/minihttpd-an-http-web-server-library" target="_blank" rel="noopener">https://www.codeproject.com/articles/11342/minihttpd-an-http-web-server-library</a></p><h1 id="Embedded-NET-HTTP-Server"><a href="#Embedded-NET-HTTP-Server" class="headerlink" title="Embedded .NET HTTP Server"></a>Embedded .NET HTTP Server</h1><p>嵌入式.NET的HTTP服务器</p><p><a href="https://www.codeproject.com/Articles/25050/Embedded-NET-HTTP-Server" target="_blank" rel="noopener">https://www.codeproject.com/Articles/25050/Embedded-NET-HTTP-Server</a></p><h1 id="HttpLib"><a href="#HttpLib" class="headerlink" title="HttpLib"></a>HttpLib</h1><p>HttpLib是一个免费的.net(Apache 2.0许可协议)web请求帮助,让开发人员更容易访问和从互联网下载资源</p><p><a href="http://httplib.codeplex.com/" target="_blank" rel="noopener">http://httplib.codeplex.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;minihttpd&quot;&gt;&lt;a href=&quot;#minihttpd&quot; class=&quot;headerlink&quot; title=&quot;minihttpd&quot;&gt;&lt;/a&gt;minihttpd&lt;/h1&gt;&lt;p&gt;minihttpd：HTTPWeb服务器库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="http" scheme="https://caojingyou.github.io/tags/http/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>带你玩转Visual Studio</title>
    <link href="https://caojingyou.github.io/2016/11/15/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%ACVisual%20Studio/"/>
    <id>https://caojingyou.github.io/2016/11/15/带你玩转Visual Studio/</id>
    <published>2016-11-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="带你玩转Visual-Studio"><a href="#带你玩转Visual-Studio" class="headerlink" title="带你玩转Visual Studio"></a>带你玩转Visual Studio</h1><h2 id="带你新建一个工程"><a href="#带你新建一个工程" class="headerlink" title="带你新建一个工程"></a>带你新建一个工程</h2><h3 id="工程目录下各文件的含义"><a href="#工程目录下各文件的含义" class="headerlink" title="工程目录下各文件的含义"></a>工程目录下各文件的含义</h3><h4 id="解决方案与工程"><a href="#解决方案与工程" class="headerlink" title="解决方案与工程"></a>解决方案与工程</h4><p>在这之前先了解一个概念：解决方案与工程。<br>解决方案(Solution)：一个大型项目的整体的工作环境；<br>工程 (Project)：一个解决方案下的一个子工程；</p><p>在VS中，一个Solution可以有一个或多个Project。在我们创建一个工程时，如果没有指定Solution，VS会帮我们创建一个与工程名相同的Solution，这时一个Solution里只有一个Project。所有在我们的TestProject的文件目录结构中TestProject文件夹下还有一个TestProject文件夹(如图4)，第一个就是整个Solution的目录，第二个才是Project的目录。</p><h4 id="解决方案相关的文件："><a href="#解决方案相关的文件：" class="headerlink" title="解决方案相关的文件："></a>解决方案相关的文件：</h4><p>TestProject.sln：<br>整个解决方案(Solution)的配制文件，组织多个工程和相关的元素到一个解决方案中。用鼠标双击它就能用VS打开整个工程项目。</p><p>TestProject.sdf：<br>浏览相关的数据库文件，它支持浏览和导航的特性。如跳转到方法、变量的声明，查找所有对象的所有被引用的地方，类视图等等。</p><p>TestProject.suo：<br>(solution user opertion) 解决方案用户选项,记录所有将与解决方案建立关联的选项， 以便在每次打开时，它都包含您所做的自定义设置.</p><p>TestProject.opensdf：<br>打开解决方案(Solution)时的临时文件，这个文件只有你的解决方案在VS打开的状态才会有，工程一关闭文件就被删除了。</p><h4 id="工程相关的文件"><a href="#工程相关的文件" class="headerlink" title="工程相关的文件"></a>工程相关的文件</h4><p>TestProject.vcxproj：<br>记录工程(Project)相关的属性配制。</p><p>TestProject.vcxproj.filters：<br>文件过虑器，上图3“工程结构”中各个文件的组织和编排都是定义在这个文件中的。如果由于某种特殊的原因(如系统或VS突然崩溃)导致你打开工程时文件的组织结构是乱的，100%就是这个文件的原因。</p><p>TestProject.vcxproj.user：<br>用户相关的一些配制。</p><p>上面这些文件中有几个比较重要的一定不能删的文件是：</p><p>TestProject.sln、TestProject.vcxproj、TestProject.vcxproj.filters</p><p>不要问我是怎样知道这些文件的作用的，请看官方文档：</p><p>VS2010定义：<a href="工程目录下各文件的含义">https://msdn.microsoft.com/en-us/library/3awe4781.aspx</a>.</p><p>VS2015定义：<a href="https://msdn.microsoft.com/en-us/library/vstudio/hx0cxhaw(v=vs.110" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/vstudio/hx0cxhaw(v=vs.110).aspx</a>.aspx)</p><h2 id="带你了解VC-各种类型的工程"><a href="#带你了解VC-各种类型的工程" class="headerlink" title="带你了解VC++各种类型的工程"></a>带你了解VC++各种类型的工程</h2><h3 id="理解几个概念"><a href="#理解几个概念" class="headerlink" title="理解几个概念"></a>理解几个概念</h3><h4 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h4><p>COM(Component Object Model)组件对象模型是microsoft制定的一个组件软件标准，跟unix上的CORBA一样。凡是遵循COM标准开发出来的组件称为COM组件。目地是实现二进制方式的软件重用 。在windows平台上，COM的实现形式有DLL(进程内组件)和EXE(进程外组件)2种。</p><h4 id="OLE"><a href="#OLE" class="headerlink" title="OLE"></a>OLE</h4><p>OLE(Object Linking and Embedding)对象连接与嵌入是微软的复合文档技术，可方便实现应用程序之间的通信。在后来的OLE2中才导入了 COM，提供了对COM的支持，利用这种技术可开发可重复使用的软件组件COM。OLE是软件比较早提出的一种技术。</p><h4 id="ATL"><a href="#ATL" class="headerlink" title="ATL"></a>ATL</h4><p>ATL(Active Template Library)活动模板库是一套C++模板库，常用于开发COM程序和ActiveX程序。要理解ATL技术可从以下两方面理解：</p><ol><li>ATL可以说是把COM封装了一下，象MFC一样做成一个库，并有一个向导，使COM应用开发尽可能地自动化、可视化，这就决定了ATL只面向COM开发提供支持。</li><li>ATL因其采用了特定的基本实现技术，摆脱了大量冗余代码，使用ATL开发出来的COM应用的代码简练高效。<br>在ATL产生以前，开发COM组件的方法主要有两种：一是使用COM SDK(COM软件开发包)直接开发COM组件，另一种方式是通过MFC提供的COM支持来实现。而现在 ATL已经成为Microsoft支持COM应用开发的主要开发工具。<h4 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h4></li></ol><p>MFC(Microsoft Foundation Classes)微软基础类是微软提供的一个用于Windows程序开发的基础类库。MFC以C++类的形式封装了Windows的API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含的类包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p><h4 id="ActiveX"><a href="#ActiveX" class="headerlink" title="ActiveX"></a>ActiveX</h4><p>ActiveX是微软提出的一组使用COM技术使得软件组件在网络环境中进行交互的技术集，它与具体的编程语言无关。作为针对Internet应用开发的技术，ActiveX被广泛应用于WEB服务器以及客户端的各个方面。同时，ActiveX技术也被用于方便地创建普通的桌面应用程序，此外ActiveX一般具有界面。</p><p>ActiveX既包含服务器端技术，也包含客户端技术。其主要内容是：</p><ol><li>ActiveX控制（ActiveX Control）；用于向WEB页面、Microsoft Word等支持ActiveX的容器（Container）中插入COM对象。</li><li>ActiveX文档（ActiveX Document）；用于在WEB Browser或者其它支持ActiveX的容器中浏览复合文档（非HTML文档），例如Microsoft Word文档，Microsoft Excel文档或者用户自定义的文档等。</li><li>ActiveX脚本描述（ActiveX Scripting）；用于从客户端或者服务器端操纵ActiveX控制和Java程序，传递数据，协调它们之间的操作。</li><li>ActiveX服务器框架（ActiveX Server Framework）；提供了一系列针对WEB服务器应用程序设计各个方面的函数及其封装类，诸如服务器过滤器、HTML数据流控制等。</li><li>在Internet Explorer中内置Java虚拟机(Java Virtual Machine)，从而使Java Applet能够在Internet Explorer上运行，并可以与ActiveX控制通过脚本描述语言进行通信。</li></ol><h2 id="带你高效开发"><a href="#带你高效开发" class="headerlink" title="带你高效开发"></a>带你高效开发</h2><p>使用Visual Assist X</p><h3 id="Visual-Assist-X-Snippets-宏"><a href="#Visual-Assist-X-Snippets-宏" class="headerlink" title="Visual Assist X Snippets 宏"></a>Visual Assist X Snippets 宏</h3><p><a href="http://blog.csdn.net/ejay/article/details/7750728" target="_blank" rel="noopener">Visual Assist X Snippets 宏</a> </p><h2 id="带你高效管理代码"><a href="#带你高效管理代码" class="headerlink" title="带你高效管理代码"></a>带你高效管理代码</h2><h3 id="目前主流的版本控制系统有："><a href="#目前主流的版本控制系统有：" class="headerlink" title="目前主流的版本控制系统有："></a>目前主流的版本控制系统有：</h3><ol><li>CVS：是一个用于代码版本控制的自由软件，它是一个比较早出现的工具，由于它有很多自身的缺陷，现在几乎被SVN所取代了。</li><li>SVN：SVN是Subversion的简称，它是集中式的版本控制系统。SVN继承了CVS的基本思想，包含了CVS的几乎所有功能。你可以认为SVN是CVS的升级版(但实际上它们完全是两个软件)。</li><li>GIT：GIT是分布式的版本控制系统。相信玩过开源代码的都知道github吧，它就是一个基于git的代码托管平台</li></ol><h3 id="C-工程上传服务器要忽视的文件"><a href="#C-工程上传服务器要忽视的文件" class="headerlink" title="C++工程上传服务器要忽视的文件"></a>C++工程上传服务器要忽视的文件</h3><h4 id="C-工程上传服务器要忽视的文件-1"><a href="#C-工程上传服务器要忽视的文件-1" class="headerlink" title="C++工程上传服务器要忽视的文件"></a>C++工程上传服务器要忽视的文件</h4><pre><code>h: 头文件cpp: 源文件txt: 说明文件，如readmerc: 资源文件rc2: 资源文件ico: 图标，如logo等sln: 解决方案工程文件vcxproj: 工程文件filters: 文件过虑器</code></pre><h4 id="不要上传的文件类型"><a href="#不要上传的文件类型" class="headerlink" title="不要上传的文件类型"></a>不要上传的文件类型</h4><pre><code>Debug、Release等编译结构目录ipch目录aps: last resource editor stateexe: build resultidb: build stateipch: build helperlastbuildstate: build helperlib: build result. Can be 3rd partylog: build logmanifest: build helper. Can be written yourself.obj: build helperpch: build helperpdb: build resultres: build helpersdf: intellisense dbasesuo: solution user optionstlog: build loguser: debug settings. Do preserve if just one dev or custom debug settings</code></pre><p>如果用TortoiseSVN进行管理，需要手动添加ignore属性将不需要上传的文件忽略掉。在你工程目录里，右键-&gt;TortoiseSVN-&gt;Properties-&gt;New-&gt;Other，弹出的对话框中Property name中选择svn:ignore，Property value中填入要忽略的内容(这里可以使用能配符)。可以设置全局忽略样式。</p><h2 id="带你跳出坑爹的Runtime-Library坑"><a href="#带你跳出坑爹的Runtime-Library坑" class="headerlink" title="带你跳出坑爹的Runtime Library坑"></a>带你跳出坑爹的Runtime Library坑</h2><pre><code>Multi-threaded     /MT     Release版的多线程静态库     libcmt.lib     Multi-threaded Debug     /MTd     Debug版的多线程静态库     libcmtd.lib     Multi-threaded DLL     /MD     Release版的多线程动态库     msvcrt.lib+msvcrtxx.dll     Multi-threaded DLL Debug     MDd     Debug版的多线程动态库     msvcrtd.lib+msvcrtxxd.dll</code></pre><p>结论：/MD和/MDd将是潮流所趋，/ML和/MLd方式请及时放弃，/MT和/MTd在非必要时最好也不要采用了。</p><h2 id="带你理解多字节编码与Unicode码"><a href="#带你理解多字节编码与Unicode码" class="headerlink" title="带你理解多字节编码与Unicode码"></a>带你理解多字节编码与Unicode码</h2><ol><li>当设置为Use Unicode Character Set时，会有预编译宏：_UNICODE、UNICODE </li><li>当设置为Use Unicode Character Set时，会有预编译宏：_UNICODE、UNICODE </li></ol><h2 id="incremental-linking-增量链接-的作用"><a href="#incremental-linking-增量链接-的作用" class="headerlink" title="incremental linking(增量链接)的作用"></a>incremental linking(增量链接)的作用</h2><p><a href="http://www.cnblogs.com/lidabo/archive/2012/05/29/2524170.html" target="_blank" rel="noopener">VS中的路径宏 vc++中OutDir、ProjectDir、SolutionDir各种路径</a></p><h2 id="命令行编译C-C-程序"><a href="#命令行编译C-C-程序" class="headerlink" title="命令行编译C/C++程序"></a>命令行编译C/C++程序</h2><p>打开安装目录下的VSDIR\VC\bin可以看到一系列的可执行程序.exe和批处理文件，这些就是VS2010构建、编译、链接时要用到的工具。看一下几个主要的工具：</p><pre><code>cl.exe：编译程序link.exe：链接程序lib.exe：加载lib库的程序nmake.exe：用makefile进行构建、编译的工具</code></pre><p><a href="http://www.lellansin.com/%E5%BE%AE%E8%BD%AF-cl-exe-%E7%BC%96%E8%AF%91%E5%99%A8.html" target="_blank" rel="noopener">微软 CL.exe 编译器</a></p><p>##性能分析与优化## </p><p>使用VS的性能分析工具</p><h3 id="性能分析工具的选择"><a href="#性能分析工具的选择" class="headerlink" title="性能分析工具的选择"></a>性能分析工具的选择</h3><p>打开一个“性能分析”的会话:Debug-&gt;Start Diagnotic Tools Without Debugging(或按Alt+F2)，VS2013在Analysis菜单中。 </p><h4 id="CPU-Usage"><a href="#CPU-Usage" class="headerlink" title="CPU Usage"></a>CPU Usage</h4><p>检测CPU的性能，主要用于发现影响CPU瓶颈(消耗大量CPU资源)的代码。</p><h4 id="GPU-Usage"><a href="#GPU-Usage" class="headerlink" title="GPU Usage"></a>GPU Usage</h4><p>检测GPU的性能，常用于图形引擎的应用(如DirectX程序)，主要用于判断是CPU还是GPU的瓶颈。</p><h4 id="Memory-Usage"><a href="#Memory-Usage" class="headerlink" title="Memory Usage"></a>Memory Usage</h4><p>检测应用程序的内存，发现内存。</p><h4 id="Performance-Wizard"><a href="#Performance-Wizard" class="headerlink" title="Performance Wizard"></a>Performance Wizard</h4><p>性能(监测)向导，综合检测程序的性能瓶颈。这个比较常用，下面再逐一说明。</p><h3 id="性能-监测-向导"><a href="#性能-监测-向导" class="headerlink" title="性能(监测)向导"></a>性能(监测)向导</h3><h4 id="CPU-Sampling-CPU采样-："><a href="#CPU-Sampling-CPU采样-：" class="headerlink" title="CPU Sampling(CPU采样)："></a>CPU Sampling(CPU采样)：</h4><p>进行采样统计，以低开销水平监视占用大量CPU的应用程序。这个对于计算量大的程序可大大节省监控时间。</p><h4 id="Instrumentation-检测-："><a href="#Instrumentation-检测-：" class="headerlink" title="Instrumentation(检测)："></a>Instrumentation(检测)：</h4><p>完全统计，测量函数调用计数和用时</p><h4 id="NET-memory-allocation-NET-内存分配-："><a href="#NET-memory-allocation-NET-内存分配-：" class="headerlink" title=".NET memory allocation(.NET 内存分配)："></a>.NET memory allocation(.NET 内存分配)：</h4><p>跟踪托管内存分配。这个好像只有托管代码(如C#)才可用，一般以C++代码好像不行。</p><h4 id="Resource-contention-data-并发-："><a href="#Resource-contention-data-并发-：" class="headerlink" title="Resource contention data(并发)："></a>Resource contention data(并发)：</h4><p>检测等待其他线程的线程，多用于多线程的并发。</p><h3 id="性能分析报告"><a href="#性能分析报告" class="headerlink" title="性能分析报告"></a>性能分析报告</h3><h4 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h4><p>有几个不同的视图可供我们切换，下面加粗的部分是个人觉得比较方便和常用的视图。</p><ul><li>Summary(概要):整个报告概要说明</li><li>Call Tree(调用树):以树形表格的方式展开函数之间的关系。</li><li>Module(模块):分析调用的不同的程序模块，如不同的DLL、lib模块的耗时</li><li>Caller/Callee(调用与被调用):以数值显示的调用与被调用的关系</li><li>Functions(函数统计):以数值显示的各个函数的执行时间和执行次数统计值</li><li>Marks(标记):</li><li>Processers(进程):</li><li>Function Detials(函数详情):以图表的方式形象地显示：调用函数-当前函数-被调用子函数之间的关系和时间比例。</li></ul><h4 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h4><ul><li>Num of Calls:(函数)调用次数</li><li>Elapsed Inclusive Time:已用非独占时间</li><li>Elapsed Exclusive Time:已用独占时间</li><li>Avg Elapsed Inclusive Time:平均已用非独占时间</li><li>Avg Elapsed Exclusive Time:平均已用独占时间</li><li>Module Name:模块名称，一般为可执行文件(.exe)、动态库(.dll)、静态库(.lib)的名称。</li></ul><h2 id="调用约定cdecl、stdcall和-fastcall"><a href="#调用约定cdecl、stdcall和-fastcall" class="headerlink" title="调用约定cdecl、stdcall和__fastcall"></a>调用约定<strong>cdecl、</strong>stdcall和__fastcall</h2><h3 id="什么是调用约定"><a href="#什么是调用约定" class="headerlink" title="什么是调用约定"></a>什么是调用约定</h3><p>函数的调用约定，顾名思义就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。它决定以下内容：(1)函数参数的压栈顺序，(2)由调用者还是被调用者把参数弹出栈，(3)以及产生函数修饰名的方法。</p><p>常见的调用约定有<strong>cdecl、</strong>stdcall、fastcall，应用最广泛的是<strong>cdecl和</strong>stdcall,下面我们会详细进行讲述。。还有一些不常见的，如 <strong>pascal、</strong>thiscall、__vectorcall。</p><h3 id="cdecl的特点"><a href="#cdecl的特点" class="headerlink" title="__cdecl的特点"></a>__cdecl的特点</h3><p>__cdecl 是 C Declaration 的缩写，表示 C 和 C++ 默认的函数调用约定。是C/C++和MFCX的默认调用约定。</p><ul><li>按从右至左的顺序压参数入栈、。</li><li>由调用者把参数弹出栈。切记：对于传送参数的内存栈是由调用者来维护的，返回值在EAX中。因此对于像printf这样可变参数的函数必须用这种约定。</li><li>编译器在编译的时候对这种调用规则的函数生成修饰名的时候，在输出函数名前加上一个下划线前缀，格式为_function。如函数int add(int a, int b)的修饰名是_add。</li></ul><h3 id="stdcall的特点"><a href="#stdcall的特点" class="headerlink" title="__stdcall的特点"></a>__stdcall的特点</h3><p><strong>stdcall是Standard Call的缩写，是C++的标准调用方式,当然这是微软定义的标准，</strong>stdcall通常用于Win32 API中(可查看WINAPI的定义)。</p><ul><li>按从右至左的顺序压参数入栈。</li><li>由被调用者把参数弹出栈。切记：函数自己在退出时清空堆栈，返回值在EAX中。</li><li>__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为_function@number。如函数int sub(int a, int b)的修饰名是_sub@8。</li></ul><h3 id="fastcall的特点"><a href="#fastcall的特点" class="headerlink" title="__fastcall的特点"></a>__fastcall的特点</h3><p>__fastcall调用的主要特点就是快，因为它是通过寄存器来传送参数的。</p><ul><li>实际上__fastcall用ECX和EDX传送前两个DWORD或更小的参数，剩下的参数仍自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈。</li><li>__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@function@number,如double multi(double a, double b)的修饰名是@multi@16。</li><li><strong>fastcall和</strong>stdcall很象，唯一差别就是头两个参数通过寄存器传送。注意通过寄存器传送的两个参数是从左向右的，即第1个参数进ECX，第2个进EDX，其他参数是从右向左的入栈，返回仍然通过EAX。</li></ul><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p>__thiscall是C++类成员函数缺省的调用约定，但它没有显示的声明形式。因为在C++类中，成员函数调用还有一个this指针参数，因此必须特殊处理，thiscall调用约定的特点：</p><ul><li>参数入栈：参数从右向左入栈</li><li>this指针入栈：如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入栈。</li><li>栈恢复：对参数个数不定的，调用者清理栈，否则函数自己清理栈。</li></ul><h2 id="调用约定与-动态-库"><a href="#调用约定与-动态-库" class="headerlink" title="调用约定与(动态)库"></a>调用约定与(动态)库</h2><p><a href="http://blog.csdn.net/luoweifu/article/details/52456407" target="_blank" rel="noopener">调用约定与(动态)库</a></p><p>参考：</p><ul><li><a href="http://blog.csdn.net/column/details/visualstudio.html" target="_blank" rel="noopener">带你玩转Visual Studio</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;带你玩转Visual-Studio&quot;&gt;&lt;a href=&quot;#带你玩转Visual-Studio&quot; class=&quot;headerlink&quot; title=&quot;带你玩转Visual Studio&quot;&gt;&lt;/a&gt;带你玩转Visual Studio&lt;/h1&gt;&lt;h2 id=&quot;带你新建一
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VC" scheme="https://caojingyou.github.io/tags/VC/"/>
    
  </entry>
  
  <entry>
    <title>C# 进程间通信</title>
    <link href="https://caojingyou.github.io/2016/11/01/CShap%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2016/11/01/CShap 进程间通信/</id>
    <published>2016-11-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用SendMessage向另一进程发送WM-COPYDATA消息"><a href="#使用SendMessage向另一进程发送WM-COPYDATA消息" class="headerlink" title="使用SendMessage向另一进程发送WM_COPYDATA消息"></a>使用SendMessage向另一进程发送WM_COPYDATA消息</h1><h2 id="Send端："><a href="#Send端：" class="headerlink" title="Send端："></a>Send端：</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;using System.Windows.Shapes;using System.Runtime.InteropServices;namespace SentTest{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        public MainWindow()        {            InitializeComponent();            this.Title = &quot;发送窗口&quot;;        }        const int WM_COPYDATA = 0x004A;        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        [DllImport(&quot;User32.dll&quot;)]        public static extern int SendMessage(int hwnd, int msg, int wParam, ref COPYDATASTRUCT IParam);        [DllImport(&quot;User32.dll&quot;)]        public static extern int FindWindow(string lpClassName, string lpWindowName);        private void button1_Click(object sender, RoutedEventArgs e)        {            String strSent = &quot;需要发送的信息&quot;;            int WINDOW_HANDLE = FindWindow(null, &quot;接收窗口&quot;);            if (WINDOW_HANDLE != 0)            {                byte[] arr = System.Text.Encoding.Default.GetBytes(strSent);                int len = arr.Length;                COPYDATASTRUCT cdata;                cdata.dwData = (IntPtr)100;                cdata.lpData = strSent;                cdata.cData = len + 1;                SendMessage(WINDOW_HANDLE, WM_COPYDATA, 0, ref cdata);            }        }    }}</code></pre><h2 id="Get端："><a href="#Get端：" class="headerlink" title="Get端："></a>Get端：</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;using System.Windows.Shapes;using System.Runtime.InteropServices;using System.Windows.Interop;namespace GetTest{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        IntPtr hwnd;        public MainWindow()        {            InitializeComponent();            this.Title = &quot;接受窗口&quot;;            this.Loaded += new RoutedEventHandler(MainWindow_Loaded);            this.Closed += new EventHandler(MainWindow_Closed);        }        void MainWindow_Loaded(object sender, RoutedEventArgs e)        {            //窗口加载完毕才可用，否则会报错。            hwnd = new WindowInteropHelper(this).Handle;            HwndSource source = HwndSource.FromHwnd(hwnd);            if (source != null) source.AddHook(WndProc);        }        void MainWindow_Closed(object sender, EventArgs e)        {            try            {                HwndSource.FromHwnd(hwnd).RemoveHook(WndProc);            }            catch (Exception)            {                throw;            }        }        const int WM_COPYDATA = 0x004A;//WM_COPYDATA消息的主要目的是允许在进程间传递只读数据。        //Windows在通过WM_COPYDATA消息传递期间，不提供继承同步方式。        //其中,WM_COPYDATA对应的十六进制数为0x004A        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        //wpf用此方法        private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)        {            if (msg == WM_COPYDATA)            {                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)Marshal.PtrToStructure(lParam, mytype);                this.textBox1.Text = cdata.lpData;            }            return IntPtr.Zero;        }        //WinFrom用此方法        /* protected override void DefWndProc(ref Message m)        {            switch (m.Msg)            {            case WM_COPYDATA:                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)m.GetLParam(mytype);                this.textBox1.Text = cdata.lpData;                break;            default:                base.DefWndProc(ref m);                break;            }        } */    }}</code></pre><h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><p><a href="http://blog.csdn.net/feiren127/article/details/5459827" target="_blank" rel="noopener">c# 进程间同步实现 进程之间通讯的几种方法 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用SendMessage向另一进程发送WM-COPYDATA消息&quot;&gt;&lt;a href=&quot;#使用SendMessage向另一进程发送WM-COPYDATA消息&quot; class=&quot;headerlink&quot; title=&quot;使用SendMessage向另一进程发送WM_COP
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="VLC" scheme="https://caojingyou.github.io/tags/VLC/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>C# 视频编辑</title>
    <link href="https://caojingyou.github.io/2016/10/01/CShap%20%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91/"/>
    <id>https://caojingyou.github.io/2016/10/01/CShap 视频编辑/</id>
    <published>2016-10-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VidCoder"><a href="#VidCoder" class="headerlink" title="VidCoder"></a>VidCoder</h1><p>VidCoder是一个开源免费的DVD/蓝光视频抓取和转码软件.使用HandBrake做为编码引擎.比Handbrake拥有更友好的用户界面.</p><p>可裁剪、剪切、字幕编辑、转码等。</p><p>官网：<br><a href="http://vidcoder.codeplex.com/" target="_blank" rel="noopener">http://vidcoder.codeplex.com/</a></p><h1 id="VLC-media-player"><a href="#VLC-media-player" class="headerlink" title="VLC media player"></a>VLC media player</h1><p>VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。</p><p>官网：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></p><h1 id="ffmpeg-Mencoder"><a href="#ffmpeg-Mencoder" class="headerlink" title="ffmpeg + Mencoder"></a>ffmpeg + Mencoder</h1><p>ffmpeg下载：<a href="http://ffmpeg.org/download.html" target="_blank" rel="noopener">http://ffmpeg.org/download.html</a></p><p>Mencoder下载：<a href="http://www.mplayerhq.hu/design7/dload.html" target="_blank" rel="noopener">http://www.mplayerhq.hu/design7/dload.html</a></p><p>C#调用ffmpeg的方法，仅供参考：<a href="https://github.com/CAOJINGYOU/VideoEditor" target="_blank" rel="noopener">VideoEditor</a></p><h1 id="SharpFFmpeg"><a href="#SharpFFmpeg" class="headerlink" title="SharpFFmpeg"></a>SharpFFmpeg</h1><p>SharpFFmpeg 是一个 ffmpeg 的 C# 绑定版本，允许 .NET 开发者轻松的创建音频和视频应用。</p><p>个人没用过，感觉不错，一会有机会研究下。</p><p>下载地址：<a href="https://sourceforge.net/projects/sharpffmpeg/" target="_blank" rel="noopener">https://sourceforge.net/projects/sharpffmpeg/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VidCoder&quot;&gt;&lt;a href=&quot;#VidCoder&quot; class=&quot;headerlink&quot; title=&quot;VidCoder&quot;&gt;&lt;/a&gt;VidCoder&lt;/h1&gt;&lt;p&gt;VidCoder是一个开源免费的DVD/蓝光视频抓取和转码软件.使用HandBrake做为编
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="VidCoder" scheme="https://caojingyou.github.io/tags/VidCoder/"/>
    
      <category term="VLC" scheme="https://caojingyou.github.io/tags/VLC/"/>
    
      <category term="ffmpeg" scheme="https://caojingyou.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>C++ 引用计数技术及智能指针的简单实现</title>
    <link href="https://caojingyou.github.io/2016/10/01/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://caojingyou.github.io/2016/10/01/C++智能指针/</id>
    <published>2016-10-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用计数技术及智能指针的简单实现"><a href="#引用计数技术及智能指针的简单实现" class="headerlink" title="引用计数技术及智能指针的简单实现"></a>引用计数技术及智能指针的简单实现</h1><h2 id="基础对象类"><a href="#基础对象类" class="headerlink" title="基础对象类"></a>基础对象类</h2><pre><code>class Point{public:    Point(int xVal = 0, int yVal = 0) : x(xVal), y(yVal) { }    int getX() const    {        return x;    }    int getY() const    {        return y;    }    void setX(int xVal)    {        x = xVal;    }    void setY(int yVal)    {        y = yVal;    }    private:    int x, y;};</code></pre><h2 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h2><pre><code>//模板类作为友元时要先有声明template &lt;typename T&gt;class SmartPtr;template &lt;typename T&gt;class U_Ptr     //辅助类{private:    //该类成员访问权限全部为private，因为不想让用户直接使用该类    friend class SmartPtr&lt;T&gt;;      //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类    //构造函数的参数为基础对象的指针    U_Ptr(T *ptr) : p(ptr), count(1) { }    //析构函数    ~U_Ptr()    {        delete p;    }    //引用计数    int count;    //基础对象指针    T *p;};</code></pre><h2 id="智能指针类"><a href="#智能指针类" class="headerlink" title="智能指针类"></a>智能指针类</h2><pre><code>template &lt;typename T&gt;class SmartPtr   //智能指针类{public:    SmartPtr(T *ptr) : rp(new U_Ptr&lt;T&gt;(ptr)) { }     //构造函数    SmartPtr(const SmartPtr&lt;T&gt; &amp;sp) : rp(sp.rp)    {        ++rp-&gt;count;    //复制构造函数    }    SmartPtr &amp;operator=(const SmartPtr&lt;T&gt; &amp;rhs)      //重载赋值操作符    {        ++rhs.rp-&gt;count;     //首先将右操作数引用计数加1，        if (--rp-&gt;count == 0)     //然后将引用计数减1，可以应对自赋值            delete rp;        rp = rhs.rp;        return *this;    }    T &amp;operator *()         //重载*操作符    {        return *(rp-&gt;p);    }    T *operator -&gt;()       //重载-&gt;操作符    {        return rp-&gt;p;    }    ~SmartPtr()          //析构函数    {        if (--rp-&gt;count == 0)    //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象            delete rp;        else            cout &lt;&lt; &quot;还有&quot; &lt;&lt; rp-&gt;count &lt;&lt; &quot;个指针指向基础对象&quot; &lt;&lt; endl;    }private:    U_Ptr&lt;T&gt; *rp;  //辅助类对象指针};</code></pre><p>使用测试</p><pre><code>int main(){    int *i = new int(2);    {        SmartPtr&lt;int&gt; ptr1(i);        {            SmartPtr&lt;int&gt; ptr2(ptr1);            {                SmartPtr&lt;int&gt; ptr3 = ptr2;                cout &lt;&lt; *ptr1 &lt;&lt; endl;                *ptr1 = 20;                cout &lt;&lt; *ptr2 &lt;&lt; endl;            }        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><p>参考：</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;mid=2651156666&amp;idx=1&amp;sn=4109903d526468f5913922d2f06e5a1a&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">C++ 引用计数技术及智能指针的简单实现</a>(文章写的太好了，转过了以后用)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用计数技术及智能指针的简单实现&quot;&gt;&lt;a href=&quot;#引用计数技术及智能指针的简单实现&quot; class=&quot;headerlink&quot; title=&quot;引用计数技术及智能指针的简单实现&quot;&gt;&lt;/a&gt;引用计数技术及智能指针的简单实现&lt;/h1&gt;&lt;h2 id=&quot;基础对象类&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="智能指针" scheme="https://caojingyou.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Github pages + jekyll 博客快速搭建</title>
    <link href="https://caojingyou.github.io/2016/09/15/Github%20pages%20+%20jekyll%20%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    <id>https://caojingyou.github.io/2016/09/15/Github pages + jekyll 博客快速搭建/</id>
    <published>2016-09-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-pages-jekyll-博客快速搭建"><a href="#Github-pages-jekyll-博客快速搭建" class="headerlink" title="Github pages + jekyll 博客快速搭建"></a>Github pages + jekyll 博客快速搭建</h1><h2 id="寻找喜欢的模版"><a href="#寻找喜欢的模版" class="headerlink" title="寻找喜欢的模版"></a>寻找喜欢的模版</h2><ul><li><a href="https://github.com/jekyll/jekyll/wiki/sites" target="_blank" rel="noopener">https://github.com/jekyll/jekyll/wiki/sites</a></li><li><a href="http://jekyllthemes.org/" target="_blank" rel="noopener">http://jekyllthemes.org/</a></li></ul><h2 id="Fork到自己的github"><a href="#Fork到自己的github" class="headerlink" title="Fork到自己的github"></a>Fork到自己的github</h2><p>找到自己github中的此项目</p><p>点击“Settings”，将“Repository name”改为 {你的Github用户名}.github.io，点击“Rename”</p><p>修改成自己的名字</p><p>此时就可以通过 <a href="http://{你的Github用户名}.github.io" target="_blank" rel="noopener">http://{你的Github用户名}.github.io</a> 访问你fork下来的网站了。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>使用git for window 把此项目clone本地</p><p>在_posts 文件夹里有一篇xxx.markdown文件，模仿此文件写博客即可。</p><p>然后用git for window提交到github</p><p>参考：</p><ul><li><a href="http://www.cnblogs.com/xulei1992/p/5650329.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Github pages + jekyll 博客快速搭建</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-pages-jekyll-博客快速搭建&quot;&gt;&lt;a href=&quot;#Github-pages-jekyll-博客快速搭建&quot; class=&quot;headerlink&quot; title=&quot;Github pages + jekyll 博客快速搭建&quot;&gt;&lt;/a&gt;Github
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Github Pages" scheme="https://caojingyou.github.io/tags/Github-Pages/"/>
    
      <category term="静态博客" scheme="https://caojingyou.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="jekyll" scheme="https://caojingyou.github.io/tags/jekyll/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages和Hexo创建静态博客网站</title>
    <link href="https://caojingyou.github.io/2016/09/01/Github%20Pages%E5%92%8CHexo%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <id>https://caojingyou.github.io/2016/09/01/Github Pages和Hexo创建静态博客网站/</id>
    <published>2016-09-01T08:03:00.000Z</published>
    <updated>2018-02-02T10:33:18.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Pages和Hexo创建静态博客网站"><a href="#Github-Pages和Hexo创建静态博客网站" class="headerlink" title="Github Pages和Hexo创建静态博客网站"></a>Github Pages和Hexo创建静态博客网站</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>本人是window环境，所以下载window版。</p><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h2 id="下载-msysgit"><a href="#下载-msysgit" class="headerlink" title="下载 msysgit"></a>下载 msysgit</h2><p>下载地址：<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">https://git-for-windows.github.io/</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>点击鼠标右键菜单Git Bash Here</p><pre><code>npm install hexo-cli -gnpm install hexo --save#如果命令无法运行，可以尝试更换taobao的npm源npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>创建一个blog目录</p><p>执行命令：</p><pre><code>hexo initnpm install</code></pre><p>安装插件，可跳过此步骤：</p><pre><code>npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save</code></pre><p>最好执行：</p><pre><code>npm install hexo-generator-feed --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save</code></pre><p>分别对应：rss、百度爬虫sitemap、通用搜索引擎sitemap</p><p>运行本地Hexo:</p><pre><code>hexo generatehexo server</code></pre><p>浏览器查看效果：</p><pre><code>localhost:4000</code></pre><h2 id="上传到Github"><a href="#上传到Github" class="headerlink" title="上传到Github"></a>上传到Github</h2><p>找到主项目的https地址：<a href="https://xxx/github.io.git" target="_blank" rel="noopener">https://xxx/github.io.git</a></p><p>打开blog文件夹下_config.yml文件修改：</p><pre><code>deploy:  type: git  repository: https://xxx/github.io.git  branch: master</code></pre><p>执行命令：</p><pre><code>hexo g -d</code></pre><h2 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h2><p>Hexo主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>执行命令下载主题：</p><p>git clone <a href="https://github.com/xxx.git(主题地址" target="_blank" rel="noopener">https://github.com/xxx.git(主题地址</a>) themes/xxx(主题文件夹)</p><p>修改_config.yml文件：</p><pre><code>theme: xxx（主题名）</code></pre><p>执行命令：</p><pre><code>hexo ghexo s</code></pre><p>打开<a href="http://localhost:4000/即可看到效果。" target="_blank" rel="noopener">http://localhost:4000/即可看到效果。</a></p><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>执行命令：</p><pre><code>hexo clean   hexo g -d</code></pre><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><pre><code>hexo n &quot;文章标题&quot; #新建md文件hexo g -d #生成并部署</code></pre><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>Create a new post</p><pre><code>hexo new &quot;My New Post&quot;</code></pre><p>Run server</p><pre><code>hexo server</code></pre><p>Generate static files</p><pre><code>hexo generate</code></pre><p>Deploy to remote sites</p><pre><code>hexo deploy</code></pre><h1 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h1><p>hexo d后 ERROR Deployer not found: git</p><pre><code>npm install --save hexo-deployer-git</code></pre><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><p><a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" title="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5</a></p><p>参考：</p><ul><li><a href="http://blog.csdn.net/ljcitworld/article/details/50901626" target="_blank" rel="noopener">小白独立搭建博客–Github Pages和Hexo简明教程</a></li><li><a href="http://www.jianshu.com/p/73779eacb494" target="_blank" rel="noopener">Hexo 靜態博客使用指南</a></li><li><a href="http://wiki.jikexueyuan.com/project/hexo-document/" target="_blank" rel="noopener">Hexo 中文版</a></li><li><a href="http://www.jianshu.com/p/cc38fc9493d4" target="_blank" rel="noopener">解决hexo d命令提交部署博客发生的TaskCanceledException异常</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-Pages和Hexo创建静态博客网站&quot;&gt;&lt;a href=&quot;#Github-Pages和Hexo创建静态博客网站&quot; class=&quot;headerlink&quot; title=&quot;Github Pages和Hexo创建静态博客网站&quot;&gt;&lt;/a&gt;Github Page
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Github Pages" scheme="https://caojingyou.github.io/tags/Github-Pages/"/>
    
      <category term="Hexo" scheme="https://caojingyou.github.io/tags/Hexo/"/>
    
      <category term="静态博客" scheme="https://caojingyou.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>程序打包</title>
    <link href="https://caojingyou.github.io/2016/08/15/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    <id>https://caojingyou.github.io/2016/08/15/程序打包/</id>
    <published>2016-08-15T08:03:00.000Z</published>
    <updated>2018-04-11T07:46:48.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Installer"><a href="#Visual-Studio-Installer" class="headerlink" title="Visual Studio Installer"></a>Visual Studio Installer</h1><p><a href="http://www.cnblogs.com/daban/archive/2012/06/27/2565449.html" target="_blank" rel="noopener">VS2010程序打包操作</a></p><h1 id="InstallShield"><a href="#InstallShield" class="headerlink" title="InstallShield"></a>InstallShield</h1><p><a href="http://liucw.blog.51cto.com/6751239/1220134" target="_blank" rel="noopener">InstallShield使用完全教程</a></p><p><a href="http://www.jb51.net/softjc/467.html" target="_blank" rel="noopener">探索InstallShield——制作一个完整的应用程序安装实例</a></p><p><a href="http://blog.csdn.net/duanbeibei/article/details/50333603" target="_blank" rel="noopener">一个完整的Installshield安装程序实例</a> </p><p>从Visual Studio 2012开始，微软就把自家原来的安装与部署工具彻底废掉了，转而让大家去安装使用第三方的打包工具“InstallShield Limited Edition for Visual Studio”，注意这个版本是免费的，只需要邮件注册下，就会有要注册码。</p><p><a href="http://www.cnblogs.com/zhuxiaohui/p/5139740.html" target="_blank" rel="noopener">Visual Studio InstallShield</a></p><p><a href="http://www.cnblogs.com/wuhuacong/p/4438761.html" target="_blank" rel="noopener">Visual Studio InstallShield</a></p><h1 id="Inno"><a href="#Inno" class="headerlink" title="Inno"></a>Inno</h1><p><a href="http://blog.csdn.net/ruifangcui7758/article/details/6662646" target="_blank" rel="noopener">Inno setup 简单打包教程</a> </p><p>官网上下载的不能新建中文项目，所以还是到网上找汉化版的吧。</p><pre><code>&quot;ISCC.exe&quot; &quot;%~dp0..\Inno Setup\PeriodicalEditor.iss&quot;</code></pre><h1 id="advanced-installer"><a href="#advanced-installer" class="headerlink" title="advanced installer"></a>advanced installer</h1><p><a href="http://anger6678.blog.163.com/blog/static/3293226201072944119412/" target="_blank" rel="noopener">Advanced Installer汉化版教程</a></p><h1 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h1><p><a href="http://blog.csdn.net/csxiaoshui/article/details/45310135" target="_blank" rel="noopener">NSIS简介</a> </p><p><a href="http://www.cnblogs.com/modou/p/3573772.html" target="_blank" rel="noopener">使用NSIS制作安装包</a></p><p><a href="http://www.hanzify.org/teach/index.php?Go=Show::196-1108396800" target="_blank" rel="noopener">NSIS安装制作基础教程[初级篇]</a></p><p><a href="http://hmne.sourceforge.net/" target="_blank" rel="noopener">NIS Edit</a></p><p><a href="https://sourceforge.net/projects/nsis/" target="_blank" rel="noopener">NSIS: Nullsoft Scriptable Install System</a></p><p><a href="http://www.nsisfans.com/" title="NSIS中文论坛" target="_blank" rel="noopener">http://www.nsisfans.com/</a></p><p><a href="http://blog.csdn.net/sdujava2011/article/details/51271567" target="_blank" rel="noopener">NSIS UI 美化类插件分享 </a></p><p><a href="http://www.aceui.cn" target="_blank" rel="noopener">www.aceui.cn-nsSkinEngine</a></p><p><a href="https://github.com/cppfuns/nsSkinEngine_NSIS_demo" target="_blank" rel="noopener">nsSkinEngine_NSIS_demo</a></p><h1 id="牛牛安装包界面美化控件-nsNiuniuSkin"><a href="#牛牛安装包界面美化控件-nsNiuniuSkin" class="headerlink" title="牛牛安装包界面美化控件 [nsNiuniuSkin]"></a>牛牛安装包界面美化控件 [nsNiuniuSkin]</h1><p><a href="http://www.ggniu.cn/download.htm" title="http://www.ggniu.cn/download.htm" target="_blank" rel="noopener">http://www.ggniu.cn/download.htm</a></p><h1 id="WixToolSet"><a href="#WixToolSet" class="headerlink" title="WixToolSet"></a>WixToolSet</h1><p><a href="http://wixtoolset.org/" title="http://wixtoolset.org/" target="_blank" rel="noopener">http://wixtoolset.org/</a></p><p><a href="http://wixtoolset.org/releases/" target="_blank" rel="noopener">http://wixtoolset.org/releases/</a></p><p><a href="https://www.firegiant.com/wix/tutorial/" title="WiX Toolset Tutorial" target="_blank" rel="noopener">https://www.firegiant.com/wix/tutorial/</a></p><p><a href="http://blog.csdn.net/xxdddail/article/details/12652233" target="_blank" rel="noopener">WIX安装图文并茂简易说明</a></p><p><a href="http://www.cnblogs.com/stoneniqiu/category/522235.html" title="http://www.cnblogs.com/stoneniqiu/category/522235.html" target="_blank" rel="noopener">http://www.cnblogs.com/stoneniqiu/category/522235.html</a></p><p><a href="https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/" title="https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/" target="_blank" rel="noopener">https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/</a></p><p><a href="http://wixtoolset.org/documentation/manual/v3/" title="http://wixtoolset.org/documentation/manual/v3/" target="_blank" rel="noopener">http://wixtoolset.org/documentation/manual/v3/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Visual-Studio-Installer&quot;&gt;&lt;a href=&quot;#Visual-Studio-Installer&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Installer&quot;&gt;&lt;/a&gt;Visual Studio Ins
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="打包" scheme="https://caojingyou.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="InstallShield" scheme="https://caojingyou.github.io/tags/InstallShield/"/>
    
      <category term="Inno" scheme="https://caojingyou.github.io/tags/Inno/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢的Notepad++插件</title>
    <link href="https://caojingyou.github.io/2016/08/01/%E6%88%91%E5%96%9C%E6%AC%A2%E7%9A%84Notepad++%E6%8F%92%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2016/08/01/我喜欢的Notepad++插件/</id>
    <published>2016-08-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notepad-插件"><a href="#Notepad-插件" class="headerlink" title="Notepad++插件"></a>Notepad++插件</h1><h2 id="HEX-Editor"><a href="#HEX-Editor" class="headerlink" title="HEX-Editor"></a>HEX-Editor</h2><p>文本转16进制，查看编辑。</p><h2 id="NppExport"><a href="#NppExport" class="headerlink" title="NppExport"></a>NppExport</h2><p>导出已着色代码为其他格式的文件。<br>将彩色代码，导出为word文档（RFT）或网页（HTML）文件，或者将彩色代码（RTF格式或HTMl格式）拷贝到剪贴板，粘贴到别的（word文档，HTML网页）中去。</p><h2 id="CoolFormatNppPlugin"><a href="#CoolFormatNppPlugin" class="headerlink" title="CoolFormatNppPlugin"></a>CoolFormatNppPlugin</h2><p>代码格式化</p><h2 id="NppAStyle"><a href="#NppAStyle" class="headerlink" title="NppAStyle"></a>NppAStyle</h2><p>代码格式化</p><h2 id="XML-Tools"><a href="#XML-Tools" class="headerlink" title="XML Tools"></a>XML Tools</h2><p>XML语法规则检查</p><h2 id="Compare-Plugin"><a href="#Compare-Plugin" class="headerlink" title="Compare Plugin"></a>Compare Plugin</h2><p>比较文件</p><h2 id="PyNpp"><a href="#PyNpp" class="headerlink" title="PyNpp"></a>PyNpp</h2><p>直接在Notepad中编写运行Python</p><h2 id="JSON-Viewer"><a href="#JSON-Viewer" class="headerlink" title="JSON Viewer"></a>JSON Viewer</h2><p>Json查看格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Notepad-插件&quot;&gt;&lt;a href=&quot;#Notepad-插件&quot; class=&quot;headerlink&quot; title=&quot;Notepad++插件&quot;&gt;&lt;/a&gt;Notepad++插件&lt;/h1&gt;&lt;h2 id=&quot;HEX-Editor&quot;&gt;&lt;a href=&quot;#HEX-Edito
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Notepad++" scheme="https://caojingyou.github.io/tags/Notepad/"/>
    
  </entry>
  
  <entry>
    <title>Json</title>
    <link href="https://caojingyou.github.io/2016/07/15/Json/"/>
    <id>https://caojingyou.github.io/2016/07/15/Json/</id>
    <published>2016-07-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JsonCpp"><a href="#JsonCpp" class="headerlink" title="JsonCpp"></a>JsonCpp</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="https://github.com/open-source-parsers/jsoncpp" title="https://github.com/open-source-parsers/jsoncpp" target="_blank" rel="noopener">https://github.com/open-source-parsers/jsoncpp</a></p><p><a href="https://sourceforge.net/projects/jsoncpp/" title="https://sourceforge.net/projects/jsoncpp/" target="_blank" rel="noopener">https://sourceforge.net/projects/jsoncpp/</a></p><p><a href="https://github.com/open-source-parsers/jsoncpp/archive/1.7.4.zip" title="JsonCpp1.7.4" target="_blank" rel="noopener">https://github.com/open-source-parsers/jsoncpp/archive/1.7.4.zip</a></p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>本人使用的是JsonCpp1.7.4，解压后直接把include与src复制到自己的项目下。</p><p>在项目中附加包含目录：<code>../include;../src/lib_json;</code></p><p>把两个目录中的文件添加到项目中</p><p>json_reader.cpp、json_value.cpp和json_writer.cpp三个文件的预编译头改成“不使用预编译头”</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>Json::Value root;   // will contains the root value after parsing.Json::Reader reader;bool parsingSuccessful = reader.parse( config_doc, root );if ( !parsingSuccessful ){// report to the user the failure and their locations in the document.std::cout  &lt;&lt; &quot;Failed to parse configuration\n&quot;   &lt;&lt; reader.getFormattedErrorMessages();return;}// Get the value of the member of root named &apos;encoding&apos;, return &apos;UTF-8&apos; if there is no// such member.std::string encoding = root.get(&quot;encoding&quot;, &quot;UTF-8&quot; ).asString();// Get the value of the member of root named &apos;encoding&apos;, return a &apos;null&apos; value if// there is no such member.const Json::Value plugins = root[&quot;plug-ins&quot;];for ( int index = 0; index &lt; plugins.size(); ++index )  // Iterates over the sequence elements.loadPlugIn( plugins[index].asString() );setIndentLength( root[&quot;indent&quot;].get(&quot;length&quot;, 3).asInt() );setIndentUseSpace( root[&quot;indent&quot;].get(&quot;use_space&quot;, true).asBool() );// ...// At application shutdown to make the new configuration document:// Since Json::Value has implicit constructor for all value types, it is not// necessary to explicitly construct the Json::Value object:root[&quot;encoding&quot;] = getCurrentEncoding();root[&quot;indent&quot;][&quot;length&quot;] = getCurrentIndentLength();root[&quot;indent&quot;][&quot;use_space&quot;] = getCurrentIndentUseSpace();Json::StyledWriter writer;// Make a new JSON document for the configuration. Preserve original comments.std::string outputConfig = writer.write( root );// You can also use streams.  This will put the contents of any JSON// stream at a particular sub-value, if you&apos;d like.std::cin &gt;&gt; root[&quot;subtree&quot;];// And you can write to a stream, using the StyledWriter automatically.std::cout &lt;&lt; root;</code></pre><h1 id="ggicci–json"><a href="#ggicci–json" class="headerlink" title="ggicci–json"></a>ggicci–json</h1><p>发现JsonCpp竟然有内存泄露！！！可能我用法不对，放弃了。另外找了一个ggicci–json。</p><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><p><a href="https://github.com/ggicci/ggicci--json" title="https://github.com/ggicci/ggicci--json" target="_blank" rel="noopener">https://github.com/ggicci/ggicci–json</a></p><h1 id="rapidjson"><a href="#rapidjson" class="headerlink" title="rapidjson"></a>rapidjson</h1><p>rapidjson更快,最终使用了rapidjson</p><h2 id="下载地址：-1"><a href="#下载地址：-1" class="headerlink" title="下载地址："></a>下载地址：</h2><p><a href="https://github.com/miloyip/rapidjson/" title="https://github.com/miloyip/rapidjson/" target="_blank" rel="noopener">https://github.com/miloyip/rapidjson/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JsonCpp&quot;&gt;&lt;a href=&quot;#JsonCpp&quot; class=&quot;headerlink&quot; title=&quot;JsonCpp&quot;&gt;&lt;/a&gt;JsonCpp&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Json" scheme="https://caojingyou.github.io/tags/Json/"/>
    
      <category term="JsonCpp" scheme="https://caojingyou.github.io/tags/JsonCpp/"/>
    
      <category term="ggicci--json" scheme="https://caojingyou.github.io/tags/ggicci-json/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://caojingyou.github.io/2016/07/01/jQuery/"/>
    <id>https://caojingyou.github.io/2016/07/01/jQuery/</id>
    <published>2016-07-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>jQuery是一个快速,小,功能丰富的JavaScript库。 它使 HTML文档遍历和操作、事件处理、 动画和Ajax更简单和易于使用的API,在工作 众多的浏览器。 和多功能性的结合 可扩展性,jQuery已经改变了数百万人的方式写 JavaScript。</p><h2 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h2><ol><li><a href="http://jquery.com/" title="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a></li><li><a href="https://jquery.com/download/" title="https://1. jquery.com/download/" target="_blank" rel="noopener">https://jquery.com/download/</a></li><li><a href="http://www.jquery123.com/" title="http://www.jquery123.com/" target="_blank" rel="noopener">http://www.jquery123.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery&quot;&gt;&lt;a href=&quot;#jQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery&quot;&gt;&lt;/a&gt;jQuery&lt;/h1&gt;&lt;p&gt;jQuery是一个快速,小,功能丰富的JavaScript库。 它使 HTML文档遍历和操作、事件处理、 动
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="jQuery" scheme="https://caojingyou.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>C++ tinyXML使用</title>
    <link href="https://caojingyou.github.io/2016/06/15/C++%20tinyXML%E4%BD%BF%E7%94%A8/"/>
    <id>https://caojingyou.github.io/2016/06/15/C++ tinyXML使用/</id>
    <published>2016-06-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tinyXML下载："><a href="#tinyXML下载：" class="headerlink" title="tinyXML下载："></a>tinyXML下载：</h1><p><a href="http://sourceforge.net/projects/tinyxml/" title="http://sourceforge.net/projects/tinyxml/" target="_blank" rel="noopener">http://sourceforge.net/projects/tinyxml/</a></p><h1 id="加载到项目："><a href="#加载到项目：" class="headerlink" title="加载到项目："></a>加载到项目：</h1><p>这六个文件添加到你的c++工程中，分别是tinystr.h、tinystr.cpp、tinyxml.h、tinyxml.cpp、tinyxmlerror.cpp、tinyxmlparser.cpp</p><p>添加头文件</p><pre><code>#include &quot;tinyxml.h&quot;</code></pre><h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><pre><code>_bstr_t errorWords;TiXmlDocument pXmlDoc;TiXmlDeclaration pDeclaration;pDeclaration.Parse( &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&quot;, 0, TIXML_ENCODING_UNKNOWN );//插入头pXmlDoc.InsertEndChild(pDeclaration);TiXmlElement xElement(&quot;proof-result&quot;);TiXmlElement errorElement(&quot;error-result&quot;);TiXmlElement errorLevelElement(&quot;error&quot;);errorLevelElement.SetAttribute(&quot;level&quot;,szLevel);//设置节点属性TiXmlText  levelText(m_pCheckResult[i].ErrWord);levelText.SetCDATA(true);//设置DATA属性errorLevelElement.InsertEndChild(levelText);errorElement.InsertEndChild(errorLevelElement);TiXmlElement replaceElement(&quot;replace&quot;);TiXmlText  replaceText(errorWords);replaceText.SetCDATA(true);replaceElement.InsertEndChild(replaceText);//插入文本errorElement.InsertEndChild(replaceElement);TiXmlElement positionElement(&quot;position&quot;);TiXmlText  szLevelText(errorWords);positionElement.InsertEndChild(szLevelText);errorElement.InsertEndChild(positionElement);TiXmlElement source_sentenceElement(&quot;source_sentence&quot;);TiXmlText  sentenseText(sentense);sentenseText.SetCDATA(true);source_sentenceElement.InsertEndChild(sentenseText);errorElement.InsertEndChild(source_sentenceElement);xElement.InsertEndChild(errorElement);TiXmlElement leader_sort_errorsElement(&quot;leader_sort_errors&quot;);leader_sort_errorsElement.SetAttribute(&quot;count&quot;,szCount);TiXmlText  szLeaderBufferText((const char*)szLeaderBuffer);szLeaderBufferText.SetCDATA(true);leader_sort_errorsElement.InsertEndChild(szLeaderBufferText);xElement.InsertEndChild(leader_sort_errorsElement);pXmlDoc.InsertEndChild(xElement);//插入根节点//获得生成的xml字符串TiXmlPrinter printer;printer.SetStreamPrinting();pXmlDoc.Accept( &amp;printer );_bstr_t bstrOutPutSentense(printer.CStr());</code></pre><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>可以查看tinyXML自带的文档</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tinyXML下载：&quot;&gt;&lt;a href=&quot;#tinyXML下载：&quot; class=&quot;headerlink&quot; title=&quot;tinyXML下载：&quot;&gt;&lt;/a&gt;tinyXML下载：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/projec
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="tinyXML" scheme="https://caojingyou.github.io/tags/tinyXML/"/>
    
      <category term="XML" scheme="https://caojingyou.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>electron之Windows下使用 html js css 开发桌面应用程序</title>
    <link href="https://caojingyou.github.io/2016/06/01/electron%E4%B9%8BWindows%E4%B8%8B%E4%BD%BF%E7%94%A8%20html%20js%20css%20%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://caojingyou.github.io/2016/06/01/electron之Windows下使用 html js css 开发桌面应用程序/</id>
    <published>2016-06-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-atom-electron"><a href="#1-atom-electron" class="headerlink" title="1.atom/electron"></a>1.atom/electron</h1><h2 id="github"><a href="#github" class="headerlink" title="github:"></a>github:</h2><p><a href="https://github.com/atom/electron" target="_blank" rel="noopener">https://github.com/atom/electron</a></p><h2 id="中文文档："><a href="#中文文档：" class="headerlink" title="中文文档："></a>中文文档：</h2><p><a href="https://github.com/atom/electron/tree/master/docs-translations/zh-CN" target="_blank" rel="noopener">https://github.com/atom/electron/tree/master/docs-translations/zh-CN</a></p><h1 id="2-下载-electron-v0-36-5-win32-x64"><a href="#2-下载-electron-v0-36-5-win32-x64" class="headerlink" title="2.下载 electron-v0.36.5-win32-x64"></a>2.下载 electron-v0.36.5-win32-x64</h1><p><a href="https://github.com/atom/electron/releases/download/v0.36.5/electron-v0.36.5-win32-x64.zip" target="_blank" rel="noopener">https://github.com/atom/electron/releases/download/v0.36.5/electron-v0.36.5-win32-x64.zip</a></p><h1 id="3-新建一个项目-快速入门："><a href="#3-新建一个项目-快速入门：" class="headerlink" title="3.新建一个项目-快速入门："></a>3.新建一个项目-快速入门：</h1><p><a href="https://github.com/atom/electron/blob/master/docs-translations/zh-CN/tutorial/quick-start.md" target="_blank" rel="noopener">https://github.com/atom/electron/blob/master/docs-translations/zh-CN/tutorial/quick-start.md</a></p><p>大体上，一个 Electron 应用的目录结构如下：</p><pre><code>your-app/├── package.json├── main.js└── index.html</code></pre><h2 id="you-app"><a href="#you-app" class="headerlink" title="you-app:"></a>you-app:</h2><p><a href="http://files.cnblogs.com/files/yhcao/electron%E4%B9%8BWindows%E4%B8%8B%E4%BD%BF%E7%94%A8html%2Cjs%2Ccss%2C%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F_you-app.rar" target="_blank" rel="noopener">electron之Windows下使用html,js,css,开发桌面应用程序_you-app.rar</a></p><h3 id="package-json："><a href="#package-json：" class="headerlink" title="package.json："></a>package.json：</h3><pre><code>{  &quot;name&quot;: &quot;your-app&quot;,  &quot;version&quot; : &quot;0.1.0&quot;,  &quot;main&quot;: &quot;main.js&quot;}</code></pre><h3 id="main-js："><a href="#main-js：" class="headerlink" title="main.js："></a>main.js：</h3><pre><code>var app = require(&apos;app&apos;);  // 控制应用生命周期的模块。var BrowserWindow = require(&apos;browser-window&apos;);  // 创建原生浏览器窗口的模块// 保持一个对于 window 对象的全局引用，不然，当 JavaScript 被 GC，// window 会被自动地关闭var mainWindow = null;// 当所有窗口被关闭了，退出。app.on(&apos;window-all-closed&apos;, function() {  // 在 OS X 上，通常用户在明确地按下 Cmd + Q 之前  // 应用会保持活动状态  if (process.platform != &apos;darwin&apos;) {app.quit();  }});// 当 Electron 完成了初始化并且准备创建浏览器窗口的时候// 这个方法就被调用app.on(&apos;ready&apos;, function() {  // 创建浏览器窗口。  mainWindow = new BrowserWindow({width: 800, height: 600});  // 加载应用的 index.html  mainWindow.loadURL(&apos;file://&apos; + __dirname + &apos;/index.html&apos;);  // 打开开发工具  mainWindow.openDevTools();  // 当 window 被关闭，这个事件会被发出  mainWindow.on(&apos;closed&apos;, function() {// 取消引用 window 对象，如果你的应用支持多窗口的话，// 通常会把多个 window 对象存放在一个数组里面，// 但这次不是。mainWindow = null;  });});</code></pre><h3 id="index-html："><a href="#index-html：" class="headerlink" title="index.html："></a>index.html：</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;&lt;title&gt;Hello World!&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;We are using io.js &lt;script&gt;document.write(process.version)&lt;/script&gt;and Electron &lt;script&gt;document.write(process.versions[&apos;electron&apos;])&lt;/script&gt;.  &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="4-应用部署"><a href="#4-应用部署" class="headerlink" title="4.应用部署:"></a>4.应用部署:</h1><p><a href="https://github.com/atom/electron/blob/master/docs-translations/zh-CN/tutorial/application-distribution.md" target="_blank" rel="noopener">https://github.com/atom/electron/blob/master/docs-translations/zh-CN/tutorial/application-distribution.md</a></p><p>为了使用Electron部署你的应用程序，你存放应用程序的文件夹需要叫做 app 并且需要放在 Electron 的资源文件夹下（在 OS X 中是指 Electron.app/Contents/Resources/，在 Linux 和 Windows 中是指 resources/） 就像这样：</p><p>在 Windows 和 Linux 中:</p><pre><code>electron/resources/app├── package.json├── main.js└── index.html</code></pre><h2 id="Windows环境下的NodeJS-NPM-Bower安装配置"><a href="#Windows环境下的NodeJS-NPM-Bower安装配置" class="headerlink" title="Windows环境下的NodeJS+NPM+Bower安装配置"></a>Windows环境下的NodeJS+NPM+Bower安装配置</h2><p><a href="http://jingyan.baidu.com/article/2d5afd69e243cc85a2e28efa.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/2d5afd69e243cc85a2e28efa.html</a></p><h2 id="下载并安装node-v5-5-0-x64-msi"><a href="#下载并安装node-v5-5-0-x64-msi" class="headerlink" title="下载并安装node-v5.5.0-x64.msi"></a>下载并安装node-v5.5.0-x64.msi</h2><p><a href="https://nodejs.org/dist/v5.5.0/node-v5.5.0-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v5.5.0/node-v5.5.0-x64.msi</a></p><h3 id="检验是否安装成功："><a href="#检验是否安装成功：" class="headerlink" title="检验是否安装成功："></a>检验是否安装成功：</h3><pre><code>C:\Users\yhcao&gt;node -vv5.5.0C:\Users\yhcao&gt;npm -v3.3.12</code></pre><h3 id="用nmp打包成asar"><a href="#用nmp打包成asar" class="headerlink" title="用nmp打包成asar:"></a>用nmp打包成asar:</h3><p>第一步：安装asar</p><pre><code>npm install -g asar</code></pre><p>第二步：打包</p><pre><code>asar pack your-app app.asar</code></pre><p>例如：asar pack F:\atom_project\myatom_1 F:\atom_project\app.asar<br>这样就会把myatom_1打包成app.asar</p><p><a href="http://files.cnblogs.com/files/yhcao/electron%E4%B9%8BWindows%E4%B8%8B%E4%BD%BF%E7%94%A8html%2Cjs%2Ccss%2C%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F_app.rar" target="_blank" rel="noopener">electron之Windows下使用html,js,css,开发桌面应用程序_app.rar</a></p><h1 id="5-更改Electron名称"><a href="#5-更改Electron名称" class="headerlink" title="5.更改Electron名称"></a>5.更改Electron名称</h1><p>你可以将 electron.exe 改成任意你喜欢的名字，然后可以使用像 <a href="https://github.com/atom/rcedit" target="_blank" rel="noopener">rcedit</a> 或者<a href="http://www.resedit.net/" target="_blank" rel="noopener">ResEdit</a> 编辑它的icon和其他信息。</p><h2 id="ResEdit"><a href="#ResEdit" class="headerlink" title="ResEdit:"></a>ResEdit:</h2><p><a href="http://www.cr173.com/soft/12721.html" target="_blank" rel="noopener">http://www.cr173.com/soft/12721.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-atom-electron&quot;&gt;&lt;a href=&quot;#1-atom-electron&quot; class=&quot;headerlink&quot; title=&quot;1.atom/electron&quot;&gt;&lt;/a&gt;1.atom/electron&lt;/h1&gt;&lt;h2 id=&quot;github&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="electron" scheme="https://caojingyou.github.io/tags/electron/"/>
    
      <category term="桌面应用程序" scheme="https://caojingyou.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>agsxmpp</title>
    <link href="https://caojingyou.github.io/2016/05/01/agsxmpp/"/>
    <id>https://caojingyou.github.io/2016/05/01/agsxmpp/</id>
    <published>2016-05-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="agsXMPP使用"><a href="#agsXMPP使用" class="headerlink" title="agsXMPP使用"></a>agsXMPP使用</h1><p>agsXMPP中的例子已经有注册、登录、添加好友、接收好友添加请求、发送消息、接收消息等功能。</p><h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><p>登录后可用以下方法修改密码</p><pre><code>IQ iq = new IQ(IqType.set);Register riq = new Register();riq.Username = &quot;Username&quot;;riq.Password = &quot;Password&quot;;iq.Query = riq;XmppClientConnection.Send(iq);</code></pre><p>此代码生成的xml为：</p><pre><code>&lt;query xmlns=&quot;jabber:iq:register&quot;&gt;&lt;username&gt;yhcao&lt;/username&gt;&lt;password&gt;yhcao1&lt;/password&gt;&lt;/query&gt;</code></pre><h2 id="程序例子"><a href="#程序例子" class="headerlink" title="程序例子"></a>程序例子</h2><p><a href="http://files.cnblogs.com/files/yhcao/IM.rar" title="http://files.cnblogs.com/files/yhcao/IM.rar" target="_blank" rel="noopener">http://files.cnblogs.com/files/yhcao/IM.rar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;agsXMPP使用&quot;&gt;&lt;a href=&quot;#agsXMPP使用&quot; class=&quot;headerlink&quot; title=&quot;agsXMPP使用&quot;&gt;&lt;/a&gt;agsXMPP使用&lt;/h1&gt;&lt;p&gt;agsXMPP中的例子已经有注册、登录、添加好友、接收好友添加请求、发送消息、接收消
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="agsXMP" scheme="https://caojingyou.github.io/tags/agsXMP/"/>
    
      <category term="即时通讯" scheme="https://caojingyou.github.io/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>EChart</title>
    <link href="https://caojingyou.github.io/2016/05/01/EChart/"/>
    <id>https://caojingyou.github.io/2016/05/01/EChart/</id>
    <published>2016-05-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EChart"><a href="#EChart" class="headerlink" title="EChart"></a>EChart</h1><p>ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。</p><h1 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h1><ol><li><a href="http://echarts.baidu.com/" title="http://echarts.baidu.com/" target="_blank" rel="noopener">http://echarts.baidu.com/</a></li><li><a href="https://github.com/ecomfe/echarts" title="https://github.com/ecomfe/echarts" target="_blank" rel="noopener">https://github.com/ecomfe/echarts</a></li><li><a href="http://echarts.baidu.com/echarts2/index.html" title="http://echarts.baidu.com/echarts2/index.html" target="_blank" rel="noopener">http://echarts.baidu.com/echarts2/index.html</a></li><li><a href="http://echarts.baidu.com/download.html" title="http://echarts.baidu.com/download.html" target="_blank" rel="noopener">http://echarts.baidu.com/download.html</a></li></ol><h2 id="丰富的图表类型"><a href="#丰富的图表类型" class="headerlink" title="丰富的图表类型"></a>丰富的图表类型</h2><p>ECharts 提供了常规的折线图，柱状图，散点图，饼图，K线图，用于统计的盒形图，用于地理数据可视化的地图，热力图，线图，用于关系数据可视化的关系图，treemap，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。</p><h2 id="引入-ECharts"><a href="#引入-ECharts" class="headerlink" title="引入 ECharts"></a>引入 ECharts</h2><p>ECharts 3 开始不再强制使用 AMD 的方式按需引入，代码里也不再内置 AMD 加载器。因此引入方式简单了很多，只需要像普通的 JavaScript 库一样用 script 标签引入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;header&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;!-- 引入 ECharts 文件 --&gt;</span><br><span class="line">&lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/header&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="绘制一个简单的图表"><a href="#绘制一个简单的图表" class="headerlink" title="绘制一个简单的图表"></a>绘制一个简单的图表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的Dom --&gt;</span><br><span class="line">    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>然后就可以通过 echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图，下面是完整代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts&lt;/title&gt;</span><br><span class="line">    &lt;!-- 引入 echarts.js --&gt;</span><br><span class="line">    &lt;script src=&quot;echarts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;</span><br><span class="line">    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // 基于准备好的dom，初始化echarts实例</span><br><span class="line">        var myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line"></span><br><span class="line">        // 指定图表的配置项和数据</span><br><span class="line">        var option = &#123;</span><br><span class="line">            title: &#123;</span><br><span class="line">                text: &apos;ECharts 入门示例&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            tooltip: &#123;&#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line">                data:[&apos;销量&apos;]</span><br><span class="line">            &#125;,</span><br><span class="line">            xAxis: &#123;</span><br><span class="line">                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;&#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line">                name: &apos;销量&apos;,</span><br><span class="line">                type: &apos;bar&apos;,</span><br><span class="line">                data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 使用刚指定的配置项和数据显示图表。</span><br><span class="line">        myChart.setOption(option);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EChart&quot;&gt;&lt;a href=&quot;#EChart&quot; class=&quot;headerlink&quot; title=&quot;EChart&quot;&gt;&lt;/a&gt;EChart&lt;/h1&gt;&lt;p&gt;ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="EChart" scheme="https://caojingyou.github.io/tags/EChart/"/>
    
      <category term="图表" scheme="https://caojingyou.github.io/tags/%E5%9B%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>xmpp</title>
    <link href="https://caojingyou.github.io/2016/04/15/xmpp/"/>
    <id>https://caojingyou.github.io/2016/04/15/xmpp/</id>
    <published>2016-04-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xmpp学习"><a href="#xmpp学习" class="headerlink" title="xmpp学习"></a>xmpp学习</h1><hr><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="http://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="noopener">Openfire</a></p><p>服务器：Openfire 4.0.2</p><p>客户端：Spark 2.7.7</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Openfire安装："><a href="#Openfire安装：" class="headerlink" title="Openfire安装："></a>Openfire安装：</h3><p>根据提示一直下一步，服务器域名设置为：localhost(ps:如果使用gloox，还是直接用机器名，因为gloox不识别ip)；数据库使用内嵌数据库或别的标准数据库。</p><p>使用mysql的时候需要注意要用管理员权限打开Openfire,否则会出现如下错误：</p><pre><code>HTTP ERROR 500Problem accessing /setup/setup-profile-settings.jsp. Reason:     Server ErrorCaused by:</code></pre><p>安装完成后浏览器登录：<a href="http://127.0.0.1:9090" target="_blank" rel="noopener">http://127.0.0.1:9090</a></p><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>分别在两台电脑上安装Spark，创建各自用户，互添加好友，然后就可以通信了。</p><h2 id="自己实现客户端"><a href="#自己实现客户端" class="headerlink" title="自己实现客户端"></a>自己实现客户端</h2><h3 id="使用agsXMPP"><a href="#使用agsXMPP" class="headerlink" title="使用agsXMPP"></a>使用agsXMPP</h3><p>很好用，直接到官网下载即可，有详细例子，但是程序运行时调试输出信息中会有</p><pre><code>在 System.Net.Sockets.SocketException 中第一次偶然出现的“System.dll”类型的异常</code></pre><p>的提示</p><p>网上说可能是服务器的问题，暂时没找。</p><h3 id="使用gloox"><a href="#使用gloox" class="headerlink" title="使用gloox"></a>使用gloox</h3><h4 id="下载gloox"><a href="#下载gloox" class="headerlink" title="下载gloox"></a>下载gloox</h4><p>下载地址：<a href="https://camaya.net/gloox/download/" title="https://camaya.net/gloox/download/" target="_blank" rel="noopener">https://camaya.net/gloox/download/</a></p><p>gloox 0.9.9.12：<a href="http://camaya.net/download/gloox-0.9.9.12.tar.bz2" title="http://camaya.net/download/gloox-0.9.9.12.tar.bz2" target="_blank" rel="noopener">http://camaya.net/download/gloox-0.9.9.12.tar.bz2</a></p><p>直接用vs打开gloox.vcxproj即可运行</p><p>gloox 1.0.15：<a href="http://camaya.net/download/gloox-1.0.15.tar.bz2" title="http://camaya.net/download/gloox-1.0.15.tar.bz2" target="_blank" rel="noopener">http://camaya.net/download/gloox-1.0.15.tar.bz2</a></p><p>直接用vs打开gloox.vcxproj运行会有问题，需要修改一下文件。<br>以下提供一个可在vs2013中直接运行的gloox</p><p><a href="http://files.cnblogs.com/files/yhcao/gloox_lib_with_vs2013.rar" target="_blank" rel="noopener">gloox_lib_with_vs2013.rar</a></p><p>svn地址：<br>gloox-1.0：svn co svn://svn.camaya.net/gloox/branches/1.0</p><h4 id="调试例子"><a href="#调试例子" class="headerlink" title="调试例子"></a>调试例子</h4><ol><li>新建一个win32控制台空项目,字符集为多字节</li><li>新建筛选器gloox</li><li>把gloox中src文件夹与config.h.win文件复制到新项目中</li><li>修改src文件夹为gloox,并把其中文件(不包括子目录)添加到筛选器gloox中</li><li>加载gloox文件夹下的examples中例子进行调试</li></ol><p>例如：MyGloox2015下MyGloox项目</p><p><a href="http://files.cnblogs.com/files/yhcao/MyGloox.rar" title="MyGloox.rar" target="_blank" rel="noopener">MyGloox.rar</a></p><h4 id="gloox内存泄露"><a href="#gloox内存泄露" class="headerlink" title="gloox内存泄露"></a>gloox内存泄露</h4><p>本人发现不管是直接使用gloox还是自己封装gloox，都会有内存泄露，找了几个版本以及别人写的程序，发现都有内存泄露的问题。</p><h3 id="使用libstrophe"><a href="#使用libstrophe" class="headerlink" title="使用libstrophe"></a>使用libstrophe</h3><h4 id="libstrophe编译"><a href="#libstrophe编译" class="headerlink" title="libstrophe编译"></a>libstrophe编译</h4><ol><li><p>下载libstrophe-master.zip</p></li><li><p>解压，看看各目录，expat是空的，再下载expat，解压，不需要编译，把.h和.c放到expat\lib下面。</p></li><li><p>然后先编译expat，顺利编译出 lib文件、</p></li><li><p>再编译libstrophe工程，会提示没有parser.c。看说明文档，libstrophe缺省用的是expat,可选用libxml2，进入src下，看到有parser_libxml2.c和parser_expat.c，很明显，把parser_expat.c改名成parser.c就可以了。编译通过。</p></li><li><p>再编译其他例子工程，提示没有va_copy。vc2008时好象没有兼容它，不过也没关系，这问题肯定很多人碰到过，果然随便一google，就有答案了， #define一下就行了。</p><pre><code>#ifndef va_copy# ifdef __va_copy# define va_copy(DEST,SRC) __va_copy((DEST),(SRC))# else# define va_copy(DEST, SRC) memcpy((&amp;DEST), (&amp;SRC), sizeof(va_list))# endif#endif </code></pre></li></ol><p>或者</p><pre><code>#ifndef va_copy#define va_copy(d,s) ((d) = (s))#endif</code></pre><ol><li>全部编译通过，测试登录和发消息，api简洁明了，是目前见过最好用的xmpp库。当然gloox和qxmpp也都很好用，还有libjingle功能更强，各取所需。</li></ol><p>个人又遇到一个错误：</p><pre><code>1&gt;libstrophe.lib(sasl.obj) : error LNK2019: 无法解析的外部符号 _SCRAM_SHA1_ClientSignature，该符号在函数 _sasl_scram_sha1 中被引用1&gt;libstrophe.lib(sasl.obj) : error LNK2019: 无法解析的外部符号 _SCRAM_SHA1_ClientKey，该符号在函数 _sasl_scram_sha1 中被引用1&gt;E:\code\C\Local\xmpp\libstrophe-0.8.8\libstrophe-0.8.8\vs2008\Debug\roster example.exe : fatal error LNK1120: 2 个无法解析的外部命令</code></pre><p>此问题需要把sasl.c与auth.c文件</p><p>如果还不行请用这个：</p><p><a href="http://files.cnblogs.com/files/yhcao/libstrophe%28%E5%8F%AF%E7%94%A8%29.rar" title="http://files.cnblogs.com/files/yhcao/libstrophe%28%E5%8F%AF%E7%94%A8%29.rar" target="_blank" rel="noopener">libstrophe(可用).rar</a></p><p>可用vs2008与vs2012直接打开</p><h4 id="libstrophe文档"><a href="#libstrophe文档" class="headerlink" title="libstrophe文档"></a>libstrophe文档</h4><p><a href="http://strophe.im/libstrophe/doc/0.8-snapshot/" title="http://strophe.im/libstrophe/doc/0.8-snapshot/" target="_blank" rel="noopener">http://strophe.im/libstrophe/doc/0.8-snapshot/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xmpp学习&quot;&gt;&lt;a href=&quot;#xmpp学习&quot; class=&quot;headerlink&quot; title=&quot;xmpp学习&quot;&gt;&lt;/a&gt;xmpp学习&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="即时通讯" scheme="https://caojingyou.github.io/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="xmpp" scheme="https://caojingyou.github.io/tags/xmpp/"/>
    
      <category term="Openfire" scheme="https://caojingyou.github.io/tags/Openfire/"/>
    
      <category term="agsXMPP" scheme="https://caojingyou.github.io/tags/agsXMPP/"/>
    
      <category term="gloox" scheme="https://caojingyou.github.io/tags/gloox/"/>
    
      <category term="libstrophe" scheme="https://caojingyou.github.io/tags/libstrophe/"/>
    
  </entry>
  
  <entry>
    <title>Qt安装配置</title>
    <link href="https://caojingyou.github.io/2016/04/01/Qt%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://caojingyou.github.io/2016/04/01/Qt安装配置/</id>
    <published>2016-04-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink" title="Qt Creator:"></a>Qt Creator:</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-mingw492-5.5.0.exe" target="_blank" rel="noopener">Qt 5.5.1 for Windows 32-bit(MinGW 4.9.2, 1.0 GB)</a>:<a href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-mingw492-5.5.0.exe" target="_blank" rel="noopener">http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-mingw492-5.5.0.exe</a></p><p>安装：</p><p>一直“下一步”安装下去。</p><h2 id="Qt-Creator运行："><a href="#Qt-Creator运行：" class="headerlink" title="Qt Creator运行："></a>Qt Creator运行：</h2><p>用Qt Creator创建项目：<br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135230436-2035070806.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135300327-642081944.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135329124-11023139.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135348983-981255417.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135405702-1719283850.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135425343-750603627.png" alt=""></p><hr><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio:"></a>Visual Studio:</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载:"></a>下载:</h2><p><a href="http://download.qt-project.org/official_releases/vsaddin/qt-vs-addin-1.2.4-opensource.exe" target="_blank" rel="noopener">Visual Studio Add-in 1.2.4 for Qt5(156 MB)</a>:<a href="http://download.qt-project.org/official_releases/vsaddin/qt-vs-addin-1.2.4-opensource.exe" target="_blank" rel="noopener">http://download.qt-project.org/official_releases/vsaddin/qt-vs-addin-1.2.4-opensource.exe</a></p><p><a href="http://download.qt.io/official_releases/qt/5.5/5.5.1/qt-opensource-windows-x86-msvc2013_64-5.5.1.exe" target="_blank" rel="noopener">Qt 5.5.1 for Windows 64-bit (VS 2013, 823 MB)</a>或<a href="http://download.qt.io/official_releases/qt/5.5/5.5.1/qt-opensource-windows-x86-msvc2013-5.5.1.exe" target="_blank" rel="noopener">Qt 5.5.1 for Windows 32-bit (VS 2013, 804 MB)</a></p><h2 id="vs2013进行QT配置："><a href="#vs2013进行QT配置：" class="headerlink" title="vs2013进行QT配置："></a>vs2013进行QT配置：</h2><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135450046-76850689.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135504546-1612990196.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135519155-1738395535.png" alt=""></p><h2 id="创建项目："><a href="#创建项目：" class="headerlink" title="创建项目："></a>创建项目：</h2><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151116135534624-413319152.png" alt=""></p><p>一直下一步。</p><h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><p>可以成功安装到V2013上，但是却出现了下面的问题： Qt5Widgetsd.lib(Qt5Widgetsd.dll) : fatal error LNK1112: 模块计算机类型“x64”与目标计算机类型“X86”冲突</p><p><a href="http://jingyan.baidu.com/article/a948d65159d8890a2dcd2e84.html" target="_blank" rel="noopener">百度百科解决方法</a>：<a href="http://jingyan.baidu.com/article/a948d65159d8890a2dcd2e84.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/a948d65159d8890a2dcd2e84.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt-Creator&quot;&gt;&lt;a href=&quot;#Qt-Creator&quot; class=&quot;headerlink&quot; title=&quot;Qt Creator:&quot;&gt;&lt;/a&gt;Qt Creator:&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Qt" scheme="https://caojingyou.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Maven环境配置</title>
    <link href="https://caojingyou.github.io/2016/03/15/Maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://caojingyou.github.io/2016/03/15/Maven环境配置/</id>
    <published>2016-03-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载Maven"><a href="#1-下载Maven" class="headerlink" title="1.下载Maven:"></a>1.下载Maven:</h1><p>下载地址：<a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a></p><h1 id="2-安装-Maven"><a href="#2-安装-Maven" class="headerlink" title="2.安装 Maven"></a>2.安装 Maven</h1><p>如果需要使用到 Maven ，必须首先安装 Maven ， Maven 的下载地址在 Apache Maven 中有，您也可以点击这里下载 zip ,tar.gz。</p><p>下载好 Maven 后，需要简单安装下。将下载的  zip  或者  tar.gz  包解压到需要安装到的目录。 接下简单配置下环境变量：</p><ol><li>新建环境变量  M2_HOME  ,输入值为 Maven 的安装目录。</li><li>新建环境变量  M2  ，输入值为:  %M2_HOME%\bin  。</li><li>将 M2 环境变量加入  Path  的最后，如：  ;%M2%  ;。</li><li><p>环境变量就这么简单配置下就可以了。打开命令行窗口输入  mvn -version  。可以看到如下输出：</p><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151103151936539-1813106675.png" alt=""></p></li></ol><p>看到以上输出，您的 Maven 环境就已经搭建好了。</p><p>来源： <a href="http://maven.oschina.net/help.html" target="_blank" rel="noopener">http://maven.oschina.net/help.html</a></p><h1 id="3-配置eclipse"><a href="#3-配置eclipse" class="headerlink" title="3.配置eclipse:"></a>3.配置eclipse:</h1><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151103152011211-772620241.png" alt=""></p><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151103152029711-1972974655.png" alt=""></p><h1 id="4-设置JRE"><a href="#4-设置JRE" class="headerlink" title="4.设置JRE:"></a>4.设置JRE:</h1><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151103152055383-1622076243.png" alt=""></p><pre><code>-Dmaven.multiModuleProjectDirectory=$M2_HOME</code></pre><p>网址：<a href="http://www.cnblogs.com/yhcao/p/4901815.html" target="_blank" rel="noopener">http://www.cnblogs.com/yhcao/p/4901815.html</a></p><h1 id="5-为项目安装Maven"><a href="#5-为项目安装Maven" class="headerlink" title="5.为项目安装Maven:"></a>5.为项目安装Maven:</h1><p>选中选项右键</p><p><img src="http://images2015.cnblogs.com/blog/792271/201511/792271-20151103152154649-802120497.png" alt=""></p><p>如果出现错误，请检查网络。（公司网络不能访问外网，出错了，最后让网管开通外网才成功）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-下载Maven&quot;&gt;&lt;a href=&quot;#1-下载Maven&quot; class=&quot;headerlink&quot; title=&quot;1.下载Maven:&quot;&gt;&lt;/a&gt;1.下载Maven:&lt;/h1&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apache.org/&quot; 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Maven" scheme="https://caojingyou.github.io/tags/Maven/"/>
    
      <category term="eclipse" scheme="https://caojingyou.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下安装hadoop</title>
    <link href="https://caojingyou.github.io/2016/03/01/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85hadoop/"/>
    <id>https://caojingyou.github.io/2016/03/01/CentOS下安装hadoop/</id>
    <published>2016-03-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS下安装hadoop"><a href="#CentOS下安装hadoop" class="headerlink" title="CentOS下安装hadoop"></a>CentOS下安装hadoop</h1><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code>adduser hadooppasswd hadoop</code></pre><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h3><pre><code>chmod u+w /etc/sudoersvi /etc/sudoers在root    ALL=(ALL) ALL下添加hadoop    ALL=(ALL) ALLchmod u-w /etc/sudoers</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><h3 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h3><pre><code>service iptables status</code></pre><h3 id="关闭防火墙-1"><a href="#关闭防火墙-1" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><pre><code>service iptables stop</code></pre><h3 id="查看防火墙开机启动状态"><a href="#查看防火墙开机启动状态" class="headerlink" title="查看防火墙开机启动状态"></a>查看防火墙开机启动状态</h3><pre><code>chkconfig iptables --list</code></pre><h3 id="关闭防火墙开机启动"><a href="#关闭防火墙开机启动" class="headerlink" title="关闭防火墙开机启动"></a>关闭防火墙开机启动</h3><pre><code>chkconfig iptables off</code></pre><h2 id="安装JDK1-7"><a href="#安装JDK1-7" class="headerlink" title="安装JDK1.7"></a>安装JDK1.7</h2><h3 id="卸载系统自带OpenJDK"><a href="#卸载系统自带OpenJDK" class="headerlink" title="卸载系统自带OpenJDK"></a>卸载系统自带OpenJDK</h3><h4 id="查看目前系统jdk"><a href="#查看目前系统jdk" class="headerlink" title="查看目前系统jdk"></a>查看目前系统jdk</h4><pre><code>rpm -qa | grep jdk</code></pre><h4 id="得到结果："><a href="#得到结果：" class="headerlink" title="得到结果："></a>得到结果：</h4><pre><code>java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.51-2.4.5.5.el7.x86_64</code></pre><h4 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h4><pre><code>rpm -e --nodeps java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.51-2.4.5.5.el7.x86_64</code></pre><h3 id="下载JDK1-7"><a href="#下载JDK1-7" class="headerlink" title="下载JDK1.7"></a>下载JDK1.7</h3><p>下载地址： <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" title="jdk-7u79-linux-x64.tar.gz" target="_blank" rel="noopener">jdk-7u79-linux-x64.tar.gz</a> <a href="http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz" title="下载" target="_blank" rel="noopener">下载</a></p><h3 id="上传hadoop文件"><a href="#上传hadoop文件" class="headerlink" title="上传hadoop文件"></a>上传hadoop文件</h3><p>使用<a href="http://https//filezilla-project.org/" target="_blank" rel="noopener">Filezilla client</a>把jdk-7u79-linux-x64.tar.gz放到CentOS目录/usr/lib/jvm中(<a href="http://jingyan.baidu.com/article/219f4bf7d28185de442d38d2.html" target="_blank" rel="noopener">史上最简单的上传文件到linux系统方法</a>)</p><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><pre><code>sudo chmod u+x jdk-7u79-linux-x64.tar.gz</code></pre><h3 id="解压JDK1-7"><a href="#解压JDK1-7" class="headerlink" title="解压JDK1.7"></a>解压JDK1.7</h3><pre><code>cd /usr/lib/jvmsudo tar -zxvf ./jdk-7u79-linux-x64.tar.gz  -C /usr/lib/jvm  </code></pre><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="打开profile文件："><a href="#打开profile文件：" class="headerlink" title="打开profile文件："></a>打开profile文件：</h4><pre><code>sudo gedit /etc/profile</code></pre><h4 id="在文件最下边输入："><a href="#在文件最下边输入：" class="headerlink" title="在文件最下边输入："></a>在文件最下边输入：</h4><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_4579export JRE_HOME=/usr/lib/jvm/jdk1.7.0_4579/jreexport CLASSPATH=.:$JRE_HOME/lib/tr.jar:$JAVA_HOME/lib:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$PATH</code></pre><h4 id="使其立刻生效："><a href="#使其立刻生效：" class="headerlink" title="使其立刻生效："></a>使其立刻生效：</h4><pre><code>source /etc/profile</code></pre><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><pre><code>java -version</code></pre><h3 id="手动设置系统默认JDK"><a href="#手动设置系统默认JDK" class="headerlink" title="手动设置系统默认JDK"></a>手动设置系统默认JDK</h3><pre><code>sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_79/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.7.0_79/bin/javac 300sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.7.0_79/bin/jar 300sudo update-alternatives --config java</code></pre><h2 id="配置SSH免密码登陆"><a href="#配置SSH免密码登陆" class="headerlink" title="配置SSH免密码登陆"></a>配置SSH免密码登陆</h2><h3 id="进入用户的根目录下"><a href="#进入用户的根目录下" class="headerlink" title="进入用户的根目录下"></a>进入用户的根目录下</h3><pre><code>ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsacat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre><h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><pre><code>ssh -version</code></pre><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><pre><code>ssh localhost</code></pre><h2 id="安装Hadoop2-6-0"><a href="#安装Hadoop2-6-0" class="headerlink" title="安装Hadoop2.6.0"></a>安装Hadoop2.6.0</h2><h3 id="下载hadoop2-6"><a href="#下载hadoop2-6" class="headerlink" title="下载hadoop2.6"></a>下载hadoop2.6</h3><p><a href="http://mirrors.hust.edu.cn/apache/hadoop/common/stable/hadoop-2.6.0.tar.gz" target="_blank" rel="noopener">hadoop-2.6.0.tar.gz</a></p><h3 id="解压hadoop-2-6-0-tar-gz"><a href="#解压hadoop-2-6-0-tar-gz" class="headerlink" title="解压hadoop-2.6.0.tar.gz"></a>解压hadoop-2.6.0.tar.gz</h3><h4 id="进入-usr-local-hadoop"><a href="#进入-usr-local-hadoop" class="headerlink" title="进入/usr/local/hadoop"></a>进入/usr/local/hadoop</h4><pre><code>sudo tar -zxvf ./hadoop-2.6.0.tar.gz -C /usr/localcd /usr/local/sudo mv ./hadoop-2.6.0/ ./hadoopsudo chown -R hadoop:hadoop ./hadoop</code></pre><h3 id="配置hadoop2-6-0环境"><a href="#配置hadoop2-6-0环境" class="headerlink" title="配置hadoop2.6.0环境"></a>配置hadoop2.6.0环境</h3><h4 id="打开profile"><a href="#打开profile" class="headerlink" title="打开profile"></a>打开profile</h4><pre><code>sudo gedit /etc/profile</code></pre><h3 id="在最下边添加："><a href="#在最下边添加：" class="headerlink" title="在最下边添加："></a>在最下边添加：</h3><pre><code># set hadoop pathexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><h4 id="使其立刻生效：-1"><a href="#使其立刻生效：-1" class="headerlink" title="使其立刻生效："></a>使其立刻生效：</h4><pre><code>source /etc/profile</code></pre><h3 id="修改-usr-local-hadoop-etc-hadoop-hadoop-env-sh"><a href="#修改-usr-local-hadoop-etc-hadoop-hadoop-env-sh" class="headerlink" title="修改/usr/local/hadoop/etc/hadoop/hadoop-env.sh"></a>修改/usr/local/hadoop/etc/hadoop/hadoop-env.sh</h3><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_79</code></pre><h2 id="伪分布式Hadoop2-6-0配置"><a href="#伪分布式Hadoop2-6-0配置" class="headerlink" title="伪分布式Hadoop2.6.0配置"></a>伪分布式Hadoop2.6.0配置</h2><h3 id="etc-hadoop-core-site-xml"><a href="#etc-hadoop-core-site-xml" class="headerlink" title="etc / hadoop / core-site.xml:"></a>etc / hadoop / core-site.xml:</h3><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="etc-hadoop-hdfs-site-xml"><a href="#etc-hadoop-hdfs-site-xml" class="headerlink" title="etc / hadoop / hdfs-site.xml:"></a>etc / hadoop / hdfs-site.xml:</h3><pre><code>&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h2 id="启动Hadoop2-6-0"><a href="#启动Hadoop2-6-0" class="headerlink" title="启动Hadoop2.6.0"></a>启动Hadoop2.6.0</h2><h3 id="进入hadoop的bin目录"><a href="#进入hadoop的bin目录" class="headerlink" title="进入hadoop的bin目录"></a>进入hadoop的bin目录</h3><pre><code>cd /usr/local/hadoop/bin</code></pre><h3 id="格式化Hadoop的文件系统HDFS"><a href="#格式化Hadoop的文件系统HDFS" class="headerlink" title="格式化Hadoop的文件系统HDFS"></a>格式化Hadoop的文件系统HDFS</h3><pre><code>hdfs namenode -format</code></pre><h3 id="进入hadoop的sbin目录"><a href="#进入hadoop的sbin目录" class="headerlink" title="进入hadoop的sbin目录"></a>进入hadoop的sbin目录</h3><pre><code>cd /usr/local/hadoop/sbin</code></pre><h3 id="启动所有进程"><a href="#启动所有进程" class="headerlink" title="启动所有进程"></a>启动所有进程</h3><pre><code>start-all.sh</code></pre><p>成功的话，会看到 successfully formatted 的提示，且倒数第5行的提示如下，Exitting with status 0 表示成功，若为 Exitting with status 1 则是出错。若出错（不该如此，请仔细检查之前步骤），可试着加上 sudo, 既 sudo bin/hdfs namenode -format 再试试看。</p><h3 id="关闭命令"><a href="#关闭命令" class="headerlink" title="关闭命令"></a>关闭命令</h3><pre><code>stop-all.sh</code></pre><h3 id="用jps查看启动的进程"><a href="#用jps查看启动的进程" class="headerlink" title="用jps查看启动的进程"></a>用jps查看启动的进程</h3><pre><code>JpsResourceManagerNameNodeDataNodeSecondaryNameNodeNodeManager</code></pre><h2 id="浏览器访问：http-localhost-50070"><a href="#浏览器访问：http-localhost-50070" class="headerlink" title="浏览器访问：http://localhost:50070"></a>浏览器访问：<a href="http://localhost:50070" target="_blank" rel="noopener">http://localhost:50070</a></h2><h2 id="hadoop进程管理页面http-localhost-8088"><a href="#hadoop进程管理页面http-localhost-8088" class="headerlink" title="hadoop进程管理页面http://localhost:8088"></a>hadoop进程管理页面<a href="http://localhost:8088" target="_blank" rel="noopener">http://localhost:8088</a></h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code></pre><p>原因是hadoop-2.6.0.tar.gz安装包是在32位机器上编译的，64位的机器加载本地库.so文件时出错，不影响使用。</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><pre><code>1、重新编译源码后将新的lib/native替换到集群中原来的lib/native2、修改hadoop-env.sh ，增加export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_PREFIX/lib:$HADOOP_PREFIX/lib/native&quot;</code></pre><hr><h4 id="文档参考："><a href="#文档参考：" class="headerlink" title="文档参考："></a>文档参考：</h4><ol><li><a href="http://www.aboutyun.com/thread-10554-1-1.html" target="_blank" rel="noopener">hadoop 2.6.0单节点-伪分布式模式安装</a></li><li><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/singlecluster.html" target="_blank" rel="noopener">Hadoop:设置一个节点集群</a></li><li><a href="http://www.powerxing.com/install-hadoop/" target="_blank" rel="noopener">Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04</a></li><li><a href="http://www.linuxidc.com/linux/2015-03/114669.htm" target="_blank" rel="noopener">Hadoop入门基础教程之服务器基础环境搭建</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CentOS下安装hadoop&quot;&gt;&lt;a href=&quot;#CentOS下安装hadoop&quot; class=&quot;headerlink&quot; title=&quot;CentOS下安装hadoop&quot;&gt;&lt;/a&gt;CentOS下安装hadoop&lt;/h1&gt;&lt;h2 id=&quot;用户配置&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="CentOS" scheme="https://caojingyou.github.io/tags/CentOS/"/>
    
      <category term="hadoop" scheme="https://caojingyou.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="https://caojingyou.github.io/2016/02/15/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://caojingyou.github.io/2016/02/15/搭建个人博客/</id>
    <published>2016-02-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>  </p><h1 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h1><p>根据：<a href="http://isnowfy.github.io/about-simple-cn.html" target="_blank" rel="noopener">用静态页面生成静态博客 </a> </p><h1 id="个性化博客"><a href="#个性化博客" class="headerlink" title="个性化博客"></a>个性化博客</h1><h2 id="做自己的simple"><a href="#做自己的simple" class="headerlink" title="做自己的simple:"></a>做自己的simple:</h2><p>根据：<a href="http://isnowfy.github.io/about-simple.html" target="_blank" rel="noopener">About Simple</a></p><p>先fork，push到你fork之后的你的simple项目下,然后把src文件夹push到gh-pages分支</p><pre><code>The template files are at /src/template, so you can modify the template files and css files. If you want use your own theme you can clone the project, modify the template files and push the entire src folder in your gh-pages branch which will allow you generate your own static blog.  </code></pre><h2 id="改名称："><a href="#改名称：" class="headerlink" title="改名称："></a>改名称：</h2><pre><code>You can use your own blog name, just modify the main.json file, and change name=&quot;username&quot;.  </code></pre><h2 id="设置disqus："><a href="#设置disqus：" class="headerlink" title="设置disqus："></a>设置disqus：</h2><pre><code>You can use disqus comment system, just modify the main.json file, and change disqus_shortname=&quot;&quot; to disqus_shortname=&quot;your_shortname&quot;. </code></pre><p>实测要改成disqus_shortname=”Login”才能加载</p><p>登录disqus： <a href="https://disqus.com/" target="_blank" rel="noopener">https://disqus.com/</a><br>在设置中的Website中填入博客地址  </p><h2 id="添加多说评论系统："><a href="#添加多说评论系统：" class="headerlink" title="添加多说评论系统："></a>添加多说评论系统：</h2><h3 id="登录多说评论系统：http-duoshuo-com"><a href="#登录多说评论系统：http-duoshuo-com" class="headerlink" title="登录多说评论系统：http://duoshuo.com/"></a>登录多说评论系统：<a href="http://duoshuo.com/" target="_blank" rel="noopener">http://duoshuo.com/</a></h3><p>可知，在页面中加入以下代码即可：</p><pre><code>&lt;!-- 多说评论框 start --&gt;    &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = {short_name:&quot;yhcao&quot;};    (function() {        var ds = document.createElement(&apos;script&apos;);        ds.type = &apos;text/javascript&apos;;ds.async = true;        ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;        ds.charset = &apos;UTF-8&apos;;        (document.getElementsByTagName(&apos;head&apos;)[0]          || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);    })();    &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;</code></pre><h3 id="修改自己simple项目的模版post-html"><a href="#修改自己simple项目的模版post-html" class="headerlink" title="修改自己simple项目的模版post.html"></a>修改自己simple项目的模版post.html</h3><pre><code>&lt;div class=&quot;entry&quot; id=&quot;main&quot;&gt;</code></pre><p>后添加：</p><pre><code>&lt;div class=&quot;duoshuo-div&quot; id=&quot;duoshuo-div&quot;&gt;&lt;!-- 多说评论框 start &lt;div class=&quot;ds-thread&quot; Id=&quot;data-duoshuo&quot; data-thread-key=&quot;ID&quot; data-title=&quot;标题&quot; data-url=&quot;http://caojingyou.github.io&quot;&gt;&lt;/div&gt; --&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = {short_name:&quot;yhcao&quot;};    (function() {        var ds = document.createElement(&apos;script&apos;);        ds.type = &apos;text/javascript&apos;;ds.async = true;        ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;        ds.charset = &apos;UTF-8&apos;;        (document.getElementsByTagName(&apos;head&apos;)[0]          || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);    })();    &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;&lt;/div&gt;&lt;script id=&quot;pagesTemplate&quot; type=&quot;text/mustache&quot;&gt;</code></pre><p>后添加：</p><pre><code>&lt;script id=&quot;duoshuo-sc&quot; type=&quot;text/mustache&quot;&gt;&lt;div class=&quot;ds-thread&quot; Id=&quot;data-duoshuo&quot; data-thread-key=&quot;{{key}}&quot; data-title=&quot;{{title}}&quot; data-url=&quot;博客网址{{url}}&quot;&gt;&lt;/div&gt;&lt;/script&gt;$(&quot;#main&quot;).prepend(contentHtml);</code></pre><p>后添加：</p><pre><code>var duoshuoTemplate = Hogan.compile($(&quot;#duoshuo-sc&quot;).html());var duoshuoHtml = duoshuoTemplate.render({&quot;key&quot;: path, &quot;title&quot;: post.title, &quot;url&quot;: path});$(&quot;#duoshuo-div&quot;).prepend(duoshuoHtml);</code></pre><h3 id="添加百度站内搜索："><a href="#添加百度站内搜索：" class="headerlink" title="添加百度站内搜索："></a>添加百度站内搜索：</h3><p>进入百度站长平台<br>按照<a href="http://gengbiao.me/2014/10/22/hexo%e6%b7%bb%e5%8a%a0%e7%99%be%e5%ba%a6%e7%ab%99%e5%86%85%e6%90%9c%e7%b4%a2/#" target="_blank" rel="noopener">百度站内搜索</a>所讲进行操作即可</p><h3 id="添加swiftype站内搜索："><a href="#添加swiftype站内搜索：" class="headerlink" title="添加swiftype站内搜索："></a>添加swiftype站内搜索：</h3><p>在github中百度站内搜索不识别，所有添加了swiftype而放弃百度。<br>网站地址：<a href="https://swiftype.com/" target="_blank" rel="noopener">https://swiftype.com/</a></p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="noopener">创建GitHub技术博客全攻略</a><br><a href="http://isnowfy.github.io/about-simple-cn.html" target="_blank" rel="noopener">用静态页面生成静态博客</a><br><a href="http://isnowfy.github.io/about-simple.html" target="_blank" rel="noopener">About Simple</a><br><a href="http://www.freehao123.com/github-farbox-dropbox/" target="_blank" rel="noopener">Github空间在线写文章和用Farbox,Droppages在Dropbox建博客网站</a><br><a href="http://gengbiao.me/2014/10/22/hexo%e6%b7%bb%e5%8a%a0%e7%99%be%e5%ba%a6%e7%ab%99%e5%86%85%e6%90%9c%e7%b4%a2/#" target="_blank" rel="noopener">百度站内搜索</a><br><a href="http://blog.csdn.net/v123411739/article/details/45092871" target="_blank" rel="noopener">使用swiftype实现站内搜索</a><br><a href="http://https//swiftype.com/documentation/sitemap" target="_blank" rel="noopener">Sitemap.xml Support</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注册GitHub账号&quot;&gt;&lt;a href=&quot;#注册GitHub账号&quot; class=&quot;headerlink&quot; title=&quot;注册GitHub账号&quot;&gt;&lt;/a&gt;注册GitHub账号&lt;/h1&gt;&lt;p&gt;地址：&lt;a href=&quot;https://github.com/&quot; targe
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Github Pages" scheme="https://caojingyou.github.io/tags/Github-Pages/"/>
    
      <category term="GitHub" scheme="https://caojingyou.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>我喜爱的火狐浏览器插件</title>
    <link href="https://caojingyou.github.io/2016/02/01/%E6%88%91%E5%96%9C%E7%88%B1%E7%9A%84%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2016/02/01/我喜爱的火狐浏览器插件/</id>
    <published>2016-02-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:18.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="书签管理"><a href="#书签管理" class="headerlink" title="书签管理"></a>书签管理</h3><p>xmarks<br><a href="https://download.xmarks.com/download/firefox" target="_blank" rel="noopener">https://download.xmarks.com/download/firefox</a></p><hr><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>LastPass Password Manager<br><a href="https://lastpass.com/" target="_blank" rel="noopener">https://lastpass.com/</a>  </p><hr><h3 id="离线阅读器"><a href="#离线阅读器" class="headerlink" title="离线阅读器"></a>离线阅读器</h3><p>Instaright<br><a href="https://addons.mozilla.org/en-US/firefox/addon/instaright-social-bookmarks/" target="_blank" rel="noopener">https://addons.mozilla.org/en-US/firefox/addon/instaright-social-bookmarks/</a><br><a href="https://www.instapaper.com/u" target="_blank" rel="noopener">https://www.instapaper.com/u</a>  </p><hr><h3 id="Readablity"><a href="#Readablity" class="headerlink" title="Readablity"></a>Readablity</h3><p><a href="https://www.readability.com/addons" target="_blank" rel="noopener">https://www.readability.com/addons</a><br><a href="https://www.readability.com/" target="_blank" rel="noopener">https://www.readability.com/</a>  </p><hr><h3 id="Pocket"><a href="#Pocket" class="headerlink" title="Pocket"></a>Pocket</h3><p><a href="https://activations.cdn.mozilla.net/en-US/pocket.html" target="_blank" rel="noopener">https://activations.cdn.mozilla.net/en-US/pocket.html</a>  </p><hr><h3 id="有道网页翻译"><a href="#有道网页翻译" class="headerlink" title="有道网页翻译"></a>有道网页翻译</h3><p><a href="http://mozilla.com.cn/thread-52722-1-1.html" target="_blank" rel="noopener">http://mozilla.com.cn/thread-52722-1-1.html</a>  </p><hr><h3 id="网页截图"><a href="#网页截图" class="headerlink" title="网页截图"></a>网页截图</h3><p><a href="https://addons.mozilla.org/zh-CN/firefox/addon/easyscreenshot/?src=userprofile" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/addon/easyscreenshot/?src=userprofile</a><br><a href="http://mozilla.com.cn/thread-230325-1-1.html" target="_blank" rel="noopener">http://mozilla.com.cn/thread-230325-1-1.html</a>  </p><hr><h3 id="为知笔记"><a href="#为知笔记" class="headerlink" title="为知笔记"></a>为知笔记</h3><p><a href="https://addons.mozilla.org/zh-Cn/firefox/addon/wiznote-web-clipper/?src=userprofile" target="_blank" rel="noopener">https://addons.mozilla.org/zh-Cn/firefox/addon/wiznote-web-clipper/?src=userprofile</a>  </p><hr><h3 id="Evernote-Web-Clipper-and-Evernote-Clearly"><a href="#Evernote-Web-Clipper-and-Evernote-Clearly" class="headerlink" title="Evernote Web Clipper and Evernote Clearly"></a>Evernote Web Clipper and Evernote Clearly</h3><p><a href="https://addons.mozilla.org/zh-CN/firefox/user/evernote-corp/?src=api" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/user/evernote-corp/?src=api</a>  </p><hr><h3 id="Todoist"><a href="#Todoist" class="headerlink" title="Todoist"></a>Todoist</h3><p><a href="https://addons.mozilla.org/zh-CN/firefox/user/todoist/?src=api" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/user/todoist/?src=api</a>  </p><hr><h3 id="滴答清单"><a href="#滴答清单" class="headerlink" title="滴答清单"></a>滴答清单</h3><p><a href="https://addons.mozilla.org/zh-CN/firefox/user/appest/?src=api" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/user/appest/?src=api</a></p><h3 id="onetab-标签页转换成一个列表"><a href="#onetab-标签页转换成一个列表" class="headerlink" title="onetab 标签页转换成一个列表"></a>onetab 标签页转换成一个列表</h3><p><a href="https://www.one-tab.com/" target="_blank" rel="noopener">https://www.one-tab.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;书签管理&quot;&gt;&lt;a href=&quot;#书签管理&quot; class=&quot;headerlink&quot; title=&quot;书签管理&quot;&gt;&lt;/a&gt;书签管理&lt;/h3&gt;&lt;p&gt;xmarks&lt;br&gt;&lt;a href=&quot;https://download.xmarks.com/download/firefo
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="火狐" scheme="https://caojingyou.github.io/tags/%E7%81%AB%E7%8B%90/"/>
    
      <category term="浏览器插件" scheme="https://caojingyou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编辑器使用法术</title>
    <link href="https://caojingyou.github.io/2016/01/21/Markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%B3%95%E6%9C%AF/"/>
    <id>https://caojingyou.github.io/2016/01/21/Markdown编辑器使用法术/</id>
    <published>2016-01-21T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用Markdown编辑器写博客"><a href="#欢迎使用Markdown编辑器写博客" class="headerlink" title="欢迎使用Markdown编辑器写博客"></a>欢迎使用Markdown编辑器写博客</h1><p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit" target="_blank" rel="noopener">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code> </li><li>斜体    <code>Ctrl + I</code> </li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="noopener">链接</a>等，详细语法参考帮助？。</p><p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra" target="_blank" rel="noopener">Github</a>.  </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 元</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 元</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 元</td><td style="text-align:center">234</td></tr></tbody></table><p>###定义列表</p><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p><p>项目３<br>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure></p><p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="noopener">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p><p>博客发表后，本地缓存将被删除。　</p><p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p></blockquote><p>##浏览器兼容</p><ol><li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li><li>IE９以下不支持</li><li>IE９，１０，１１存在以下问题<ol><li>不支持离线功能</li><li>IE9不支持文件导入导出</li><li>IE10不支持拖拽文件导入</li></ol></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎使用Markdown编辑器写博客&quot;&gt;&lt;a href=&quot;#欢迎使用Markdown编辑器写博客&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用Markdown编辑器写博客&quot;&gt;&lt;/a&gt;欢迎使用Markdown编辑器写博客&lt;/h1&gt;&lt;p&gt;本Markd
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Markdown" scheme="https://caojingyou.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>ABOUT ME</title>
    <link href="https://caojingyou.github.io/2016/01/01/ABOUT%20ME/"/>
    <id>https://caojingyou.github.io/2016/01/01/ABOUT ME/</id>
    <published>2016-01-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.034Z</updated>
    
    <content type="html"><![CDATA[<p>You can also find me here.</p><p><a href="http://caojingyou.github.io/" target="_blank" rel="noopener">caojingyou.github.io</a></p><p><a href="https://github.com/CAOJINGYOU" target="_blank" rel="noopener">caojingyou@github</a></p><p><a href="http://weibo.com/chihun" target="_blank" rel="noopener">caojingyou@weibo</a></p><p><a href="http://blog.csdn.net/chihun_love" target="_blank" rel="noopener">caojingyou@csdn</a></p><p><a href="https://www.gitbook.com/@caojingyou" target="_blank" rel="noopener">caojingyou@GitBook</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;You can also find me here.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://caojingyou.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;caojingyou.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="ABOUT ME" scheme="https://caojingyou.github.io/tags/ABOUT-ME/"/>
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
