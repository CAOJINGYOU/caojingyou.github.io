<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曹景游</title>
  <icon>https://www.gravatar.com/avatar/404413bf834782c83904fd110c940e38</icon>
  <subtitle>曹景游</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caojingyou.github.io/"/>
  <updated>2018-09-03T02:15:49.642Z</updated>
  <id>https://caojingyou.github.io/</id>
  
  <author>
    <name>yhcao</name>
    <email>caojingyoump@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux从入门到精通</title>
    <link href="https://caojingyou.github.io/2018/09/01/Linux%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>https://caojingyou.github.io/2018/09/01/Linux从入门到精通/</id>
    <published>2018-09-01T10:14:00.000Z</published>
    <updated>2018-09-03T02:15:49.642Z</updated>
    
    <content type="html"><![CDATA[<p>桌面：Gnome和KDE</p><p>windows下常用刻录软件Nero</p><p>Linux默认使用的操作系统引导加载器Grub,可重装Grub</p><p>用户可执行不带参数的su命令将自己提升为root权限，另一个命令行工具是sudo，它可以临时使用root身份运行一个程序，运行完毕后返回普通用户状态</p><p>Ubuntu附带编辑器gedit</p><p>Windows Maker,FVWM,IceWM,Sawfish等是目前比较常见的窗口管理器。</p><p>通过命令行运行startx命令启动X服务器。</p><p>桌面环境的引导脚本是一段Linux命令组成的脚本程序Xsession</p><p>KDE是用C++编写的，基于Qt库。</p><p>Gnome是C语言写成的，基于GTK+widget库。</p><p>Shell命令行：pwd,cd,ls,dir,vdir</p><p>查看文本文件：cat,more,head,tail</p><p>更好的文本阅读工具：less</p><p>查找文件内容：grep</p><p>找文件：find</p><p>更快速定位文件：locate</p><p>查找特定程序：whereis</p><p>用户以及版本信息：who,whoami,uname -a,uname -r</p><p>帮助：man</p><p>获取命令简介：whatis,apropos</p><p>改变文件所有权：chown,chgrp</p><p>改变文件权限：chmod</p><p>建立链接：ln</p><p>重定向与管道：&lt;,&gt;,|</p><p>SUSE,Red Hat,Fedora等发行版本使用RPM,而Debian,Ubuntu使用.deb格式的软件包。</p><p>对于Debian，Ubuntu:sudo dpkg -i</p><p>对于openSUSE和其他使用RPM软件包：rpm -ivh</p><p>高级软件包管理工具APT,yum可自动搜寻依赖关系并执行安装。</p><p>管理.deb软件包：dpkg</p><p>管理RPM软件包：rpm</p><p>高级软件包工具:APT:apt-get update,pat-get install,apt-get upgrade,apt-get remove,apt-get source,apt-get clean,apt-cache search，apt-cachedepends</p><p>MPlayer开源多媒体播放软件，支持Linux,Windows,Mac OS.</p><p>从源代码编译软件：</p><p>下载解压：tar</p><p>configure依据用户提供的参数生产对于的makefile文件：./configure –prefix=</p><p>编译源代码：make</p><p>安装：sudo make install</p><p>swap交换分区，分区容量应该大于物理大小，但目前不能超过2GB</p><p>挂载文件系统：mount,umount</p><p>查看磁盘使用情况:df</p><p>检查和修复文件系统:fsck</p><p>在磁盘上建立文件系统：mkfs</p><p>列出当前内核发现的USB设备：lsusb</p><p>压缩工具：gzip,bzip2,RAR for linux</p><p>存档工具:tar,dd</p><p>建立分区表工具：fdisk</p><p>建立ext3fs文件系统：mkfs</p><p>创建并激活较好分区：mkswap</p><p>高级硬盘管理工具：RAID,LVM</p><p>备份工作与系统工具：dump,restore</p><p>定时自动完成：cron</p><p>添加用户useradd,groupadd</p><p>记录用户操作:history</p><p>直接编辑passwd,shadow</p><p>管理用户：usermod</p><p>受限的特权：sudo,配置/etc/sudoers指定用户可以执行的特权命令。修改sudoers文件应该使用visudo命令</p><p>监视进程：ps aux,ps lax</p><p>即时跟踪进程信息：top</p><p>查看占用文件进程：lsof</p><p>向进程发生信号：kill</p><p>调整进程的谦让度：nice,renice</p><p>/PROC文件系统：目录下存放内核系统状态的各种有意义信息。</p><p>使用ifconfig配置网络接口</p><p>使用route配置静态路由</p><p>netstat -r命令看当前系统中的路由信息</p><p>使用wvdial建立PPP连接</p><p>浏览器：firefox,opera</p><p>基于文本的浏览器：lynx</p><p>Gnome下的邮件客户端：Evolution,Thunderbird</p><p>KDE邮件客户端：Kmail</p><p>Linux间的网络硬盘：NFS,使用mount挂载</p><p>与windows协作：Samba</p><p>查看当前可使用的Samba资源：smbtree,nmblookup</p><p>Linux下的Samba客户端：smbclient</p><p>挂载共享目录：mount.cifs，将windows共享目录挂载到本地某目录下</p><p>使用FTP:FileZilla</p><p>ftp命令：get,mget,prompt off,put,lcd</p><p>基于SSH的文件传输：sftp,scp</p><p>远程登录：</p><p>OpenSSH是linux下最常用的SSH服务器与客户端软件</p><p>VNC可用于图形化得登录：vnc4server</p><p>安装：速冻apt-getinstallvnc4-common vnc4server</p><p>SUSE防火墙，允许DHCPv4服务器和dnsmasq</p><p>SSH：ssh -l login_name hostname</p><p>SSH默认开启22号端口，可通过-p选项指定要连接的端口。</p><p>登录X窗口系统：图形化得VNC</p><p>SSH连接远程主机，运行vncserver生成配置文件，使用vncviewer跨平台的VNC客户端工具，执行vncviewer ip-address:1</p><p>从windows登录Linux，window上有几种不同的SSH客户端，其中开源的PuTTY是使用最广泛的。window版vncviewer.</p><p>从Linux登录到windows：1.windows安装VNC Server软件。2.通过RDP协议连接到windows,下载rdesktop</p><p>xine是linux中最著名的播放软件之一。另一款播放引擎叫做gstreamer.</p><p>播放器：Rhythmbox,amarok,MPlayer</p><p>比较流行的音乐文件格式：MP3,WMA,MIDI</p><p>linux上使用的Ogg，完全免费开源。</p><p>使用Konqueror和Nautilus，GIMP,Shotwell查看图片。</p><p>LibreOffice绘图工具。</p><p>打印机语言：PDL</p><p>PostScript,PCL5,PCL6和PDF是如今最知名的PDL.</p><p>CUPS打印系统</p><p>设置当前用户的默认打印机：lpoptions</p><p>测试打印机：lpr</p><p>管理CUPS服务器：</p><p>CUPS的配置文件cupsd.conf</p><p>显示当前CUPS的状态：lpstat -t</p><p>办公软件：LibreOffice,Xpdf，Adobe Reader</p><p>光盘刻录：Gnome下B染色肉，KDE下K3b</p><p>Linux编程：</p><p>编辑器：Vim,Emacs</p><p>Gnome下的编辑器gedit</p><p>C和C++的编译器：gcc,同时支持C,C++,Objective C,Chill,Fortran和Java</p><p>gcc:-c,-S,-E,-g</p><p>优化选项:-O1,-O2,-O3</p><p>gcc -O2</p><p>编译C++程序：C++</p><p>调试gdb:gdb -g</p><p>list命令可指定代码行号</p><p>gdb提供search命令搜索特定内容</p><p>设置断点：break , info break, clear</p><p>运行程序和单步执行：run,next,continue</p><p>监视变量：print,watch</p><p>临时修改变量：set var</p><p>查看堆栈情况：bt</p><p>退出gdb:quit</p><p>版本控制系统：Subversion</p><p>svnadmin create,svn import,svn checkout,svn co,svn status, svn diff,svn commint,svn lig,svn update,svn resolved,svn merge</p><p>Shel编程</p><p>GNU/Linux中有两套库可用于正则表达式，POSIX和PCRE</p><p>图形化得gedit和kate支持Shell脚本语法加亮。</p><p>Shell编程工具：source,export,for,$[],expr,let,if,case,;;,test,文件测试，数字比较，复合表达式，while,until,read,exit,trap,命令表的表示形式，cut,diff,sort,uniq,tr,wc,substr,seq,printenv,mypr,alias</p><p>个性化设置：修改.bashrc文件</p><p>立刻生效：source .bashrc</p><p>服务器配置：</p><p>inetd和xinetd管理守护进程。</p><p>HTTP服务器-Apache</p><p>设置Apache服务器：配置文件httpd.conf</p><p>日子文件：</p><p>cgi公共网关接口，定义了Web服务器和外接程序交互的接口，是网站上实现动态页面的最简单和常用方法。httpd.conf文件，可以找到下边命令：ScriptAlias /cgi-bin/ /usr/local/apache2/cgi-bin/</p><p>使用PHP+MySQL</p><p>LAMP:Linux,Apache,MySQL,PHP</p><p>FTP服务器-vsftpd</p><p>除了standalone方式运行FTP服务器，还可以配置以xinetd来管理vsftpd。</p><p>vsftpd匿名用户，本地用户，虚拟用户。</p><p>在非匿名应用方面，有基于SSH的sftp.</p><p>Samba服务：sudo apt-get install samba-common samba</p><p>从源代码安装：tar,./autogen.sh,./configure,make,sudo make install</p><p>Samba配置：smb.conf全局设置和共享定义。</p><p>create mask设置用户在共享目录中创建文件所使用的权限。</p><p>可孤立用户的共享目录</p><p>SWAT管理工具，为Samba服务器提供图形管理。</p><p>网络硬盘- NFS</p><p>安装NFS服务器：sudo apt-get install nfs-common nfs-kernel-server</p><p>配置文件/etc/exports,在末尾添加：/srv/nfs_share *(rw)</p><p>NFS使用RPC作为自己的传输协议</p><p>监视NFS状态：nfsstat</p><p>任务计划：cron</p><p>配置/etc/crontab文件</p><p>sudo /etc/init.d/cron restart</p><p>可放到/etc/cron.d目录，还有/etc/cron.hourly,/etc/cron.daily,/etc/cron.weekly,/etc/cron.monthly</p><p>普通用户在获得管理员批准后也可以定制自己的任务计划，每个咏鹅的cron配置文件保存在/var/spool/cron目录下，SUSE在/var/spool/cron/tabs目录下</p><p>简单定时：at命令</p><p>使用atq命令可以看到当前已经设置的任务</p><p>atrm 删除任务</p><p>Linux防火墙 IP Tables</p><p>iptables命令最常用的5个选项：-F,-P,-A,-D,-L</p><p>扫描网络端口：nmap</p><p>找出不安全的口令：John the Ripper</p><p>对于那些包含主机访问控制hosts_access功能服务（典型的有xinetd,sshd），Linux提供了除防火墙之外另一种来源控制方案，在/etc目录下有两个文件hosts.allow和hosts.deny.</p><p>掩盖入侵痕迹：rootkits</p><p>linux下防病毒软件：ClamAV</p><p>ClamAV也提供图形化工具：sudo apt-get install clamtk</p><p>附录：Linux常用指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桌面：Gnome和KDE&lt;/p&gt;
&lt;p&gt;windows下常用刻录软件Nero&lt;/p&gt;
&lt;p&gt;Linux默认使用的操作系统引导加载器Grub,可重装Grub&lt;/p&gt;
&lt;p&gt;用户可执行不带参数的su命令将自己提升为root权限，另一个命令行工具是sudo，它可以临时使用root
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Linux" scheme="https://caojingyou.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://caojingyou.github.io/2018/08/14/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://caojingyou.github.io/2018/08/14/TCP IP网络编程/</id>
    <published>2018-08-14T10:04:00.000Z</published>
    <updated>2018-09-17T02:54:48.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/column/details/13478.html" target="_blank" rel="noopener">网络通信编程</a></p><p><a href="https://blog.csdn.net/column/details/19222.html" target="_blank" rel="noopener">Windows网络模型</a></p><p><a href="https://blog.csdn.net/column/details/18557.html" target="_blank" rel="noopener">网络协议</a></p><h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><p>《TCP/IP网络编程》</p><p>《Windows网络编程》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/column/details/13478.html&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="网络编程" scheme="https://caojingyou.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP/IP" scheme="https://caojingyou.github.io/tags/TCP-IP/"/>
    
      <category term="SOCKET" scheme="https://caojingyou.github.io/tags/SOCKET/"/>
    
  </entry>
  
  <entry>
    <title>个人喜欢的工具</title>
    <link href="https://caojingyou.github.io/2018/08/08/%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://caojingyou.github.io/2018/08/08/个人喜欢的工具/</id>
    <published>2018-08-08T10:23:00.000Z</published>
    <updated>2018-08-08T10:36:11.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zeal"><a href="#Zeal" class="headerlink" title="Zeal"></a>Zeal</h1><p><a href="https://zealdocs.org/" target="_blank" rel="noopener">Zeal</a>是一款面向软件开发人员的离线文档浏览器。</p><p><a href="https://zealdocs.org/download.html#windows" target="_blank" rel="noopener">https://zealdocs.org/download.html#windows</a></p><p><a href="https://github.com/deerawan/vscode-dash" target="_blank" rel="noopener">Visual Studio Code插件</a></p><p>安装Zeal后，转到Tools⟶ Docsets浏览并下载docsets。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Zeal&quot;&gt;&lt;a href=&quot;#Zeal&quot; class=&quot;headerlink&quot; title=&quot;Zeal&quot;&gt;&lt;/a&gt;Zeal&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zealdocs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="工具" scheme="https://caojingyou.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>MFC</title>
    <link href="https://caojingyou.github.io/2018/08/05/MFC/"/>
    <id>https://caojingyou.github.io/2018/08/05/MFC/</id>
    <published>2018-08-05T02:39:00.000Z</published>
    <updated>2018-08-06T01:07:16.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MFC创建选项"><a href="#MFC创建选项" class="headerlink" title="MFC创建选项"></a>MFC创建选项</h1><p>复合文档支持的各选项功能如下：</p><pre><code>◆ 无复合文档支持：即无OLE（Object Linking and Embedding，对象连接与嵌入）支持。 ◆ 容器支持：将对象嵌入或链接至文档，以便用户编辑。◆ 袖珍服务器：表示应用程序可创建和管理复合文档对象。不能独立运行并且仅支持嵌入项。 ◆ 完全服务器：表示应用程序可创建和管理复合文档对象。能够独立运行，并且既支持链接项也支持嵌入项。 ◆ 容器/完全服务器：表示应用程序可以既是容器又是服务器。容器是可将嵌入项或者链接项并入自己的文档中的应用程序。服务器是可创建供容器应用程序使用的自动化项的应用程序。 其他支持包括： ◆ 自动化：允许应用程序向脚本工具和其他应用程序公开对象。 ◆ ActiveX控件：应用程序能够将ActiveX控件包含在内。</code></pre><p><a href="https://baike.baidu.com/item/MAPI" target="_blank" rel="noopener">MAPI</a>支持：可以从应用程序直接调用MAPI函数。</p><p>MAPI”表示“消息传递应用程序接口”。它是电子邮件等应用程序的消息传递结构和客户接口组件。如果双方应用程序都启用“MAPI”，就可以相互共享邮件信息，为多个应用程序提供一致接口。</p><pre><code>◆ Windows套接字：启用适当的头文件、库和MFC Windows Socket规范，使应用程序支持TCP/IP网络协议。</code></pre><h1 id="说你对Windows消息机制的理解"><a href="#说你对Windows消息机制的理解" class="headerlink" title="说你对Windows消息机制的理解"></a>说你对Windows消息机制的理解</h1><p> Windows系统是一个消息驱动的操作系统。什么是消息呢？下面从不同的几个方面进行讲解： </p><pre><code>1）消息的组成：一个消息由一个消息名称（UINT）和两个参数（WPARAM，LPARAM）组成。当用户进行了输入或是窗口的状态发生改变时系统都会发送消息到某一个窗口。例如，当菜单选择之后会有WM_COMMAND消息发送，WPARAM的高字节中（HIWORD(wParam)）是命令的ID号，对菜单来讲就是菜单ID。当然，用户也可以定义自己的消息名称，也可以利用自定义消息来发送通知和传送数据。 2）谁将收到消息：一个消息必须有一个窗口接收。在窗口过程（WNDPROC）中可以对消息进行分析，对自己感兴趣的消息进行处理。例如，希望对菜单选择进行处理，那么可以定义对WM_COMMAND进行处理的代码，如果希望在窗口中进行图形输出，则就必须对WM_PAINT进行处理。 3）未处理的消息到哪里去了：Microsoft为窗口编写了默认的窗口过程，这个窗口过程将负责处理那些没有被处理的消息。正因为有了这个默认窗口过程，我们才可以利用Windows的窗口进行开发而不必过多关注窗口各种消息的处理。例如，窗口在被拖动时会有很多消息发送，而我们都可以不予理睬而让系统自己去处理。 4）窗口句柄：说到消息就不能不说窗口句柄，系统通过窗口句柄在整个系统中唯一标识一个窗口，发送一个消息时必须指定一个窗口句柄表明该消息由哪个窗口接收。而每个窗口都会有自己的窗口句柄，所以用户的输入就会被正确地处理。例如，有两个窗口共用一个窗口过程代码，在窗口1上按下鼠标时消息就会通过窗口1的句柄被发送到窗口1而不是窗口2。 </code></pre><p>系统将会维护一个或多个消息队列，所有产生的消息都会被放入或插入队列中。系统会在队列中取出每一条消息，根据消息的接收句柄而将该消息发送给拥有该窗口程序的消息循环。每一个运行的程序都有自己的消息循环，在循环中得到属于自己的消息并根据接收窗口的句柄调用相应的窗口过程。而在没有消息时消息循环就将控制权交给系统，所以Windows可以同时进行多个任务。</p><h1 id="数据库编程基础"><a href="#数据库编程基础" class="headerlink" title="数据库编程基础"></a>数据库编程基础</h1><ul><li>ODBC数据库链接：可以学到在VC 6.0中使用ODBC进行数据库链接。 </li><li>ADO数据库链接：可以学到在VC 6.0中使用ADO进行数据库链接。</li></ul><h2 id="OLE-DB"><a href="#OLE-DB" class="headerlink" title="OLE DB"></a>OLE DB</h2><p>OLE DB模板是活动模板库(ATL)的一部分，它们通过提供实现许多常用OLE DB接口的类来使得高性能OLE DB数据库技术使用起来很简单。模板库中附带有创建OLE DB起始应用程序的向导支持。 模板库包含两部分： </p><ul><li>OLE DB使用者模板：用于实现OLE DB客户（使用者）应用程序。 </li><li><p>OLE DB提供程序模板：用于实现OLE DB服务器（提供程序）应用程序。</p><p>OLE DB数据使用者模板是由一些模板组成的。下面对一些常用类做一些介绍。 </p></li><li><p>（1）CDataSource类 CDataSource类与OLE DB的数据源对象相对应。这个类代表了OLE DB数据提供程序和数据源之间的连接，即主要负责数据源对象。只有当数据源的连接被建立之后，才能产生会话对象，可以调用Open()函数来打开数据源的连接。 </p></li><li>（2）CSession类 CSession所创建的对象代表了一个单独的数据库访问的会话，该类负责管理数据源和应用程序进程的会话。一个用CDataSource类产生的数据源对象可以创建一个或者多个会话，要在数据源对象上产生一个会话对象，需要调用Open()函数来打开。同时，会话对象还可用于创建事务的操作。 </li><li>（3）CEnumeratorAccessor类CEnumeratorAccessor类是用来访问枚举器查询后所产生的行集中可用数据提供程序的信息的访问器，可提供当前可用的数据提供程序和可见的访问器。 </li></ul><p>访问器类用于管理与访问相关的操作。常用的访问器类如下。 </p><ul><li>（1）CAcessor类 CAccessor类代表与访问器的类型。当用户知道数据库的类型和结构时，可以使用此类。它支持对一个行集采用多个访问器，并且存放数据的缓冲区是由用户分配的。 </li><li>（2）CDynamicAccessor类 CDynamicAccessor类用来在程序运行时动态地创建访问器。当系统运行时，可以动态地从行集中获得列的信息，可根据此信息动态地创建访问器。 </li><li>（3）CManualAccessor类 CManualAccessor类用来在程序运行时将列与变量绑定或者将参数与变量绑定。 </li></ul><p>行集类用于管理以行为单位的数据集。常用的行集类如下。</p><ul><li>（1）CRowSet类 CRowSet类封装了行集对象和相应的接口，并且提供了一些方法用于查询、设置数据等。可以用Move()等函数进行记录移动，用GetData()函数读取数据，用Insert()、Delete()、SetData()来更新数据。 </li><li>（2）CBulkRowset类 CBulkRowset类用于在一次调用中取回多个行句柄或者对多个行进行操作。</li><li>（3）CArrayRowset类 CArrayRowset类提供用数组下标进行数据访问。 </li></ul><p>命令类包括以下两类。 </p><ul><li>（1）CTable类 CTable类用于对数据库的简单访问，用数据源的名称得到行集，从而得到数据。</li><li>（2）CCommand类 CCommand类用于支持命令的数据源。</li></ul><p>可以用Open()函数来执行SQL命令，也可以用Prepare()函数先对命令进行准备，对于支持命令的数据源，可以提高程序的灵活性和健壮性。 注意　如果使用OLE DB进行数据库程序设计，则应该使用OLE DB类，在使用OLE DB类的过程中，也可以和其他数据库连接方式的类兼容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MFC创建选项&quot;&gt;&lt;a href=&quot;#MFC创建选项&quot; class=&quot;headerlink&quot; title=&quot;MFC创建选项&quot;&gt;&lt;/a&gt;MFC创建选项&lt;/h1&gt;&lt;p&gt;复合文档支持的各选项功能如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;◆ 无复合文档支持：即无OLE（Obj
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MFC" scheme="https://caojingyou.github.io/tags/MFC/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>COM编程</title>
    <link href="https://caojingyou.github.io/2018/08/02/COM%E7%BC%96%E7%A8%8B/"/>
    <id>https://caojingyou.github.io/2018/08/02/COM编程/</id>
    <published>2018-08-02T07:53:00.000Z</published>
    <updated>2018-08-06T01:07:16.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="COM线程模型"><a href="#COM线程模型" class="headerlink" title="COM线程模型"></a>COM线程模型</h1><p>要注意单线程与多线程的问题</p><h2 id="https-blog-csdn-net-zj510-article-category-2510453"><a href="#https-blog-csdn-net-zj510-article-category-2510453" class="headerlink" title="https://blog.csdn.net/zj510/article/category/2510453"></a><a href="https://blog.csdn.net/zj510/article/category/2510453" target="_blank" rel="noopener">https://blog.csdn.net/zj510/article/category/2510453</a></h2><p>通常我们提交COM的线程模型，其实指的是两方面：一个是客户程序的线程模式，一个是组件所支持的线程模式。客户程序的线程模式只有两种，单线程公寓(STA)和多线程公寓(MTA)。组件所支持的线程模式有四种：Single(单线程)、Apartment(STA)、Free(MTA)、Both(STA+MTA)。</p><p>注意，公寓和套间是同一个概念，这只是翻译而已，都是指apartment</p><p><img src="https://i.imgur.com/lxuGA7p.jpg" alt=""><br><img src="https://i.imgur.com/FFDSI0f.jpg" alt=""></p><p>STA客户调用STA COM组件</p><ol><li><p>STA对象在客户创建的STA套间线程里面运行；</p></li><li><p>STA客户直接调用STA COM对象指针；</p></li></ol><p>MTA客户调用STA COM组件</p><ol><li>STA对象在default STA里面运行，如果有多个STA对象，它们统统在同一个default sta线程里面运行。</li></ol><ol><li>MTA客户调用STA COM对象的代理。</li></ol><h2 id="谈谈COM的线程-模型-。然后-讨论-进程内-外组件的差别"><a href="#谈谈COM的线程-模型-。然后-讨论-进程内-外组件的差别" class="headerlink" title="谈谈COM的线程 模型 。然后 讨论 进程内/外组件的差别"></a><a href="https://www.nowcoder.com/questionTerminal/d7aed0e7935e42839c8285c6b822a258?orderByHotValue=3&amp;page=7&amp;onlyReference=false" target="_blank" rel="noopener">谈谈COM的线程 模型 。然后 讨论 进程内/外组件的差别</a></h2><p>中文翻译为“ 公寓 ” ，有时候为 “ 套间 ” ，这里就翻译为 “ 公寓 ” 吧，都一个意思，指的就是COM的线程模式，这个概念很抽象，理解起来比较困难。因为公寓不像 Windows内核对象那样有个 “ 句柄 ” ，并且跟公寓相关的Windows API很少，只有5个：CoInitialize，CoUninitialize，CoInitializeEx，OleInitialize和 OleUninitialize，大家都很熟悉了，5个关于COM初始化和反初始化的函数。如何来理解公寓呢？可以这样：1、线程住在公寓中；2、对象住在公寓中。有时候，对象和创建它的线程住在同一个公寓中，有时候不是。这样还是很难理解对吧，但没事，这个先记下来，后面会明白的。<br>COM只有两种公寓，一种叫单线程公寓（Single-Thread Apartment），简称STA，一种叫多线程公寓（Multi-Thread Apartment），简称MTA，顾名思义，一种只能容纳一个线程，另一种能容纳多个线程。在一个进程中，MTA只有一个，而STA可以有很多。</p><p>我们在使用COM之前，都应该先初始化COM，怎么初始化？当然是前文提到的那几个函数了，CoInitialize，CoInitializeEx和OleInitialize，那我们是每个程序（进程）初始化一次还是每个线程初始化一次？答案是线程，每个线程初始化一次，这么个初始化，就相当于把这个线程安置在某个公寓中。具体这样的：CoInitialize或OleInitialize把线程放置入STA；CoInitializeEx允许你把线程放置入MTA。从公寓中移除线程的方法是CoUninitialize和OleUninitialize。</p><p>我们都知道，对象是线程创建的，那对象什么时候跟创建它的线程同一个公寓，什么时候不是同一个公寓呢？前面说了线程所在的公寓类型是由那几个初始化函数所决定，那对象所在什么公寓是由什么决定的呢？这个稍微复杂一点，答案是：由创建它的线程的类型及对象本身的线程属性所决定。线程类型大家都知道啦，就前面提到的由那几个初始化函数决定，那么对象本身线程属性怎么来定呢？答案：注册表里的信息来定。</p><p>打开注册表编辑器，按照这路径： “ \ HKEY_CLASSES_ROOT\CLSID{00000010-0000-0010-8000-00AA006D2EA4}\InprocServer32 ” ，（这个 GUID很奇怪吧，明显不是用工具生成的，微软可有手动填写GUID的特权哦）看看 “ ThreadingModel ” 的值，嗯，没错，是 “ Apartment ” ，这个 “ Apartment ” 就是刚才我所提到的 “ 对象本身线程属性 ” ，对象本身线程属性一共有四种：Apartment、Both、Free和Single。下面我列个表，一目了然。</p><h2 id="组件线程属性-STA线程-MTA线程"><a href="#组件线程属性-STA线程-MTA线程" class="headerlink" title="组件线程属性 | STA线程                       | MTA线程"></a>组件线程属性 | STA线程                       | MTA线程</h2><p>Apartment   | 同一公寓中，直接访问          | 创建一个STA，用代理访问<br>Free        | MTA中，用代理访问             | MTA，直接访问<br>Both        | 同一公寓中，直接访问          | MTA，直接访问<br>Single      | 主STA中，通过主STA访问</p><p>备注：第一个以 COINIT_APARTMENTTHREADED调用CoInitializeEx()的线程被称作是主STA。</p><p>例如一个STA线程创建了一个本身线程属性为 Free的对象，那该对象存在于MTA中，这个STA线程访问它就得通过代理，当然了，这对程序员来说是透明的，因为这个功能是靠COM的 remoting层来实现的。要说和直接访问有什么能体现出来的不同，可能就是通过代理访问会慢一些，毕竟消息需要Marshalling，但这几毫秒的时间差你们地球人是很难感觉出来的( J )。</p><p>那么很明显了，只要我们把组件类型设置为 Apartment，就不会有任何线程访问冲突的问题。《Win32 多线程》侯捷</p><p>进程内/外组件的差别是Com组建的一种表现形式:.exe文件,它是进程外组建,dll是进程内组建.</p><h2 id="关于COM组件线程模型的实验"><a href="#关于COM组件线程模型的实验" class="headerlink" title="关于COM组件线程模型的实验"></a><a href="http://blog.sina.com.cn/s/blog_56dee71a0100ngrv.html" target="_blank" rel="noopener">关于COM组件线程模型的实验</a></h2><h3 id="单线程模型-Single"><a href="#单线程模型-Single" class="headerlink" title="单线程模型(Single)"></a>单线程模型(Single)</h3><p>在注册表中删除上述ThreadingModel键值，则COM组件被配置为使用单线程模型。使用单线程模型的组件只能存在于主STA，也就是进程中的第一个STA中。对于具有图形界面的Windows程序，第一个STA通常由主线程，也就是界面线程创建。具有图形界面的COM组件，比如说，ActiveX控件，常常使用单线程模型。</p><h3 id="套间线程模型-Apartment"><a href="#套间线程模型-Apartment" class="headerlink" title="套间线程模型(Apartment)"></a>套间线程模型(Apartment)</h3><p>设置上述ThreadingModel键值为Apartment，则COM组件被配置为使用套间线程模型。使用套间线程模型的组件只能存在于STA中。套间线程模型是在Visual Studio中使用ATL开发COM组件时默认的线程模型。</p><p>单线程模型和套间线程模型的共同点是在任何时刻只有一个线程可以直接访问组件，这个线程就是创建组件所在的STA的线程(不一定是调用CoCreateInstance创建组件的线程)。其他线程对组件的调用都是通过这个线程间接进行的：COM基础设施为STA创建一个隐藏的窗口，将其他线程对STA中组件的调用请求转化为发送给这个窗口的消息，然后由套间中唯一的线程处理消息，返回调用结果。所以，使用单线程模型和套间线程模型的组件要求消息队列，其他线程对组件的调用都是间接地通过消息队列进行的。这一点很重要。本文后面将通过代码验证这一点。</p><h3 id="自由线程模型-Free"><a href="#自由线程模型-Free" class="headerlink" title="自由线程模型(Free)"></a>自由线程模型(Free)</h3><p>设置上述ThreadingModel键值为Free，则COM组件被配置为使用自由线程模型。使用自由线程模型的组件只能存在于MTA中，可以被处于MTA中的多个线程“自由”地调用。不在MTA中的线程调用MTA组件时，COM基础设施随机选择RPC线程池中的某个RPC线程代为间接处理(RPC线程池是COM基础设施的组成部分)。由于COM基础设施没有提供任何同步方面的帮助，多个线程可以并发地调用组件的方法，所以需要编写代码对组件实施必要的保护，就像多线程编程中需要对共享资源实施保护一样。</p><h3 id="双线程模型-Both"><a href="#双线程模型-Both" class="headerlink" title="双线程模型(Both)"></a>双线程模型(Both)</h3><p>设置上述ThreadingModel键值为Both，则COM组件被配置为使用双线程模型。此时组件与创建组件的线程存在于相同的套间中：既可能是STA，也可能是MTA。因为组件可能存在于MTA中，被多个线程并发访问，所以需要编写代码对组件实施必要的保护。</p><p>自由线程模型和双线程模型有一个重要的差别：采用自由线程模型的组件可以创建能够直接调用组件的工作线程；而采用双线程模型的组件不能。因为采用双线程模型的组件可能位于STA中，如果组件创建的工作线程可以直接访问组件，则工作线程也必须位于STA中(套间之外的线程对组件的调用不能直接进行)，这就违反了STA中只能有一个线程的规则，破坏了COM线程模型的同步机制。</p><h3 id="线程中立模型-Neutral"><a href="#线程中立模型-Neutral" class="headerlink" title="线程中立模型(Neutral)"></a>线程中立模型(Neutral)</h3><p>设置上述ThreadingModel键值为Neutral，则COM组件被配置为使用线程中立模型。使用线程中立模型的组件位于TNA中，可以被任何线程自由地、直接地访问。调用线程访问这种类型的组件时将暂时离开所属的STA或者MTA，进入TNA，直接对组件进行方法调用，调用完成后返回STA或者MTA。与采用自由线程模型和双线程模型的组件一样，必须编写代码对组件实施必要的保护，以防止多线程并发访问可能出现的问题。线程中立模型是运行在组件服务中的，不需要用户界面的组件的最优选择。</p><h1 id="什么是COM"><a href="#什么是COM" class="headerlink" title="什么是COM"></a>什么是COM</h1><p>《Visual C++从入门到精通（视频实战版）》</p><p>COM是Component Object Model（组件对象模型）的缩写。不管用户需要什么样的产品，以下两个条件是必须要保证的： </p><ul><li>高效：使用软件产品可以做的工作，一般而言，使用手工劳动一样能达到同样效果，只是软件可以快速处理相同工作。在众多软件的选择中，高效的软件具备无可比拟的优势。 </li><li>健壮：如果一个软件系统出现很小的问题就会异常终止，导致整个系统工作无法进行，并且需要系统管理员不厌其烦地重启服务器，这样的软件还会有人购买吗？因此，健壮性也是软件产品的一个必要条件。 面向对象的程序设计可以说是一次革命性的变革，因为面向对象的程序设计可以将要解决的问题和对象抽象成为数据对象，将功能和动作封装起来，并提供一些接口。但当今的计算机时代是“后OO时代”（后面向对象时代），即面向组件的时代。 COM是一种跨应用和语言共享二进制代码的方法。 </li><li>跨应用：指不同的应用程序可以使用或共享COM组件。 </li><li>跨语言：指不同的语言可以调用同一个COM组件。 </li></ul><p>COM提倡源代码重用，而ATL则在代码重用方面不如COM，因为ATL只是在代码级别上的重用好，但只能用于C++语言，如果不使用名称控件，还可能引起名字冲突的问题。同时，这样的重用很可能会导致工程膨胀和源代码臃肿。 Windows使用DLLs在二进制级共享代码。所以Windows程序运行经常会调用到诸如kernel32.dll、user32.dll等。但DLLs是针对C接口（Win32 SDK）而写的，它们只能被C或理解C调用规范的语言（如C++）使用。由编程语言来负责实现共享代码，这样会导致DLLs的使用受到限制。 MFC引入了另外一种MFC扩展DLLs二进制共享机制。但它的使用仍受限制，因为其只能在MFC程序中使用。 COM通过定义二进制标准解决了这些问题，即COM明确指出二进制模块（DLLs和EXEs）必须被编译成与指定的结构匹配。实际上，COM在这里充当了中间层的作用。这个标准也确切规定了在内存中如何组织COM对象。COM定义的二进制标准还必须独立于任何编程语言，这样才能对任何语言独立平等地进行对待。满足这些条件之后，就可以很方便地从其他语言中使用这些模块中的功能。由编译器负责所产生的二进制代码与标准兼容。这样使后来的人就能更容易地使用这些二进制代码。 大多数COM的代码都是用C++编写的，但并非就表明编写代码一定要用C++，编写COM组件是与开发语言没有关系的，而且二进制代码也可以为所有语言所用。 注意　在操作系统层次中，COM也不是Win32特有的。从理论上讲，它可以被移植到UNIX或其他操作系统中。</p><h2 id="COM接口"><a href="#COM接口" class="headerlink" title="COM接口"></a>COM接口</h2><p>COM的接口都必须从IUnknown继承，犹如在MFC中，CObject类的地位。IUnknown有三个重要的函数： 1）QueryInterface()函数。该函数的原型如下： HRESULT__stdcall QueryInterface(const IID＆iid,void**ppv); 该函数的参数的含义是： </p><pre><code>iid：标志客户所需的接口，是一个接口标志符“结构（IID）”。 ppv：QueryInterface用来存放所请求接口的地址。 </code></pre><p>该函数的返回值可以是S_OK或E_NOINTERFACE，并且应该用SUCEEDED或者FAILED宏验证是否调用成功。 </p><p>该函数的使用方法是：假如知道一个指向IUnknown接口的指针pI，传给它一个接口标志符即可。 使用例子可以如以下代码所示：</p><pre><code>void Function( IUnknown*pI ){    IX*pIX = NULL; HRESULT hr = pI - ＞ QueryInterface( IID_IX, (void * *) pIX ); if ( SUCCEEDED( hr ) )    {        pIX - ＞ FX();    }}</code></pre><ul><li>Addref()函数：用于增加引用计数。 </li><li>Release()函数：用于释放引用计数。 </li></ul><p>这三个函数的顺序是不能变化的。QueryInterface用于查询组件实现的其他接口，也就是看看这个组件的父类中还有哪些接口类，AddRef用于增加引用计数，Release用于减少引用计数。一般在以下两种情况下必须调用Release： </p><p>调用QueryInterface后。 调用了任何得到一个接口指针的函数后。 IDispatch接口把每一个函数每一个属性编上号，Client要调用这些函数、属性的时候就把这个编号传给IDispatch接口。开发组件时一般有两种方式：</p><ul><li>ATL：使用ATL对于用C++创建COM组件和节省空间都是一种快速简便的方法。如果不需要MFC自动提供的所有内置功能，使用ATL创建控件。</li><li>MFC：MFC允许创建具有完整功能的应用程序、ActiveX控件和活动文档。 如果已经使用MFC创建了控件，可能需要继续使用MFC进行开发。当创建新控件时，如果不需要MFC的所有内置功能，可考虑使用ATL。ATL与传统的C++模板库的区别：ATL通常只作为源代码提供，并且在本质上没有固有的分层结构或没有必要有分层结构；不是从派生类得到所需的功能，而是从模板中实例化类。</li></ul><h1 id="COM组件、ActiveX、OCX区别"><a href="#COM组件、ActiveX、OCX区别" class="headerlink" title="COM组件、ActiveX、OCX区别"></a><a href="https://blog.csdn.net/qq_20161893/article/details/74182761" target="_blank" rel="noopener">COM组件、ActiveX、OCX区别</a></h1><p>COM 组件就是一组接口的集合，实现了 IDispath 接口的 COM 组件叫做 自动化组件。在自动化组件的基础上，在实现规定的接口就称为 ActiveX 组件，Ocx 是 Activex 的文件载体<br>一般来讲 ，一个 ActiveX 对应一个 Ocx 文件， 如果愿意， 一个Ocx 文件也可以包含多个 ActiveX  控件。</p><p>COM是microsoft制定的一个组件软件标准，跟unix上的CORBA一样。凡是遵循COM标准开发出来的组件称为COM组件。简单的说就是要实现在二进制方式的重用 。<br>在windows平台上，COM的实现形式有DLL(进程内组件)和EXE(进程外组件)2种。<br>ActiveX是Microsoft提出的一组使用COM（Component Object Model，部件对象模型）使得软件部件在网络环境中进行交互的技术集。它与具体的编程语言无关。作为针对Internet应用开发的技术，ActiveX被广泛应用于WEB服务器以及客户端的各个方面。同时，ActiveX技术也被用于方便地创建普通的桌面应用程序，此外ActiveX一般具有界面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;COM线程模型&quot;&gt;&lt;a href=&quot;#COM线程模型&quot; class=&quot;headerlink&quot; title=&quot;COM线程模型&quot;&gt;&lt;/a&gt;COM线程模型&lt;/h1&gt;&lt;p&gt;要注意单线程与多线程的问题&lt;/p&gt;
&lt;h2 id=&quot;https-blog-csdn-net-zj51
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="COM" scheme="https://caojingyou.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://caojingyou.github.io/2018/07/16/UML/"/>
    <id>https://caojingyou.github.io/2018/07/16/UML/</id>
    <published>2018-07-16T06:30:00.000Z</published>
    <updated>2018-07-17T05:49:19.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML软件"><a href="#UML软件" class="headerlink" title="UML软件"></a>UML软件</h1><p>PowerDesigner</p><p>StarUML</p><p>EA</p><h1 id="UML类关系"><a href="#UML类关系" class="headerlink" title="UML类关系"></a>UML类关系</h1><p>在UML类图中，常见的有以下几种关系:泛化（Generalization）,  实现（Realization）,关联（Association）,聚合（Aggregation）,组合(Composition)，依赖(Dependency)</p><p>在UML类图中，类之间的关系可以分成：关联(association)、聚合(aggregation)、组合(composition)、依赖(dependency)、泛化(generalization)/继承(inheritance)和实现(realization)。这六种关系如下图所描绘：</p><p><img src="https://i.imgur.com/RfuR0l5.png" alt=""></p><h2 id="泛化-generalization-继承-inheritance"><a href="#泛化-generalization-继承-inheritance" class="headerlink" title="泛化(generalization)/继承(inheritance)"></a>泛化(generalization)/继承(inheritance)</h2><p>【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为</p><p>【箭头指向】：带三角箭头的实线，箭头指向父类</p><h2 id="实现（Realization"><a href="#实现（Realization" class="headerlink" title="实现（Realization)"></a>实现（Realization)</h2><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现</p><p>【箭头指向】：带三角箭头的虚线，箭头指向接口</p><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；</p><p>关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>【聚合关系】：是整体与部分的关系</p><p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p><h2 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h2><p>【组合关系】：是整体与部分的关系.,没有公司就不存在部门      组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p>【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。</p><p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p><p>【箭头及指向】：带箭头的虚线，指向被使用者</p><h2 id="各种关系的强弱顺序："><a href="#各种关系的强弱顺序：" class="headerlink" title="各种关系的强弱顺序："></a>各种关系的强弱顺序：</h2><pre><code>泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/tianhai110/article/details/6339565" target="_blank" rel="noopener">https://blog.csdn.net/tianhai110/article/details/6339565</a></p><p><a href="https://www.jianshu.com/p/4cd95d4ddb59" target="_blank" rel="noopener">https://www.jianshu.com/p/4cd95d4ddb59</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UML软件&quot;&gt;&lt;a href=&quot;#UML软件&quot; class=&quot;headerlink&quot; title=&quot;UML软件&quot;&gt;&lt;/a&gt;UML软件&lt;/h1&gt;&lt;p&gt;PowerDesigner&lt;/p&gt;
&lt;p&gt;StarUML&lt;/p&gt;
&lt;p&gt;EA&lt;/p&gt;
&lt;h1 id=&quot;UML类关系&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UML" scheme="https://caojingyou.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>算法图解</title>
    <link href="https://caojingyou.github.io/2018/06/25/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://caojingyou.github.io/2018/06/25/算法图解-读书笔记/</id>
    <published>2018-06-25T01:58:00.000Z</published>
    <updated>2018-06-25T02:45:56.591Z</updated>
    
    <content type="html"><![CDATA[<p>算法图解</p><p>【美】Aditya Bhargava</p><p>关于本书</p><p><a href="www.manning.com/books/grokking-algorithms">www.manning.com/books/grokking-algorithms</a></p><p><a href="https://github.com/egonschiele/grokking_algorithms" target="_blank" rel="noopener">https://github.com/egonschiele/grokking_algorithms</a></p><p>1.2.1 更佳的查找方式</p><p>一般而言，对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。</p><p>1.3.4 一些常见的大O运行时间</p><p>下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。<br>O(log^n)，也叫对数时间，这样的算法包括二分查找。<br>O(n)，也叫线性时间，这样的算法包括简单查找。<br>O(n*log^n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O(n^2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p><p>3.1 递归</p><p>Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”</p><p>3.3.2 递归调用栈</p><p>使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。<br>重新编写代码，转而使用循环。<br>使用尾递归</p><p>第4章 快速排序</p><p>学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。</p><p>4.2 快速排序</p><p>语言标准库中的函数qsort实现的就是快速排序</p><p>4.3 再谈大O表示法</p><p>选择排序，其运行时间为O(n2)，速度非常慢。<br>还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n logn)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。<br>与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n logn)。</p><p>5.3 冲突</p><p>散列函数总是将不同的键映射到数组的不同位置。</p><p>处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。</p><p>5.4 性能</p><p>避免冲突，需要有：<br>较低的填装因子；<br>良好的散列函数。</p><p>第6章 广度优先搜索</p><p>广度优先搜索让你能够找出两样东西之间的最短距离</p><p>6.3.2 队列</p><p>队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。</p><p>第7章 狄克斯特拉算法</p><p>介绍狄克斯特拉算法，让你能够找出加权图中前往X的最短路径。</p><p>介绍图中的环，它导致狄克斯特拉算法不管用。</p><p>7.2 术语</p><p>狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。</p><p>要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法</p><p>7.4 负权边</p><p>如果有负权边，就不能使用狄克斯特拉算法</p><p>在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼-福德算法（Bellman-Ford algorithm）。</p><p>7.5 实现</p><p>节点的所有邻居都存储在散列表中。</p><p>一个散列表来存储每个节点的开销。</p><p>节点的开销指的是从起点出发前往该节点需要多长时间。</p><p>还需要一个存储父节点的散列表</p><p>需要一个数组，用于记录处理过的节点，因为对于同一个节点，你不用处理多次。</p><p>第8章 贪婪算法</p><p>学习贪婪策略</p><p>8.1 教室调度问题</p><p>贪婪算法很简单：每步都采取最优的做法</p><p>第9章 动态规划</p><p>学习动态规划，这是一种解决棘手问题的方法，它将问题分成小问题，并先着手解决这些小问题。</p><p>9.1.2 动态规划</p><p>动态规划先解决子问题，再逐步解决大问题。</p><p>9.4 小结</p><p>需要在给定约束条件下优化某种指标时，动态规划很有用。<br>问题可分解为离散子问题时，可使用动态规划来解决。<br>每种动态规划解决方案都涉及网格。<br>单元格中的值通常就是你要优化的值。<br>每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。<br>没有放之四海皆准的计算动态规划解决方案的公式。</p><p>第10章 K最近邻算法</p><p>K最近邻算法创建分类系统</p><p>10.2.1 特征抽取</p><p>要计算两点的距离，可使用毕达哥拉斯公式。</p><p>10.2.2 回归</p><p>使用KNN来做两项基本工作——分类和回归：<br>分类就是编组；<br>回归就是预测结果（如一个数字）。</p><p>余弦相似度<br>前面计算两位用户的距离时，使用的都是距离公式。</p><p>余弦相似度不计算两个矢量的距离，而比较它们的角度，因此更适合处理前面所说的情况。本书不讨论余弦相似度，但如果你要使用KNN，就一定要研究研究它！</p><p>10.3.2 创建垃圾邮件过滤器</p><p>垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（Naive Bayes classifier）</p><p>10.4 小结</p><p>KNN用于分类和回归，需要考虑最近的邻居。<br>分类就是编组。<br>回归就是预测结果（如数字）。<br>特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。<br>能否挑选合适的特征事关KNN算法的成败。</p><p>如果考虑的邻居太少，结果很可能存在偏差。一个不错的经验规则是：如果有N位用户，应考虑sqrt(N)个邻居。</p><p>11.1 树</p><p>二叉查找树</p><p>对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。</p><p>也有一些处于平衡状态的特殊二叉查找树，如红黑树。</p><p>B树是一种特殊的二叉树，数据库常用它来存储数据。</p><p>请研究如下数据结构：B树，红黑树，堆，伸展树。</p><p>11.3 傅里叶变换</p><p>绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。</p><p>傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。</p><p>11.4 并行算法</p><p>并行算法</p><p>在最佳情况下，排序算法的速度大致为O(n logn)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！对数组进行排序时，快速排序的并行版本所需的时间为O(n)。</p><p>11.5 MapReduce</p><p>有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。</p><p>11.5.1 分布式算法为何很有用</p><p>分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。</p><p>11.5.3 归并函数</p><p>映射是将一个数组转换为另一个数组。</p><p>而归并是将一个数组转换为一个元素。</p><p>11.6 布隆过滤器和HyperLogLog</p><p>布隆过滤器和HyperLogLog</p><p>11.6.1 布隆过滤器</p><p>布隆过滤器提供了解决之道。布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的</p><p>11.6.2 HyperLogLog</p><p>HyperLogLog是一种类似于布隆过滤器的算法</p><p>面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！</p><p>11.7 SHA算法</p><p>　SHA算法</p><p>11.7.1 比较文件</p><p>另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA返回其散列值。</p><p>11.7.2 检查密码</p><p>当前，最安全的密码散列函数是bcrypt，</p><p>11.8 局部敏感的散列算法</p><p>希望散列函数是局部敏感的。在这种情况下，可使用Simhash</p><p>如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！</p><p>11.9 Diffie-Hellman密钥交换</p><p>这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题：如何对消息进行加密，以便只有收件人才能看懂呢？</p><p>Diffie-Hellman使用两个密钥：公钥和私钥</p><p>Diffie-Hellman算法及其替代者RSA依然被广泛使用</p><p>11.10 线性规划</p><p>线性规划用于在给定约束条件下最大限度地改善指定的指标</p><p>线性规划使用Simplex算法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/OctoptusLian/p/9026319.html?dt_platform=other&amp;dt_dapp=1" target="_blank" rel="noopener">http://www.cnblogs.com/OctoptusLian/p/9026319.html?dt_platform=other&amp;dt_dapp=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法图解&lt;/p&gt;
&lt;p&gt;【美】Aditya Bhargava&lt;/p&gt;
&lt;p&gt;关于本书&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;www.manning.com/books/grokking-algorithms&quot;&gt;www.manning.com/books/grokking-algo
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="读书笔记" scheme="https://caojingyou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="https://caojingyou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>啊哈算法-读书笔记</title>
    <link href="https://caojingyou.github.io/2018/06/22/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95/"/>
    <id>https://caojingyou.github.io/2018/06/22/啊哈算法/</id>
    <published>2018-06-22T14:53:00.000Z</published>
    <updated>2018-06-24T04:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本书涉及的数据结构有栈、队列、树、并查集、堆和图等；算法有各种排序、枚举、深度和广度优先搜索、图上的遍历，当然还有图论中不可缺少的四种最短路径算法、两种最小生成树算法、割点与割边算法、二分图的最大匹配算法等。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>时间复杂度O(N+M)</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。</p><p>从大到小排序。</p><p>冒泡排序的核心部分是双重嵌套循环。时间复杂度是O(N^2)。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>首先找一个数作为基准数，设置两个哨兵变量，指向序列最左边与最右边，找到右边小于基准数的数与左边大于基准数的数，两数交换，两哨兵变量相遇后，交换基准数与哨兵变量所指的数，然后对两哨兵变量左边与右边做相同的操作。</p><p>快速排序的每一轮处理其实就是将这一轮的基准数归为，直到所有的基准数都归为。</p><p>快速排序的最差时间复杂度和冒泡排序一样都是O(N^2),他的平均时间复杂度为O(NlogN)。</p><p>快速排序基于“二分”发。</p><p>排序算法还有选择排序、计数排序、基数排序、插入排序、归并排序、堆排序。堆排序是基于二叉树的排序。</p><h1 id="栈、队列、链表"><a href="#栈、队列、链表" class="headerlink" title="栈、队列、链表"></a>栈、队列、链表</h1><p>可使用两个数组模拟链表。第一个整数数组data是用来存放序列中的具体数字，另外一个整数数组right是用来存放当前序列中的每一个元素右边的元素在数组data中位置。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>穷举法</p><h1 id="万能的搜索"><a href="#万能的搜索" class="headerlink" title="万能的搜索"></a>万能的搜索</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>栈</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>队列</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>也是用深度或广度优先搜索</p><p>可使用二维数组来存储一个图。二维数组沿主对角线对称，说明是无向图。</p><p>广度优先搜索可找到两点之间经过最少点的路径。</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>求有权图中两点最短路径，可使用深度优先搜索、广度优先搜索、Floyd、Bellman-Ford、Dijkstra等。</p><table><thead><tr><th></th><th>Floyd</th><th>Dijkstra</th><th>Bellman-Ford</th><th>队列优化的Bellman-Ford</th></tr></thead><tbody><tr><td>空间复杂度</td><td>O(N^2)</td><td>O(M)</td><td>O(M)</td><td>O(M)</td></tr><tr><td>时间复杂度</td><td>O(N^3)</td><td>O((M+N)logN)</td><td>O(NM)</td><td>最坏是O(NM)</td></tr><tr><td>适用情况</td><td>1.稠密图2.和顶点关系密切</td><td>1.稠密图2.和顶点关系密切</td><td>1.稀疏图2.和边关系密切</td><td>1.稀疏图2.和边关系密切</td></tr><tr><td>负权</td><td>可以解决负权</td><td>不能解决负权</td><td>可以解决负权</td><td>可以解决负权</td></tr></tbody></table><p>注：其中N表示点数，M表示边数</p><p>Floyd算法虽然总体时间复杂度，但是可以解决负权边(不能解决负权环，实际上这几种都无法解决负权回路，因为一直循环下去总能找到更小的路径)，并且均摊到每一点对上，在所有的算法中还是比较好的. Floyd算法代码复杂度小也是一大优势. Dijkstra算法最大的弊端就是无法适应有负权边的图，但Dijkstra具有很好的可扩展性，另外在Dijkstra算法在选择剩余不在最短路径顶点的集合中选择最小值是可以堆优化，这样算法的时间复杂度可以达到O(MlogN). 当图中含有负边时，使用Bellman-Ford或者队列优化的Bellman-Ford算法. </p><h2 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h2><p>每个定点都有可能使另外两个定点之间的路程变短。</p><p>核心代码：</p><pre><code>for(k=1;k&lt;=n;k++){    for(i=1;i&lt;=n;i++)    {        for(j=1;j&lt;.n;j++)        {            if(e[i][j]&gt;e[i][k]+e[k][j])            {                e[i][j]=e[i][k]+e[k][j];            }        }    }}</code></pre><p>从i号顶点到j号顶点只经过前k号点的最短路径。(动态规划)</p><p>可求出任意两个点之间的最短路径。不能解决带有“负权回路”或者叫“负权环”，因为带有“负权回路”的图没有最短路径。</p><h2 id="Dijkstra算法–单源最短路径"><a href="#Dijkstra算法–单源最短路径" class="headerlink" title="Dijkstra算法–单源最短路径"></a>Dijkstra算法–单源最短路径</h2><p>边数M少于N^2的叫稀疏图，M相对较大的为稠密图。</p><p>使用邻接表使时间复杂度优化到O(M+N)logN.</p><p>贪心策略的算法。</p><p>不能计算有负权边的图。</p><h2 id="Bellman-Ford–解决负权边"><a href="#Bellman-Ford–解决负权边" class="headerlink" title="Bellman-Ford–解决负权边"></a>Bellman-Ford–解决负权边</h2><pre><code>for(k=1;k&lt;=n-1;k++)    for(i=1;i&lt;=m;i++        if(dis[v[i]]&gt;dis[u[i]]+w[i])            dis[v[i]]-dis[u[i]]+w[i]    </code></pre><p>外循环n-1次（n为定点数），内循环数m次（m为边的个数）。dis数组存储源点到其他点的最短距离。u、v、w三个数组记录边的信息。例如第i条边存储在u[i]、v[i]和w[i]中，表示从顶点u[i]到顶点v[i]这条边（u[i]-&gt;v[i]）权值为w[i].</p><p>外循环n-1次，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。</p><p>如果在n-1轮松弛后最短路径仍然会发生变化，则该图必然存在负权回路。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以添加一个变量标记数组dis在本轮松弛中是否发生了变化，如果没有变化，则可以提前跳出循环。</p><p>每次仅对最短路径估计值发生变化了的顶点的所有出边执行松弛操作：Bellman-Ford队列优化</p><h2 id="Bellman-Ford队列优化"><a href="#Bellman-Ford队列优化" class="headerlink" title="Bellman-Ford队列优化"></a>Bellman-Ford队列优化</h2><p>队列广度优先搜索，</p><p>每次选取队首顶点u,对顶点u的所有出边进行松弛操作。例如有一条u-&gt;v的边,如果通过u-&gt;v这条边使得源点到顶点v的最短路程变短<code>(dis[u]+e[u][v]&lt;dis[v])</code>,且顶点v不在当前的队列中,就将顶点v放入队尾。需要注意的是,同一个顶点同时在队列中出现多次是毫无意义的,所以我们需要一个数组来判重(判断哪些点已经在队列中)。在对顶点u的所有出边松弛完毕后,就将顶点u出队。接下来不断从队列中取出新的队首顶点再进行如上操作,直至队列空为止。</p><p>如果某个点进入队列的次数超过n次，则存在负环。</p><p>还有最短路径SPFA快速算法，也是基于队列优化的Bellman-Ford算法。</p><h1 id="神奇的树"><a href="#神奇的树" class="headerlink" title="神奇的树"></a>神奇的树</h1><p>树其实就是不含回路的无向图</p><p>二叉树的特点是每个节点最多两个子节点。</p><p>如果二叉树中每个内部节点都有两个子节点，叫做满二叉树。深度为h且有2^h-1个节点。</p><p>完全二叉树：除h层外，其他层的节点个数达到最大数。</p><h2 id="堆–神奇的优先队列"><a href="#堆–神奇的优先队列" class="headerlink" title="堆–神奇的优先队列"></a>堆–神奇的优先队列</h2><p>堆是一种特殊的特殊的完全二叉树</p><p>所有父节点都比子节点小，最小堆。反之，最大堆。</p><p>优先队列：支持插入元素和寻找最大（小）值元素的数据结构。</p><p>如果使用普通队列来实现这个两个功能，那么寻找最大元素需要枚举整个队列，这样的时间复杂度比较高。如果已排序好的数组，那么插入一个元素则需要移动很多元素，时间复杂度依旧很高。而堆就是一种优先队列的实现，可以很好的解决这两种操作。</p><p>堆还经常被用来求一个数列中第K大的数。只需要建立一个大小为K的最小堆，堆顶就是第K大的数。如果求一个数列中第K小的数，只最需要建立一个大小为K的最大堆，堆顶就是第K小的数，这种方法的时间复杂度是O(NlogK)。当然你也可以用堆来求前K大的数和前K小的数。</p><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p><p>堆排序的时间复杂度也是O(NlogN)与快速排序一样。</p><p>树还有很多神奇的用法：线段树、树状数组、Trie树（字典树）、二叉搜索树、红黑树（一种平衡二叉搜索树）。</p><h1 id="更多精彩算法"><a href="#更多精彩算法" class="headerlink" title="更多精彩算法"></a>更多精彩算法</h1><p>1.最小生成树</p><p>Kruskal算法是一步步地将森林中的树进行合并，而Prim算法则是通过每次增加一条边来建立一棵树</p><p>Kruskal算法适用于稀疏图，没有使用堆优化的Prim算法适用于稠密图，使用了堆优化Prim算法则适用于稀疏图。</p><p>Kruskal算法：首先按照边的权值进行从小到大排序，每次从剩余的边中选择权值较小且边的二个顶点不在同一个集合内的边，加入到生成树种，直到加入了n-1条边为止。</p><p>时间复杂度：O(MlogM).</p><p>2.图的割点与割边</p><p>3.二分图最大匹配</p><p>增广路</p><h1 id="还能更好吗——微软亚洲研究院面试"><a href="#还能更好吗——微软亚洲研究院面试" class="headerlink" title="还能更好吗——微软亚洲研究院面试"></a>还能更好吗——微软亚洲研究院面试</h1><p>主元素问题</p><p>声明一个变量count = 0，声明一个常量size等于数组大小。<br>假设该数组的第一个元素a(1)为主元素，让其与a(2)进行比较，若相同，则使变量count+1，若不同，则count-1。然后继续比较a(3)。以此类推。</p><p>当与a(n)比较后，count = -1时，将count重新归为0，并重新假设a(n+1)为主元素，并继续与a(n+2)作比较。</p><p>当count&gt;=(size-m)/2时，此时假设的主元素a(m)即为实际的主元素。<br>或遍历完整个数组后，当前假设的主元素为实际主元素。</p><h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><ul><li>艾伦·图灵传：如谜的解密者</li><li>图灵的秘密</li><li>编程之美</li><li>算法导论</li><li>思考的乐趣</li><li>数学之美</li><li>具体数学</li><li>算法帝国</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/review/9372703/" target="_blank" rel="noopener">《啊哈！算法》读书笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本书涉及的数据结构有栈、队列、树、并查集、堆和图等；算法有各种排序、枚举、深度和广度优先搜索、图上的遍历，当然还有图论中不可缺少的四种最短路径算法、两种最小生成树算法、割点与割边算法、二分图的最大匹配算法等。&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; cl
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="读书笔记" scheme="https://caojingyou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="https://caojingyou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://caojingyou.github.io/2018/06/21/git/"/>
    <id>https://caojingyou.github.io/2018/06/21/git/</id>
    <published>2018-06-21T10:08:00.000Z</published>
    <updated>2018-06-26T05:21:47.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="团队协作时的访问权限模型"><a href="#团队协作时的访问权限模型" class="headerlink" title="团队协作时的访问权限模型"></a>团队协作时的访问权限模型</h1><p><img src="http://file.ituring.com.cn/Original/1710e7d8b081b6c3a4c7" alt=""></p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a></p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</p><p>要随时掌握工作区的状态，使用git status命令。</p><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><p>查看历史记录</p><pre><code>git loggit log --pretty=oneline</code></pre><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>退到某个版本<br>    git reset –hard HEAD^<br>    git reset –hard commit_id</p><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令</p><p><code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</p><p><code>git checkout -- file</code>可以丢弃工作区的修改：</p><pre><code>$ git checkout -- readme.txt</code></pre><p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令</p><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><p>通常直接在文件管理器中把没用的文件删了，或者用rm命令删了</p><p>用命令<code>git rm</code>删掉，并且<code>git commit</code></p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><pre><code>$ git log --graph --pretty=oneline --abbrev-commit</code></pre><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward</p><pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></pre><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><p>用git stash list命令看看之前保存的工作现场</p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了</p><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p><p>要查看远程库的信息，用git remote或者，用git remote -v显示更详细的信息</p><p>多人协作的工作模式通常是这样：</p><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>命令<code>git tag &lt;tagname</code>&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p><p>命令<code>git tag</code>可以查看所有标签。</p><p>命令git push origin <tagname>可以推送一个本地标签；</tagname></p><p>命令git push origin –tags可以推送全部未推送过的本地标签；</p><p>命令git tag -d <tagname>可以删除一个本地标签；</tagname></p><p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub页面支持使用键盘快捷键，shift + / 键可打开一览表</p><p>在某仓库页面上按下键盘的t键再输入文件名，可快速查询需要的目录或文件名，不用手动找</p><p>emoji表情自动补全功能，评论中输入:后便会启动，emoji速查表在<a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">这里</a></p><p>Wiki也可以通过Git进行管理，Clone其URL即可</p><p>在GitHub上，可以任意Fork开源仓库；</p><p>自己拥有Fork后的仓库的读写权限；</p><p>可以推送pull request给官方仓库来贡献代码。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p><p>点“Add Key”，你就应该看到已经添加的Key</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git；</code></p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令.</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p><h1 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h1><p>一个本地库能不能既关联GitHub，又关联码云呢</p><p>用不同的名称来标识不同的远程库</p><pre><code>git remote add github git@github.com:michaelliao/learngit.gitgit remote add gitee git@gitee.com:liaoxuefeng/learngit.git</code></pre><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><p>让Git显示颜色，会让命令输出看起来更醒目：</p><pre><code>$ git config --global color.ui true</code></pre><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>每个仓库的Git配置文件都放在.git/config文件中</p><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><pre><code>$ sudo apt-get install git$ sudo adduser git</code></pre><p>创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>始化Git仓库<br>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</p><pre><code>$ sudo git init --bare sample.git</code></pre><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p><pre><code>$ sudo chown -R git:git sample.git</code></pre><p>禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code></pre><p>改为：</p><pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></pre><p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><p>克隆远程仓库：</p><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><pre><code>$ git clone git@server:/srv/sample.git</code></pre><p>可以用Gitosis来管理公钥</p><h1 id="https-learngitbranching-js-org-demo"><a href="#https-learngitbranching-js-org-demo" class="headerlink" title="https://learngitbranching.js.org/?demo"></a><a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">https://learngitbranching.js.org/?demo</a></h1><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h2><p>创建一个新的提交记录</p><h2 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h2><p>创建分支</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout "></a>git checkout <name></name></h2><p>切换到某一分支上</p><h2 id="git-checkout-b"><a href="#git-checkout-b" class="headerlink" title="git checkout -b "></a>git checkout -b <your-branch-name></your-branch-name></h2><p>创建一个新的分支同时切换到新创建的分支</p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并两个分支</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>在项目的提交树上前后移动。</p><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p><p>如果想看 HEAD 指向，可以通过 <code>cat .git/HEAD</code> 查看， 如果 HEAD 指向的是一个引用，还可以用 <code>git symbolic-ref HEAD</code> 查看它的指向。</p><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</p><p>通过哈希值指定提交记录。</p><p>相对引用非常给力，这里我介绍两个简单的用法：</p><p>使用 ^ 向上移动 1 个提交记录<br>使用 ~<num> 向上移动多个提交记录，如 ~3</num></p><h2 id="git-branch-f-master-HEAD-3"><a href="#git-branch-f-master-HEAD-3" class="headerlink" title="git branch -f master HEAD~3"></a>git branch -f master HEAD~3</h2><p>上面的命令会将 master 分支强制指向 HEAD 的第 3 级父提交。</p><p>强制修改分支位置</p><p>相对引用为我们提供了一种简洁的引用提交记录的方式， 而 -f 则容许我们将分支强制移动到那个位置。</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查查看提交记录的哈希值,只需要提供能够唯一标识提交记录的前几个字符即可。</p><h2 id="git-reset与-git-revert"><a href="#git-reset与-git-revert" class="headerlink" title="git reset与 git revert"></a>git reset与 git revert</h2><p>主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。</p><p>git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><p>虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并分享给别人，我们需要使用 git revert。</p><p>git reset：本地分支<br>git revert：远程分支</p><h2 id="git-cherry-pick-lt-提交号-gt-…"><a href="#git-cherry-pick-lt-提交号-gt-…" class="headerlink" title="git cherry-pick &lt;提交号&gt;…"></a>git cherry-pick &lt;提交号&gt;…</h2><p>整理提交记录</p><p>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。</p><h2 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h2><p>当你你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i</p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p>你可以选择通过 fast-forward 快速合并</p><p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p><pre><code>git rebase -igit cherry-pick</code></pre><h2 id="提交的技巧"><a href="#提交的技巧" class="headerlink" title="提交的技巧"></a>提交的技巧</h2><p>正如你在上一关所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 –amend 修改它，然后把它们重新排成我们想要的顺序。</p><h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p>可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；</p><p>git describe 的​​语法是：</p><p>git describe <ref></ref></p><p><ref> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。</ref></p><p>它输出的结果是这样的：</p><p><tag>_<numcommits>_g<hash></hash></numcommits></tag></p><p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。</p><p>当 ref 提交记录上有某个标签时，则只输出标签名称</p><h2 id="选择父提交记录"><a href="#选择父提交记录" class="headerlink" title="选择父提交记录"></a>选择父提交记录</h2><p>选择父提交记录<br>操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。</p><p>但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p><p>Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。</p><h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><p>Pro Git</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.ituring.com.cn/article/497347" target="_blank" rel="noopener">http://www.ituring.com.cn/article/497347</a></li><li><a href="http://www.ituring.com.cn/article/264697" target="_blank" rel="noopener">http://www.ituring.com.cn/article/264697</a></li><li><a href="https://git-scm.com/book/zh/" target="_blank" rel="noopener">https://git-scm.com/book/zh/</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li><li><a href="http://www.ituring.com.cn/article/469123" target="_blank" rel="noopener">http://www.ituring.com.cn/article/469123</a></li><li><a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">https://learngitbranching.js.org/?demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;团队协作时的访问权限模型&quot;&gt;&lt;a href=&quot;#团队协作时的访问权限模型&quot; class=&quot;headerlink&quot; title=&quot;团队协作时的访问权限模型&quot;&gt;&lt;/a&gt;团队协作时的访问权限模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://file.ituring.
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="git" scheme="https://caojingyou.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://caojingyou.github.io/2018/06/20/%E7%AE%97%E6%B3%95/"/>
    <id>https://caojingyou.github.io/2018/06/20/算法/</id>
    <published>2018-06-20T01:12:00.000Z</published>
    <updated>2018-07-19T07:59:11.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断是否是2的幂"><a href="#判断是否是2的幂" class="headerlink" title="判断是否是2的幂"></a>判断是否是2的幂</h1><p><a href="https://www.exploringbinary.com/ten-ways-to-check-if-an-integer-is-a-power-of-two-in-c/" target="_blank" rel="noopener">https://www.exploringbinary.com/ten-ways-to-check-if-an-integer-is-a-power-of-two-in-c/</a></p><p><a href="https://blog.csdn.net/K346K346/article/details/53316953" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/53316953</a></p><p>Shift Right</p><pre><code>int isPowerOfTwo (unsigned int x){ while (((x &amp; 1) == 0) &amp;&amp; x &gt; 1) /* While x is even and &gt; 1 */   x &gt;&gt;= 1; return (x == 1);}</code></pre><p>Decrement and Compare</p><pre><code>int isPowerOfTwo (unsigned int x){  return ((x != 0) &amp;&amp; !(x &amp; (x - 1)));}</code></pre><p>Complement and Compare</p><pre><code>int isPowerOfTwo (unsigned int x){  return ((x != 0) &amp;&amp; ((x &amp; (~x + 1)) == x));}</code></pre><h1 id="常用排序算法总结"><a href="#常用排序算法总结" class="headerlink" title="常用排序算法总结"></a>常用排序算法总结</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562536&amp;idx=1&amp;sn=76435fe625722e05c08a118a07c72839&amp;chksm=f1fee96bc689607d35158022250756fbe9230dd633e7760efd51124c9891ede8eefed60fe01f&amp;scene=0#rd" target="_blank" rel="noopener">常用排序算法总结（1）</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650562543&amp;idx=1&amp;sn=c82892b85e1de790766896c6d80d7b3c&amp;chksm=f1fee96cc689607a11ccc109098d070d38ef0bad61c0390fe01348b631bbd492945b6f2b0601&amp;scene=0#rd" target="_blank" rel="noopener">常用排序算法总结（2）</a></p><h2 id="排序算法大体可分为两种："><a href="#排序算法大体可分为两种：" class="headerlink" title="排序算法大体可分为两种："></a>排序算法大体可分为两种：</h2><p>一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。</p><p>另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。</p><p><img src="https://i.imgur.com/Vu6SiPi.jpg" alt=""></p><p>排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。</p><h1 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h1><ul><li>选择排序</li><li>递归</li><li>快速排序</li><li>散列表</li><li>广度优先搜索</li><li>狄克斯特拉算法</li><li>贪婪算法</li><li>动态规划</li><li>K最近邻算法</li></ul><h1 id="常用算法的时间复杂度"><a href="#常用算法的时间复杂度" class="headerlink" title="常用算法的时间复杂度"></a><a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">常用算法的时间复杂度</a></h1><p><img src="https://i.imgur.com/rNBfUlV.jpg" alt=""></p><p><img src="https://i.imgur.com/0qxpoTW.jpg" alt=""></p><p><img src="https://i.imgur.com/jzva3QU.jpg" alt=""></p><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>利用了栈的先进后出的特性，首先遍历显示根节点，然后将右子树（注意是右子树不是左子树）压栈，最后将左子树压栈。由于最后时将左子树节点压栈，所以下一次首先出栈的应该是左子树的根节点，也就保证了先序遍历的规则。</p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>首先将根节点所有的左子树节点压栈，然后一一出栈，每当出栈一个元素后，便将其右子树节点压栈。这样就可以实现首先出栈的永远是栈中的左子树节点，然后是根节点，最后时右子树节点，也就可以保证中序遍历的规则。</p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>使用了两个栈来辅助，其中一个stackIn作为中间存储起到过渡作用，而另一个stackOut则作为最后的输出结果进行遍历显示。众所周知，栈的特性使LIFO（后进先出），那么stackIn在进行存储过渡时，先按照根节点-&gt;左孩子-&gt;右孩子的顺序依次压栈，那么其出栈顺序就是右孩子-&gt;左孩子-&gt;根节点。而每当循环一次就会从stackIn中出栈一个元素，并压入stackOut中，那么这时stackOut中的出栈顺序则变成了左孩子-&gt;右孩子-&gt;根节点的顺序，也就符合了后序遍历的规则。</p><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>使用了一个队列来辅助实现，队列是遵循FIFO（先进先出）的，与栈刚好相反，所以，我们这里只需要按照根节点-&gt;左孩子-&gt;右孩子的入队顺序依次入队，输出时就可以符合根节点-&gt;左孩子-&gt;右孩子的规则了。</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>广度与深度遍历</p><p>广度：队列<br>深度：栈</p><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>哈希（散列）技术既是一种存储方法，也是一种查找方法。</p><h2 id="构造哈希函数的方法"><a href="#构造哈希函数的方法" class="headerlink" title="构造哈希函数的方法"></a>构造哈希函数的方法</h2><p>构造哈希函数的目标在于使哈希地址尽可能均匀地分布在连续的内存单元地址上，以减少发生冲突的可能性，同时使计算尽可能简单以达到尽可能高的时间效率，这里主要看看两个构造哈希函数的方法。</p><p>　　（1）直接地址法</p><p>　　直接地址法取关键字的某个线性函数值为哈希地址，即h(key)=key 或 h(key)=a*key+b</p><p>　　其中，a、b均为常数，这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p><p>　　（2）除留余数法</p><p>　　除留余数法采用取模运算（%）把关键字除以某个不大于哈希表表长的整数得到的余数作为哈希地址，它也是最常用的构造哈希函数的方法，其形式为：h(key)=key%p</p><h2 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h2><p>（1）闭散列法</p><p>　　闭散列法时把所有的元素都存储在哈希表数组中，当发生冲突时，在冲突位置的附近寻找可存放记录的空单元。寻找“下一个”空位的过程则称为探测。</p><p>（2）开散列法</p><p>　　开散列法的常见形式是将所有关键字为同义词的记录存储在一个单链表中。我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p><h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><ul><li>算法图解</li><li>编程之法：面试和算法心得</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断是否是2的幂&quot;&gt;&lt;a href=&quot;#判断是否是2的幂&quot; class=&quot;headerlink&quot; title=&quot;判断是否是2的幂&quot;&gt;&lt;/a&gt;判断是否是2的幂&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.exploringbinary.com/ten-w
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="算法" scheme="https://caojingyou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux与Qt程序设计-读书笔记</title>
    <link href="https://caojingyou.github.io/2018/06/20/Linux%E4%B8%8EQt%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://caojingyou.github.io/2018/06/20/Linux与Qt程序设计-读书笔记/</id>
    <published>2018-06-20T01:12:00.000Z</published>
    <updated>2018-06-21T08:11:37.836Z</updated>
    
    <content type="html"><![CDATA[<p>Linux与Qt程序设计</p><p>陈爽主编</p><p>Citation (APA): 陈爽主编. (2011). Linux与Qt程序设计 [Kindle Android version]. Retrieved from Amazon.com</p><p>安装完毕后，MySQL会自动启动，也可以通过命令来启动和停止MySQL服务。</p><p>（1）启动MySQL服务 <code>chenshuang@myHost:～$sudo start mysql mysql start/running,process 3209</code></p><p>（2）停止MySQL服务 <code>chenshuang@myHost:～$sudo stop mysql mysql stop/waiting</code></p><p>（3）测试MySQL是否启动，返回MySQL服务的进程id。 <code>chenshuang@myHost:～$pgrep mysqlid 3209</code></p><p>（4）通过命令行连接MySQL服务器，登录过程中，需要输入root密码。 </p><pre><code>chenshuang@myHost:～$mysql-uroot-p Enter password: Welcome to the MySQL monitor. Commands end with;or\g. Your MySQL connection id is 34 Server version:5.1.54-1ubuntu4(Ubuntu) Copyright(c)2000,2010,Oracle and/or its affiliates.All rights reserved. This software comes with ABSOLUTELY NO WARRANTY.This is free software, and you are welcome to modify and redistribute it under the GPL v2 license Type&apos;help;&apos;or&apos;\h&apos;for help.Type&apos;\c&apos;to clear the current input statement. mysql&gt;</code></pre><p><code>sudo</code>是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，</p><p>Qt是以工具开发包的形式提供给开发者的，这些工具开发包包括Qt图形设计器（Qt Designer），Makefile 制作工具（qmake），字体国际化工具（Qt Linguist），Qt的C++类库，等等。</p><p>Qt已经成为Linux上自由软件的主流GUI开发工具，是流行的KDE桌面环境的基础。如今在Internet上有很多关于Qt开发的可用资源，如： </p><pre><code>Qt官方主页（英文）：http://Qt.nokia.com/； Qt中文网论坛（Qt中文网论坛）（简体中文）：http://www.Qtcn.org/；匿名访问FTP：ftp://ftp.trolltech.com； Qt中心（论坛，新闻，Wiki）：http://www.Qtcentre.org； Qt的实验室（开发人员博客，研究项目）：http://labs.Qt.nokia.com/；邮件列表：http://lists.Qt.nokia.com.</code></pre><p>Qt为各种专业应用提供了丰富的类库，共计超过370个，主要包括：界面控件类，数据库类，日期时间类，拖曳操作类，事件类，通用容器类，图形图像类，打印类，系统帮助类，布局管理类，设备相关类，输入输出与网络类，窗口相关类等。这些类组成了Qt编程的基本模块—组件，Qt含有用来实现各种专业应用所需要的各种组件。</p><p>图形支持 Qt通过<code>QPainter</code>和<code>QGraphicsViewAPI</code>对高级2D图形提供了支持。此外，Qt通过其OpenGL模块支持3D图形。 QPainter提供了一个全面的2D绘图框架。除了渲染多边形、绘图路径等功能外，还支持平滑处理、渐变和alpha混合。 Qt Graphics View提供了2D场景图形API。它带有高级API，用于在场景中放置对象并在多个视图中显示场景。 Qt开发人员可以使用OpenGL在GUI应用程序中绘制3D图形。Qt提供了单独的Qt OpenGL模块，可将OpenGL图像与本地窗口系统集成在一起。</p><p>Qt SDK包括了Qt库、Qt Creator IDE和Qt工具，Qt SDK同样也支持Linux/X11，Windows，Mac三种主流桌面操作系统。主要开发工具如下。</p><pre><code>（1）Qt Designer。一个功能强大的GUI布局与窗口构造器，能够在所有支持平台上，以本地化的视图外观与认知，快速开发高性能的用户界面。（2）Qt Linguist。一套用来消除国际化工作流程中所带来的障碍的工具。使用Qt Linguist，开发小组可把应用程序的翻译转换外包给非技术性翻译人员，从而可增加精确度，大大加快本地化处理过程。（3）Qt Assistant。一个完全可自定义、重新分配的帮助文件或文档浏览器。</code></pre><p>由于GNOME和KDE都是以X Window系统为基础，所以GNOME和KDE上的应用程序也都是基于X Window系统的。为了屏蔽X协议层实现的细节，Xlib库被开发了出来。Xlib是一种X Window System协议的客户端，以C语言撰写。其功能是与X Server沟通，这样的功能可以让程序人员撰写程序时，无须了解其协议的细节。Xlib是底层库，在应用程序开发过程中很少有应用程序直接调用Xlib，而是使用在Xlib库上发展出的更高层的函数库，如：Xt SDK、Motif SDK和Qt SDK。</p><p>Qt SDK中主要包括：类库（class library）、开发工具（development tools）、平台相关支持（cross-platform support）、授权许可（Flexible license）等。其中类库包含了Qt的所有对外发布的功能组件，介绍如下。</p><pre><code>（1）Core：Qt4的基本模块,定义了其他模块使用的Qt核心的非GUI类,所有其他的模块都依赖于该模块。（2）GUI：定义了图形用户界面类。（3）WebKit：提供了一个在Qt中使用Web Browser的渲染与解析引擎。（4）Graphic View：提供的是一种 Qt Model-View的编程模式，既可以管理大数量的定制2D graphical items，又可与它们交互，有一个视图窗口可以把这些项绘制出来，并支持旋转与缩放。（5）Scripting：提供了对脚本（如Java、Python、Perl、Ruby）的支持。（6）OpenGL：提供了便于在Qt应用程序中使用OpenGL和OpenGL ES加入3D图形的类。（7）XML：定义了处理XML（eXtensible Markup Language）语言的类。（8）Multimedia：提供了播放媒体源的功能。（9）Database：提供了与平台和数据库种类无关的SQL访问接口。（10）Network：定义了Qt的网络编程类。（11）Unit Tests：定义了对Qt应用程序和库进行单元测试的类。</code></pre><p>开发工具集包含了Qt开发者所使用的集成开发环境，介绍如下。</p><pre><code>（1）Qt Creator：是一个跨平台集成开发环境（Integrated Development Environment，IDE），开发人员能够利用这个Qt提供的轻量级开发环境快速、简单地完成开发任务；（2）GUI Designer：是一个所见即所得的GUI构造器，利用Qt Designer，可以拖放各种Qt控件构造图形用户界面并可以在多种平台上使用。（3）Build Tool：包括qmake、moc、uic等，构成了Qt完整的编译体系。（4）Help System：Qt Assistant是可配置且可重新发布的文档阅读器，可轻易进行定制并与用户的Qt应用程序一起重新发布。</code></pre><p>在平台相关支持，Qt支持下列操作系统：Microsoft Windows 95/98、Microsoft Windows NT、Linux、Solaris、SunOS、HP-UX、DigitalUNIX（OSF/1、Tru64）、Irix、Free BSD、BSD/OS、SCO、AIX、OS 390和QNX等。特别是在嵌入式环境中，Qt提供的Qt Embedded已经直接取代了X Server及X Library等角色，将所有的功能全部整合在一起。</p><p>首先要介绍的是扩展名为Pro的文件类型，此类型的文件在Qt中是物理级别最高的，称为工程文件。之所以称之为物理级别最高是因为在Qt中存在会话（session）的概念，在一个会话中可以包含多个Qt工程，Qt通过会话来管理多个工程之间协作开发。在Qt中，应用程序是以Project的形式存在的，Qt将程序的资源（头文件(.h)、源文件(.cpp)、ui文件、qrc文件）以工程的形式组织在一起，Project文件的扩展名是.pro。 Qt工程文件是以标签选项的结构进行组织的，其中常用的标签项有：<code>TEMPLATE</code>、<code>SOURCES</code>、<code>HEADERS</code>、<code>FORMS</code>、<code>TARGET</code>、<code>DESTDIR</code>、<code>INCLUDEPATH</code>、<code>DEPENDPATH</code>、<code>CONFIG等</code>，</p><p>对一些常用的标签进行详细介绍。</p><ul><li>1.TEMPLATE 此标签的作用是用qmake表示Qt工程类型，以便qmake程序根据不同的工程类型配置编译过程。 TEMPLATE的主要类型如下。 <ul><li>app：建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，它将被使用。 </li><li>lib：建立一个库的makefile。 </li><li>subdirs：这是一个特殊的模板，它可以创建一个能够进入的特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。 </li><li>vcapp：建立一个应用程序的Visual Studio项目文件。 </li><li>vclib：建立一个库的Visual Studio项目文件。 </li><li>vcsubdirs：同subdirs。</li></ul></li><li>2.TARGET 可执行应用程序的名称。默认值为项目文件的名称。（如果需要扩展名，会被自动加上。） </li><li>3.Qt Qt 变量被用来声明引用Qt提供的扩展模块，如：core，gui，network，opengl，sql，svg，xml，xmlpatterns，Qt3support。Qt的core模块和gui模块会被作为默认选项自动添加，如果想去掉默认选项，可以通过Qt-=gui实现。 </li><li>4.CONFIG CONFIG 变量指定了编译器所要使用的选项和所需要被连接的库。配置变量中可以添加任何东西，但只有下面这些选项可以被qmake识别。<ul><li>下面这些选项控制着使用哪些编译器标志： <ul><li>release：应用程序将以release模式连编。如果debug被指定，它将被忽略。 </li><li>debug：应用程序将以debug模式连编。 </li><li>warn_on：编译器会输出尽可能多的警告信息。如果warn_off被指定，它将被忽略。 </li><li>warn_off：编译器会输出尽可能少的警告信息。</li></ul></li><li>下面这些选项定义了所要连编的库/应用程序的类型： <ul><li>Qt：应用程序是一个Qt应用程序，并且Qt库将会被连接。</li><li>thread：应用程序是一个多线程应用程序。 </li><li>x11：应用程序是一个X11应用程序或库。 </li><li>windows：只用于app模板，应用程序是一个Windows下的窗口应用程序。 </li><li>console：只用于app模板，应用程序是一个Windows下的控制台应用程序。 </li><li>dll：只用于lib模板，库是一个共享库（dll）。 </li><li>staticlib：只用于lib模板，库是一个静态库。 </li><li>plugin：只用于lib模板，库是一个插件，这将会使dll选项生效。</li></ul></li></ul></li><li>5.HEADERS 应用程序中的所有头文件的列表。 </li><li>6.SOURCES 应用程序中的所有源文件的列表。 </li><li>7.FORMS 应用程序中的所有.ui文件（由Qt设计器生成）的列表。 </li><li>8.LIBS 记录了程序中所用到的其他库文件列表（以-l开头）及库文件的搜索路径（以-L开头）。 </li><li>9.TARGET 可执行应用程序的名称。默认值为项目文件的名称。（如果需要扩展名，会被自动加上。） </li><li>10.DESTDIR 放置可执行程序目标的目录。 </li><li>11.DEFINES 应用程序所需的额外的预处理程序定义的列表。 </li><li>12.INCLUDEPATH 应用程序所需的额外的包含路径的列表。 </li><li>13.DEPENDPATH 应用程序所依赖的搜索路径。 </li><li>14.DEF_FILE 只有Windows需要，应用程序所要连接的.def文件。 </li><li>15.RC_FILE 只有Windows需要，应用程序的资源文件。 </li><li>16.RES_FILE 只有Windows需要，应用程序所要连接的资源文件。</li></ul><p>MOC（Meta-Object Compiler）是用来实现Qt对C++的扩展部分。MOC解析C++文件中的类定义，并生成元对象（Meta Object）的代码，包括所有signal和slot成员的名字和函数指针。Meta Object还包含诸如对象的类名称等静态信息，以此来检查该对象的继承派生关系。moc文件必须与目标类的实现代码一起被编译和链接。 MOC 读取 C++类文件。如果它发现其中该类包含<code>Q_OBJECT</code> 宏，它就会给含有<code>Q_OBJECT</code>宏的类生成另一个含有元对象代码的C++源文件。除了提供对象间通信的信号和槽机制之外，派生自QObject中的元对象代码实现其他特征。</p><pre><code>（1）className()：函数在运行的时候以字符串返回类的名称，不需要C++编译器中的本地运行类型信息（RTTI）的支持。（2）inherits()：函数返回这个对象是否是一个继承于QObject继承树中一个特定类的实例。（3）tr()：用于国际化中的字符串翻译。（4）setProperty()、property()：两个函数是用来通过名称动态设置和获得对象属性的。（5）metaObject()：函数返回这个类所关联的元对象。</code></pre><p>单继承方法是Qt4之后的默认实现方法。以上面所创建的MyMainWindow工程为例，它的主窗口名为MyMainWindow，它继承于QMainWindow，它有一个Ui:: MyMainWindow的私有成员，并在MyMainWindow的构造函数中，实例化这个私有的Ui::MyMainWindow，之后调用这个私有Ui::MyMainWindow的setupUi 方法，设置MyMainWindow的用户界面接口，即按UI文件中记录的界面信息初始化MyMainWindow的界面。至此，一个按照UI文件设计的界面的窗口就建立起来了。</p><p>在Linux操作系统中，采用了很多共享对象技术（Shared Object），虽然它和Windows里的动态库相对应，但它并不称为动态库。相应的共享对象文件以.so作为后缀，</p><p>所有从<code>QObject</code>或其子类(例如QWidget)派生的类都能够包含<code>信号和槽</code>。当对象改变其状态时，信号就由该对象发射(<code>emit</code>)出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射，系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。</p><p>指定信号 <code>signal</code>时必须使用Qt的宏 <code>SIGNAL()</code>，当指定槽函数时必须使用宏 <code>SLOT()</code>。如果发射者与接收者属于同一个对象，那么在<code>connect</code> 调用中接收者参数可以省略。</p><p>在Windows 平台下，Qt程序的消息处理系统每收到一个操作系统底层传来的消息就会调用<code>winEventFilter</code>函数，原型 如下： </p><pre><code>bool winEventFilter( MSG* msg, long* result);</code></pre><p>窗口消息截获的主要功能实现是通过派生 QApplication类并重新实现函数winEventFilter。当程序接收到一个发自Windows的消息时会调用winEventFilter并将消息的内容通过参数msg进行传递，在重新实现的winEventFilter中，首先对消息的类型进行判断，当消息的类型是窗口消息时（在Windows中窗口消息的类型定义为<code>WM_COPYDATA</code>），就将消息的内容还原成一个字符串，并触发信号signalReceiveCopyData将内容传递出去。</p><p>当派生类QApplication4Win32Filter 触发信号后，槽会被调用，从而实现信息的传递。</p><p>与前节所述的Windows 消息截获相类似，Linux平台下消息的截获是通过派生应用类QApplication并重新实现函数x11EventFilter来实现的，不同之处在于Linux平台下x11EventFilter的参数是一个定义自XLib的结构体指针。Xlib是X Window提供的API集合，Qt建立在Xlib之上。</p><p>在Qt中引入了一个MVC的变体——Model/View结构。这个结构依然是分离数据存储与数据，它与MVC都基于同样的思想，但它更简单一些。在几个不同的View 上显示同一个数据成为可能，需重新实现新的View时,不必改变底层的数据结构。为了更灵活地对用户输入进行处理，引入了delegate的概念。它的好处是，数据项的渲染与编程可以进行定制。</p><p>在Qt Creator/Desinger中，常用的基础控件都被放在WidgetBox中，而且根据控件的类型进行了分类。</p><p>QButton类是按钮窗口控件的抽象基类，并且为用户提供了按钮共有的功能。其中包括isDown()、isOn()、isEnabled()、setAutoRepeat()、setToggleButton()这五种基本状态，以及pressed()、released()、clicked()、toggled(bool)、stateChanged(int)五种基本信号。</p><p>用户可以通过QPushButton类创建一个常用的按钮。</p><p>QButtonGroup类将多个QButton窗口控件组合在一起。它是一组按钮的父窗口控件，也就是说它是按钮构造函数中的parent参数。QRadionButton类则是单选按钮控件，一般与QButtonGroup类结合使用来控制组群的唯一性。</p><p>QlineEdit类是一个单行文本输入框，用户在文本框内可以输入文字或数字，也可以对输入的文本进行验证，还可以设置文本的显示方式。下面展示了几种不同类型的QlineEdit类，包括字符串输入、密码输入、只读和验证类型等，</p><p>与QlineEdit类的单行文本框不同，QtextEdit类提供了强大的单页面的多信息文本编辑器，它支持浏览HTML风格标记的多信息文本格式。QtextEdit类提供了三种文本操作模式，包括：一般文本编辑器、多信息文本编辑器和文本查看器。</p><p>通过调用QtextEdit类提供的setAcceptRichText()来设置该文本部件对象是否接受富文本形式。</p><p>QCalendarWidget类提供一个日历控件，它允许用户简单直观地选择日期。</p><p>QCombox类是一个下拉列表框控件，它为用户提供了一组可以选择的下拉列表。用户在使用QCombox类的过程中需引入头文件声明#include。</p><p>QLCDNumber类是一个LCD显示控件，该控件以LCD方式显示数字。用户在使用QLCDNumber类的过程中需引入头文件声明#include。</p><p>QProgressBar类是一个横的或者竖的进度条控件，该类常用来显示目前的工作进度，</p><p>QSpinBox类和QDoubleSpinBox类都是微调控件，QSpinBox类常用来手动设置整数和一些其他数据的集合，而QdoubleSpinBox类常用来设置浮点数。它们允许用户通过单击上下按钮来选择值，或者通过按键盘的Up或Down键来增大或减小当前显示值，也允许手工设置值。</p><p>QSlider类是一个横或者竖的滑动条控件,该类通过滑块来控制一个绑定变量的值。</p><p>QTreeWidget类是一种树形的部件，它以树的形式显示各个项，每一项用QtreeWidgetItem类来描述。</p><p>Qt提供了三种方式来管理窗口上子窗口部件的布局。 </p><ol><li>绝对位置法这种布局方法是一种比较原始的布局窗口部件的方法。该布局方法通过调用基类QWidget提供的setGeometry()函数来设置子窗口部件在父窗口中显示的固定大小和位置。这种布局方式有很多种缺点，主要包括：<ol><li>无法改变窗口的大小；</li><li>当应用程序的运行环境或者样式发生改变时，有可能会影响子窗口部件的显示效果和内容；</li><li>为了达到比较好的显示效果，必须通过人工反复计算子窗口部件的大小和位置，不易于开发和维护。 </li></ol></li><li>人工位置法这种布局方式也是通过调用基类QWidget提供的setGeometry()函数来设置子窗口部件在父窗口中显示的位置和大小。但与绝对位置法不同的是，该方法通过重载void QWidget::resizeEvent(QResizeEvent*)函数使得子窗口部件大小和父窗口部件大小成比例。 </li><li>布局管理器方式这种布局方法是一种简单的布局窗口部件的方法。该布局方法为不同类型的窗口部件提供一系列合适的默认值，并且会根据窗口的大小策略和最大、最小尺寸，自动调整布局来响应样式、窗口大小的变化。 </li></ol><p>布局管理器：Qt布局管理器负责在父窗口部件区域内存放子窗口部件。布局管理器可以使其中的窗口部件自动定位并重新调整它们的位置和大小。QLayout类是布局管理器的基类，它的派生类主要有QBoxLayout、QFormLayout、QGridLayout和QStackedLayout，而QBoxLayout又有两类派生类QHBoxLayout和QVBoxLayout。</p><p>Qt中常用的五种布局管理器的特点如下。</p><pre><code>（1）QHBoxLayout：水平布局管理器，按水平方向存放窗口部件。（2）QVBoxLayout：垂直布局管理器，按垂直方向存放窗口部件。（3）QGridLayout：网格布局管理器，按二维网格方式存放窗口部件。（4）QFormLayout：表单布局管理器，按表单形式存放窗口部件。（5）QStackedLayout：栈布局管理器，按类似栈方式存放窗口部件。</code></pre><p>QFormLayout布局管理器将窗口部件按表单形式布局，</p><p>QStackedLayout布局管理器按照一种类似栈的方式排列窗口部件，</p><pre><code>//Main.cpp#include&quot;mainwindow.h&quot;int main(int argc, char *argv[]){    QApplication a(argc, argv);    QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;gb18030&quot;));    MainWindow w;    w.show();    return a.exec();}</code></pre><p> 在上述代码中，MainWindow是派生自QMainWindow的主窗口应用程序类。Main文件完成两个功能：设置字符集支持汉字和创建并显示主窗口应用程序。</p><p>根据数据在容器中排列的特性，容器可以分为序列式（Sequence）和关联式（Associative）两种。</p><p>与标准模板库对应，Qt也提供了一组自己的通用容器模板类。与标准模板库相比，在Qt的开发环境中更加易于使用。Qt通用容器类都是隐含共享（Implicit Sharing）的，这使得容器类实例在传值操作中内存开销最优化。Qt提供了如QVector、QList等序列式容器模板类（它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价），也提供了如QMap、QHash等关联式容器模板类。</p><p>QFile类是一个操作文件的输入/输出设备，是用来读写二进制文件和文本文件的。用户可以单独使用QFile类，也可以和QDataStream或QTextStream一起使用。</p><p>QDir类提供了一种与平台无关的遍历目录结构并获得目录结构当中的内容，使用QDir类可以操作目录、存取目录或文件信息、操作底层文件系统和存取Qt资源文件。Qt使用“/”作为分隔符。用户通过QDir类提供的convertSeparators()静态函数，根据底层操作系统环境的不同，自动将程序中的目录分隔符转换成符合要求的符号（如Windows使用“\”，Linux使用“/”）。</p><p>QFileInfo类提供了一种与平台无关的文件信息，包括文件名称、路径、读取权限、大小、最后修改/读取时间及是否为目录或者符号链接等。要读取一个文件信息，可以在QFileInfo类的构造函数中设置文件名，也可以通过setFile()函数来设置。</p><p>exists()函数用来判断一个文件是否存在，size()函数用来返回文件的大小。文件类型可以通过isFile()、isDir()和isSymLink()来获取。symLinkTarget()函数用来返回符号链接所指向的文件名。为了提高运行效率，QFileInfo类将文件的一部分信息存入缓存当中，由于文件在使用过程中，很有可能被应用程序改变，所以QFileInfo类提供了refresh()函数来刷新文件信息。</p><p>Qt提供了<code>QFileSystemWatcher</code>类来监视目录或者文件的变化。addPath()、addPaths()函数用来监视指定的一个或者多个文件或者目录。如果需要移除不需要监视的文件或者目录，则可以调用removePath()或者removePaths()函数。当所监视的文件发生改变时，会产生一个fileChange()信号，当所监视的目录发生改变时，会产生一个directoryChange()信号。</p><p>Qt提供了QXML模块来支持对XML数据的处理。QXML模块提供了以下两种常见的XML文件操作方式。（1）DOM（Document Object Model，文档对象模型），其实现方式是将整个XML文档数据以树状结构的形式加载到内存。这种方式的优点是操作简单，缺点是将整个XML文件放入内存，不适合处理过大文件。（2）SAX（Simple API for XML，XML简单应用程序接口），其实现方式是基于事件的循序存取XML数据流。这种方式的优点是适合处理大的文件，但是操作比较复杂。</p><p>在Qt中，常见的操作XML的类有QXmlStreamReader、QDomDocument、QxmlDefault Handler等。</p><p>Qt提供了三种生成XML文档的方法：使用QXmlStreamWriter、DOM树保存和手动生成XML文档。利用QDomDocument类生成XML首先需要构造DOM树，然后调用save()方法将占据保存为XML文档。</p><p>用户可以配置Qt来支持多线程，并提供类来表示线程、互斥锁、信号灯、线程全局存储，另外还提供支持不同锁定机制的类。</p><p>Qt通过三种形式提供了对线程的支持。它们分别是: </p><pre><code>（1）平台无关的线程类；（2）线程安全的事件投递；（3）跨线程的信号-槽连接。</code></pre><p>Qt包含下面一些线程相关的类：</p><pre><code>（1）QThread提供了开始一个新线程的方法；（2）QThreadStorage提供逐线程数据存储；（3）QMutex提供相互排斥的锁，或互斥量；（4）QMutexLocker是一个互斥锁的，它可以自动对QMutex加锁与解；（5）QReadWriterLock提供了一个可以同时读操作的锁；（6）QReadLocker与QWriteLocker是便利类，它自动对QReadWriteLock加锁与解锁；（7）QSemaphore提供了一个整型信号量，是互斥量的泛化；（8）QWaitCondition提供了一种方法，使得线程可以在被其他线程唤醒它之前一直休眠。</code></pre><p>Qt 4中实现线程同步的机制包括：互斥体（QMutex）、读写锁（QReadWriteLock）、信号量（QSemaphore）和条件变量（QWaitCondition）。</p><p>QSemaphore类是QMutex类的一般化，它可以保护一定数量的相同资源，与此相对，一个QMutex类只保护一个资源。</p><p>使用QSemaphore类来控制对环状缓冲的访问，此缓冲区被生产者线程和消费者线程共享。生产者不断向缓冲区写入数据直到缓冲末端，再从头开始。消费者从缓冲区不断读取数据。信号量比互斥量有更好的并发性，假如用互斥量来控制对缓冲区的访问，那么生产者、消费者不能同时访问缓冲区。然而，在同一时刻，不同线程访问缓冲区的不同部分并没有什么危害。</p><p>QWaitCondition类允许线程在某些情况发生时唤醒其他的线程。当一个或多个线程阻塞等待时，可用wakeOne()或wakeAll()执行唤醒操作。wakeOne()随机唤醒一个线程，wakeAll()唤醒所有线程。</p><p>每一个Qt的应用程序都有一个全局的QThreadPool对象，可以通过函数globalInstance()调用该线程池全局对象。</p><p>事实上，这里是使用QThreadPool类来运行一个QRunnable对象，它维护了一个线程池。通过调用QThreadPool::start(runnable)，把一个QRunnable放入QThreadPool的运行队列中；只要线程是可见的，QRunnable将会被拾起并且在那个线程里运行。尽管所有的Qt应用程序都有一个全局的线程池，且它是通过调用QThreadPool::globalInstance()可见的，但通常是显式地创建并管理一个私有的QThreadPool实例。</p><p>Qt支持的数据库类型</p><p>Qt的数据库模块主要通过QSqlDatabase类和QSqlQuery类来实现对数据库的绑定、连接和执行。可以通过QSqlDatabase类对象实现对数据库的绑定和连接，然后通过QSqlQuery类对象执行相关的SQL语句对数据库进行操作。</p><pre><code>QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);db.setHostName(&quot;qpk&quot;);db.setDatabaseName(&quot;bookmis.db&quot;);db.setUserName(&quot;qpk&quot;);db.setPassword(&quot;cugbupt&quot;);bool ok = db.open();QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);db.setDatabaseName(&quot;bookmis.db&quot;);if(!db.open()){    QMessageBox::critical(0, qApp-&gt;tr(&quot;Cannot open database&quot;), qApp-&gt;tr(&quot;Unable to establish a database connection.\n&quot;), QMessageBox::Cancel);    return false;}</code></pre><p> 在上述代码中，首先实例化QSqlDatabase对象并指定加载SQLite数据库，指定打开的数据库名称。由于SQLite为文件数据库，所以无须指定用户名密码等相关信息。</p><p>QSqlQuery提供了执行数据库语句的方法，在Qt中利用QSqlQuery类实现了执行SQL语句。它可以返回所有的执行结果。当建立好数据库连接后可以使用<code>QSqlQuery::exec()</code>，如同下面的语句： <code>QSqlQuery query; query.exec(&quot;SELECT*FROM book&quot;);</code> 当创建一个QSqlQuery对象后，可以被指定的QSqlDatabase对象连接来使用。</p><p>在Qt中，QHostInfo类用来获取主机网络配置的相关信息。该类提供了两个常用的静态函数来获取主机信息，一个是使用<code>lookupHost( const QString &amp; name, QObject*receiver, const char *member)</code>函数异步查询主机信息，并且在主机查询完毕后发出一个信号，另一个是使用<code>QHostInfo fromName(const QString&amp;name)</code>函数阻塞查询主机信息，并且返回一个QHostInfo对象。</p><p>TCP是一种可靠的、面向数据量、面向连接的传输协议，在它的基础上构成了HTTP、FTP等高层网络协议。而UDP 则是一种不可靠的、面向数据报的、面向无连接的传输协议。在Qt中，QTcpSocket、QTcpServer类用来实现TCP客户端和服务器端的应用程序，QUdpSocket类可以用来发送和接收UDP数据报。</p><p>超文本传输协议 HTTP是一种应用级的网络文件传输协议，主要用于文件传输。Qt提供了QHttp、QNetworkAccessManager等类来构建 HTTP客户端，并且提供了许多常用的操作。</p><p>QHttp采用异步执行方式，如果某个操作不能立即执行完毕，函数也会马上返回。</p><p>Qt对2D和3D图形提供了强大的支持。Qt的2D图形类支持点阵图形和向量图形，可以加载并保存各种图形格式，并可将文本和图形导出为Portable Document Format(PDF)文件。Qt可以绘制转换后的Unicode文本和Scalable Vector Graphics(SVG)图纸，并可为需要交互的应用程序提供功能全面的Canvas。Qt实际上是与平台无关的OpenGL编程的一个标准GUI框架。</p><p>Qt的2D图形系统的基础是类QPainter。QPainter类提供了一个与平台无关的API，以便在控件和其他绘图设备中进行绘图。Qt的所有内建的控件均可使用QPainter来绘制其本身。QPainter能够绘制各种几何图形（点、线、矩形、椭圆、圆弧、弦、扇形、多段线、贝赛尔曲线），还能绘制位图、图像和文字。此外QPainter还提供了很多高级功能：如平滑（平滑文字和几何图形的边界），透明度，渐变色和矢量路径。QPainter还支持矩阵变换，使绘制2D图形和分辨率无关。</p><p>Qt一共提供了四个继承自QPainterDevice类，分别是QPixmap、QBitmap、QImage和QPicture。</p><p>Qt中使用QPainterPath显示任意路径曲线的绘制。通过连接基本图形元素，如直线、椭圆、多段线、圆弧、二次和三次贝塞尔曲线等，QPainterPath类能确定任何矢量图形。因此，绘图路径（Painter Paths）是最基本的绘制元素，任何图形和图形的组合都可以用路径（Path）表示。一个路径能够确定一个轮廓，由这个轮廓确定的区域可以由刷子来填充。</p><p>绘图设备是指继承QPainterDevice的子类。Qt一共提供了四个这样的类，分别是QPixmap、QBitmap、QImage和QPicture。其中，QPixmap专门为图像在屏幕上的显示做了优化，而QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。QImage专门为图像的像素级访问做了优化。QPicture 则可以记录和重现QPainter的各条命令。</p><p>坐标系变换是利用变换矩阵来进行的，可以利用QTransform类来设置变换矩阵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux与Qt程序设计&lt;/p&gt;
&lt;p&gt;陈爽主编&lt;/p&gt;
&lt;p&gt;Citation (APA): 陈爽主编. (2011). Linux与Qt程序设计 [Kindle Android version]. Retrieved from Amazon.com&lt;/p&gt;
&lt;p&gt;安装完
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Qt" scheme="https://caojingyou.github.io/tags/Qt/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="https://caojingyou.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++性能优化指南-读书笔记</title>
    <link href="https://caojingyou.github.io/2018/06/19/C++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://caojingyou.github.io/2018/06/19/C++性能优化指南-读书笔记/</id>
    <published>2018-06-19T02:38:00.000Z</published>
    <updated>2018-06-21T02:02:01.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows计时函数"><a href="#Windows计时函数" class="headerlink" title="Windows计时函数"></a>Windows计时函数</h1><pre><code>time()GetTickCount()GetTickCount64()timeGetTime(clock()GetSystemTimeAsFileTime( ) GetSystemTimePreciseAsFileTime()QueryPerformanceCounter()</code></pre><h1 id="创建-stopwatch-类"><a href="#创建-stopwatch-类" class="headerlink" title="创建 stopwatch 类"></a>创建 stopwatch 类</h1><h2 id="stopwatch-类"><a href="#stopwatch-类" class="headerlink" title="stopwatch 类"></a>stopwatch 类</h2><pre><code>template &lt;typename T&gt; class basic_stopwatch : T{    typedef typename T BaseTimer;public:    // 创建一个秒表，开始计时一项程序活动（可选）    explicit basic_stopwatch(bool start);    explicit basic_stopwatch(char const *activity = &quot;Stopwatch&quot;,                             bool start = true);    basic_stopwatch(std::ostream &amp;log,                    char const *activity = &quot;Stopwatch&quot;,                    bool start = true);    // 停止并销毁秒表    ~basic_stopwatch();    // 得到上一次计时时间（上一次停止时的时间）    unsigned LapGet() const;    // 判断：如果秒表正在运行，则返回true    bool IsStarted() const;    // 显示累计时间，一直运行，设置/返回上次计时时间    unsigned Show(char const *event = &quot;show&quot;);    // 启动（重启）秒表， 设置/返回上次计时时间    unsigned Start(char const *event_namee = &quot;start&quot;);    // 停止正在计时的秒表， 设置/返回上次计时时间    unsigned Stop(char const *event_name = &quot;stop&quot;);private: // 成员变量    char const *m_activity; // &quot;activity&quot;字符串    unsigned m_lap; // 上次计时时间（上一次停止时的时间）    std::ostream &amp;m_log; // 用于记录事件的流};</code></pre><h2 id="使用了-的-TimerBase-类"><a href="#使用了-的-TimerBase-类" class="headerlink" title="使用了  的 TimerBase 类"></a>使用了 <chrono> 的 TimerBase 类</chrono></h2><pre><code># include &lt;chrono&gt;using namespace std::chrono;class TimerBase{public:    // 清除计时器    TimerBase() : m_start(system_clock::time_point::min()) { }    // 清除计时器    void Clear()    {        m_start = system_clock::time_point::min();    }    // 如果计时器正在计时，则返回true    bool IsStarted() const    {        return (m_start.time_since_epoch() != system_clock::duration(0));    }    // 启动计时器    void Start()    {        m_start = system_clock::now();    }    // 得到自计时开始后的毫秒值    unsigned long GetMs()    {        if (IsStarted())        {            system_clock::duration diff;            diff = system_clock::now() - m_start;            return (unsigned)(duration_cast&lt;milliseconds&gt;(diff).count());        }        return 0;    }private:    system_clock::time_point m_start;};</code></pre><p> TimerBase 类与这个类的功能相同，不过其中使用的是在 Windows 上和<br>Linux 上都可以使用的 clock() 函数。</p><h2 id="使用了-clock-的-TimerBase-类"><a href="#使用了-clock-的-TimerBase-类" class="headerlink" title="使用了 clock() 的 TimerBase 类"></a>使用了 clock() 的 TimerBase 类</h2><pre><code>class TimerBaseClock{public:    // 清除计时器    TimerBaseClock()    {        m_start = -1;    }    // 清除计时器    void Clear()    {        m_start = -1;    }    // 如果计时器正在计时，则返回true    bool IsStarted() const    {        return (m_start != -1);    }    // 启动计时器    void Start()    {        m_start = clock();    }    // 得到自计时开始后的毫秒值    unsigned long GetMs()    {        clock_t now;        if (IsStarted())        {            now = clock();            clock_t dt = (now - m_start);            return (unsigned long)(dt * 1000 / CLOCKS_PER_SEC);        }        return 0;    }private:    clock_t m_start;};</code></pre><p>这种实现方式的优点是在不同 C++ 版本和不同操作系统之间具有可移植性，缺点是在<br>Linux 上和 Windows 上， clock() 函数的测量结果略有不同。</p><h2 id="使用了-gettimeofday-的-TimerBase"><a href="#使用了-gettimeofday-的-TimerBase" class="headerlink" title="使用了 gettimeofday() 的 TimerBase"></a>使用了 gettimeofday() 的 TimerBase</h2><pre><code># include &lt;chrono&gt;using namespace std::chrono;class TimerBaseChrono{public:    // 清除计时器    TimerBaseChrono() :        m_start(system_clock::time_point::min())    {    }    // 清除计时器    void Clear()    {        m_start = system_clock::time_point::min();    }    // 如果计时器正在计时，则返回true    bool IsStarted() const    {        return (m_start != system_clock::time_point::min());    }    // 启动计时器    void Start()    {        m_start = std::chrono::system_clock::now();    }    // 得到自计时开始后的毫秒值    unsigned long GetMs()    {        if (IsStarted())        {            system_clock::duration diff;            diff = system_clock::now() - m_start;            return (unsigned)                   (duration_cast&lt;milliseconds&gt;(diff).count());        }        return 0;    }private:    std::chrono::system_clock::time_point m_start;};</code></pre><p>TimerBase 类可以工作于旧版本的 Windows 上和 Linux 上。如果是在<br>Windows 上，那么还必须显式地提供 gettimeofday() 函数，因为它既不属于 Windows<br>API，也不属于 C 标准库。</p><p>这种实现方式在不同的 C++ 版本和不同操作系统之间具有可移植性。但当运行于 Windows<br>上时，需要实现 gettimeofday() 函数。    </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>Stopwatch sw(&quot;activity&quot;);</code></pre><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>timer（V1）库包含三个小组件，分别是：计时器timer、progress_timer和进度指示器progress_display，</p><p>timer类可以测量时间的流逝，是一个小型的计时器，提供毫秒级别的计时精度和操作函数，供程序员手工控制使用，就像是个方便的秒表。</p><p>progress_timer也是一个计时器，它继承自timer，会在析构时自动输出时间，省去了timer手动调用elapsed（）的工作，是一个用于自动计时相当方便的小工具。</p><p>progress_display可以在控制台上显示程序的执行进度，如果程序执行很耗费时间，那么它能够提供一个友好的用户界面，不至于让用户在等待中失去耐心。</p><p>timer和progress_timer是两个用于计时的小工具，实现原理很简单，使用了C标准中的std：：clock（），精度不高但足够用。特别是progress_timer，它利用了C++中析构函数会被自动调用的特点，能够自动显示时间，用起来更方便。但如果我们需要更高精度的计时，那么应该使用timer库的另一个组件：cpu_timer</p><p>cpu_timer使用了chrono库的高精度时钟high_resolution_clock，不仅能够度量进程使用的实际时间，还能够度量CPU时间，它支持最高到微秒精度的计时，而且使用起来同样非常方便，是旧版本timer的很好替代品。</p><p>auto_cpu_timer是一个类似于progress_timer的自动计时器，它继承自cpu_timer</p><h1 id="采用更丰富的-std-string-库"><a href="#采用更丰富的-std-string-库" class="headerlink" title="采用更丰富的 std::string 库"></a>采用更丰富的 std::string 库</h1><h2 id="Boost-字符串库（http-www-boost-org-doc-libs-view-category-String）"><a href="#Boost-字符串库（http-www-boost-org-doc-libs-view-category-String）" class="headerlink" title="Boost 字符串库（http://www.boost.org/doc/libs/?view=category_String）"></a>Boost 字符串库（<a href="http://www.boost.org/doc/libs/?view=category_String）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/?view=category_String）</a></h2><p>Boost 字符串库提供了按标记将字符串分段、格式化字符串和其他操作 std::string 的<br>函数。这为那些喜爱标准库中的 <algorithm> 头文件的开发人员提供了很大的帮助。</algorithm></p><h2 id="C-字符串工具包-（http-www-partow-net-programming-strtk-index-html）"><a href="#C-字符串工具包-（http-www-partow-net-programming-strtk-index-html）" class="headerlink" title="C++ 字符串工具包 （http://www.partow.net/programming/strtk/index.html）"></a>C++ 字符串工具包 （<a href="http://www.partow.net/programming/strtk/index.html）" target="_blank" rel="noopener">http://www.partow.net/programming/strtk/index.html）</a></h2><p>另一个选择是 C++ 字符串工具包（StrTk）。StrTk 在解析字符串和按标记将字符串分段<br>方面格外优秀，而且它兼容 std::string 。</p><h2 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h2><p>C++引入了ostringstream、istringstream、stringstream这三个类，要使用他们创建对象就必须包含sstream.h头文件。</p><pre><code>istringstream类用于执行C++风格的串流的输入操作。 ostringstream类用于执行C风格的串流的输出操作。 strstream类同时可以支持C风格的串流的输入输出操作。</code></pre><p>C++ 中还有另外一种字符串。 std::stringstream 之于字符串，就如同 std::ostream 之于<br>输出文件。 std::stringstream 类以一种不同的方式封装了一块动态大小的缓冲区（事实<br>上，通常就是一个 std::string ），数据可以被添加至这个实体<br>中。 std::stringstream 是一个很好的例子，它展示了如何在类似的实现的顶层使用不同的<br>API 来提高代码性能。</p><h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><p>string_view 可以解决 std::string 的某些问题。它包含一个指向字符串数据的无主指<br>针和一个表示字符串长度的值，所以它可以表示为 std::string 或字面字符串的子字<br>符串。与 std::string 的返回值的成员函数相比，它的 substring 和 trim 等操作更高<br>效。 std::string. string_view 可能会被加入到 C++14 中。有些编译器现在已经实现了<br>std::experimental::string_view 。 string_view 与 std::string 的接口几乎相同。<br>std::string 的问题在于指针是无主的。程序员必须确保每个 string_view 的生命周期<br>都不会比它所指向的 std::string 的生命周期长。</p><h2 id="boost-string-ref"><a href="#boost-string-ref" class="headerlink" title="boost.string_ref"></a>boost.string_ref</h2><p>string_ref提供了一个“只读视图”，可以避免字符串的拷贝代价，是更好的const std：：string&amp;</p><p>boost.string_ref就是这样一种轻量级的字符串，顾名思义，它只持有字符串的引用，没有内存拷贝成本，所以运行效率很高，是更好的const std：：string&amp;。</p><p>string_ref是轻量级的字符串表示，功能与std：：string一样，但操作它只需要很小的成本，完全可以代替const std：：string&amp;来提高字符串处理的效率，非常有价值。string_ref即将在C++17标准里出现，但可能采用新名字string_view。 </p><h2 id="folly-fbstring-（https-github-com-facebook-folly-blob-master-folly-docs-FBString-md）"><a href="#folly-fbstring-（https-github-com-facebook-folly-blob-master-folly-docs-FBString-md）" class="headerlink" title="folly::fbstring （https://github.com/facebook/folly/blob/master/folly/docs/FBString.md）"></a>folly::fbstring （<a href="https://github.com/facebook/folly/blob/master/folly/docs/FBString.md）" target="_blank" rel="noopener">https://github.com/facebook/folly/blob/master/folly/docs/FBString.md）</a></h2><p>folly是一个完整的代码库，它被 Facebook 用在了他们自己的服务器上。它包含了高度<br>优化过的、可以直接替代 std::string 的 fbstring 。在 fbstring 的实现方式中，对于短<br>的字符串是不用分配缓冲区的。 fbstring 的设计人员声称他们测量到性能得到了改善。<br>由于这种特性，Folly 很可能非常健壮和完整。目前，只有 Linux 支持 Folly。</p><h2 id="字符串类的工具包（http-johnpanzer-com-tsc-cuj-ToolboxOfStrings-html）"><a href="#字符串类的工具包（http-johnpanzer-com-tsc-cuj-ToolboxOfStrings-html）" class="headerlink" title="字符串类的工具包（http://johnpanzer.com/tsc_cuj/ToolboxOfStrings.html）"></a>字符串类的工具包（<a href="http://johnpanzer.com/tsc_cuj/ToolboxOfStrings.html）" target="_blank" rel="noopener">http://johnpanzer.com/tsc_cuj/ToolboxOfStrings.html）</a></h2><p>这篇发表于 2000 年的文章和代码描述了一个模板化的字符串类型，其接口与 SGI 5 的<br>std::string 相同。它提供了一个固定最大长度的字符串类型和一个可变长度的字符串<br>类型。这是模板元编程（template metaprogramming）魔法的一个代表作，但可能会让<br>一些人费解。对于那些致力于设计更好的字符串类的开发人员来说，这是一个切实可行<br>的候选类库。</p><h2 id="C-03-表达式模板（http-craighenderson-co-uk-papers-exptempl-）"><a href="#C-03-表达式模板（http-craighenderson-co-uk-papers-exptempl-）" class="headerlink" title="C++03 表达式模板（http://craighenderson.co.uk/papers/exptempl/）"></a>C++03 表达式模板（<a href="http://craighenderson.co.uk/papers/exptempl/）" target="_blank" rel="noopener">http://craighenderson.co.uk/papers/exptempl/）</a></h2><p>这是在 2005 年的一篇论文中展示的用于解决特定字符串连接问题的模板代码。表达<br>式模板重写了 + 运算符， 这样可以创建一个表示两个字符串的连接或是一个字符串和<br>一个字符串表达式的连接的中间类型。当表达式模板被赋值给一个字符串时，表达式<br>模板将内存分配和复制推迟至表达式结束，只会执行一次内存分配。表达式模版兼容<br>std::string 。当既存的代码中有一个连接一长串子字符串的表达式时，使用表达式模<br>板可以显著地提升性能。这个概念可以扩展至整个字符串库。</p><h2 id="Better-String-库（http-bstring-sourceforge-net-）"><a href="#Better-String-库（http-bstring-sourceforge-net-）" class="headerlink" title="Better String 库（http://bstring.sourceforge.net/）"></a>Better String 库（<a href="http://bstring.sourceforge.net/）" target="_blank" rel="noopener">http://bstring.sourceforge.net/）</a></h2><p>这个代码归档文件中包含了一个通用的字符串实现。它与 std::string 的实现方式不<br>同，但是包含一些强大的特征。如果许多字符串是从其他字符串中的一部分构建出来<br>的， bstring 允许通过相对一个字符串的偏移量和长度来组成一个新的字符串。我用过<br>以这种思想设计实现的有专利权的字符串，它们确实非常高效。在 C++ 中有一个称为<br>CBString 的 bstring 库的包装类。</p><h2 id="rope-（https-www-sgi-com-tech-stl-Rope-html）"><a href="#rope-（https-www-sgi-com-tech-stl-Rope-html）" class="headerlink" title="rope （https://www.sgi.com/tech/stl/Rope.html）"></a>rope<t,alloc> （<a href="https://www.sgi.com/tech/stl/Rope.html）" target="_blank" rel="noopener">https://www.sgi.com/tech/stl/Rope.html）</a></t,alloc></h2><p>这是一个非常适合在长字符串中进行插入和删除操作的字符串库。它不兼容 std::string 。</p><h2 id="Boost-字符串算法（http-www-boost-org-doc-libs-1-60-0-doc-html-string-algo-html）"><a href="#Boost-字符串算法（http-www-boost-org-doc-libs-1-60-0-doc-html-string-algo-html）" class="headerlink" title="Boost 字符串算法（http://www.boost.org/doc/libs/1_60_0/doc/html/string_algo.html）"></a>Boost 字符串算法（<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/string_algo.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/string_algo.html）</a></h2><p>这是一个字符串算法库，它是对 std::string 的成员函数的补充。这个库是基于“查找<br>和替换”的概念构建起来的。</p><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="时间开销"><a href="#时间开销" class="headerlink" title="时间开销"></a>时间开销</h2><p>概括介绍了一些常用算法的时间开销以及相对于程序运行时开销的倍数。</p><h3 id="O-1-，即常量时间"><a href="#O-1-，即常量时间" class="headerlink" title="O(1)，即常量时间"></a>O(1)，即常量时间</h3><p>最快的算法的时间开销是常量时间；也就是说，它们的开销是固定的，完全不取决于输<br>入数据的规模。常量时间算法就像是“圣杯”一样，如果你找到它，它就具有难以置信<br>的价值，但是你也可能穷极一生都找不到它，因此要当心那些向你兜售常量时间算法的<br>陌生人。常量的比例可能非常高；也就是说，开销可能只是一次操作，但这次操作的时<br>间可能非常长。实际上，它可能是 O(n) 伪装而成的，甚至可能更糟。</p><h3 id="O-log-2-n"><a href="#O-log-2-n" class="headerlink" title="O(log 2^n)"></a>O(log 2^n)</h3><p>时间开销比线性更小。例如，一种可以在每一步都将输入数据分为两半的查找算法，其<br>时间开销是 O(log 2^ n)。时间开销比线性更小，表示这类算法的时间开销的增长速度比输<br>入数据规模的增长速度缓慢。因此，它们通常足够高效，以至于许多情况下（但并非所<br>有情况下）都无需再去寻找更快的算法。算法的实现代码也不会出现在分析器列出的昂<br>贵函数列表中。我们可以在程序中大量地调用 O(log 2^ n) 时间开销的算法，而不用担心这<br>会明显地降低程序性能。二分查找算法是一种常用的具有 O(log 2^ n) 时间开销的算法。</p><h3 id="O-n-，即线性时间"><a href="#O-n-，即线性时间" class="headerlink" title="O(n)，即线性时间"></a>O(n)，即线性时间</h3><p>如果一个算法的时间开销是 O(n)，那么算法需要花费的时间与输入数据的规模成正比。<br>这种算法称为线性时间算法。时间开销是 O(n) 的算法通常是那些从输入数据的一端向<br>另一端扫描，直至找到最小值或最大值的算法。线性时间算法的时间开销的增长速度与<br>其输入数据规模的增长速度相同。这种算法也并不昂贵，即使不断地扩大程序的输入数<br>据的规模，也不必担心会占用巨大的计算资源。不过，当多种线性时间算法合并在一起<br>时，可能会导致它们的时间开销变为 O(n ^2 ) 或者更差。因此，当一个程序对大型输入数<br>据集的处理时间很长时，很可能就是这个原因。</p><h3 id="O-n-log-2-n"><a href="#O-n-log-2-n" class="headerlink" title="O(n log 2 ^n)"></a>O(n log 2 ^n)</h3><p>算法可能具有超线性时间开销。例如，许多排序算法会在每一步都成对地比较输入数<br>据，并将待排序的数据分成两部分。这些算法的时间开销是 O(nlog 2 ^n) 。虽然随着 n 的<br>增加，时间开销是 O(n log 2^ n) 的算法时间开销相对更大，但其增长速率是如此之慢，以<br>至于通常情况下即使 n 很大，使用这类算法也没有问题。当然，还是要避免在程序中无<br>谓地调用这类算法。</p><h3 id="O-n-2-、O-n-3-等"><a href="#O-n-2-、O-n-3-等" class="headerlink" title="O(n^ 2 )、O(n ^3 ) 等"></a>O(n^ 2 )、O(n ^3 ) 等</h3><p>有些算法，包括一些比较低效的排序算法，必须将每个输入数据都与其他所有输入数据<br>进行比较。这类算法的时间开销是 O(n^ 2 )。这类算法的时间开销的增长速度非常快，以<br>至于让人不免有些担心它在 n 很大的数据集上的效率。对于有些问题，简单解决方案的<br>时间开销是 O(n ^2 ) 或 O(n ^3 )，而微妙一点的解决方案的速度会更快。</p><h3 id="O-2-n"><a href="#O-2-n" class="headerlink" title="O(2^ n )"></a>O(2^ n )</h3><p>O(2 ^n ) 算法的时间开销增长得太快了，它们应当只被应用于 n 很小的情况下。有时，这<br>是没问题的。那些需要检查规模为 n 的输入数据集中的所有数据组合的算法的时间复<br>杂度是 O(2 ^n )。调度问题和行程规划问题，如著名的旅行商问题（Traveling Salesman<br>Problem）的时间开销是 O(2 ^n )。如果解决基本问题时使用的算法的时间开销是 O(2 ^n<br>)，<br>那么开发人员将面临几个难以抉择的选项：使用一种无法确保最优解决方案的启发式算<br>法，将解决方案限制在 n 很小的输入数据集上；或是找到其他方法加上与解决问题完全<br>无关的值。</p><h2 id="查找算法的时间开销"><a href="#查找算法的时间开销" class="headerlink" title="查找算法的时间开销"></a>查找算法的时间开销</h2><ul><li>线性查找算法的时间开销为 O(n)，它的开销虽然大，却极其常用。它可以用于无序表。<br>即使无法对表中的关键字进行排序，只要能够比较关键字是否相等，即可使用它。对于有序表，线性查找算法可以在查找完表中的所有元素之前结束。虽然它的时间开销仍然<br>是 O(n)，但是平均速度的确比原来快了一倍。<br>如果允许改变表，一种将每次查找结果都移动至表头的线性查找算法在某些情况下可<br>能会有更高的性能。例如， 每次在表达式中用到标识符时，都会去查找编译器中的符号<br>表。如果程序中有很多形如 i = i + 1; 的表达式，这项优化就可以使线性算法有用武<br>之地了。</li></ul><ul><li>二分查找算法的时间开销是 O(log 2 n)，效率更高，但它并不是可能的最好的查找算法。<br>二分查找算法要求表已经按照查找关键字排序完成，不仅需要可以比较查找关键字是否<br>相等，还需要可以比较它们之间的大小关系。<br>在查找和排序世界中，二分查找是最常用的算法。它是一种分治法算法，通过将待排序<br>元素的关键字与位于表中间的元素的关键字进行比较，来决定该元素究竟是排在中间元<br>素之前还是之后，不断地将表一分为二。</li></ul><ul><li>插补查找（interpolation search）与二分查找类似，也是将有序表分为两部分，不过它用<br>到了查找关键字的一些其他特性来改善分块性能。当查找关键字均匀分布时，插补查找<br>的性能可以达到非常高效的 O(log log n) 。如果表很大或是测试表项的成本很高（例如<br>当在一个旋转盘上时），这种改善效果是非常显著的。不过，插补查找仍然不是可能的<br>最快的查找算法。</li></ul><ul><li>通过散列法，即将查找关键字转换为散列表中的数组索引，是可以以平均 O(1) 的时间<br>找出一条记录的。 散列法无法工作于键值对的链表上，它需要一种特殊结构的表。它<br>只需要比较散列表项是否相等即可。散列法在最差情况下的性能是 O(n)，而且它所需<br>要的散列表项的数量可能比要查找的记录的数量多。不过，当表的内容是固定时（例如<br>月份的名字或是编程语言的关键字），就不会发生最差情况了。</li></ul><h2 id="高效排序算法"><a href="#高效排序算法" class="headerlink" title="高效排序算法"></a>高效排序算法</h2><table><thead><tr><th>排序算法</th><th>最好情况</th><th>平均情况</th><th>最差情况</th><th>空间需求</th><th>最好/最差情况的注意点</th></tr></thead><tbody><tr><td>插入排序</td><td>n</td><td>n^ 2</td><td>n^ 2</td><td>1</td><td>最好情况出现在当数据集已经排序完成或是几乎排序完成时</td></tr><tr><td>快速排序</td><td>nlog 2^ n</td><td>n log 2^ n</td><td>n^ 2</td><td>log 2^ n</td><td>最差情况出现在数据集已经排序完成或是支点元素的原生选择（第一个 / 最后一个）</td></tr><tr><td>归并排序</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>1</td><td></td></tr><tr><td>树形排序</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>n</td><td></td></tr><tr><td>堆排序</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>1</td><td></td></tr><tr><td>Timsort^ 1</td><td>n</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>n</td><td>最好情况出现在当数据集已经排序完成时</td></tr><tr><td>内省排序</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>nlog 2^ n</td><td>1</td></tr></tbody></table><h3 id="利用输入数据集的已知特性"><a href="#利用输入数据集的已知特性" class="headerlink" title="利用输入数据集的已知特性"></a>利用输入数据集的已知特性</h3><p>如果你知道输入数据集已经排序完成或是几乎排序完成，通常情况下性能差得让人无法接<br>受的插入排序算法反而在这些数据上的性能很棒，达到了 O(n)。<br>Timsort 是一种相对较新的混合型排序算法，它在输入数据集已经排序完成或是几乎排序<br>完成时，性能也能达到 O(n)；而对于其他情况，最优性能则是 O(n log 2 n)。Timsort 现在已<br>经成为 Python 语言的标准排序算法了。<br>最近还出现了一种称为内省排序（introsort）的算法，它是快速排序和堆排序的混合形式。<br>内省排序首先以快速排序算法开始进行排序，但是当输入数据集导致快速排序的递归深度<br>太深时，会切换为堆排序。内省排序可以确保在最差情况下的时间开销是 O(n log 2 n) 的同<br>时，利用了快速排序算法的高效实现来减少平均情况下的运行时间。自 C++11 开始，内省<br>排序已经成为了 std::sort() 的优先实现。<br>另外一种最近非常流行的算法是 Flash Sort。对于抽取自某种概率分布的数据，它的性能非<br>常棒，达到了 O(n)。Flash Sort 是与基数排序类似，都是基于概率分布的百分位将数据排<br>序至桶中。Flash Sort 的一个简单的适用场景是当数据元素均匀分布时。</p><h1 id="优化动态分配内存的变量"><a href="#优化动态分配内存的变量" class="headerlink" title="优化动态分配内存的变量"></a>优化动态分配内存的变量</h1><h2 id="减少动态变量的使用"><a href="#减少动态变量的使用" class="headerlink" title="减少动态变量的使用"></a>减少动态变量的使用</h2><ul><li>静态地创建类的成员变量</li><li>使用静态数据结构<ul><li>用 std::array 替代 std::vector</li><li>在栈上创建大块缓冲区</li><li>静态地创建链式数据结构，可以使用静态初始化的方式构建具有链式数据结构的数据</li><li>在数组中创建二叉树，在数组中构建二叉树，然后不在节点中保存子节点的链接，而是利用节点的数组索引来计算子节点的数组索引。如果节点的索引是 i，那么它的两个子节点的索引分别是 2i 和 2i+1。这种方法带来的另外一个好处是，能够很快地知道父节点的索引是 i/2。对于平衡二叉树而言，数组形式的树可能会比链式树低效。</li><li>用环形缓冲区替代双端队列</li></ul></li><li>使用 std::make_shared 替代 new 表达式</li><li>不要无谓地共享所有权</li></ul><h2 id="减少动态变量的重新分配"><a href="#减少动态变量的重新分配" class="headerlink" title="减少动态变量的重新分配"></a>减少动态变量的重新分配</h2><ul><li>预分配动态变量以防止重新分配</li><li>在循环外创建动态变量</li></ul><h2 id="移除无谓的复制"><a href="#移除无谓的复制" class="headerlink" title="移除无谓的复制"></a>移除无谓的复制</h2><ul><li><p>在类定义中禁止不希望发生的复制，将复制构造函数和赋值运算符的可见性声明为 private 可以防止它们被<br>外部调用。在 C++11 中，我们可以在复制构造函数和赋值运算符后面加上 delete 关键字来达到这个目的。</p></li><li><p>移除函数调用上的复制，引用参数</p></li><li>移除函数返回上的复制，返回引用。<ul><li>为复制省略（copy elision）或是返回值优化（return value optimization，RVO）。</li><li>函数内更新引用参数。<h2 id="实现移动语义"><a href="#实现移动语义" class="headerlink" title="实现移动语义"></a>实现移动语义</h2></li></ul></li></ul><ul><li>std::swap() ：“穷人”的移动语义<ul><li>交换操作的强大之处在于它可以递归地应用于类的成员变量上。交换并不会复制指针所指<br>向的对象，而是交换指针自身。对于那些指向大的、动态分配内存的数据结构，交换比复<br>制更加高效。</li></ul></li></ul><ul><li>共享所有权的实体<ul><li>实体无法复制。不过，一个指向实体的共享指针却可以复制。因此，虽然在移动语义出现之前无法创建 std::vector<std::mutex> 等，但是我们可以定义一个 std::vector&lt;std::shared_ptr<std::mutex>&gt; 。</std::mutex></std::mutex></li></ul></li></ul><ul><li>移动语义的移动部分<ul><li>C++ 的类型系统被扩展了，它能够从函数调用上的左值中识别出右值。如果 T 是一个类<br>型，那么声明 T&amp;&amp; 就是指向 T 的右值引用——也就是说，一个指向类型 T 的右值的引用。函数重载的解析规则也被扩展了，这样当右值是一个实参时，优先右值引用重载；而当左值是实参时，则需要左值引用重载。特殊成员函数的列表被扩展了，现在它包含了移动构造函数和一个移动赋值运算符。这些函数是复制构造函数和赋值运算符的重载，它们接收右值引用作为参数。如果一个类实现了移动构造函数和移动赋值运算符，那么在进行初始化或是赋值实例时就可以使用高效的移动语义。std::move。</li></ul></li></ul><h1 id="优化热点语句"><a href="#优化热点语句" class="headerlink" title="优化热点语句"></a>优化热点语句</h1><ul><li>从循环中移除代码<ul><li>缓存循环结束条件值</li><li>使用更高效的循环语句，将一个 for 循环简化为 do 循环通常可以提高循环处理的速度。在 Visual Studio 2010 上耗时 482 毫秒，性能提高了12%；不过在 Visual Studio 2015 上却耗时 674 毫秒，性能降低了 25%。</li><li>用递减替代递增</li><li>从循环中移除不变性代码</li><li>从循环中移除无谓的函数调用</li><li>从循环中移除隐含的函数调用<ul><li>声明一个类实例（调用构造函数）</li><li>初始化一个类实例（调用构造函数）</li><li>赋值给一个类实例（调用赋值运算符）</li><li>涉及类实例的计算表达式（调用运算符成员函数）</li><li>退出作用域（调用在作用域中声明的类实例的析构函数）</li><li>函数参数（每个参数表达式都会被复制构造到它的形参中）</li><li>函数返回一个类的实例 （调用复制构造函数，可能是两次） </li><li>向标准库容器中插入元素（元素会被移动构造或复制构造）</li><li>向矢量中插入元素（如果矢量重新分配了内存，那么所有的元素都需要被移动构造或是复制构造）</li></ul></li><li>从循环中移除昂贵的、缓慢改变的调用</li><li>将循环放入函数以减少调用开销</li><li>不要频繁地进行操作,不要频繁地检测事件</li></ul></li><li>从函数中移除代码<ul><li>简短地声明内联函数,内联是一种通过在编译时进行计算来移除多余计算的改善性能的手段。函数内联可能是最强力的代码优化武器。事实上，Visual Studio 中“调试”版本与“正式”版本（或是在 GCC 的 -d 选项与 -O 选项）的性能区别，主要源于“调试”版本关闭了函数内联。</li><li>在使用之前定义函数,在第一次调用函数之前定义函数（提供函数体）给了编译器优化函数调用的机会。当编译器编译对某个函数的调用时发现该函数已经被定义了，那么编译器能够自主选择内联这次函数调用。如果编译器能够同时找到函数体，以及实例化那些发生虚函数调用的类变量、指针或是引用的代码，那么这也同样适用于虚函数。</li><li>移除未使用的多态性</li><li>放弃不使用的接口</li><li>用模板在编译时选择实现,模板参数可以是任意类型——具有自己的一组成员函数的类类型或是具有内建运算符的基本类型。因此，存在两种接口：模板类的 public 成员，以及由在模板参数上被调用的运算符和函数所定义的接口。抽象基类中定义的接口是非常严格的，继承类必须实现在抽象基类中定义的所有函数。而通过模板定义的接口就没有这么严格了。只有参数中那些实际会被模板的某种特化所调用的函数才需要被定义。</li><li>避免使用PIMPL惯用法,采用将BigClass 分解，使接口功能更加集中的方法，可能与 PIMPL 同样有效。</li><li>移除对DDL的调用,一种改善函数调用性能的方式是不使用 DLL，而是使用对象代码库并将其链接到可执行程序上。</li><li>使用静态成员函数取代成员函数,每次对成员函数的调用都有一个额外的隐式参数：指向成员函数被调用的类实例的 this 指针。通过对 this 指针加上偏移量可以获取类成员数据。虚成员函数必须解引 this 指针来获得虚函数表指针。有时，一个成员函数中的处理仅仅使用了它的参数，而不用访问成员数据，也不用调用其他的虚成员函数。在这种情况下， this 指针没有任何作用。</li><li>将虚析构函数移至基类中</li></ul></li><li>优化表达式<ul><li>简化表达式，y = a<em>x</em>x<em>x + b</em>x<em>x + c</em>x + d优化为y = (((a<em>x + b)</em>x) + c)*x + d;</li><li>将常量组合在一起，seconds = 24 <em> 60 </em> 60 <em> days;或是seconds = days </em> (24 <em> 60 </em> 60);编译器会计算表达式中的常量部分，产生类似下面的表达式：seconds = 86400 <em> days;但是，如果程序员这样写：seconds = 24 </em> days <em> 60 </em> 60;编译器只能在运行时进行乘法计算了。</li><li>使用更高效的运算符，位移运算和加法运算替代乘法。例如，整数表达式 x<em>9 可以被重写为x</em>8+x*1 ，进而可以重写为 (x&lt;&lt;3)+x 。</li><li>使用整数计算替代浮点型计算</li><li>双精度类型可能会比浮点型更快</li><li>用闭形式替代迭代计算</li></ul></li><li>优化控制流程惯用法<ul><li>用 switch 替代 if-else　if-else</li><li>用虚函数替代 switch 或 if</li><li>使用无开销的异常处理<ul><li>在 C++11 中引入了一种新的异常规范，称为 noexcept 。声明一个函数为 noexcept 会告诉编译器这个函数不可能抛出任何异常。如果这个函数抛出了异常，那么如同在 throw() 规范中一样， terminate() 将会被调用。</li></ul></li></ul></li></ul><h2 id="判断一个整数是否是-2-的幂的闭形式"><a href="#判断一个整数是否是-2-的幂的闭形式" class="headerlink" title="判断一个整数是否是 2 的幂的闭形式"></a>判断一个整数是否是 2 的幂的闭形式</h2><pre><code>inline bool is_power_2_closed(unsigned n) {    return ((n != 0) &amp;&amp; !(n &amp; (n - 1)));}int isPowerOfTwo (unsigned int x){  return ((x != 0) &amp;&amp; ((x &amp; (~x + 1)) == x));}</code></pre><p>Rick Regan 在他的网页（<a href="http://www.exploringbinary.com/ten-ways-" target="_blank" rel="noopener">http://www.exploringbinary.com/ten-ways-</a><br>to-check-if-an-integer-is-a-power-of-two-in-c/）上记录了 10 种方法</p><p>Hacker’s Delight ：<a href="http://hackersdelight.org/" target="_blank" rel="noopener">http://hackersdelight.org/</a></p><h1 id="优化查找和排序"><a href="#优化查找和排序" class="headerlink" title="优化查找和排序"></a>优化查找和排序</h1><p>lower_bound<br>返回指向第一个不小于给定值的元素的迭代器 </p><p>upper_bound<br>返回指向第一个大于给定值的元素的迭代器 </p><p>binary_search<br>判断一个元素是否在区间内 </p><p>equal_range<br>返回匹配特定键值的元素区间 </p><p>以 C 风格的 char* 作为键、lambda 表达式作为比较函数的 map</p><pre><code>auto comp = [](char const* p1, char const* p2) {    return strcmp(p1,p2)&lt;0;};std::map&lt;char const*,    unsigned,    decltype(comp)&gt; table(comp);    </code></pre><p>这段示例代码中使用了 C++11 中的 decltype 关键字。 map 的第三个参数是一个类<br>型。名字 comp 是一个变量，而 decltype(comp) 则是变量的类型。lambda 表达式的类型没<br>有名字，每个 lambda 表达式的类型都是唯一的，因此 decltype 是获得 lambda 表达式的类<br>型的唯一方法。</p><h3 id="std-find-：-功能如其名，O-n-时间开销"><a href="#std-find-：-功能如其名，O-n-时间开销" class="headerlink" title="std::find()： 功能如其名，O(n)时间开销"></a>std::find()： 功能如其名，O(n)时间开销</h3><pre><code>kv* result=std::find(std::begin(names), std::end(names), key);</code></pre><p>find() 函数的一种变化形式是 find_if() ，它接收比较函数作为第四个参数。这里开发人<br>员不用在 find() 的作用域中定义 operator==() ，而是可以编写一个 lambda 表达式作为比<br>较函数。lambda 表达式只接收一个参数——要进行比较的表元素。因此，lambda 表达式必<br>须从环境中捕捉键值。</p><h3 id="std-binary-search-：-不返回值"><a href="#std-binary-search-：-不返回值" class="headerlink" title="std::binary_search()： 不返回值"></a>std::binary_search()： 不返回值</h3><p>标准库算法 binary<em>search() 返回一个 bool 值，表示键是否存在于有序表中。非常奇<br>怪的是，标准库却没有提供配套的返回匹配的表元素的函数。因此， find() 和 binary</em><br>search() 虽然从名字上看都像是我们要找的解决方法，但其实不然。<br>如果程序只是想知道一个元素是否存在于表中，而不是找到它的值，那么我们可以使用<br>binary_search() 。</p><h3 id="使用-std-equal-range-的二分查找"><a href="#使用-std-equal-range-的二分查找" class="headerlink" title="使用 std::equal_range() 的二分查找"></a>使用 std::equal_range() 的二分查找</h3><pre><code>auto res = std::equal_range(std::begin(names),                            std::end(names),                            key);kv *result = (res.first == res.second)             ? std::end(names)             : res.first;</code></pre><h3 id="使用-std-lower-bound-的二分查找"><a href="#使用-std-lower-bound-的二分查找" class="headerlink" title="使用 std::lower_bound() 的二分查找"></a>使用 std::lower_bound() 的二分查找</h3><pre><code>kv *result = std::lower_bound(std::begin(names),                              std::end(names),                              key);if (result != std::end(names) &amp;&amp; key &lt; *result.key)    result = std::end(names);</code></pre><h3 id="自己编写二分查找法"><a href="#自己编写二分查找法" class="headerlink" title="自己编写二分查找法"></a>自己编写二分查找法</h3><pre><code>kv *find_binary_lessthan(kv *start, kv *end, char const *key){    kv *stop = end;    while (start &lt; stop)    {        auto mid = start + (stop - start) / 2;        if (*mid &lt; key)  // 查找右半部分[mid+1,stop)        {            start = mid + 1;        }        else   // 查找左半部分[start,mid)        {            stop = mid;        }    }    return (start == end || key &lt; *start) ? end : start;}</code></pre><h3 id="使用-strcmp-自己编写二分查找法"><a href="#使用-strcmp-自己编写二分查找法" class="headerlink" title="使用 strcmp() 自己编写二分查找法"></a>使用 strcmp() 自己编写二分查找法</h3><pre><code>kv *find_binary_3(kv *start, kv *end, char const *key){    auto stop = end;    while (start &lt; stop)    {        auto mid = start + (stop - start) / 2;        auto rc = strcmp(mid-&gt;key, key);        if (rc &gt; 0)        {            stop = mid;        }        else if (rc &lt; 0)        {            start = mid + 1;        }        else        {            return mid;        }    }    return end;}</code></pre><h2 id="优化键值对散列表中的查找"><a href="#优化键值对散列表中的查找" class="headerlink" title="优化键值对散列表中的查找"></a>优化键值对散列表中的查找</h2><p>C++ 定义了一个称为 std::hash 的标准散列函数对象。 std::hash 是一个模板，为整数、浮<br>点数据、指针和 std::string 都提供了特化实现。同样适用于指针的未特化的 std::hash<br>的定义会将散列类型转换为 size_t ，然后随机设置它的各个位的值。</p><h3 id="使用-std-unordered-map-进行散列"><a href="#使用-std-unordered-map-进行散列" class="headerlink" title="使用 std::unordered_map 进行散列"></a>使用 std::unordered_map 进行散列</h3><p>std::unordered_map 使用的默认散列函数是模板函数对象 std::hash 。由于该模板为<br>std::string 提供了特化实现，因此我们无需显式地提供散列函数。</p><pre><code>auto it = table.find(key);</code></pre><p>GNU 计划（还有其他项<br>目）构建了一个称为 gperf（<a href="http://www.gnu.org/software/gperf/）的命令行工具，它所生成" target="_blank" rel="noopener">http://www.gnu.org/software/gperf/）的命令行工具，它所生成</a><br>的完美散列函数通常也是最小散列函数。</p><h2 id="使用C-标准库优化排序"><a href="#使用C-标准库优化排序" class="headerlink" title="使用C++标准库优化排序"></a>使用C++标准库优化排序</h2><p>C++ 标准库提供了两种能够高效地对序列容器进行排序的标准算法—— std::sort() 和 std::stable_sort() 。</p><h1 id="优化数据结构"><a href="#优化数据结构" class="headerlink" title="优化数据结构"></a>优化数据结构</h1><h2 id="理解标准库容器"><a href="#理解标准库容器" class="headerlink" title="理解标准库容器"></a>理解标准库容器</h2><h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>序列容器 std::string 、 std::vector 、 std::deque 、 std::list 和 std::forward_list 中元素的顺序与它们被插入的顺序相同。因此，每个容器都有一头一尾。所有的序列容器都能够插入元素。除了 std::forward_list 外，所有的序列容器都有一个具有常量时间性能开销的成员函数能够将元素推入至序列容器的末尾。不过，只有 std::deque 、 std::list 和std::forward_list 能够高效地将元素推入至序列容器的头部。</p><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>有 四 种 有 序 关 联 容 器： std::map 、 std::multimap 、 std::set 和<br>std::multiset 。有序关联容器要求必须对键（ std::map ）或是元素自身（ std::set ）定义能够对它们进行排序的 operator&lt;() 等。有序关联容器的实现是平衡二叉树，因此我们无<br>需对有序关联容器进行排序。遍历它们时会按照排序关系的顺序访问它们中的元素。插入或是移除元素的分摊开销是 O(log 2 n)，其中 n 是容器中元素的数量。</p><p>C++11 又给我们带来了四种无序关联容器： std::unordered_map 、 std::unordered_multimap 、std::unordered_set 和 std::unordered_multiset 。无序关联容器只要求对键（ std::unordered_map ）或是元素（ std::unordered_set ）定义了相等关系即可。无序关联容器的实现方式是散列表。</p><h3 id="std-vector-与-std-string"><a href="#std-vector-与-std-string" class="headerlink" title="std::vector 与 std::string"></a>std::vector 与 std::string</h3><p>要想确保在所有版本的 C++ 中都能释放 vector 的内存，可以使用以下技巧：</p><pre><code>std::vector&lt;Foo&gt; x;...vector&lt;Foo&gt;().swap(x);</code></pre><p>这段语句会构造一个临时的空的矢量，将它的内容与矢量 x 交换，接着删除这个临时矢量，这样内存管理器会回收所有之前属于 x 的内存。</p><h4 id="std-vector-中的插入与删除"><a href="#std-vector-中的插入与删除" class="headerlink" title="std::vector 中的插入与删除"></a>std::vector 中的插入与删除</h4><p>如果数据是在另外一个容器中，使用 std::vector::insert() 可以将它复制到 vector 中：</p><pre><code>std::vector&lt;kvstruct&gt; test_container, random_vector;...test_container.insert(    test_container.end(),    random_vector.begin(),    random_vector.end());</code></pre><p>或</p><pre><code>std::vector&lt;kvstruct&gt; test_container, random_vector;...test_container.reserve(nelts);for (auto it = random_vector.begin(); it != random_vector.end(); ++it)    test_container.push_back(*it);</code></pre><h4 id="遍历-std-vector"><a href="#遍历-std-vector" class="headerlink" title="遍历 std::vector"></a>遍历 std::vector</h4><pre><code>std::vector&lt;kvstruct&gt; test_container;...unsigned sum = 0;for (auto it = test_container.begin(); it != test_container.end(); ++it)    sum += it-&gt;value;std::vector&lt;kvstruct&gt; test_container;...unsigned sum = 0;for (unsigned i = 0; i &lt; nelts; ++i)    sum += test_container.at(i).value;std::vector&lt;kvstruct&gt; test_container;...unsigned sum = 0;for (unsigned i = 0; i &lt; nelts; ++i)    sum += test_container[i].value;</code></pre><p>下标版本更加高效</p><h3 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a>std::deque</h3><p>std::deque 是一种专门用于创建“先进先出”（FIFO）队列的容器。在队列两端插入和删除元素的开销都是常量时间。下标操作也是常量时间。它的迭代器与 std::vector 一样，都是随机访问迭代器，因此对 std::deque 进行排序的时间开销是 O(n log 2^n)。</p><p>以下是三种使用 push_back() 将元素从 vector 复制到 deque 中的方法：</p><pre><code>std::deque&lt;kvstruct&gt; test_container;std::vector&lt;kvstruct&gt; random_vector;...for (auto it = random_vector.begin(); it != random_vector.end(); ++it)    test_container.push_back(*it);for (unsigned i = 0; i &lt; nelts; ++i)    test_container.push_back(random_vector.at(i));for (unsigned i = 0; i &lt; nelts; ++i)    test_container.push_back(random_vector[i]);</code></pre><p>迭代器版本最快</p><h4 id="遍历-std-deque"><a href="#遍历-std-deque" class="headerlink" title="遍历 std::deque"></a>遍历 std::deque</h4><p>有意思的是，对于 deque ，基于迭代器的遍历更快，而对于 vector ，基于下标的遍历则更快。但是遍历 deque 的最快方法的性能开销是遍历 vector 的最快方法的两倍，与之前的趋势相同。</p><h3 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a>std::list</h3><p>最快的查找 list 的方法是使用 std::find() ，它的时间开销是 O(n)。</p><p>插入删除与遍历使用迭代器比较快</p><h4 id="对-std-list-排序"><a href="#对-std-list-排序" class="headerlink" title="对 std::list 排序"></a>对 std::list 排序</h4><p>std::list 上的迭代器是双向迭代器，不如 std::vector 的随机访问迭代器功能强大。这些<br>迭代器的一个很特别的特性是，找到两个双向迭代器之间的距离或是元素个数的性能开销是 O(n)。因此，使用 std::sort() 对 std::list 排序的时间开销是 O(n ^2 )。编译器的编译结果仍然是对 list 调用一次 std::sort() ，但性能可能远比开发人员所期待的差。幸运的是， std::list 有一种内置的更高效的排序方法，其时间开销是 O(n log 2^ n)。使用std::list 内置的 sort() 函数对 list 排序耗时 23.2 毫秒，只比排序相同的 vector 慢了25%。</p><h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h3><p>单向链表，其他方面跟list差不多</p><h3 id="std-map-与-std-multimap"><a href="#std-map-与-std-multimap" class="headerlink" title="std::map 与 std::multimap"></a>std::map 与 std::multimap</h3><p>所有的提示都比无提示更快，也都比不带提示版本的 insert() 和未排序的输入数据集快。</p><h4 id="优化“检查并更新”惯用法"><a href="#优化“检查并更新”惯用法" class="headerlink" title="优化“检查并更新”惯用法"></a>优化“检查并更新”惯用法</h4><p>一种常用的编程惯用法是在程序中先检查某个键是否存在于 map 中，然后根据结果进行相应的处理。当这些处理涉及插入或是更新键所对应的值时，那么就可能进行性能优化。理解性能优化的关键在于，由于需要先检查键是否存在于 map 中，然后再找到插入位置，因此 map::find() 和 map::insert() 的时间开销都是 O(log 2 n)。这两种操作都会遍历 map 的二叉树数据结构中的相同的节点：</p><pre><code>iterator it = table.find(key); // O(log n)if (it != table.end()) {    // 找到key的分支    it-&gt;second = value;}else {    // 没有找到key的分支    it = table.insert(key, value); // O(log n)}</code></pre><p>如果程序程序能够得到第一次查找的结果，那么就能够将其作为对 insert() 的提示，将插入操作的时间开销提高到 O(1)。取决于程序的需求，有两种方法能够实现这个惯用法。如果只要知道是否找到了键即可，那么可以使用返回 pair 的版本的 insert() 。在被返回的pair 中保存的是一个指向找到或是插入的元素的迭代器以及一个布尔型变量，当这个布尔型变量为 true 时表示该元素被找到了，而当这个布尔型变量为 false 时表示该元素是被插入的。当程序在检查元素是否存在于 map 之前知道如何初始化元素，或是更新值的性能开销并不大时，这种方法非常有效：</p><pre><code>std::pair&lt;value_t, bool&gt; result = table.insert(key, value);if (result.second) {    // k找到key的分支}else {    // 没有找到key的分支}</code></pre><p>第二种方法是通过调用 lower_bound() 或是 upper_bound() 找到键或是插入位置作为 C++98风格或是 C++11 风格的提示。 lower_bound() 会返回一个指向 map 中那些键比带查找的键小的所有元素中最小的元素或是指向 end 的迭代器。当要插入键时，这个迭代器就是插入位置提示；而当要更新已经存在的元素时，它指向的就是该元素的键。这种方法对于待插入的元素没有任何要求：</p><pre><code>iterator it = table.lower_bound(key);if (it == table.end() || key &lt; it-&gt;first) {    // 找到key的分支table.insert(it, key, value);}else {    // 没有找到key的分支    it-&gt;second = value;}</code></pre><h3 id="std-set-与-std-multiset"><a href="#std-set-与-std-multiset" class="headerlink" title="std::set 与 std::multiset"></a>std::set 与 std::multiset</h3><p> std::set 和 std::multiset 使用了与 std::map 相同的数据结构</p><h3 id="std-unordered-map-与-std-unordered-multimap"><a href="#std-unordered-map-与-std-unordered-multimap" class="headerlink" title="std::unordered_map 与 std::unordered_multimap"></a>std::unordered_map 与 std::unordered_multimap</h3><p>unordered_map 的构造是昂贵的。它包含了为表中所有元素动态分配的节点，另外还有一个会随着表的增长定期重新分配的动态可变大小的桶数组。因此，要想改善它的查找性能，需要消耗相当多的内存。每次桶数组重新分配时，迭代器都会失效。不过，只有在删除元素时，指向元素节点的引用才会失效。</p><p>unordered_map 中元素的数量就是它的大小。计算出的 size / buckets 比例称为负载系数（load factor）。负载系数大于 1.0 表示有些桶有一条多个元素链接而成的元素链，降低了查询这些键的性能（换言之，非完美散列）。在实际的散列表中，即使负载系数小于1.0，键之间的冲突也会导致形成元素链。负载系数小于 1.0 表示存在着未被使用，但却在unordered_map 的骨干数组中占用了存储空间的桶（换言之，非最小散列）。当负载系数小于 1.0 时，(1 – 负载系数 ) 的值是空桶数量的下界，但是由于散列函数可能非完美，因此未使用的存储空间通常更多。</p><p>使用迭代器遍历 unordered_map 相对比较高效.</p><h2 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h2><p>boost::circular_buffer （<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/circular_buffer.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/circular_buffer.html）</a><br>在许多方面都与 std::deque 类似，但更加高效。</p><p>Boost.Container （<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/container.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/container.html）</a><br>标准库容器的各种变种，包括一种稳定的 vector （一种发生重新分配也不会造成迭代器失效的 vector ）；一组作为 std::vector 的容器适配器实现的 map/multimap/set/multiset；<br>一个长度可变但最大长度固定的静态 vector ，以及一个当只有几个元素时具有最优行为的 vector 。</p><p>dynamic_bitset （<a href="http://www.boost.org/doc/libs/1_60_0/libs/dynamic_bitset/dynamic_bitset.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/libs/dynamic_bitset/dynamic_bitset.html）</a><br>看起来像是位组成的 vector 。</p><p>Fusion（<a href="http://www.boost.org/doc/libs/1_60_0/libs/fusion/doc/html/）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/libs/fusion/doc/html/）</a><br>元组上的容器和迭代器。</p><p>Boost 图形库（BGL，<a href="http://www.boost.org/doc/libs/1_60_0/libs/graph/doc/index.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/libs/graph/doc/index.html）</a><br>适用于遍历图形的算法和数据结构。</p><p>boost.heap （<a href="http://bit.ly/b-heap/）" target="_blank" rel="noopener">http://bit.ly/b-heap/）</a><br>比简单 std::priority_queue 容器适配器具有更好性能和更微妙行为的优先队列。</p><p>Boost.Intrusive（<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/intrusive.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/intrusive.html）</a><br>提供了侵入式容器（依赖于显式地包含链接的节点类型的容器）。侵入容器的重点是提高热点代码的性能。这个库包含单向和双向链表、关联容器、无序关联容器和各种显式平衡树实现。在大多数容器中都加入了 make_shared 、移动语义和 emplace() 成员函数，减少了对侵入式容器的需求。</p><p>boost.lockfree （<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/lockfree.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/lockfree.html）</a><br>无锁（lock-free）和无等待（wait-free）的队列和栈。</p><p>Boost.MultiIndex（<a href="http://www.boost.org/doc/libs/1_60_0/libs/multi_index/doc/index.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/libs/multi_index/doc/index.html）</a><br>有多个具有不同行为的索引的容器。</p><p>毫无疑问，Boost 中还有其他容器类。</p><p>对标准库容器类的另一个巨大贡献来自于游戏公司艺电（Electronic Arts，EA），他们开源了名为“EASTL”（<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html）的标准库容器类。艺电对标注库容器类的贡献包括：" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html）的标准库容器类。艺电对标注库容器类的贡献包括：</a></p><ul><li>一个更简单和更合理的 Allocator 的定义</li><li>对容器提供了更有力的保证，包括保证容器不会调用内存管理器，除非程序将元素放到容器中具有更多的可编程性的 std::deque</li><li>一组与 Boost 所提供的容器类似的容器</li></ul><h2 id="创建一个由无重复的-kvstruct-实例组成的-vector"><a href="#创建一个由无重复的-kvstruct-实例组成的-vector" class="headerlink" title="创建一个由无重复的 kvstruct 实例组成的 vector"></a>创建一个由无重复的 kvstruct 实例组成的 vector</h2><pre><code># include &lt;random&gt;// 创建一个由count个无重复的kvstruct实例组成的vectorvoid build_rnd_vector(std::vector&lt;kvstruct&gt; &amp;v, unsigned count){    std::default_random_engine e;    std::uniform_int_distribution&lt;unsigned&gt; d(count, 10 * count - 1);    auto randomizer = std::bind(d, e);    std::set&lt;unsigned&gt; unique;    v.clear();    while (v.size() &lt; count)    {        unsigned rv = randomizer();        if (unique.insert(rv).second == true)   // 插入元素        {            kvstruct keyvalue(rv);            v.push_back(keyvalue);        }    }}</code></pre><h2 id="sort和stable-sort的不同之处"><a href="#sort和stable-sort的不同之处" class="headerlink" title="sort和stable_sort的不同之处"></a>sort和stable_sort的不同之处</h2><p>这两个函数的原理都是快速排序，时间复杂度在所有排序中最低，为O(nlog2n) ;</p><p>stable_sort 和 sort的区别在于 前者作排序可以使原来的”相同”的值在序列中的相对位置不变，这个应用在数组里面不受影响，当函数参数传入的是结构体时，会发现两者之间的明显区别；</p><h1 id="优化I-O"><a href="#优化I-O" class="headerlink" title="优化I/O"></a>优化I/O</h1><h2 id="读取文件至字符串中"><a href="#读取文件至字符串中" class="headerlink" title="读取文件至字符串中"></a>读取文件至字符串中</h2><pre><code>bool stream_read_sgetn(std::istream &amp;f, std::string &amp;result){    std::streamoff len = stream_size(f);    if (len == -1)        return false;    result.resize (static_cast&lt;std::string::size_type&gt;(len));    f.rdbuf()-&gt;sgetn(&amp;result[0], len);    return true;}bool stream_read_string(std::istream &amp;f, std::string &amp;result){    std::streamoff len = stream_size(f);    if (len == -1)        return false;    result.resize (static_cast&lt;std::string::size_type&gt;(len));    f.read(&amp;result[0], result.length());    return true;}bool stream_read_array(std::istream &amp;f, std::string &amp;result){    std::streamoff len = stream_size(f);    if (len == -1)        return false;    std::unique_ptr&lt;char&gt; data(new char[static_cast&lt;size_t&gt;(len)]);    f.read(data.get(), static_cast&lt;std::streamsize&gt;(len));    result.assign(data.get(), static_cast&lt;std::string::size_type&gt;(len));    return true;}</code></pre><h2 id="写文件stream-write-line-noflush-更快"><a href="#写文件stream-write-line-noflush-更快" class="headerlink" title="写文件stream_write_line_noflush() 更快"></a>写文件stream_write_line_noflush() 更快</h2><pre><code>void stream_write_line_noflush(std::ostream &amp;f,                               std::string const &amp;line){    f &lt;&lt; line &lt;&lt; &quot;\n&quot;;}</code></pre><p>要么以 f.flush() 结束 stream_write_line_noflush() ，要么关闭流，这样最后一个写满数据的缓冲区中的信息才会被输出。</p><h2 id="从-std-cin-读取和向-std-cout-中写入"><a href="#从-std-cin-读取和向-std-cout-中写入" class="headerlink" title="从 std::cin 读取和向 std::cout 中写入"></a>从 std::cin 读取和向 std::cout 中写入</h2><p>当从标准输入中读取数据时， std::cin 是与 std::cout 紧密联系在一起的。</p><p>关于 std::cin 和 std::cout 的另外一件需要知道的事情的是，C++ 流在概念上是与 C 的<br>FILE* 对象的 stdin 和 stdout 连接在一起的。这让程序能够同时使用 C++ 和 C 的 I/O 语句，并使得输入或输出的交叉在某种程度上有了意义。 std::cout 与 stdout 的连接是实现定义（implementation-defined）的。多数标准库实现默认都会直接将 std::cout 发送至stdout 。 stdout 默认是按行缓存的，在 C++ 的输入输出流中没有这种方式。每当 stdout<br>遇到新的一行，它都会刷新缓冲区。切断连接有助于改善性能。调用静态成员函数 td::ios_base::sync_with_stdio(false) 可以打破这种连接，改善性能，但代价是如果程序同时使用了 C 和 C++ I/O 函数，那么交叉行为将变得不可预测。</p><h1 id="优化并发"><a href="#优化并发" class="headerlink" title="优化并发"></a>优化并发</h1><h2 id="最著名的几种并发形式如下"><a href="#最著名的几种并发形式如下" class="headerlink" title="最著名的几种并发形式如下:"></a>最著名的几种并发形式如下:</h2><h3 id="时间分割（time-slicing）"><a href="#时间分割（time-slicing）" class="headerlink" title="时间分割（time slicing）"></a>时间分割（time slicing）</h3><p>这是操作系统中的一个调度函数。在时间分割中，操作系统会维护一份当前正在执行的<br>程序和系统任务的列表，并为每个程序都分配时间块。任何时候，当一个程序等待事件<br>或是资源时，操作系统会将程序从可运行程序列表中移除，并将它所使用的处理器资源<br>共享给其他程序。<br>操作系统是依赖于处理器和硬件的。它会使用计时器和周期性的中断来调整处理器的调<br>度。C++ 程序并不知道它被时间分割了。</p><h3 id="虚拟化（Virtualization）"><a href="#虚拟化（Virtualization）" class="headerlink" title="虚拟化（Virtualization）"></a>虚拟化（Virtualization）</h3><p>一种常见的虚拟化技术是让一个称为“hypervisor”的轻量级操作系统将处理器的时<br>间块分配给客户虚拟机。客户虚拟机（VM）包含一个文件系统镜像和一个内存镜<br>像，通常这都是一个正在运行一个或多个程序的操作系统。当 hypervisor 运行客户虚<br>拟机后，某些处理器指令和对内存区域的某些访问会产生 Trap（陷入），并将它下传给<br>hypervisor，这将允许 hypervisor 竞争 I/O 设备和其他硬件资源。另外一种虚拟化技术是<br>使用传统操作系统作为客户虚拟机的主机。如果主机和客户虚拟机上运行的操作系统相<br>同，那么就能够使用操作系统的 I/O 工具更加高效地竞争 I/O 资源。<br>虚拟化技术的优点如下。</p><ul><li>客户虚拟机是在运行时被打包为磁盘文件的，因此我们能够对客户虚拟机设置检查点（checkpoint），保存客户虚拟机，加载和继续执行客户虚拟机，以及在多台主机上运行客户虚拟机。</li><li>只要资源允许，我们能够并发地运行多台客户虚拟机。hypervisor 会与计算机虚拟内存保护硬件共同协作，隔离这些客户虚拟机。这使得硬件能够被当作商品租借出去并计时收费。</li><li>我们能够配置客户虚拟机使用主机的一部分资源（物理内存、处理器核心）。计算资源能够根据每台客户虚拟机上正在运行的程序的需求“量体裁衣”，确保并发地在同一硬件上运行的多台虚拟机保持性能稳定，并防止它们之间意外地发生交互。</li></ul><p>与传统的时间分割一样，C++ 程序同样不知道它运行于 hypervisor 下的一台客户虚拟机中。<br>C++ 程序也许会间接地注意到它们所使用的资源受到了限制。虚拟化技术与 C++ 程序设计<br>是有关的，因为它既能够限制程序所消耗的计算资源，也需要让程序知道哪些资源才是真<br>正可用的。</p><h3 id="容器化（containerization）"><a href="#容器化（containerization）" class="headerlink" title="容器化（containerization）"></a>容器化（containerization）</h3><p>容器化与虚拟化的相似之处在于，容器中也有一个包含了程序在检查点的状态的文件系<br>统镜像和内存镜像；不同之处在于容器主机是一个操作系统，这样能够直接地提供 I/O<br>和系统资源，而不必通过 hypervisor 去较低效地竞争资源。<br>容器化具有与虚拟化相同的优点（打包、配置和隔离性），同时它在某种程度上更<br>加高效。对于运行于容器中的 C++ 程序，容器化是不可见的。容器化与 C++ 程序相关的原因与<br>虚拟化相同。</p><h3 id="对称式多处理（symmetric-multiprocessing）"><a href="#对称式多处理（symmetric-multiprocessing）" class="headerlink" title="对称式多处理（symmetric multiprocessing）"></a>对称式多处理（symmetric multiprocessing）</h3><p>对称式多处理器（symmetric multiprocessor）是一种包含若干执行相同机器代码并访问<br>相同物理内存的执行单元的计算机。现代多核处理器都是对称式多处理器。当前正在执<br>行的程序和系统任务能够运行于任何可用的执行单元上，尽管选择执行单元可能会给性<br>能带来影响。<br>对称式多处理器使用真正的硬件并发执行多线程控制。如果对称式多处理器有 n 个执行<br>单元，那么一个计算密集型程序的执行时间最多可以被缩短为 1/n。</p><h3 id="同步多线程（simultaneous-multithreading）"><a href="#同步多线程（simultaneous-multithreading）" class="headerlink" title="同步多线程（simultaneous multithreading）"></a>同步多线程（simultaneous multithreading）</h3><p>有些处理器的硬件核心有两个（或多个）寄存器集，可以相应地执行两条或多条指令<br>流。当一条指令流停顿时（如需要访问主内存），处理器核心能够执行另外一条指令流<br>上的指令。具有这种特性的处理器核心的行为就像是有两个（或多个）核心一样，这<br>样一个“四核处理器”就能够真正地处理八个硬件线程。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>进程是并发的执行流，这些执行流有它们自己的受保护的虚拟内存空间。进程之间通过<br>管道、队列、网络 I/O 或是其他不共享的机制<br>进行通信。线程使用同步原语或是通过<br>等待输入（即发生阻塞直至输入变为可用状态）来进行同步。<br>进程的主要优点是操作系统会隔离各个进程。如果一个进程崩溃了，其他进程依然活<br>着，尽管它们可能什么也不会做。<br>进程最大的缺点是它们有太多的状态：虚内存表、多执行单元上下文、所有暂停线程的<br>上下文。进程的启动、停止以及互相之间的切换都比线程慢。<br>C++ 无法直接操作进程。通常，一个 C++ 程序的表现形式就是操作系统中的一个进程。<br>C++ 中没有任何工具能够操作进程，因为并非所有的操作系统都有进程的概念。有些小<br>型处理器会为程序分割时间，但不会隔离程序，所以这些程序看起来更像是线程。</p><h3 id="分布式处理（distributed-processing）"><a href="#分布式处理（distributed-processing）" class="headerlink" title="分布式处理（distributed processing）"></a>分布式处理（distributed processing）</h3><p>分布式处理是指程序活动分布于一组处理器上。这些处理器可以不同。相比于处理器的<br>处理速度，它们之间的通信速度非常慢。一组通过 TCP/IP 协议进行通信的云服务器的<br>实例就是一种分布式处理。在一台单独的 PC 上也存在着分布式处理，例如将驱动器分<br>流（offload）给运行于磁盘驱动器和网卡之上的处理器。另一个例子是将图形任务分流<br>给图形处理单元（GPU）中的多种专用处理器。在典型的分布式处理结构中，数据通过管道或网络流向进程，进程在对输入数据进行处<br>理后再将数据放入到下一段管道中。这种模型与 Unix 的命令行管道一样古老，使得相<br>对重量级的进程也能够高效地运行。管道中的进程具有很长的生命周期，这样能够避免<br>启动进程的开销。进程能够连续地对工作单元进行处理，因此根据输入数据的情况，它<br>们可能会使用整个分割时间。最重要的是，进程之间不会共享内存或是同步，因此它们<br>能够全速运行。<br>尽管 C++ 中没有进程的概念，但 C++ 开发依然与分布式处理有关，因为它会影响程序<br>设计和程序结构。共享内存不会超过几个线程。有些并发方案提倡完全放弃共享内存。<br>分布式处理系统通常都会自然而然地被分解为子系统，形成模块化的、易理解的和能够<br>重新配置的体系结构。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程中的并发执行流，它们之间共享内存。线程使用同步原语进行同步，使用共<br>享的内存地址进行通信。<br>与进程相比，线程的优点在于消耗的资源更少，创建和切换也更快。<br>不过，线程也有几个缺点。由于进程中的所有线程都共享相同的内存空间，一个线程写<br>入无效的内存地址可能会覆盖掉其他线程的数据结构，导致线程崩溃或出现不可预测的<br>行为。此外，访问共享内存远比访问不共享的内存慢，并且内存中保存的内容必须在线<br>程之间同步，否则线程将会难以解释这些内容。<br>大多数操作系统都有自己的支持多线程的库。一直到现在，具有丰富的并发开发经验<br>的 C++ 开发人员一直都使用原生线程库或是提供了基本线程服务功能的跨平台解决方<br>案——POSIX 线程库。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>任务是在一个独立线程的上下文中能够被异步调用的执行单元。在基于任务的并发中，<br>任务和线程是独立地和显式地被管理的，这样可以将一个任务分配给一个线程去执行。<br>相比之下，在基于线程的并发中，线程以及在线程上运行的可执行代码是作为一个单元<br>被管理的。<br>基于任务的并发构建于线程之上，因此任务也具有线程的优点和缺点。<br>基于任务的并发的另外一个优势是，处于活动状态的软件线程的数量能够与硬件线程的<br>数量匹配起来，这样线程就能运行得非常高效。程序能够设置待执行任务的优先级和队<br>列。相比之下，在基于线程的系统中，操作系统以一种不透明的和依赖于操作系统的方<br>式设置线程优先级。<br>任务的灵活性的代价比应用程序的复杂性更大。程序必须实现对任务设置优先级或是排<br>序任务的方法。另外，程序还必须管理任务运行的基础——线程池。</p><h2 id="C-并发方式"><a href="#C-并发方式" class="headerlink" title="C++并发方式"></a>C++并发方式</h2><h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p><thread> 头文件提供了 std::thread 模板类，它允许程序创建线程对象作为操作系统自<br>身的线程工具的包装器。 std::thread 的构造函数接收一个可调用对象（函数指针、函数<br>对象、lambda 或是绑定表达式）作为参数，并会在新的软件线程上下文中执行这个对象。<br>C++ 使用可变模板参数转发“魔法”调用带有可变参数列表的函数，而底层操作系统的线<br>程调用通常接收一个指向带有 void* 参数的 void 函数的指针作为参数。</thread></p><h3 id="promise-和-future"><a href="#promise-和-future" class="headerlink" title="promise 和 future"></a>promise 和 future</h3><p>C++ 中的 std::promise 模板类和 std::future 分别是一个线程向另外一个线程发送和接收<br>消息的模板类。 promise 和 future 允许线程异步地计算值和抛出异常。 promise 和 future<br>共享一个称为共享状态（shared state）的动态分配内存的变量，这个变量能够保存一个已<br>定义类型的值，或是在标准包装器中封装的任意类型的异常。一个执行线程能够在 future<br>上被挂起，因此 future 也扮演着同步设备的角色。C++ <future> 头文件中包含 promise 和 future 的功能。 std::promise 模板的实例允许线程<br>将共享状态设置为一个指定类型的值或是一个异常。发送线程并不会等待共享状态变为可<br>读状态，它能够立即继续执行。<br>promise 的共享状态直到被设置为一个值或是一个异常后才就绪。共享状态必须且只能被<br>设置一次，否则会发生以下情况。</future></p><ul><li>如果某个线程多次试图将共享状态设置为一个值或是一个异常，那么共享状态将会被设置为 std::future_error 异常，错误代码是 promise_already_satisfied ，而且共享状态变为就绪状态，为释放所有在 promise 上等待的 future 做好准备。</li><li>如果某个线程从来没有将共享状态设置为一个值或是一个异常，那么在 promise 被销毁时，它的析构函数会将共享状态设置为 std::future_error 异常，错误代码是 broken_promise ，而且共享状态变为就绪状态，为释放所有在 promise 上等待的 future 做好准备。要想获得这个有用的错误提示，我们必须在线程的可调用对象中销毁 promise 。</li></ul><p>std::future 允许线程接收保存在 promise 的共享状态中的值或是异常。 future 是一个同步<br>原语，接收线程会在对 future 的 get() 成员函数的调用中挂起，直到相应的 promise 设置<br>了共享状态的值或是异常，变为就绪状态为止。<br>在被构造出来或是通过 promise 赋值后， future 才是有效的。在 future 无效时，接收线程<br>是无法在 future 上挂起的。 future 必须在发送线程被执行之前通过 promise 构造出来。否<br>则，接收线程会试图在 future 变为有效之前在它上面挂起。<br>promise 和 future 无法被复制。它们是代表特定通信集结点的实体。我们能构造和移动构<br>造它们，可以将一个 promise 赋值给一个 future 。理想情况下， promise 是在发送线程中<br>被创建的，而 future 则是在接收线程中被创建的。有一种编程惯用法是在发送线程中创建<br>promise ，然后使用 std::move(promise) 将其作为右值引用传递给接收线程，这样它的内<br>容就会被移动到属于接收线程的 promise 中。开发人员可以使用 std::async() 来做到这一<br>点。我们也可以通过指向发送线程的引用来传递 promise 。</p><h4 id="promise-、-future-和线程"><a href="#promise-、-future-和线程" class="headerlink" title="promise 、 future 和线程"></a>promise 、 future 和线程</h4><pre><code>void promise_future_example(){    auto meaning = [](std::promise&lt;int&gt; &amp;prom)    {        prom.set_value(42); // 计算&quot;meaning of life&quot;    };    std::promise&lt;int&gt; prom;    std::thread(meaning, std::ref(prom)).detach();    std::future&lt;int&gt; result = prom.get_future();    std::cout &lt;&lt; &quot;the meaning of life: &quot; &lt;&lt; result.get() &lt;&lt; &quot;\n&quot;;}</code></pre><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>C++11 提供了将可调用对象包装为任<br>务，并在可复用的线程上调用它的 async() 模板函数。在 C++ 标准库 <future> 头文件中定义了任务。 std::packaged_task 模板类能够包装任意<br>的可调用对象（可以是函数指针、函数对象、lambda 表达式或是绑定表达式），使其能够<br>被异步调用。 packaged_task 自身也是一个可调用对象，它可以作为可调用对象参数传递<br>给 std::thread 。与其他可调用对象相比，任务的最大优点是一个任务能够在不突然终止<br>程序的情况下抛出异常或返回值。任务的返回值或抛出的异常会被存储在一个可以通过<br>std::future 对象访问的共享状态中。</future></p><h4 id="packaged-task-和线程"><a href="#packaged-task-和线程" class="headerlink" title="packaged_task 和线程"></a>packaged_task 和线程</h4><pre><code>void promise_future_example_2(){    auto meaning = std::packaged_task&lt;int(int)&gt;(                       [](int n)    {        return n;    });    auto result = meaning.get_future();    auto t = std::thread(std::move(meaning), 42);    std::cout &lt;&lt; &quot;the meaning of life: &quot; &lt;&lt; result.get() &lt;&lt; &quot;\n&quot;;    t.join();}</code></pre><h4 id="任务和-async"><a href="#任务和-async" class="headerlink" title="任务和 async()"></a>任务和 async()</h4><pre><code>void promise_future_example_3(){    auto meaning = [](int n)    {        return n;    };    auto result = std::async(std::move(meaning), 42);    std::cout &lt;&lt; &quot;the meaning of life: &quot; &lt;&lt; result.get() &lt;&lt; &quot;\n&quot;;}</code></pre><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><mutex> 头文件包含了四种互斥量模板。</mutex></p><h4 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h4><p>一种简单且相对高效的互斥量。在 Windows 上，这个类会首先尝试繁忙等待策略，如<br>果它无法很快获得互斥量，就会改为调用操作系统。</p><h4 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h4><p>一种线程能够递归获取的互斥量，就像函数的嵌套调用一样。由于该类需要对它被获取<br>的次数计数，因此可能稍微低效。</p><h4 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a>std::timed_mutex</h4><p>允许在一定时间内尝试获取互斥量。要想在一定时间内尝试获取互斥量，通常需要操作<br>系统的介入，导致与 std::mutex 相比，这类互斥量的延迟显著地增大了。</p><h4 id="std-recursive-timed-mutex"><a href="#std-recursive-timed-mutex" class="headerlink" title="std::recursive_timed_mutex"></a>std::recursive_timed_mutex</h4><p>一种能够在一定时间内递归地获取的互斥量，开销也非常昂贵。</p><p>在 C++14 中加入的 <shared_mutex> 头文件包含了对共享互斥量——也被称为 reader/writer<br>互斥量——的支持。</shared_mutex></p><h4 id="std-shared-timed-mutex"><a href="#std-shared-timed-mutex" class="headerlink" title="std::shared_timed_mutex"></a>std::shared_timed_mutex</h4><p>一种同时支持定时和非定时获取互斥量的共享互斥量。</p><h4 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h4><p>一个更加简单的共享互斥量，按照计划在 C++17 中会被加入</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>在 <mutex> 头文件中有两个锁模板。</mutex></p><h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h4><p>一种简单的 RAII 锁。在这个类的构造过程中，程序会等待直到获得锁；而在析构过程<br>中则会释放锁。这个类的预标准实现通常被称为 scope_guard 。</p><h4 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h4><p>一个通用的互斥量所有权类，提供了 RAII 锁、延迟锁、定时锁、互斥量所有权的转移<br>和条件变量的使用。<br>在 C++14 的 <shared_mutex> 头文件中加入了共享互斥量的锁。</shared_mutex></p><h4 id="std-shared-lock"><a href="#std-shared-lock" class="headerlink" title="std::shared_lock"></a>std::shared_lock</h4><p>共享（reader/writer）互斥量的一个互斥量所有权类。它提供了 std::unique_lock 的所<br>有复杂特性，另外还有共享互斥量的控制权。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>C++ 在 <condition_variable> 头文件中提供了条件变量的两种实现方式。它们之间的区别<br>在于所接收的参数锁的一般性。</condition_variable></p><h4 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h4><p>最高效的条件变量，它需要使用 std::unique_lock 来锁住互斥量。</p><h4 id="std-condition-variable-any"><a href="#std-condition-variable-any" class="headerlink" title="std::condition_variable_any"></a>std::condition_variable_any</h4><p>一种能够使用任何 BasicLockable 锁（即任何具有 lock() 和 unlock() 成员函数的锁）<br>的条件变量。该条件变量可能会比 std::condition_variable 低效。</p><h4 id="使用条件变量实现的简单的生产者和消费者"><a href="#使用条件变量实现的简单的生产者和消费者" class="headerlink" title="使用条件变量实现的简单的生产者和消费者"></a>使用条件变量实现的简单的生产者和消费者</h4><pre><code>void cv_example(){    std::mutex m;    std::condition_variable cv;    bool terminate = false;    int shared_data = 0;    int counter = 0;    auto consumer = [&amp;]()    {        std::unique_lock&lt;std::mutex&gt; lk(m);        do        {            while (!(terminate || shared_data != 0))                cv.wait(lk);            if (terminate)                break;            std::cout &lt;&lt; &quot;consuming &quot; &lt;&lt; shared_data &lt;&lt; std::endl;            shared_data = 0;            cv.notify_one();        }        while (true);    };    auto producer = [&amp;]()    {        std::unique_lock&lt;std::mutex&gt; lk(m);        for (counter = 1; true; ++counter)        {            cv.wait(lk, [&amp;]()            {                return terminate || shared_data == 0;            });            if (terminate)                break;            shared_data = counter;            std::cout &lt;&lt; &quot;producing &quot; &lt;&lt; shared_data &lt;&lt; std::endl;            cv.notify_one();        }    };    auto p = std::thread(producer);    auto c = std::thread(consumer);    std::this_thread::sleep_for(std::chrono::milliseconds(1000));    {        std::lock_guard&lt;std::mutex&gt; l(m);        terminate = true;    }    std::cout &lt;&lt; &quot;total items consumed &quot; &lt;&lt; counter &lt;&lt; std::endl;    cv.notify_all();    p.join();    c.join();    exit(0);}</code></pre><h3 id="共享变量上的原子操作"><a href="#共享变量上的原子操作" class="headerlink" title="共享变量上的原子操作"></a>共享变量上的原子操作</h3><p>C++ 标准库 <atomic> 头文件提供了用于构建多线程同步原语的底层工具：内存栅栏和原子<br>性的加载与存储。</atomic></p><h4 id="内存栅栏"><a href="#内存栅栏" class="headerlink" title="内存栅栏"></a>内存栅栏</h4><p>std::atomic 的许多成员函数都会接收一个可选参数 memory_order ，它会选择一个围绕在操<br>作上下的栅栏。如果没有提供 memory_order 参数，它的默认值是 memory_order_acq_rel 。<br>这样会选择使用永远安全但开销昂贵的完全栅栏。当然，还有其他许多受限制的栅栏可<br>选，不过最好是由知识渊博的开发专家来做出决定。</p><p>内存栅栏通过多个硬件线程的高速缓存来同步主内存。通常，在一个线程与另一个线程同<br>步时，这两个线程上都会加上内存栅栏。在 C++ 中能够使用以下内存栅栏。</p><h4 id="memory-order-acquire"><a href="#memory-order-acquire" class="headerlink" title="memory_order_acquire"></a>memory_order_acquire</h4><p>你可以将 memory_order_acquire 理解为“通过其他线程完成所有工作”的意思。它确保<br>随后的加载不会被移动到当前的加载或是前面的加载之前。自相矛盾的是，它是通过等<br>待在处理器和主内存之间的当前的存储操作完成来实现这一点的。如果没有栅栏，当一<br>次存储还处于处理器和主内存之间，它的线程就在相同的地址进行了一次加载时，该线<br>程会得到旧的数据，仿佛这次在程序中加载被移动到了存储之前。<br>memory_order_acquire 可能会比默认的完全栅栏高效。例如，在原子性地读取在繁忙等<br>待 while 循环中的标识位时，可以使用 memory_order_acquire 。</p><h4 id="memory-order-release"><a href="#memory-order-release" class="headerlink" title="memory_order_release"></a>memory_order_release</h4><p>你可以将 memory_order_release 理解为“通过这个线程将所有工作释放到这个位置”的<br>意思。它确保这个线程完成的之前的加载和存储不会被移动到当前的存储之后。它是通<br>过等待这个线程内部的当前存储操作完成来实现这一点的。<br>memory_order_release 可能会比默认的完全栅栏高效。例如，在自定义的互斥量的尾部<br>设置标识位时，可以使用 memory_order_release 。</p><h4 id="memory-order-acq-rel"><a href="#memory-order-acq-rel" class="headerlink" title="memory_order_acq_rel"></a>memory_order_acq_rel</h4><p>这会结合之前的两种“确保”，创建一个完全栅栏。</p><h4 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h4><p>memory_order_consume 是 memory_order_acquire 的一种弱化（但更快）的形式，它只要<br>求当前的加载发生在其他依赖这次加载数据的操作之前。例如，当一个指针的加载被标<br>记为 memory_order_consume 时，紧接着的解引这个指针的操作就不会被移动它之前。</p><h4 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h4><p>使用这个值意味着允许所有的重新排序。</p><h3 id="展望未来的C-并发特性"><a href="#展望未来的C-并发特性" class="headerlink" title="展望未来的C++并发特性"></a>展望未来的C++并发特性</h3><p>许多开发人员在使用原生调用或是 POSIX 线程<br>（pthreads）库的 C 风格的函数实现线程并发方面经验丰富。</p><p>以下是 C++17 可能会带给我们的一些并发特性。</p><h4 id="协作多线程"><a href="#协作多线程" class="headerlink" title="协作多线程"></a>协作多线程</h4><p>在协作多线程中，两个或多个软件线程通过语句显式地互相传递执行，这样实际上在同<br>一时间只有一个线程在运行。协程（coroutines）就是协作多线程的例子。</p><h4 id="SIMD-指令"><a href="#SIMD-指令" class="headerlink" title="SIMD 指令"></a>SIMD 指令</h4><p>SIMD 是单指令多数据（single instruction multiple data）的首字母缩写。在支持 SIMD<br>的处理器中，某些指令会操作寄存器向量。处理器会同时在向量中的每个寄存器上进行<br>相同的操作，与标量操作相比减少了间接开销。<br>C++ 编译器通常不会生成 SIMD 指令，因为它们的行为很复杂，不太符合 C++ 描述<br>程序的方式。依赖于编译器的编译指令或是内联汇编特性允许在函数中插入 SIMD 指<br>令，然后这些函数会被收录到用于数字信号处理或是计算机图形等专业任务的库中。因<br>此，SIMD 编程是同时依赖于处理器和编译器的。互联网上有许多关于 SIMD 指令的资<br>源，其中 Stack Exchange Q&amp;A（<a href="http://gamedev.stackexchange.com/questions/12601/simd-" target="_blank" rel="noopener">http://gamedev.stackexchange.com/questions/12601/simd-</a><br>c-library）上有许多讨论如何在 C++ 中使用 SIMD 的资料。</p><h2 id="优化多线程C-程序"><a href="#优化多线程C-程序" class="headerlink" title="优化多线程C++程序"></a>优化多线程C++程序</h2><h3 id="用-std-async-替代-std-thread"><a href="#用-std-async-替代-std-thread" class="headerlink" title="用 std::async 替代 std::thread"></a>用 std::async 替代 std::thread</h3><p>并发编程的一项实用优化技巧是用复用线程取代在每次需要时创建新线程。线程可能会在<br>某个条件变量上挂起，直到程序需要使用它们时才会被释放，并接着执行一个可调用对象。尽管切换线程的有些开销（保存和恢复寄存器并刷新和重新填充高速缓存）是相同<br>的，但可以移除或减少为线程分配内存以及操作系统调度线程等其他开销。</p><p>模板函数 std::async() 会运行线程上下文中的可调用对象，但是它的实现方式允许复用<br>线程。从 C++ 标准来看， std::async() 可能是使用线程池的方式实现的。在 Windows 上，<br>std::async() 明显快得多。</p><p>使用 async() 启动和停止线程</p><pre><code>std::async(std::launch::async, []() { return; });</code></pre><p>async() 会返回一个 std::future ，在这种情况下它是一个匿名临时变量。只要 std::async()<br>一返回，程序就会立即调用这个匿名 std::future 的析构函数。析构函数会等待该 future<br>变为就绪状态，因此它可以抛出所有会发生的异常。这里不需要显式地调用 join() 或是<br>detach() 。</p><h3 id="创建与核心数量一样多的可执行线程"><a href="#创建与核心数量一样多的可执行线程" class="headerlink" title="创建与核心数量一样多的可执行线程"></a>创建与核心数量一样多的可执行线程</h3><p>C++ 提供了一个 std::thread::hardware_concurrency() 函数，它可以返回可用核心的数<br>量。这个函数会计算由 hypervisor 分配给其他虚拟机的核心，以及因多线程同步而表现为两个或多个逻辑核心的核心的数量。通过这个函数，以后我们可以方便地将程序部署到包<br>含更多（或少）核心的硬件上运行。</p><h3 id="实现任务队列和线程池"><a href="#实现任务队列和线程池" class="headerlink" title="实现任务队列和线程池"></a>实现任务队列和线程池</h3><p>解决不知道有多少个线程正在运行这个问题的方法是让线程更加明显：使用线程池（一种<br>保持固定数量的永久线程的数据结构）和任务队列（一种存储待执行的计算的列表的数据<br>结构），这些计算将由线程池中的线程负责执行。</p><h3 id="在单独的线程中执行I-O"><a href="#在单独的线程中执行I-O" class="headerlink" title="在单独的线程中执行I/O"></a>在单独的线程中执行I/O</h3><p>磁盘转速和网络连接距离等物理现实问题造成在程序请求数据和数据变为可用状态之间存<br>在着延迟。因此，I/O 是适用并发的绝佳位置。另外一个典型的 I/O 问题是，程序在写数<br>据之前或是读数据之后必须对它进行转换。例如，我们先从互联网上读取一个 XML 文件，<br>接着解析它，从中提取程序所需信息。由于在对数据进行转换之前是无法直接使用它的，<br>我们可以考虑将整个处理（包括读数据和解析数据）移动到一个单独的线程中。</p><h3 id="没有同步的程序"><a href="#没有同步的程序" class="headerlink" title="没有同步的程序"></a>没有同步的程序</h3><h4 id="面向事件编程"><a href="#面向事件编程" class="headerlink" title="面向事件编程"></a>面向事件编程</h4><p>在面向事件编程中，程序是一组由框架调用的事件处理函数的集合。底层框架从事件队<br>列中将每个事件分发给注册了该事件的事件处理函数。面向事件编程在许多方面都与面<br>向任务编程类似。在面向事件的程序中，框架的行为类似于任务调度器，而事件处理函<br>数则类似于任务。它们两者之间的重要区别在于，在面向事件的程序中，框架是单线程<br>的，事件处理函数也不会并发执行。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程是可执行对象，虽然它会显式地将执行从一个对象转交给另外一个对象，但是它们<br>会记住执行指针，这样如果它们被再次调用了也可以继续执行。与面向事件的程序相<br>同，协程并非真正的多线程，因此只要它们不受多线程控制就不需要同步。<br>协程有两种。第一种有自己的栈，而且可以在执行途中的任何位置将控制转交给另外一<br>个协程。第二种是向另外一个线程借栈，并且只能在它的顶层转交控制。</p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>在消息传递程序中，控制线程从一个或多个输入源中接收输入，对输入进行转换后将它<br>放到一个或多个输出槽中。相互连接的输出和输入组成了一幅具有良好定义的入口节点<br>和出口节点的图。这些被实现了一个消息传递程序的各个阶段的线程所读写的元素可以<br>是网络数据报、字符 I/O 流或是隐式队列中的数据结构。<br>Unix 命令行管道和 Web 服务都是消息传递编程的例子。分布式处理系统的组件也都是<br>消息传递程序。</p><h4 id="无锁编程（lock-free-programming）"><a href="#无锁编程（lock-free-programming）" class="headerlink" title="无锁编程（lock-free programming）"></a>无锁编程（lock-free programming）</h4><p>无锁编程是指无需互斥，允许多线程更新数据结构的编程实践。在无锁程序中，硬件同<br>步的原子性操作取代了昂贵的互斥量。无锁数据结构远比由互斥量保护的传统容器要优<br>秀，特别是当许多线程访问同一个容器时。<br>C++ 中无锁的数组、队列和散列表容器类已经发布了。Boost 也有无锁的栈和队列容器<br>（<a href="http://www.boost.org/doc/libs/1_59_0/doc/html/lockfree.html），" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_59_0/doc/html/lockfree.html），</a> 但 是 只 在 GCC 和 Clang<br>编译器上进行了测试。英特尔的线程构建模块（<a href="http://www.threadingbuildingblocks.org/）" target="_blank" rel="noopener">http://www.threadingbuildingblocks.org/）</a><br>中有无锁的数组、队列和散列表容器。由于无锁编程的需求，这些容器并非与 C++ 标<br>准库中的容器完全相同。</p><h2 id="让同步更加高效"><a href="#让同步更加高效" class="headerlink" title="让同步更加高效"></a>让同步更加高效</h2><ul><li>减小临界区的范围</li><li>限制并发线程的数量</li><li>避免惊群，当有许多线程挂起在一个事件当发生这个事件时，所有的线程都会变为可运行状态，但由于只有几个核心，因此只有几个线程能够立即运行。</li><li>避免锁护送,当大量线程同步，挂起在某个资源或是临界区上时会发生锁护送（lock convoy）。这会导致额外的阻塞，因为它们都会试图立即继续进行处理，但是每次却只有一个线程能够继续处理，仿佛是在护送锁一样。</li><li>减少竞争<ul><li>注意内存和 I/O 都是资源</li><li>复制资源</li><li>分割资源</li><li>细粒度锁,我们可以使用多个互斥量，而不是一个互斥量来锁住整个数据结构。</li><li>无锁数据结构，我们使用无锁散列表等无锁数据结构来摆脱对互斥的依赖。这是细粒度锁的终极形态。</li><li>资源的调度</li></ul></li><li>不要在单核系统上繁忙等待</li><li>不要永远等待</li><li>自己设计互斥量可能会低效</li><li>限制生产者输出队列的长度</li></ul><h2 id="并发库"><a href="#并发库" class="headerlink" title="并发库"></a>并发库</h2><h3 id="Boost-Thread（http-www-boost-org-doc-libs-1-60-0-doc-html-thread-html）和-Boost-Coroutine（http-www-boost-org-doc-libs-1-60-0-libs-coroutine-doc-html-index-html）"><a href="#Boost-Thread（http-www-boost-org-doc-libs-1-60-0-doc-html-thread-html）和-Boost-Coroutine（http-www-boost-org-doc-libs-1-60-0-libs-coroutine-doc-html-index-html）" class="headerlink" title="Boost.Thread（http://www.boost.org/doc/libs/1_60_0/doc/html/thread.html）和 Boost.Coroutine（http://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/index.html）"></a>Boost.Thread（<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/thread.html）和" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/thread.html）和</a> Boost.Coroutine（<a href="http://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/index.html）" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/libs/coroutine/doc/html/index.html）</a></h3><p>Boost 的线程库是对 C++17 标准库线程库的展望。其中有些部分现在仍然处于实验状<br>态。 Boost.Coroutine 也处于实验状态。</p><h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>POSIX 线程（pthreads）是一个跨平台的线程和同步原语库，它可能是最古老和使<br>用最广泛的并发库了。POSIX 线程是 C 风格的函数库，提供了传统的并发能力。它<br>有非常完整的文档资源，不仅适用于多种 Linux 发行版，也适用于 Windows（http://<br>sourceware.org/pthreads-win32/）。</p><h3 id="线程构建模块（TBB，http-www-threadingbuildingblocks-org-）"><a href="#线程构建模块（TBB，http-www-threadingbuildingblocks-org-）" class="headerlink" title="线程构建模块（TBB，http://www.threadingbuildingblocks.org/）"></a>线程构建模块（TBB，<a href="http://www.threadingbuildingblocks.org/）" target="_blank" rel="noopener">http://www.threadingbuildingblocks.org/）</a></h3><p>TBB 是一个有雄心壮志的、有良好文档记录的、具有模板特性的 C++ 线程 API。它提<br>供了并行 for 循环，任务和线程池，并发容器，数据流消息传递类以及同步原语。TBB<br>由英特尔开发，旨在提高多核处理器效率。现在它已经被开源了，同时支持 Windows<br>和 Linux。它有良好的文档记录，其中还包括一本优秀书籍（James Reinders 编写的<br>Intel Threading Building Blocks，O’Reilly 出版社）。</p><h3 id="0mq（也拼写为-ZeroMQ，http-zeromq-org-）"><a href="#0mq（也拼写为-ZeroMQ，http-zeromq-org-）" class="headerlink" title="0mq（也拼写为 ZeroMQ，http://zeromq.org/）"></a>0mq（也拼写为 ZeroMQ，<a href="http://zeromq.org/）" target="_blank" rel="noopener">http://zeromq.org/）</a></h3><p>0mq 是一个用于连接消息传递程序的通信库。它支持多种通信范式，追求高效与简约。<br>以我的个人经验来看，0mq 是非常优秀的。0mq 是开源的，有良好的文档，获得了不少<br>支持。0mq 还有一个称为 nanomsg 的改进版（<a href="http://www.nanomsg.org），它修正了" target="_blank" rel="noopener">http://www.nanomsg.org），它修正了</a> 0mq<br>中的一些问题。</p><h3 id="消息传递接口（MPI，http-computing-llnl-gov-tutorials-mpi-）"><a href="#消息传递接口（MPI，http-computing-llnl-gov-tutorials-mpi-）" class="headerlink" title="消息传递接口（MPI，http://computing.llnl.gov/tutorials/mpi/）"></a>消息传递接口（MPI，<a href="http://computing.llnl.gov/tutorials/mpi/）" target="_blank" rel="noopener">http://computing.llnl.gov/tutorials/mpi/）</a></h3><p>MPI 是分布式计算机网络中的消息传递的一个 API 规范。它的实现类似于 C 风格的函<br>数库。MPI 诞生于加利福尼亚的劳伦斯利弗莫尔国家实验室，该实验室长期与超级计算<br>机集群和繁荣的高能物理联系在一起。MPI 具有良好的文档记录，具有老式的 20 世纪<br>80 年代的 DoD 风格。它既有支持 Linux 的实现，也有支持 Windows 的实现，其中还包<br>括来自 Boost 的实现（<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/mpi.html），但是这" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_60_0/doc/html/mpi.html），但是这</a><br>些实现并非都完整地覆盖了规范。</p><h3 id="OpenMP（http-openmp-org）"><a href="#OpenMP（http-openmp-org）" class="headerlink" title="OpenMP（http://openmp.org）"></a>OpenMP（<a href="http://openmp.org）" target="_blank" rel="noopener">http://openmp.org）</a></h3><p>OpenMP 是一款用于“使用 C/C++ 和 Fortran 语言进行多平台共享内存并行编程”的<br>API。其用法是开发人员使用定义程序并行行为的编译指令装饰 C++ 程序。OpenMP 提<br>供了一个擅长数值计算的细粒度的并发模型，而且它正在朝着 GPU 编程的方向发展。<br>在 Linux 上，GCC 和 Clang 都支持 OpenMP；在 Windows 上 Visual C++ 支持 OpenMP。</p><h3 id="C-AMP（https-msdn-microsoft-com-en-us-library-hh265137-aspx）"><a href="#C-AMP（https-msdn-microsoft-com-en-us-library-hh265137-aspx）" class="headerlink" title="C++ AMP（https://msdn.microsoft.com/en-us/library/hh265137.aspx）"></a>C++ AMP（<a href="https://msdn.microsoft.com/en-us/library/hh265137.aspx）" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh265137.aspx）</a></h3><p>C++ AMP 是一份关于设计 C++ 库在 GPU 设备上进行并行数据计算的开源规范。其中，<br>来自于微软的版本会被解析为 DirectX 11 调用。</p><h1 id="优化内存管理"><a href="#优化内存管理" class="headerlink" title="优化内存管理"></a>优化内存管理</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows计时函数&quot;&gt;&lt;a href=&quot;#Windows计时函数&quot; class=&quot;headerlink&quot; title=&quot;Windows计时函数&quot;&gt;&lt;/a&gt;Windows计时函数&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;time()
GetTickCount()
GetT
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="读书笔记" scheme="https://caojingyou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="性能优化" scheme="https://caojingyou.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Visual C++ 技术内幕</title>
    <link href="https://caojingyou.github.io/2018/06/18/Visual%20C++%20%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>https://caojingyou.github.io/2018/06/18/Visual C++ 技术内幕/</id>
    <published>2018-06-18T03:34:00.000Z</published>
    <updated>2018-07-09T00:55:09.874Z</updated>
    
    <content type="html"><![CDATA[<ul><li>颜色调色板CPalette</li><li>调用CDC的SetViewportOrg来改变坐标原点</li><li>TRACE与afxDump诊断信息</li><li>CArchive序列化类</li><li>DragAcceptFiles标识窗口是否接受从shell拖放过来的文件</li><li>DragQueryFile 获得拖拽后的文件名称列表。</li><li>DragFinish 释放系统为拖拽功能处理文件名称而分配的内存。</li><li>OnQueryEndSession</li></ul><p>OLE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;颜色调色板CPalette&lt;/li&gt;
&lt;li&gt;调用CDC的SetViewportOrg来改变坐标原点&lt;/li&gt;
&lt;li&gt;TRACE与afxDump诊断信息&lt;/li&gt;
&lt;li&gt;CArchive序列化类&lt;/li&gt;
&lt;li&gt;DragAcceptFiles标识窗口是否接
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Visual C++ 技术内幕-读书笔记</title>
    <link href="https://caojingyou.github.io/2018/06/18/Visual%20C++%20%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://caojingyou.github.io/2018/06/18/Visual C++ 技术内幕-读书笔记/</id>
    <published>2018-06-18T03:34:00.000Z</published>
    <updated>2018-06-21T06:18:05.537Z</updated>
    
    <content type="html"><![CDATA[<ul><li>颜色调色板CPalette</li><li>调用CDC的SetViewportOrg来改变坐标原点</li><li>TRACE与afxDump诊断信息</li><li>CArchive序列化类</li><li>DragAcceptFiles标识窗口是否接受从shell拖放过来的文件</li><li>DragQueryFile 获得拖拽后的文件名称列表。</li><li>DragFinish 释放系统为拖拽功能处理文件名称而分配的内存。</li><li>OnQueryEndSession</li></ul><p>OLE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;颜色调色板CPalette&lt;/li&gt;
&lt;li&gt;调用CDC的SetViewportOrg来改变坐标原点&lt;/li&gt;
&lt;li&gt;TRACE与afxDump诊断信息&lt;/li&gt;
&lt;li&gt;CArchive序列化类&lt;/li&gt;
&lt;li&gt;DragAcceptFiles标识窗口是否接
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="读书笔记" scheme="https://caojingyou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu双系统</title>
    <link href="https://caojingyou.github.io/2018/06/16/Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://caojingyou.github.io/2018/06/16/Ubuntu双系统/</id>
    <published>2018-06-16T08:30:00.000Z</published>
    <updated>2018-06-16T08:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ubuntu系统文件</li><li>Universal-USB-Installer</li><li>EasyBCD 2.3</li></ul><p>系统分盘：/boot与/swap</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;ubuntu系统文件&lt;/li&gt;
&lt;li&gt;Universal-USB-Installer&lt;/li&gt;
&lt;li&gt;EasyBCD 2.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统分盘：/boot与/swap&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="linux" scheme="https://caojingyou.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://caojingyou.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>C++单元测试</title>
    <link href="https://caojingyou.github.io/2018/06/15/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://caojingyou.github.io/2018/06/15/代码覆盖率/</id>
    <published>2018-06-15T02:22:00.000Z</published>
    <updated>2018-06-15T03:29:17.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h1><h2 id="COVTOOL"><a href="#COVTOOL" class="headerlink" title="COVTOOL"></a>COVTOOL</h2><p>（<a href="http://covtool.sourceforge.net）是一个开源的测试覆盖率工具。" target="_blank" rel="noopener">http://covtool.sourceforge.net）是一个开源的测试覆盖率工具。</a></p><h2 id="OpenCppCoverage"><a href="#OpenCppCoverage" class="headerlink" title="OpenCppCoverage"></a>OpenCppCoverage</h2><ul><li><a href="https://github.com/OpenCppCoverage/OpenCppCoverage" target="_blank" rel="noopener">https://github.com/OpenCppCoverage/OpenCppCoverage</a></li><li><a href="https://github.com/OpenCppCoverage/OpenCppCoverage/wiki/Command-line-reference" target="_blank" rel="noopener">https://github.com/OpenCppCoverage/OpenCppCoverage/wiki/Command-line-reference</a></li><li><p><a href="https://github.com/OpenCppCoverage/OpenCppCoverage/wiki/Jenkins" target="_blank" rel="noopener">https://github.com/OpenCppCoverage/OpenCppCoverage/wiki/Jenkins</a></p><p>  OpenCppCoverage.exe –sources MySourcePath – YourProgram.exe arg1 arg2</p></li></ul><p>打开VisualStudio –&gt; 工具 –&gt; 扩展和更新 –&gt; 联机 –&gt; 右上角输入OpenCppCoverage，在下面的结果会出现“OpenCppCoverage Plugin”点击安装即可（安装中需要将VisualStudio重启）</p><p>程序写好，编译执行之后，点击“工具 –&gt; Run OpenCppCoverage”，程序运行，将命令行窗口关掉，则代码会出现红色或者绿色的阴影，下面会出现Coverage的报告</p><h1 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h1><p>Linux下的C/C++代码，可以在gcc/g++工具编译代码时加上“–coverage”选项来生成可用于覆盖率分析的二进制文件，然后用gcov命令来生成覆盖率统计情况，也可用lcov工具来生成html版本的可读性很好的代码覆盖率报告。</p><pre><code>c/c++:    gcc+gcov+lcov；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Windows环境&quot;&gt;&lt;a href=&quot;#Windows环境&quot; class=&quot;headerlink&quot; title=&quot;Windows环境&quot;&gt;&lt;/a&gt;Windows环境&lt;/h1&gt;&lt;h2 id=&quot;COVTOOL&quot;&gt;&lt;a href=&quot;#COVTOOL&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="代码覆盖率" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
      <category term="工具" scheme="https://caojingyou.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Boost C++11多线程</title>
    <link href="https://caojingyou.github.io/2018/06/12/Boost%20C++11%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://caojingyou.github.io/2018/06/12/Boost C++11 多线程/</id>
    <published>2018-06-12T02:00:00.000Z</published>
    <updated>2018-06-15T06:36:35.938Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.boost.org/doc/libs/1_55_0/doc/html/thread.html" target="_blank" rel="noopener">https://www.boost.org/doc/libs/1_55_0/doc/html/thread.html</a></p><h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><ul><li>当创建一个thread对象后，线程就立刻开始执行。</li><li>join()和timed_join()方法等待线程结束。 <ul><li>join()一直阻塞等待，直到线程结束。</li><li>timed_join()阻塞等待线程结束，或阻塞等待一定的时间段，然后不管线程是否结束都返回。</li></ul></li><li>detach()与线程执行体分离，线程执行体不受影响的继续执行直到运行结束。</li><li>可以使用bind()和function库。</li><li>thread类的3个静态成员函数： <ul><li>yield() 指示当前线程放弃时间片，允许其他的线程运行。</li><li>sleep() 让线程睡眠等待一小段时间。</li><li>hardware_concurrency() 获得硬件系统可并行的线程数量，即CPU数量。</li></ul></li><li>thread::this_thread 子命名空间： <ul><li>get_id() 获得线程ID</li><li>yield() 放弃时间片</li><li>sleep() 睡眠等待</li><li>at_thread_exit(func)函数，允许“登记”一个线程在结束的时候执行可调用物func，无论线程是否被中断。</li></ul></li><li>interrupt() 中断线程，允许正在执行的线程被中断，被中断的线程会抛出一个thread_interrupted异常。</li></ul><h2 id="创建线程4种方法以及分离或等待线程"><a href="#创建线程4种方法以及分离或等待线程" class="headerlink" title="创建线程4种方法以及分离或等待线程"></a>创建线程4种方法以及分离或等待线程</h2><p>在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。</p><pre><code>void my_func(){    std::cout &lt;&lt; &quot;detach-分离 或 join-等待 线程&quot; &lt;&lt; std::endl;}TEST(BoostThread, detachOrjoin)//简单线程,线程状态joinable、detached{    boost::thread t(my_func);    boost::thread::yield();//当前线程放弃余下的时间片。    std::cout &lt;&lt; t.joinable() &lt;&lt; std::endl;    t.join();    boost::thread t1(my_func);    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;    t1.detach();    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;}//线程的创建需要传递给thread对象一个可调用物（函数或函数对象），它必须具//有operator()以供线程执行。boost::mutex io_mutex;struct count {    count(int id) : id(id) { }    void operator()()    {        for (int i = 0; i &lt; 10; ++i)        {            boost::mutex::scoped_lock                lock(io_mutex);            std::cout &lt;&lt; id &lt;&lt; &quot;: &quot;                &lt;&lt; i &lt;&lt; std::endl;        }    }    int id;};TEST(BoostThread, Typeobject)//复杂类型对象作为参数来创建线程{    boost::thread thrd1(count(1));    boost::thread thrd2(count(2));    thrd1.join();    thrd2.join();}class HelloWorldStatic{public:    static void hello()    {        std::cout &lt;&lt;            &quot;Hello world, I&apos;&apos;m a thread!&quot;            &lt;&lt; std::endl;    }    static void start()    {        boost::thread thrd(hello);        thrd.join();    }};TEST(BoostThread, InClassStatic)//类内部创建线程{    HelloWorldStatic::start();//在这里start()和hello()方法都必须是static方法。}class HelloWorld{public:    void hello()    {        std::cout &lt;&lt;            &quot;Hello world, I&apos;&apos;m a thread!&quot;            &lt;&lt; std::endl;    }    void start()    {        boost::function0&lt; void&gt; f = boost::bind(&amp;HelloWorld::hello, this);        boost::thread thrd(f);        thrd.join();    }};TEST(BoostThread, InClass)//start()和hello()方法不是静态方法则采用此方法创建线程{    HelloWorld hello;    hello.start();}class HelloWorldOut{public:    void hello(const std::string&amp; str)    {        std::cout &lt;&lt; str;    }};TEST(BoostThread, OutClass){    HelloWorldOut obj;    boost::thread thrd(boost::bind(&amp;HelloWorldOut::hello, &amp;obj, &quot;Hello world, I&apos;&apos;m a thread!&quot; ) ) ;    thrd.join();}</code></pre><h2 id="线程的参数传递"><a href="#线程的参数传递" class="headerlink" title="线程的参数传递"></a>线程的参数传递</h2><pre><code>void func1(const int &amp;id){    std::cout &lt;&lt; &quot;func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;}struct MyThread{    void operator()(const int &amp;id)    {        std::cout &lt;&lt; &quot;MyThread id : &quot; &lt;&lt; id &lt;&lt; std::endl;    }    void func1(const int &amp;id)    {        std::cout &lt;&lt; &quot;MyThread::func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;    }};TEST(BoostThread, Threadparameters){    //普通函数      boost::thread t1(func1, 11);    t1.join();    //函数对象      MyThread myThread;    boost::thread t2(myThread, 22);    t2.join();    //成员函数      boost::thread t3(&amp;MyThread::func1, myThread, 33);    t3.join();    //临时对象      boost::thread t4(MyThread(), 44);    t4.join();    //对象引用      boost::thread t5(boost::ref(myThread), 55);    t5.join();}</code></pre><p>还可使用bing与ref</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>禁用于回复中断：<br><code>boost::this_thread::disable_interruption</code>与<code>boost::this_thread::restore_interruption</code></p><pre><code>void f(){    // interruption enabled here    {        boost::this_thread::disable_interruption di;        // interruption disabled        {            boost::this_thread::disable_interruption di2;            // interruption still disabled        } // di2 destroyed, interruption state restored        // interruption still disabled    } // di destroyed, interruption state restored    // interruption now enabled}void g(){    // interruption enabled here    {        boost::this_thread::disable_interruption di;        // interruption disabled        {            boost::this_thread::restore_interruption ri(di);            // interruption now enabled        } // ri destroyed, interruption disable again    } // di destroyed, interruption state restored    // interruption now enabled}</code></pre><p>函数检测当前线程是否允许中断：<code>boost::this_thread::interruption_enabled()</code></p><p>函数检测当前线程是否被要求中断：<code>boost::this_thread::interruption_requested()</code></p><p>类<code>disable_interruption</code>是一个RAII类型的对象，它在构造时关闭线程的中断，析构时自动恢复线程的中断状态。在<code>disable_interruption</code> 的生命期内线程始终是不可中断的，除非使用了<code>restore_interruption</code> 对象。</p><p><code>restore_interruption</code>只能在<code>disable_interruption</code> 的作用域内使用，它在构造时临时打开线程的中断状态，在析构时又关闭中断状态。</p><p>thread库预定义了若干个线程的中断点:</p><pre><code>boost::thread::join()boost::thread::timed_join()boost::thread::try_join_for(),boost::thread::try_join_until(),boost::condition_variable::wait()boost::condition_variable::timed_wait()boost::condition_variable::wait_for()boost::condition_variable::wait_until()boost::condition_variable_any::wait()boost::condition_variable_any::timed_wait()boost::condition_variable_any::wait_for()boost::condition_variable_any::wait_until()boost::thread::sleep()boost::this_thread::sleep_for()boost::this_thread::sleep_until()boost::this_thread::interruption_point()</code></pre><p>而最后一个位于子名字空间this_thread的interruption_point()则是一个特殊的中断点函数，它并不等待，只是起到一个标签的作用，表示线程执行到这个函数所在的语句就可以被中断。</p><h2 id="thread-group线程组"><a href="#thread-group线程组" class="headerlink" title="thread_group线程组"></a>thread_group线程组</h2><p>thread库提供类thread_group用于管理一组线程，就像是一个线程池，它内部使用<br>std::list<thread*> 来容纳创建的thread对象。</thread*></p><pre><code>void thread_group_Fun(){    std::cout &lt;&lt;&quot;当前线程ID:&quot;&lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;}TEST(BoostThread, thread_group){    boost::thread_group grp;    boost::thread *p = new boost::thread(thread_group_Fun);    grp.add_thread(p);    std::cout &lt;&lt; &quot;remove_thread:&quot; &lt;&lt; p-&gt;get_id()&lt;&lt; std::endl;    grp.remove_thread(p);    grp.create_thread(thread_group_Fun);    grp.create_thread(thread_group_Fun);       grp.join_all();                 }</code></pre><p>##作用域线程 ## </p><pre><code>boost::strict_scoped_thread&lt;&gt; t((boost::thread(F)));boost::scoped_thread&lt;&gt; t((boost::thread(F)));</code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Lock-Guard"><a href="#Lock-Guard" class="headerlink" title="Lock Guard"></a>Lock Guard</h3><pre><code>Class template lock_guardNon Member Function make_lock_guardNon Member Function make_lock_guard</code></pre><p>boost::lock_guard 在其内部构造和析构函数分别自动调用 lock() 和 unlock() 。 访问共享资源是需要同步的，因为它显示地被两个方法调用。</p><p>使用 lock_guard 自动加锁、解锁。原理是 RAII，和智能指针类似。</p><h3 id="RAII型的lock-guard类"><a href="#RAII型的lock-guard类" class="headerlink" title="RAII型的lock_guard类"></a>RAII型的lock_guard类</h3><p>直接使用mutex的lock()函数来锁定互斥量不够方便，且在发生异常退出作用域等情况下很可能忘记解锁。<br>故，thread库提供了RAII型lock_guard类，辅助：在构造时锁定互斥量，析构时自动解锁。<br>mutex类使用内部类型定义了两种lock_guard对象： </p><pre><code>scoped_lock scoped_try_lock</code></pre><p>使用 unique_lock 自动加锁、解锁。<br>unique_lock 与 lock_guard 原理相同，但是提供了更多功能（比如可以结合条件变量使用）。<br>注意：mutex::scoped_lock 其实就是 unique_lock<mutex> 的 typedef。</mutex></p><h3 id="Lock-Types"><a href="#Lock-Types" class="headerlink" title="Lock Types"></a>Lock Types</h3><pre><code>Class template unique_lockClass template shared_lock - C++14Class template upgrade_lock - EXTENSIONClass template upgrade_to_unique_lock -- EXTENSIONMutex-specific class scoped_try_lock -- DEPRECATED</code></pre><p>boost::unique_lock 这个所谓的独占锁意味着一个互斥量同时只能被一个线程获取。 其他线程必须等待，直到互斥体再次被释放。 除了独占锁，还有非独占锁。 Boost.Thread里有个 boost::shared_lock 的类提供了非独占锁。</p><p>shared_lock是read lock。被锁后仍允许其他线程执行同样被shared_lock的代码。这是一般做读操作时的需要。</p><p>unique_lock是write lock。被锁后不允许其他线程执行被shared_lock或unique_lock的代码。在写操作时，一般用这个，可以同时限制unique_lock的写和share_lock的读。</p><h4 id="boost-mutex-scoped-lock"><a href="#boost-mutex-scoped-lock" class="headerlink" title="boost::mutex::scoped_lock"></a>boost::mutex::scoped_lock</h4><pre><code>boost::mutex io_mutex;void foo( ){    {        boost::mutex::scoped_lock lock( io_mutex );         /// 锁定    } /// 解锁}</code></pre><h4 id="boost-lock-guard-lt-gt-和boost-unique-lock-lt-gt-的区别"><a href="#boost-lock-guard-lt-gt-和boost-unique-lock-lt-gt-的区别" class="headerlink" title="boost::lock_guard&lt;&gt;和boost::unique_lock&lt;&gt;的区别"></a>boost::lock_guard&lt;&gt;和boost::unique_lock&lt;&gt;的区别</h4><pre><code>boost::mutex  m;void foo( ){    boost::lock_guard&lt;boost::mutex&gt; lk( m );    process( data );};//lock_guard只能像上面这样使用，而unique_lock允许设置超时，推迟锁定lock以及在对象销毁之前unlock。{    boost::unique_lock&lt;boost::mutex&gt; lk( m );    process( data );    lk.unlock( );    // do other thing};</code></pre><p>设置锁超时</p><pre><code>boost::unique_lock&lt;boost::timed_mutex&gt; lk( m, std::chrono::milliseconds(3) ); // 超时3秒if( lk )  process( data );</code></pre><h3 id="Other-Lock-Types-EXTENSION"><a href="#Other-Lock-Types-EXTENSION" class="headerlink" title="Other Lock Types - EXTENSION"></a>Other Lock Types - EXTENSION</h3><pre><code>Strict LocksLocking pointersExternally LockedClass template shared_lock_guardClass template reverse_lock</code></pre><h2 id="互斥类型"><a href="#互斥类型" class="headerlink" title="互斥类型"></a>互斥类型</h2><h3 id="独占式互斥量："><a href="#独占式互斥量：" class="headerlink" title="独占式互斥量："></a>独占式互斥量：</h3><pre><code>Class mutexTypedef try_mutexClass timed_mutex</code></pre><h3 id="递归式互斥量："><a href="#递归式互斥量：" class="headerlink" title="递归式互斥量："></a>递归式互斥量：</h3><pre><code>Class recursive_mutexTypedef recursive_try_mutexClass recursive_timed_mutex</code></pre><p>boost::recursive_mutex提供一个递归式的互斥量。对于一个实例最多允许一个线程拥有其锁定，如果一个线程已经锁定一个boost::recursive_mutex实例，那么这个线程可以多次锁定这个实例。</p><h3 id="共享式互斥量："><a href="#共享式互斥量：" class="headerlink" title="共享式互斥量："></a>共享式互斥量：</h3><pre><code>Class shared_mutex -- C++14Class upgrade_mutex -- EXTENSION</code></pre><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><pre><code>Class null_mutex -- EXTENSION</code></pre><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><pre><code>typedef boost::shared_lock&lt;boost::shared_mutex&gt; readLock;typedef boost::unique_lock&lt;boost::shared_mutex&gt; writeLock;boost::shared_mutex rwmutex;std::vector&lt;int&gt; random_numbers;void readOnly(){    for (int i = 0; i &lt; 3; ++i)    {        wait(1);        readLock rdlock(rwmutex);        std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;    }}void writeOnly(){    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    for (int i = 0; i &lt; 3; ++i)    {        writeLock wtlock(rwmutex);        random_numbers.push_back(std::rand());        wait(1);    }}int sum = 0;void count(){    for (int i = 0; i &lt; 3; ++i)    {        wait(1);        readLock rdlock(rwmutex);        sum += random_numbers.back();    }}TEST(BoostThread, readwrite)//读写锁{    boost::thread t1(writeOnly);    boost::thread t2(readOnly);    boost::thread t3(count);    t1.join();    t2.join();    t3.join();    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;}</code></pre><p>shared_mutex 比一般的 mutex 多了函数 lock_shared() / unlock_shared()，允许多个（读者）线程同时加锁、解锁，而 shared_lock 则相当于共享版的 lock_guard。</p><p>对 shared_mutex 使用 lock_guard 或 unique_lock 就达到了写者独占的目的。</p><h2 id="Condition-Variables条件变量"><a href="#Condition-Variables条件变量" class="headerlink" title="Condition Variables条件变量"></a>Condition Variables条件变量</h2><p>从一个线程中给另一个线程发送通知</p><p>条件变量是thread库提供的另一种用于等待的同步机制，可以实现线程间的通信，它必须和互斥量配合使用，等待另一个线程中某个事件的发送（满足某个条件），然后线程才能继续执行。<br>thread库提供两种条件变量对象： </p><pre><code>condition_variable condition_variable_any （常用，能够适应更广泛的互斥量类型）</code></pre><p>条件变量的使用方法很简单:</p><p>拥有条件变量的线程先锁定互斥量，然后循环检查某个条件，如果条件不满足，那么<br>就调用变量的成员函数wait()等待直至条件满足。其他线程处理条件变更要求的条件，<br>当条件满足时调用它的成员函数notify_one()或notify_all()，以通知一个或者所<br>有正在等待条件变更的线程停止等待继续执行。</p><p>其他用法<br>条件变量的wait()函数有一个有用的重载形式:wiat(lock_type&amp; lock, predicate_type<br>predicate),它比普通的形式多接受一个谓词函数（或函数对象），当谓词predicate不<br>满足时持续等待。</p><p>使用这个重载形式或以写出更简洁清晰的代码，通常需要配合bind来简化谓词函数的<br>编写。<br>例如,buffer类的两个条件变量的等待可以改写成:<br>cond_put.wait(mu, !bind(&amp;buffer::is_full, this));<br>cond_get.wait(mu, !bind(&amp;buffer::is_empty, this));</p><p><a href="https://segmentfault.com/a/1190000006679917" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006679917</a></p><h3 id="条件变量读写"><a href="#条件变量读写" class="headerlink" title="条件变量读写"></a>条件变量读写</h3><pre><code>boost::condition_variable_any cond;boost::mutex rwmutexCV;std::vector&lt;int&gt; random_numbersCV;void print(){    std::size_t next_size = 1;    for (int i = 0; i &lt; 3; ++i)    {        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);        while (random_numbersCV.size() != next_size)            cond.wait(rwmutexCV);        std::cout &lt;&lt; random_numbersCV.back() &lt;&lt; std::endl;        ++next_size;        cond.notify_all();    }}void fill(){    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    for (int i = 0; i &lt; 3; ++i)    {        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);        random_numbersCV.push_back(std::rand());        cond.notify_all();        cond.wait(rwmutexCV);    }}TEST(BoostThread, ConditionVariables)//条件变量{    boost::thread t1(fill);    boost::thread t2(print);    t1.join();    t2.join();}</code></pre><h3 id="生产者-消费者模式的后进先出型-std-stack-缓冲区"><a href="#生产者-消费者模式的后进先出型-std-stack-缓冲区" class="headerlink" title="生产者-消费者模式的后进先出型(std::stack)缓冲区"></a>生产者-消费者模式的后进先出型(std::stack)缓冲区</h3><pre><code>class Buffer{public:    //构造函数    Buffer(size_t n) :un_read(0), capacity(n) {}    //写入数据x    void put(int x) {        //局部域        {            boost::mutex::scoped_lock lock(mu);  //锁定互斥量            while (is_full()) {                cond_put.wait(mu);  //条件变量等待            }            stk.push(x);  //写入数据            ++un_read;        }  //解锁互斥量        cond_get.notify_one();  //通知可以读取数据    }    //读取数据    void get(int *x) {        {            boost::mutex::scoped_lock lock(mu);            while (is_empty()) {                cond_get.wait(mu);            }            *x = stk.top();            stk.pop();            --un_read;        }        cond_put.notify_one();    }private:    //判断缓冲区是否满    bool is_full() {        return un_read == capacity;    }    //判断缓冲区是否为空    bool is_empty() {        return un_read == 0;    }private:    boost::mutex mu;  //互斥量，配合条件变量使用    boost::condition_variable_any cond_put;  //写入条件变量    boost::condition_variable_any cond_get;  //读取条件变量    std::stack&lt;int&gt; stk;  //缓冲区对象    int un_read;    int capacity;};Buffer buf(5);  //定义一个缓冲区对象boost::mutex io_mu_;  //定义一个输出互斥量//生产者,n个void producer(int n){    for (int i = 0; i &lt; n; i++) {        //输出信息        {            boost::mutex::scoped_lock lock(io_mu_);            std::cout &lt;&lt; &quot;put &quot; &lt;&lt; i &lt;&lt; &quot; to buffer&quot; &lt;&lt; std::endl;        }        buf.put(i);  //写入数据    }}//消费者void consumer(int n){    int result(0);    for (int i = 0; i &lt; n; i++) {        {            buf.get(&amp;result);  //读取数据            boost::mutex::scoped_lock lock(io_mu_);            std::cout &lt;&lt; &quot;get &quot; &lt;&lt; result &lt;&lt; &quot; from buffer&quot; &lt;&lt; std::endl;        }    }}TEST(BoostThread, producer_consumer_test){    boost::thread t_producer(producer, 20);    boost::thread t_consumer1(consumer, 10);    boost::thread t_consumer2(consumer, 10);    t_producer.join();    t_consumer1.join();    t_consumer2.join();}</code></pre><p><a href="https://segmentfault.com/a/1190000006703543" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006703543</a></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;boost/utility.hpp&gt;#include &lt;boost/thread/condition_variable.hpp&gt;#include &lt;boost/thread/thread.hpp&gt;class BoundedBuffer : private boost::noncopyable {public:  BoundedBuffer(size_t size)    : begin_(0), end_(0), buffered_(0), circular_buffer_(size) {  }  void Produce(int n) {    boost::unique_lock&lt;boost::mutex&gt; lock(mutex_);    // 等待缓冲不为满。    not_full_cv_.wait(lock, [=] { return buffered_ &lt; circular_buffer_.size(); });    // 插入新的元素，更新下标。    circular_buffer_[end_] = n;    end_ = (end_ + 1) % circular_buffer_.size();    ++buffered_;    // 通知前，手动解锁。    lock.unlock();    // 通知消费者。    not_empty_cv_.notify_one();  }  int Consume() {    boost::unique_lock&lt;boost::mutex&gt; lock(mutex_);    // 等待缓冲不为空。    not_empty_cv_.wait(lock, [=] { return buffered_ &gt; 0; });    // 移除一个元素。    int n = circular_buffer_[begin_];    begin_ = (begin_ + 1) % circular_buffer_.size();    --buffered_;    // 通知前，手动解锁。    lock.unlock();    // 通知生产者。    not_full_cv_.notify_one();    return n;  }private:  size_t begin_;  size_t end_;  size_t buffered_;  std::vector&lt;int&gt; circular_buffer_;  boost::condition_variable not_full_cv_;  boost::condition_variable not_empty_cv_;  boost::mutex mutex_;};BoundedBuffer g_buffer(2);boost::mutex g_io_mutex;void Producer() {  int n = 0;  while (n &lt; 100000) {    g_buffer.Produce(n);    if ((n % 10000) == 0) {      boost::unique_lock&lt;boost::mutex&gt; lock(g_io_mutex);      std::cout &lt;&lt; &quot;Produce: &quot; &lt;&lt; n &lt;&lt; std::endl;    }    ++n;  }  g_buffer.Produce(-1);}void Consumer() {  boost::thread::id thread_id = boost::this_thread::get_id();  int n;  do {    n = g_buffer.Consume();    if ((n % 10000) == 0) {      boost::unique_lock&lt;boost::mutex&gt; lock(g_io_mutex);      std::cout &lt;&lt; &quot;Consume: &quot; &lt;&lt; n &lt;&lt; &quot; (&quot; &lt;&lt; thread_id &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;    }  } while (n != -1);  // -1 表示缓冲已达末尾。  // 往缓冲里再放一个 -1，这样其他消费者才能结束。  g_buffer.Produce(-1);}int main() {  boost::thread_group threads;  threads.create_thread(&amp;Producer);  threads.create_thread(&amp;Consumer);  threads.create_thread(&amp;Consumer);  threads.create_thread(&amp;Consumer);  threads.join_all();  return 0;}</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="https://segmentfault.com/a/1190000006691692" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006691692</a></p><p>也可使用ATL的ThreadPool或<a href="http://threadpool.sourceforge.net/" target="_blank" rel="noopener">http://threadpool.sourceforge.net/</a></p><pre><code>#include &lt;iostream&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/asio.hpp&gt;class ThreadPool {public:  explicit ThreadPool(size_t size) : work_(io_service_) {    for (size_t i = 0; i &lt; size; ++i) {      workers_.create_thread(          boost::bind(&amp;boost::asio::io_service::run, &amp;io_service_));    }  }  ~ThreadPool() {    io_service_.stop();    workers_.join_all();  }  // Add new work item to the pool.  template&lt;class F&gt;  void Enqueue(F f) {    io_service_.post(f);  }private:  boost::thread_group workers_;  boost::asio::io_service io_service_;  boost::asio::io_service::work work_;};</code></pre><p>成员变量 io_service::work 的作用是，让 asio::io_service 即使在没有异步任务可执行时也保持运行（即 io_service::run 不返回）。</p><pre><code>int main() {  // Create a thread pool of 4 worker threads.  ThreadPool pool(4);  // Queue a bunch of work items.  for (int i = 0; i &lt; 8; ++i) {    pool.Enqueue([i] {      std::cout &lt;&lt; &quot;hello &quot; &lt;&lt; i &lt;&lt; std::endl;      boost::this_thread::sleep(boost::posix_time::seconds(1));      std::cout &lt;&lt; &quot;world &quot; &lt;&lt; i &lt;&lt; std::endl;    });  }  return 0;}</code></pre><h2 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h2><p>Boost线程库提供了智能指针boost::thread_specific_ptr来访问本地存储线程。每一个线程第一次使用这个智能指针的实例时，它的初值是NULL，所以必须要先检查这个它的只是否为空，并且为它赋值。Boost线程库保证本地存储线程中保存的数据会在线程结束后被清除。</p><pre><code>void init_number_generator(){    static boost::thread_specific_ptr&lt;bool&gt; tls;    if (!tls.get())        tls.reset(new bool(false));    if (!*tls)    {        *tls = true;        std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    }}boost::mutex mutex;void random_number_generator(){    init_number_generator();    int i = std::rand();    boost::lock_guard&lt;boost::mutex&gt; lock(mutex);    std::cout &lt;&lt; i &lt;&lt; std::endl;}TEST(BoostThread, thread_specific_ptr)//线程局部存储{    boost::thread t[3];    for (int i = 0; i &lt; 3; ++i)        t[i] = boost::thread(random_number_generator);    for (int i = 0; i &lt; 3; ++i)        t[i].join();}</code></pre><h2 id="只初始化一次共享资源"><a href="#只初始化一次共享资源" class="headerlink" title="只初始化一次共享资源"></a>只初始化一次共享资源</h2><h3 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h3><p>准确执行一次可调用 (Callable) 对象 f ，即使同时从多个线程调用。</p><pre><code>#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::once_flag flag1, flag2;void simple_do_once(){    std::call_once(flag1, [](){ std::cout &lt;&lt; &quot;Simple example: called once\n&quot;; });}void may_throw_function(bool do_throw){  if (do_throw) {    std::cout &lt;&lt; &quot;throw: call_once will retry\n&quot;; // 这会出现多于一次    throw std::exception();  }  std::cout &lt;&lt; &quot;Didn&apos;t throw, call_once will not attempt again\n&quot;; // 保证一次}void do_once(bool do_throw){  try {    std::call_once(flag2, may_throw_function, do_throw);  }  catch (...) {  }}int main(){    std::thread st1(simple_do_once);    std::thread st2(simple_do_once);    std::thread st3(simple_do_once);    std::thread st4(simple_do_once);    st1.join();    st2.join();    st3.join();    st4.join();    std::thread t1(do_once, true);    std::thread t2(do_once, true);    std::thread t3(do_once, false);    std::thread t4(do_once, true);    t1.join();    t2.join();    t3.join();    t4.join();}</code></pre><h3 id="boost-call-once"><a href="#boost-call-once" class="headerlink" title="boost::call_once"></a>boost::call_once</h3><pre><code>#include &lt;iostream&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;boost/thread/once.hpp&gt;// Some sort of connection class that should only be initialized oncestruct Conn {   static void init( ) {++i_;}   static boost::once_flag init_;   static int i_;   // ...};int Conn::i_ = 0;boost::once_flag Conn::init_ = BOOST_ONCE_INIT;void worker( ) {   boost::call_once(Conn::init, Conn::init_);   // Do the real work...}Conn c;  // You probably don&apos;t want to use a global, so see the         // next Recipeint main( ) {   boost::thread_group grp;   for (int i = 0; i &lt; 100; ++i)      grp.create_thread(worker);   grp.join_all( );   std::cout &lt;&lt; c.i_ &lt;&lt; &apos;\n&apos;;// c.i_ = 1}</code></pre><p>一个共享资源不得不在某个地方被初始化，并且你希望第一次使用这个资源的线程来完成初始化工作。一个once_flag类型和call_once函数能够保证多个线程不会重复的初始化同一个对象。首先，必须使用BOOST_ONCE_INIT宏来初始化这个once_flag对象。boost::once<em>flag Conn::init</em> = BOOST_ONCE_INIT; 之后调用call_once函数，boost::call<em>once(Conn::init, Conn::init</em>); 第一个形参是希望被执行一次的初始化函数的地址。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>boost::atomic&lt;&gt;</p><h2 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h2><p>很多情况下线程不仅仅要执行一些工作，它还可能要返回一些计算结果。</p><p>thread库使用future范式提供了一种异步操作线程返回值的方法，</p><p>future使用packaged_task和promise两个模板类来包装异步调用，用unique_future<br>和shared_future来获取异步调用结果（即future值)。</p><p>package_task和unique_future</p><p>packaged_task用来存储packaged_task异步计算得到的future值，它只能持有结果的<br>唯一的一个引用。成员函数wait()和timed_wait()的行为类似thread.join()，可以<br>阻塞等待packaged_task的执行，直至获得future值。成员函数is_ready()、has_value()<br>和has_exception()分别用来测试unique_future是否可用。</p><p>下面代码示范了future特性的用法，使用packaged_task和unique_future:</p><pre><code>int fab(int n){    if (n == 0 || n == 1)    {        return 1;    }    return fab(n - 1) + fab(n - 2);}int main(){    // 声明packaged_task对象，用模板参数指明返回值类型    // packaged_task只接受无参函数，因此需要使用bind    packaged_task&lt;int&gt; pt(bind(fab, 10));    // 声明unique_future对象，接受packaged_task的future值    // 同样要用模板参数指明返回值类型    unique_future&lt;int&gt; uf = pt.get_future();    // 启动线程计算，必须使用boost::move()来转移package_task对象    // 因为packaged_task是不可拷贝的    thread(boost::move(pt));    uf.wait(); // unique_future等待计算结果    assert(uf.is_ready() &amp;&amp; uf.has_value());    cout &lt;&lt; uf.get(); // 输出计算结果99}</code></pre><p>使用多个future对象</p><p>为了支持多个future对象的使用,future还提供wait_for_any()和wiat_for_all()两个<br>自由函数，它们可以阻塞等待多个future对象，直到任意一个或者所有future对象都<br>可以(is_ready())。这两个函数有多个重载形式，可以接受一对表示future容器区间<br>的迭代器或者最多5个future对象。</p><p>promise</p><p>promise也用于处理异步调用返回值，但它不同于packaged_task，不能包装一个函数，<br>而是包装一个值，这个值可以作为函数的输出参数，适用于从函数参数返回值的函数。</p><p>promise的用法与packaged_task类似，在线程中用set_value()设置要返回的值，用<br>成员函数get_future()获得future值赋给future对象。</p><pre><code>int calculate_the_answer_to_life_the_universe_and_everything(){    return 42;}void invoke_lazy_task(boost::packaged_task&lt;int&gt;&amp; task){    try    {        task();    }    catch (boost::task_already_started&amp;)    {    }}//shared_future与unique_futureTEST(BoostThread, BoostFuture){    {        boost::packaged_task&lt;int&gt; pt(calculate_the_answer_to_life_the_universe_and_everything);        boost::unique_future&lt;int&gt; fi = pt.get_future();        boost::thread task(boost::move(pt)); // launch task on a thread        fi.wait(); // wait for it to finish        ASSERT_TRUE(fi.is_ready());        ASSERT_TRUE(fi.has_value());        ASSERT_TRUE(!fi.has_exception());        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);        ASSERT_TRUE(fi.get() == 42);    }    {        boost::promise&lt;int&gt; pi;        boost::unique_future&lt;int&gt; fi;        fi = pi.get_future();        pi.set_value(42);        ASSERT_TRUE(fi.is_ready());        ASSERT_TRUE(fi.has_value());        ASSERT_TRUE(!fi.has_exception());        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);        ASSERT_TRUE(fi.get() == 42);    }    {        boost::packaged_task&lt;int&gt; task(calculate_the_answer_to_life_the_universe_and_everything);        task.set_wait_callback(invoke_lazy_task);        boost::unique_future&lt;int&gt; f(task.get_future());        ASSERT_TRUE(f.get() == 42);    }}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/renyuan/p/6613638.html" target="_blank" rel="noopener">https://www.cnblogs.com/renyuan/p/6613638.html</a></li><li><a href="https://blog.csdn.net/lp310018931/article/details/50596469" target="_blank" rel="noopener">https://blog.csdn.net/lp310018931/article/details/50596469</a></li><li><a href="https://www.cnblogs.com/lidabo/p/3785176.html" target="_blank" rel="noopener">https://www.cnblogs.com/lidabo/p/3785176.html</a></li><li><a href="https://blog.csdn.net/yvhqbat/article/details/51922153" target="_blank" rel="noopener">https://blog.csdn.net/yvhqbat/article/details/51922153</a></li><li><a href="https://blog.csdn.net/liujiayu2/article/details/50587064" target="_blank" rel="noopener">https://blog.csdn.net/liujiayu2/article/details/50587064</a></li><li><a href="https://blog.csdn.net/u012592062/article/details/80467118" target="_blank" rel="noopener">https://blog.csdn.net/u012592062/article/details/80467118</a></li><li><a href="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/Table-of-contents.md" target="_blank" rel="noopener">C++ 并发编程指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/doc/html/thread.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.boost.org/doc/libs/1_55_0
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Boost" scheme="https://caojingyou.github.io/tags/Boost/"/>
    
      <category term="多线程" scheme="https://caojingyou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="C++11" scheme="https://caojingyou.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>多媒体开发</title>
    <link href="https://caojingyou.github.io/2018/06/07/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/06/07/多媒体开发/</id>
    <published>2018-06-07T06:00:00.000Z</published>
    <updated>2018-06-21T10:12:00.371Z</updated>
    
    <content type="html"><![CDATA[<p>视频开发：DShow、OpenCV、FFmpeg</p><h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1><h2 id="FFmpeg官网："><a href="#FFmpeg官网：" class="headerlink" title="FFmpeg官网："></a>FFmpeg官网：</h2><p><a href="http://ffmpeg.org/" target="_blank" rel="noopener">http://ffmpeg.org/</a></p><h2 id="下载-Download-FFmpeg-for-Windows"><a href="#下载-Download-FFmpeg-for-Windows" class="headerlink" title="下载 Download FFmpeg for Windows:"></a>下载 Download FFmpeg for Windows:</h2><p><a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds/</a></p><h2 id="雷霄骅-leixiaohua1020-的专栏"><a href="#雷霄骅-leixiaohua1020-的专栏" class="headerlink" title="雷霄骅(leixiaohua1020)的专栏:"></a>雷霄骅(leixiaohua1020)的专栏:</h2><p><a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020</a></p><h2 id="百度网盘资料："><a href="#百度网盘资料：" class="headerlink" title="百度网盘资料："></a>百度网盘资料：</h2><p>链接：<a href="http://pan.baidu.com/s/1o80QYoy" target="_blank" rel="noopener">http://pan.baidu.com/s/1o80QYoy</a> 密码：i5mb</p><h2 id="FFmpeg介绍："><a href="#FFmpeg介绍：" class="headerlink" title="FFmpeg介绍："></a>FFmpeg介绍：</h2><p>FFmpeg是一个集合的库和工具来处理多媒体内容诸如音频、视频、字幕和相关元数据。<br>图书馆查询系统</p><pre><code>libavcodec提供了执行更广泛的范围,用于各种类型声音/图像编解码;libavformat实现流媒体协议容器格式和基本I/O访问,用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；libavutil包括hashers、压缩器和杂项功能效用,包含一些公共的工具函数；libavfilter提供了一种通过改变视频和音频解码的滤波器链。libavdevice提供一个抽象访问捕获和回放设备。libswresample实现音频混合和重采样例程。libswscale执行缩放和色彩转换例程。</code></pre><p>工具：</p><p>FFmpeg是一种命令行工具操纵、转换和流多媒体内容。<br>    ffplay是一个简约的多媒体播放器。<br>    ffprobe是一个简单的分析工具来检查多媒体内容。<br>    ffserver为多媒体流传输服务器用于实况广播,一个 HTTP 多媒体即时广播串流服务器。<br>    附加等小工具aviocat，ismindex and qt-faststart</p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><h2 id="jrtplib"><a href="#jrtplib" class="headerlink" title="jrtplib"></a>jrtplib</h2><p><a href="http://blog.csdn.net/fhxpp_27/article/details/9234069" target="_blank" rel="noopener">jrtplib使用笔记 </a></p><p>RTP 是目前解决流媒体实时传输问题的最好办法，而JRTPLIB 是一个用C++语言实现的RTP库，包括UDP通讯.</p><p>实时传送协议（Real-time Transport Protocol或简写RTP，也可以写成RTTP）是一个网络传输协议，RTP协议详细说明了在互联网上传递音频和视频的标准数据包格式。它一开始被设计为一个多播协议，但后来被用在很多单播应用中。RTP协议常用于流媒体系统（配合RTCP协议或者RTSP协议）。因为RTP自身具有Time stamp所以在ffmpeg 中被用做一种formate。</p><p>RTP协议的详细介绍，请参考这篇文章<a href="http://www.360doc.com/content/11/1009/15/496343_154624612.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/1009/15/496343_154624612.shtml</a></p><p>jrtplib需要使用jthread</p><ul><li><a href="http://research.edm.uhasselt.be/jori/page/Main/HomePage.html" title="JRTPLIB官网" target="_blank" rel="noopener">http://research.edm.uhasselt.be/jori/page/Main/HomePage.html</a></li><li><a href="http://research.edm.uhasselt.be/jori/page/CS/Jrtplib.html" title="Jrtplib" target="_blank" rel="noopener">http://research.edm.uhasselt.be/jori/page/CS/Jrtplib.html</a></li><li><a href="http://jrtplib.readthedocs.io/en/stable/" target="_blank" rel="noopener">JRTPLIB  3.11.1 文档</a></li><li><a href="http://research.edm.uhasselt.be/jori/jrtplib/jrtplib-3.11.1.zip" title="jrtplib-3.11.1.zip" target="_blank" rel="noopener">jrtplib-3.11.1.zip</a></li><li><a href="https://github.com/j0r1/JRTPLIB" title="JRTPLIB github" target="_blank" rel="noopener">https://github.com/j0r1/JRTPLIB</a></li><li><a href="https://blog.csdn.net/jinyuchuan/article/details/5977375" target="_blank" rel="noopener">jrtplib-3.7.1在windows下的编译步骤</a></li></ul><h2 id="jthread"><a href="#jthread" class="headerlink" title="jthread"></a>jthread</h2><p>所述包包含jthread和jmutex，（显然）表示一个线程和一个互斥锁。对于类Unix平台上，实现使用的pthread库。在MS-Windows平台，本机Win32线程使用。</p><ul><li><a href="http://research.edm.uhasselt.be/jori/page/CS/Jthread.html" title="jthread官网" target="_blank" rel="noopener">http://research.edm.uhasselt.be/jori/page/CS/Jthread.html</a></li><li><a href="https://github.com/j0r1/JThread" title="jthread github" target="_blank" rel="noopener">https://github.com/j0r1/JThread</a></li></ul><h2 id="emiplib"><a href="#emiplib" class="headerlink" title="emiplib"></a>emiplib</h2><p>这个库的目的就是要完成一个多媒体的网络传输库，方便多种媒体在网络上进行传输。</p><ul><li><a href="http://research.edm.uhasselt.be/jori/page/CS/Emiplib.html" title="emiplib" target="_blank" rel="noopener">http://research.edm.uhasselt.be/jori/page/CS/Emiplib.html</a></li><li><a href="http://research.edm.uhasselt.be/~emiplib/" title="emiplib主页" target="_blank" rel="noopener">http://research.edm.uhasselt.be/~emiplib/</a></li><li><a href="https://github.com/j0r1/EMIPLIB" title="emiplib github" target="_blank" rel="noopener">https://github.com/j0r1/EMIPLIB</a></li></ul><h2 id="rtmp"><a href="#rtmp" class="headerlink" title="rtmp"></a>rtmp</h2><p>RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括Adobe Media Server/Ultrant Media Server/red5等。</p><h2 id="MainConcept"><a href="#MainConcept" class="headerlink" title="MainConcept"></a>MainConcept</h2><p>对视频进行编解码，安装文件在“第三方安装程序”目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;视频开发：DShow、OpenCV、FFmpeg&lt;/p&gt;
&lt;h1 id=&quot;FFmpeg&quot;&gt;&lt;a href=&quot;#FFmpeg&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg&quot;&gt;&lt;/a&gt;FFmpeg&lt;/h1&gt;&lt;h2 id=&quot;FFmpeg官网：&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="DShow" scheme="https://caojingyou.github.io/tags/DShow/"/>
    
      <category term="OpenCV" scheme="https://caojingyou.github.io/tags/OpenCV/"/>
    
      <category term="FFmpeg" scheme="https://caojingyou.github.io/tags/FFmpeg/"/>
    
      <category term="视频" scheme="https://caojingyou.github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>curl</title>
    <link href="https://caojingyou.github.io/2018/06/01/curl/"/>
    <id>https://caojingyou.github.io/2018/06/01/curl/</id>
    <published>2018-06-01T08:36:00.000Z</published>
    <updated>2018-06-06T05:59:00.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://curl.haxx.se/" title="https://curl.haxx.se/" target="_blank" rel="noopener">curl</a></p><p><a href="https://github.com/curl/curl" target="_blank" rel="noopener">https://github.com/curl/curl</a></p><p><a href="https://curl.haxx.se/libcurl/" target="_blank" rel="noopener">libcurl/</a></p><p><a href="https://curl.haxx.se/download.html" target="_blank" rel="noopener">https://curl.haxx.se/download.html</a></p><p><a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/example.html</a></p><p>libcurl作为是一个多协议的便于客户端使用的URL传输库，基于C语言，提供C语言的API接口，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP这些协议，同时支持使用SSL证书的安全文件传输：HTTP POST, HTTP PUT, FTP 上传, 基于HTTP形式的上传、代理、Cookies、用户加密码的认证等多种应用场景。另外，libcurl是一个高移植性的库，能在绝大多数系统上运行，包括Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS等。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://curl.haxx.se/download/curl-7.60.0.tar.gz" target="_blank" rel="noopener">https://curl.haxx.se/download/curl-7.60.0.tar.gz</a></p><p><a href="https://www.gitbook.com/download/pdf/book/bagder/everything-curl" target="_blank" rel="noopener">https://www.gitbook.com/download/pdf/book/bagder/everything-curl</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>项目支持<code>Visual C++ v6.0 to v15.0</code></p><p>项目sln文件在<code>curl-7.60.0\projects</code>目录</p><p>依赖第三方库：<code>OpenSSL, wolfSSL and SSH2</code> 需要另外下载编译</p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL需要ActivePerl</p><p>build-openssl.bat支持openssl-1.0.2</p><pre><code>build-openssl.bat vc10 x86 release</code></pre><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://i.imgur.com/kkVt7zq.jpg" alt=""></p><h1 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h1><p><a href="https://curl.haxx.se/libcurl/c/" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/</a></p><h2 id="curl-global-init-初始化libcrl"><a href="#curl-global-init-初始化libcrl" class="headerlink" title="curl_global_init 初始化libcrl"></a>curl_global_init 初始化libcrl</h2><pre><code>CURLcode curl_global_init(long flags);</code></pre><p>flags参数取值范围</p><pre><code>CURL_GLOBAL_ALL    初始化所有可能的调用CURL_GLOBAL_SSL    初始化支持安全套接字层的调用CURL_GLOBAL_WIN32    初始化WIN32套接字库CURL_GLOBAL_NOTHING    没有额外的初始化要求</code></pre><p>虽然<code>libcurl</code>是线程安全的，但<code>curl_global_init</code>是不能保证线程安全的，所以不要在每个线程中都调用<code>curl_global_init</code>，应该将该函数的调用放在主线程中。</p><h2 id="curl-easy-init-获取CURL操作符"><a href="#curl-easy-init-获取CURL操作符" class="headerlink" title="curl_easy_init() 获取CURL操作符"></a>curl_easy_init() 获取CURL操作符</h2><pre><code>CURL *curl_easy_init( );</code></pre><p>初始化一个<code>CURL</code>的指针(有些像返回<code>FILE</code>类型的指针一样). 相应的在调用结束时要用<code>curl_easy_cleanup</code>函数清理.</p><h2 id="curl-easy-setopt-设置传输选项"><a href="#curl-easy-setopt-设置传输选项" class="headerlink" title="curl_easy_setopt() 设置传输选项"></a>curl_easy_setopt() 设置传输选项</h2><pre><code>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</code></pre><p>可指定<code>libcurl</code>的工作方式或程序运行中改变其工作方式，实现回调函数以完成用户特定任务。</p><h3 id="参数CURLoption"><a href="#参数CURLoption" class="headerlink" title="参数CURLoption"></a>参数CURLoption</h3><h4 id="CURLOPT-URL"><a href="#CURLOPT-URL" class="headerlink" title="CURLOPT_URL"></a>CURLOPT_URL</h4><p>设置访问URL</p><h4 id="CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h4><p>回调函数原型为：<code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code> 函数将在<code>libcurl</code>接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。<code>CURLOPT_WRITEDATA</code> 用于表明<code>CURLOPT_WRITEFUNCTION</code>函数中的<code>stream</code>指针的来源。</p><p>如果你没有通过<code>CURLOPT_WRITEFUNCTION</code>属性给<code>easy handle设</code>置回调函数，<code>libcurl</code>会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 <code>CURLOPT_WRITEDATA</code>属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p><h4 id="CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h4><p>回调函数原型为 <code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code> <code>libcurl</code>一旦接收到http 头部数据后将调用该函数。<code>CURLOPT_WRITEDATA</code> 传递指针给<code>libcurl</code>，该指针表明<code>CURLOPT_HEADERFUNCTION</code> 函数的<code>stream</code>指针的来源。</p><h4 id="CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="CURLOPT_READFUNCTION CURLOPT_READDATA"></a>CURLOPT_READFUNCTION CURLOPT_READDATA</h4><p><code>libCurl</code>需要读取数据传递给远程主机时将调用<code>CURLOPT_READFUNCTION</code>指定的函数，函数原型是：<code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)</code>. <code>CURLOPT_READDATA</code> 表明<code>CURLOPT_READFUNCTION</code>函数原型中的<code>stream</code>指针来源。</p><h4 id="CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h4><p>跟数据传输进度相关的参数。<code>CURLOPT_PROGRESSFUNCTION</code> 指定的函数正常情况下每秒被<code>libcurl</code>调用一次，为了使<code>CURLOPT_PROGRESSFUNCTION</code>被调用，<code>CURLOPT_NOPROGRESS</code>必须被设置为false，<code>CURLOPT_PROGRESSDATA</code>指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p><h4 id="CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h4><p><code>CURLOPT_TIMEOUT</code> 由于设置传输时间，<code>CURLOPT_CONNECTIONTIMEOUT</code> 设置连接等待时间</p><h4 id="CURLOPT-FOLLOWLOCATION"><a href="#CURLOPT-FOLLOWLOCATION" class="headerlink" title="CURLOPT_FOLLOWLOCATION"></a>CURLOPT_FOLLOWLOCATION</h4><p>设置重定位URL</p><h4 id="CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="CURLOPT_RANGE: CURLOPT_RESUME_FROM"></a>CURLOPT_RANGE: CURLOPT_RESUME_FROM</h4><p>断点续传相关设置。<code>CURLOPT_RANGE</code> 指定char *参数传递给libcurl，用于指明http域的RANGE头域，例如：</p><pre><code>表示头500个字节：bytes=0-499表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999</code></pre><p><code>CURLOPT_RESUME_FROM</code> 传递一个long参数给libcurl，指定你希望开始传递的 偏移量。</p><h3 id="参数parameter"><a href="#参数parameter" class="headerlink" title="参数parameter"></a>参数parameter</h3><p><code>parameter</code> 这个参数 既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数.</p><h2 id="curl-easy-perform-实现传输任务"><a href="#curl-easy-perform-实现传输任务" class="headerlink" title="curl_easy_perform() 实现传输任务"></a>curl_easy_perform() 实现传输任务</h2><pre><code>CURLcode curl_easy_perform(CURL * easy_handle );</code></pre><p>返回0意味一切ok，非0代表错误发生。主要错误码说明：</p><pre><code>CURLE_OK    任务完成一切都好CURLE_UNSUPPORTED_PROTOCOL    不支持的协议，由URL的头部指定CURLE_COULDNT_CONNECT    不能连接到remote 主机或者代理CURLE_REMOTE_ACCESS_DENIED    访问被拒绝CURLE_HTTP_RETURNED_ERROR    Http返回错误CURLE_READ_ERROR    读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过<code>const char *curl_easy_strerror(CURLcode errornum )</code> 这个函数取得.</p><p><a href="https://curl.haxx.se/libcurl/c/libcurl-errors.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/libcurl-errors.html</a></p><h2 id="curl-easy-cleanup-释放内存"><a href="#curl-easy-cleanup-释放内存" class="headerlink" title="curl_easy_cleanup() 释放内存"></a>curl_easy_cleanup() 释放内存</h2><pre><code>curl_easy_cleanup() </code></pre><h2 id="char-curl-version"><a href="#char-curl-version" class="headerlink" title="char *curl_version( )"></a>char *curl_version( )</h2><pre><code>char *curl_version( );</code></pre><p>打印当前libcurl库的版本。</p><h2 id="curl-slist-append与curl-slist-free-all"><a href="#curl-slist-append与curl-slist-free-all" class="headerlink" title="curl_slist_append与curl_slist_free_all"></a>curl_slist_append与curl_slist_free_all</h2><p>设置消息头</p><pre><code>CURL *handle;struct curl_slist *slist=NULL;slist = curl_slist_append(slist, &quot;pragma:&quot;);if (slist == NULL)  return -1;curl_easy_setopt(handle, CURLOPT_HTTPHEADER, slist);curl_easy_perform(handle);curl_slist_free_all(slist); /* free the list again */</code></pre><h2 id="curl-easy-getinfo"><a href="#curl-easy-getinfo" class="headerlink" title="curl_easy_getinfo"></a>curl_easy_getinfo</h2><p>获取的是应答头中特定的信息，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p><pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><h1 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h1><p>获取的网页内容如果是UTF_8编码，需要转换为GBK编码</p><pre><code>std::string UTF8ToGBK(const std::string&amp; strUTF8)    {        int len = MultiByteToWideChar(CP_UTF8, 0, strUTF8.c_str(), -1, NULL, 0);        WCHAR* wszGBK = new WCHAR[len+1];      memset(wszGBK, 0, len * 2 + 2);        MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)(LPCTSTR)strUTF8.c_str(), -1, wszGBK, len);        len = WideCharToMultiByte(CP_ACP, 0, wszGBK, -1, NULL, 0, NULL, NULL);        char *szGBK = new char[len + 1];        memset(szGBK, 0, len + 1);        WideCharToMultiByte(CP_ACP,0, wszGBK, -1, szGBK, len, NULL, NULL);         std::string strTemp(szGBK);        delete[]szGBK;        delete[]wszGBK;        return strTemp;    } std::string GBKToUTF8(const std::string&amp; strGBK)  {      std::string strOutUTF8 = &quot;&quot;;      WCHAR * str1;      int n = MultiByteToWideChar(CP_ACP, 0, strGBK.c_str(), -1, NULL, 0);      str1 = new WCHAR[n];      MultiByteToWideChar(CP_ACP, 0, strGBK.c_str(), -1, str1, n);      n = WideCharToMultiByte(CP_UTF8, 0, str1, -1, NULL, 0, NULL, NULL);      char * str2 = new char[n];      WideCharToMultiByte(CP_UTF8, 0, str1, -1, str2, n, NULL, NULL);      strOutUTF8 = str2;      delete[]str1;      str1 = NULL;      delete[]str2;      str2 = NULL;      return strOutUTF8;  }</code></pre><h1 id="使用LibIconv"><a href="#使用LibIconv" class="headerlink" title="使用LibIconv"></a>使用LibIconv</h1><h2 id="所需文件"><a href="#所需文件" class="headerlink" title="所需文件"></a>所需文件</h2><pre><code>iconv.exelibcharset1.dlllibiconv2.dlllibintl3.dll</code></pre><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><pre><code>curl https://www.baidu.com | iconv.exe -f utf-8 -t gbk</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>int covert(char *desc, char *src, char *input, size_t ilen, char *output, size_t olen){    char **pin = &amp;input;    char **pout = &amp;output;    iconv_t cd = iconv_open(desc, src);    if (cd == (iconv_t)-1)    {        return -1;    }    memset(output, 0, olen);    if (iconv(cd, (const char **)pin, &amp;ilen, pout, &amp;olen)) return -1;    iconv_close(cd);    return 0;}char *input = &quot;中国&quot;;size_t len = strlen(input);char *output = (char *)malloc(OUTLEN);covert(&quot;UTF-8&quot;, &quot;GBK&quot;, input, len, output, OUTLEN);printf(&quot;%s\n&quot;, output);</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u010487568/article/details/52958367" target="_blank" rel="noopener">libcurl库（C++）快速使用</a></p><p><a href="https://www.cnblogs.com/moodlxs/archive/2012/10/15/2724318.html" target="_blank" rel="noopener">C++ 用libcurl库进行http通讯网络编程</a></p><p><a href="https://blog.csdn.net/tianzhaixing2013/article/details/74726040" target="_blank" rel="noopener">https://blog.csdn.net/tianzhaixing2013/article/details/74726040</a></p><p><a href="http://my.huhoo.net/archives/2008/02/libiconv.html" target="_blank" rel="noopener">http://my.huhoo.net/archives/2008/02/libiconv.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/&quot; title=&quot;https://curl.haxx.se/&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="curl" scheme="https://caojingyou.github.io/tags/curl/"/>
    
      <category term="libcurl" scheme="https://caojingyou.github.io/tags/libcurl/"/>
    
      <category term="LibIconv" scheme="https://caojingyou.github.io/tags/LibIconv/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程、同步、并发</title>
    <link href="https://caojingyou.github.io/2018/05/30/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%B9%B6%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/05/30/进程、线程、同步、并发/</id>
    <published>2018-05-30T08:02:00.000Z</published>
    <updated>2018-08-10T02:37:48.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Boost-Thread"><a href="#Boost-Thread" class="headerlink" title="Boost.Thread"></a>Boost.Thread</h1><h2 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h2><p>Thread</p><p>thread_group</p><h2 id="线程局部存储："><a href="#线程局部存储：" class="headerlink" title="线程局部存储："></a>线程局部存储：</h2><pre><code>thread_specific_ptr</code></pre><h2 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h2><pre><code>lock_guardunique_lockscoped_lockshared_lock</code></pre><p>如果只是为了保证数据同步，那么<code>lock_guard</code>完全够用；<br>如果除了同步，还需要使用condition进行阻塞时，那么就需要用<code>unique_lock</code>。<br>boost还要一个<code>boost::mutex::scoped_lock</code>，这个是<code>boost::unique_lock&lt;boost::mutex&gt;</code>的typedef，在C++11中已经禁用。</p><p>独占锁：</p><p><code>boost::unique_lock&lt;T&gt;</code>，其中T可以mutex中的任意一种。</p><p>  如果T为mutex，那么<code>boost::unique_lock&lt;boost::mutex&gt;</code>，构造与析构时则分别自动调用lock和unlock方法。</p><p>  如果T为shared_mutex，那么<code>boost::unique_lock&lt;boost::shared_mutex&gt;</code>，构造与析构时则分别调用<code>shared_mutex</code>的<code>shared_lock</code>和<code>shared_unlock</code>方法。</p><p>注意：<code>scoped_lock</code>也是独占锁，其源代码中定义如下；</p><pre><code>typedef unique_lock&lt;mutex&gt; scoped_lock;typedef unique_lock&lt;timed_mutex&gt; scoped_timed_lock;</code></pre><p>共享锁：</p><p><code>boost::shared_lock&lt;T&gt;</code>，其中的T只能是<code>shared_mutex</code>类。<br>当然还有其他一些锁：<code>lock_guard</code>, <code>upgrade_lock</code>等。</p><p><a href="https://blog.csdn.net/huang_xw/article/details/8457599" target="_blank" rel="noopener">boost库中thread多线程详解</a></p><h2 id="互斥："><a href="#互斥：" class="headerlink" title="互斥："></a>互斥：</h2><p>独占式互斥量</p><pre><code>mutextry_mutextimed_mutex</code></pre><p>递归式互斥量</p><pre><code>recursive_mutexrecursive_try_mutexrecursive_timed_mutex</code></pre><p>共享式互斥量</p><pre><code>shared_mutex</code></pre><h2 id="条件变量："><a href="#条件变量：" class="headerlink" title="条件变量："></a>条件变量：</h2><pre><code>condition_variablecondition_variable_any</code></pre><h2 id="原子变量："><a href="#原子变量：" class="headerlink" title="原子变量："></a>原子变量：</h2><h2 id="future："><a href="#future：" class="headerlink" title="future："></a>future：</h2><pre><code>packaged_taskunique_futurePromise</code></pre><p>Promise对象可保存T类型的值，该值可被future对象读取(可能在另一个线程中)，这是promise提供的同步的一种手段。</p><p>在构造promise时，promise对象可以与共享状态关联起来，这个共享状态可以存储一个T类型或者一个由std::exception派生出的类的值，并可以通过get_future来获取与promise对象关联的对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。</p><p>Promise对象是异步provider，它可以在某一时刻设置共享状态的值。</p><p>Future对象可以返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标识变为ready，然后才能获取共享状态的值。</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>//保证在多线程中只允许一次</p><pre><code>once_flagcall_once</code></pre><p>示例：</p><pre><code>#include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;complex.h&gt;#include &lt;stack&gt;#include &lt;mutex&gt;#include &lt;boost/thread/once.hpp&gt;#include &lt;boost/thread/future.hpp&gt;#include &lt;boost/asio.hpp&gt;void my_func(){    std::cout &lt;&lt; &quot;detach-分离 或 join-等待 线程&quot; &lt;&lt; std::endl;}TEST(BoostThread, detachOrjoin)//简单线程,线程状态joinable、detached{    boost::thread t(my_func);    boost::thread::yield();//当前线程放弃余下的时间片。    std::cout &lt;&lt; t.joinable() &lt;&lt; std::endl;    t.join();    boost::thread t1(my_func);    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;    t1.detach();    std::cout &lt;&lt; t1.joinable() &lt;&lt; std::endl;}//线程的创建需要传递给thread对象一个可调用物（函数或函数对象），它必须具//有operator()以供线程执行。boost::mutex io_mutex;struct count {    count(int id) : id(id) { }    void operator()()    {        for (int i = 0; i &lt; 10; ++i)        {            boost::mutex::scoped_lock                lock(io_mutex);            std::cout &lt;&lt; id &lt;&lt; &quot;: &quot;                &lt;&lt; i &lt;&lt; std::endl;        }    }    int id;};TEST(BoostThread, Typeobject)//复杂类型对象作为参数来创建线程{    boost::thread thrd1(count(1));    boost::thread thrd2(count(2));    thrd1.join();    thrd2.join();}class HelloWorldStatic{public:    static void hello()    {        std::cout &lt;&lt;            &quot;Hello world, I&apos;&apos;m a thread!&quot;            &lt;&lt; std::endl;    }    static void start()    {        boost::thread thrd(hello);        thrd.join();    }};TEST(BoostThread, InClassStatic)//类内部创建线程{    HelloWorldStatic::start();//在这里start()和hello()方法都必须是static方法。}class HelloWorld{public:    void hello()    {        std::cout &lt;&lt;            &quot;Hello world, I&apos;&apos;m a thread!&quot;            &lt;&lt; std::endl;    }    void start()    {        boost::function0&lt; void&gt; f = boost::bind(&amp;HelloWorld::hello, this);        boost::thread thrd(f);        thrd.join();    }};TEST(BoostThread, InClass)//start()和hello()方法不是静态方法则采用此方法创建线程{    HelloWorld hello;    hello.start();}class HelloWorldOut{public:    void hello(const std::string&amp; str)    {        std::cout &lt;&lt; str;    }};TEST(BoostThread, OutClass){    HelloWorldOut obj;    boost::thread thrd(boost::bind(&amp;HelloWorldOut::hello, &amp;obj, &quot;Hello world, I&apos;&apos;m a thread!&quot; ) ) ;    thrd.join();}void func1(const int &amp;id){    std::cout &lt;&lt; &quot;func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;}struct MyThread{    void operator()(const int &amp;id)    {        std::cout &lt;&lt; &quot;MyThread id : &quot; &lt;&lt; id &lt;&lt; std::endl;    }    void func1(const int &amp;id)    {        std::cout &lt;&lt; &quot;MyThread::func1 id : &quot; &lt;&lt; id &lt;&lt; std::endl;    }};TEST(BoostThread, Threadparameters){    //普通函数      boost::thread t1(func1, 11);    t1.join();    //函数对象      MyThread myThread;    boost::thread t2(myThread, 22);    t2.join();    //成员函数      boost::thread t3(&amp;MyThread::func1, myThread, 33);    t3.join();    //临时对象      boost::thread t4(MyThread(), 44);    t4.join();    //对象引用      boost::thread t5(boost::ref(myThread), 55);    t5.join();}void wait(int seconds){    boost::this_thread::sleep(boost::posix_time::seconds(seconds));}void threadinterrupt(){    try    {        for (int i = 0; i &lt; 4; ++i)        {            wait(1);            std::cout &lt;&lt; i&lt;&lt;&quot; 是否允许中断:&quot;&lt;&lt; boost::this_thread::interruption_enabled()&lt;&lt;&quot; 是否被要求中断:&quot;&lt;&lt; boost::this_thread::interruption_requested() &lt;&lt; std::endl;        }    }    catch (boost::thread_interrupted&amp;)    {        std::cout &lt;&lt; &quot;已经中断&quot; &lt;&lt; std::endl;    }}#define testinterruption() { std::cout &lt;&lt; &quot;\r\n是否允许中断:&quot; &lt;&lt; boost::this_thread::interruption_enabled() &lt;&lt; &quot; 是否被要求中断:&quot; &lt;&lt; boost::this_thread::interruption_requested()&lt;&lt; __FUNCTION__&lt;&lt; __LINE__ &lt;&lt; std::endl;}void f(){    testinterruption();    // interruption enabled here    {        boost::this_thread::disable_interruption di;        boost::this_thread::interruption_point();        testinterruption();        // interruption disabled        {            testinterruption();            boost::this_thread::disable_interruption di2;            testinterruption();            // interruption still disabled        } // di2 destroyed, interruption state restored          // interruption still disabled        boost::this_thread::interruption_point();        testinterruption();    } // di destroyed, interruption state restored      // interruption now enabled    testinterruption();    boost::this_thread::interruption_point();    testinterruption();}void g(){    testinterruption();    // interruption enabled here    {        testinterruption();        boost::this_thread::disable_interruption di;        boost::this_thread::interruption_point();        testinterruption();        // interruption disabled        {            testinterruption();            boost::this_thread::restore_interruption ri(di);            testinterruption();            // interruption now enabled        } // ri destroyed, interruption disable again        testinterruption();        boost::this_thread::interruption_point();    } // di destroyed, interruption state restored      // interruption now enabled    testinterruption();    boost::this_thread::interruption_point();    testinterruption();}//预定于中断点：//boost::thread::join()//boost::thread::timed_join()//boost::thread::try_join_for(),//boost::thread::try_join_until(),//boost::condition_variable::wait()//boost::condition_variable::timed_wait()//boost::condition_variable::wait_for()//boost::condition_variable::wait_until()//boost::condition_variable_any::wait()//boost::condition_variable_any::timed_wait()//boost::condition_variable_any::wait_for()//boost::condition_variable_any::wait_until()//boost::thread::sleep()//boost::this_thread::sleep_for()//boost::this_thread::sleep_until()//boost::this_thread::interruption_point()TEST(BoostThread, interrupt)//中断{    std::cout &lt;&lt; &quot;中断&quot; &lt;&lt; std::endl;    boost::thread t(threadinterrupt);    wait(3);    t.interrupt();    t.join();    boost::thread tf(f);    tf.interrupt();    tf.join();    boost::thread tg(g);    tg.interrupt();    tg.join();}TEST(BoostThread, threadid_count){    std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;    std::cout &lt;&lt; boost::thread::hardware_concurrency() &lt;&lt; std::endl;}void thread_group_Fun(){    std::cout &lt;&lt;&quot;当前线程ID:&quot;&lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;}TEST(BoostThread, thread_group){    boost::thread_group grp;    boost::thread *p = new boost::thread(thread_group_Fun);    grp.add_thread(p);    std::cout &lt;&lt; &quot;remove_thread:&quot; &lt;&lt; p-&gt;get_id()&lt;&lt; std::endl;    grp.remove_thread(p);    grp.create_thread(thread_group_Fun);    grp.create_thread(thread_group_Fun);       grp.join_all();                 }class BankAccount {    boost::mutex mtx_; // explicit mutex declaration     int balance_;public:    void Deposit(int amount) {        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);        balance_ += amount;    }    void Withdraw(int amount) {        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);        balance_ -= amount;    }    int GetBalance() {        boost::lock_guard&lt;boost::mutex&gt; guard(mtx_);        return balance_;    }};BankAccount JoesAccount;void bankAgent(){    for (int i = 10; i &gt; 0; --i) {        JoesAccount.Deposit(500);        std::cout &lt;&lt; &quot;bankAgent:&quot; &lt;&lt; JoesAccount.GetBalance() &lt;&lt; std::endl;    }}void Joe() {    for (int i = 10; i &gt; 0; --i) {        JoesAccount.Withdraw(100);        std::cout &lt;&lt;&quot;Joe:&quot;&lt;&lt; JoesAccount.GetBalance() &lt;&lt; std::endl;    }}TEST(BoostThread, mutex)//互斥{    boost::thread thread1(bankAgent); // start concurrent execution of bankAgent    boost::thread thread2(Joe); // start concurrent execution of Joe    thread1.join();    thread2.join();}typedef boost::shared_lock&lt;boost::shared_mutex&gt; readLock;typedef boost::unique_lock&lt;boost::shared_mutex&gt; writeLock;boost::shared_mutex rwmutex;std::vector&lt;int&gt; random_numbers;void readOnly(){    for (int i = 0; i &lt; 3; ++i)    {        wait(1);        readLock rdlock(rwmutex);        std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;    }}void writeOnly(){    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    for (int i = 0; i &lt; 3; ++i)    {        writeLock wtlock(rwmutex);        random_numbers.push_back(std::rand());        wait(1);    }}int sum = 0;void count(){    for (int i = 0; i &lt; 3; ++i)    {        wait(1);        readLock rdlock(rwmutex);        sum += random_numbers.back();    }}TEST(BoostThread, readwrite)//读写锁{    boost::thread t1(writeOnly);    boost::thread t2(readOnly);    boost::thread t3(count);    t1.join();    t2.join();    t3.join();    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;}boost::condition_variable_any cond;boost::mutex rwmutexCV;std::vector&lt;int&gt; random_numbersCV;void print(){    std::size_t next_size = 1;    for (int i = 0; i &lt; 3; ++i)    {        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);        while (random_numbersCV.size() != next_size)            cond.wait(rwmutexCV);        std::cout &lt;&lt; random_numbersCV.back() &lt;&lt; std::endl;        ++next_size;        cond.notify_all();    }}void fill(){    std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    for (int i = 0; i &lt; 3; ++i)    {        boost::unique_lock&lt;boost::mutex&gt; lock(rwmutexCV);        random_numbersCV.push_back(std::rand());        cond.notify_all();        cond.wait(rwmutexCV);    }}TEST(BoostThread, ConditionVariables)//条件变量{    boost::thread t1(fill);    boost::thread t2(print);    t1.join();    t2.join();}//生产者-消费者模式的后进先出型(std::stack)缓冲区class Buffer{public:    //构造函数    Buffer(size_t n) :un_read(0), capacity(n) {}    //写入数据x    void put(int x) {        //局部域        {            boost::mutex::scoped_lock lock(mu);  //锁定互斥量            while (is_full()) {                cond_put.wait(mu);  //条件变量等待            }            stk.push(x);  //写入数据            ++un_read;        }  //解锁互斥量        cond_get.notify_one();  //通知可以读取数据    }    //读取数据    void get(int *x) {        {            boost::mutex::scoped_lock lock(mu);            while (is_empty()) {                cond_get.wait(mu);            }            *x = stk.top();            stk.pop();            --un_read;        }        cond_put.notify_one();    }private:    //判断缓冲区是否满    bool is_full() {        return un_read == capacity;    }    //判断缓冲区是否为空    bool is_empty() {        return un_read == 0;    }private:    boost::mutex mu;  //互斥量，配合条件变量使用    boost::condition_variable_any cond_put;  //写入条件变量    boost::condition_variable_any cond_get;  //读取条件变量    std::stack&lt;int&gt; stk;  //缓冲区对象    int un_read;    int capacity;};Buffer buf(5);  //定义一个缓冲区对象boost::mutex io_mu_;  //定义一个输出互斥量//生产者,n个void producer(int n){    for (int i = 0; i &lt; n; i++) {        //输出信息        {            boost::mutex::scoped_lock lock(io_mu_);            std::cout &lt;&lt; &quot;put &quot; &lt;&lt; i &lt;&lt; &quot; to buffer&quot; &lt;&lt; std::endl;        }        buf.put(i);  //写入数据    }}//消费者void consumer(int n){    int result(0);    for (int i = 0; i &lt; n; i++) {        {            buf.get(&amp;result);  //读取数据            boost::mutex::scoped_lock lock(io_mu_);            std::cout &lt;&lt; &quot;get &quot; &lt;&lt; result &lt;&lt; &quot; from buffer&quot; &lt;&lt; std::endl;        }    }}TEST(BoostThread, producer_consumer_test){    boost::thread t_producer(producer, 20);    boost::thread t_consumer1(consumer, 10);    boost::thread t_consumer2(consumer, 10);    t_producer.join();    t_consumer1.join();    t_consumer2.join();}class ThreadPool {public:    explicit ThreadPool(size_t size) : work_(io_service_) {        for (size_t i = 0; i &lt; size; ++i) {            workers_.create_thread(                boost::bind(&amp;boost::asio::io_service::run, &amp;io_service_));        }    }    ~ThreadPool() {        io_service_.stop();        workers_.join_all();    }    // Add new work item to the pool.    template&lt;class F&gt;    void Enqueue(F f) {        io_service_.post(f);    }private:    boost::thread_group workers_;    boost::asio::io_service io_service_;    boost::asio::io_service::work work_;};TEST(BoostThread, ThreadPool){    // Create a thread pool of 4 worker threads.    ThreadPool pool(4);    // Queue a bunch of work items.    for (int i = 0; i &lt; 8; ++i) {        pool.Enqueue([i] {            std::cout &lt;&lt; &quot;hello &quot; &lt;&lt; i &lt;&lt; std::endl;            boost::this_thread::sleep(boost::posix_time::seconds(1));            std::cout &lt;&lt; &quot;world &quot; &lt;&lt; i &lt;&lt; std::endl;        });    }}void init_number_generator(){    static boost::thread_specific_ptr&lt;bool&gt; tls;    if (!tls.get())        tls.reset(new bool(false));    if (!*tls)    {        *tls = true;        std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));    }}boost::mutex mutex;void random_number_generator(){    init_number_generator();    int i = std::rand();    boost::lock_guard&lt;boost::mutex&gt; lock(mutex);    std::cout &lt;&lt; i &lt;&lt; std::endl;}TEST(BoostThread, thread_specific_ptr)//线程局部存储{    boost::thread t[3];    for (int i = 0; i &lt; 3; ++i)        t[i] = boost::thread(random_number_generator);    for (int i = 0; i &lt; 3; ++i)        t[i].join();}std::once_flag flag1, flag2;void simple_do_once(){    std::call_once(flag1, []() { std::cout &lt;&lt; &quot;Simple example: called once\n&quot;; });}void may_throw_function(bool do_throw){    if (do_throw) {        std::cout &lt;&lt; &quot;throw: call_once will retry\n&quot;; // 这会出现多于一次        throw std::exception();    }    std::cout &lt;&lt; &quot;Didn&apos;t throw, call_once will not attempt again\n&quot;; // 保证一次}void do_once(bool do_throw){    try {        std::call_once(flag2, may_throw_function, do_throw);    }    catch (...) {    }}TEST(StdThread, std_call_once){    std::thread st1(simple_do_once);    std::thread st2(simple_do_once);    std::thread st3(simple_do_once);    std::thread st4(simple_do_once);    st1.join();    st2.join();    st3.join();    st4.join();    std::thread t1(do_once, true);    std::thread t2(do_once, true);    std::thread t3(do_once, false);    std::thread t4(do_once, true);    t1.join();    t2.join();    t3.join();    t4.join();}// Some sort of connection class that should only be initialized oncestruct Conn {    static void init() { ++i_; }    static boost::once_flag init_;    static int i_;    // ...};int Conn::i_ = 0;boost::once_flag Conn::init_ = BOOST_ONCE_INIT;void worker() {    boost::call_once(Conn::init, Conn::init_);    // Do the real work...}Conn c;  // You probably don&apos;t want to use a global, so see the         // next RecipeTEST(BoostThread, Boost_call_once){    boost::thread_group grp;    for (int i = 0; i &lt; 100; ++i)        grp.create_thread(worker);    grp.join_all();    std::cout &lt;&lt; c.i_ &lt;&lt; &apos;\n&apos;;// c.i_ = 1}int fab(int n){    if (n == 0 || n == 1)    {        return 1;    }    return fab(n - 1) + fab(n - 2);}TEST(BoostThread, futuretest){    // 声明packaged_task对象，用模板参数指明返回值类型    // packaged_task只接受无参函数，因此需要使用bind    boost::packaged_task&lt;int&gt; pt(boost::bind(fab, 10));    // 声明unique_future对象，接受packaged_task的future值    // 同样要用模板参数指明返回值类型    boost::unique_future&lt;int&gt; uf = pt.get_future();    // 启动线程计算，必须使用boost::move()来转移package_task对象    // 因为packaged_task是不可拷贝的    boost::thread(boost::move(pt));    uf.wait(); // unique_future等待计算结果    assert(uf.is_ready() &amp;&amp; uf.has_value());    std::cout &lt;&lt; uf.get()&lt;&lt;std::endl; // 输出计算结果99}int calculate_the_answer_to_life_the_universe_and_everything(){    return 42;}void invoke_lazy_task(boost::packaged_task&lt;int&gt;&amp; task){    try    {        task();    }    catch (boost::task_already_started&amp;)    {    }}//shared_future与unique_futureTEST(BoostThread, BoostFuture){    {        boost::packaged_task&lt;int&gt; pt(calculate_the_answer_to_life_the_universe_and_everything);        boost::unique_future&lt;int&gt; fi = pt.get_future();        boost::thread task(boost::move(pt)); // launch task on a thread        fi.wait(); // wait for it to finish        ASSERT_TRUE(fi.is_ready());        ASSERT_TRUE(fi.has_value());        ASSERT_TRUE(!fi.has_exception());        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);        ASSERT_TRUE(fi.get() == 42);    }    {        boost::promise&lt;int&gt; pi;        boost::unique_future&lt;int&gt; fi;        fi = pi.get_future();        pi.set_value(42);        ASSERT_TRUE(fi.is_ready());        ASSERT_TRUE(fi.has_value());        ASSERT_TRUE(!fi.has_exception());        ASSERT_TRUE(fi.get_state() == boost::future_state::ready);        ASSERT_TRUE(fi.get() == 42);    }    {        boost::packaged_task&lt;int&gt; task(calculate_the_answer_to_life_the_universe_and_everything);        task.set_wait_callback(invoke_lazy_task);        boost::unique_future&lt;int&gt; f(task.get_future());        ASSERT_TRUE(f.get() == 42);    }}</code></pre><h1 id="Win32-API"><a href="#Win32-API" class="headerlink" title="Win32 API"></a>Win32 API</h1><p><a href="http://blog.jobbole.com/109200/" target="_blank" rel="noopener">C++ 线程同步的四种方式</a></p><p>内核对象的线程同步则主要由<code>事件</code>、<code>等待定时器</code>、<code>信号量</code>以及<code>信号灯</code>等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。</p><p>在WIN32中，同步机制主要有以下几种：</p><p>（1）事件(Event);<br>（2）信号量(semaphore);<br>（3）互斥量(mutex);<br>（4）临界区(Critical section)。</p><p>下面简单对比一下Windows中的Mutex、Semaphore、Event和Critical Section。</p><p>Mutext，也叫做Mutant。只允许一个线程进入，这个进入的线程被认为是Mutex的所有者。所有者可以重入。Mutex的所有者需要在操作完成后释放这个Mutex，如果没有释放就结束了，操作系统会释放这个Mutex，但是会设置成Abandoned Mutex。</p><p>Semaphore。维护了一个计数器，每当一个线程获取这个Semaphore，就会减一。当线程释放这个Semaphore，就会加一。Semaphore不维护所有者信息。</p><p>Event。维护一个布尔标志。分为自动和手动两种。</p><p>Critical Section。和Mutex类似，但是是用户态的对象，前面3个都是内核态的。只能用在进程内。线程退出前必须释放（LeaveCriticalSection），否则其他等待这个Critical Section的线程会永远等待下去。</p><p>windows其实也有<a href="https://blog.csdn.net/u010261063/article/details/80293266" target="_blank" rel="noopener">条件变量</a>和读写锁。</p><p><a href="https://www.cnblogs.com/tocy/archive/2012/06/03/2532559.html" target="_blank" rel="noopener">线程通信机制之条件变量</a></p><ul><li>可等待定时器</li><li>原子锁</li></ul><p>根据用户模式及内核模式下的同步方式的不同，分类及对比如下：</p><p><img src="https://i.imgur.com/J3dEHpV.jpg" alt=""></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>如果自旋锁已经被锁住，这时有程序申请“获取”这个自旋锁时，程序则处于“自旋”状态。所谓自旋状态，就是不停的询问是否可以“获取”自旋锁。</p><p>自旋锁不同于其他的等待事件。在线程中如果等待某个事件（Event），操作系统会让这个线程进入睡眠状态，CPU会转而运行其他线程。而自旋锁则不同，它不会切换到别的线程，而是一直让这个线程“自旋”。因此，对自旋锁占用时间不宜过长，否则会导致申请自旋锁的其他线程处于自旋，这会浪费宝贵的CPU时间。</p><p>自旋锁的作用一般是使各派遣函数之间同步。尽量不要将自旋锁放在全局变量中，而应该将自旋锁放在设备扩展里面。自旋锁用KSPIN_LOCK数据结构表示。</p><h2 id="内核模式下线程同步"><a href="#内核模式下线程同步" class="headerlink" title="内核模式下线程同步"></a><a href="http://www.voidcn.com/article/p-bhakxtfz-beq.html" target="_blank" rel="noopener">内核模式下线程同步</a></h2><p><a href="http://www.voidcn.com/article/p-bqnbnjzn-ye.html" target="_blank" rel="noopener">内核模式下的线程同步——事件内核对象</a><br><a href="http://www.voidcn.com/article/p-qdxfckob-uy.html" target="_blank" rel="noopener">Windows Via C/C++：内核模式下的线程同步——概述</a></p><p>以下是拥有signaled/unsignaled状态的内核对象：</p><p>进程（Processes）<br>线程（Threads）<br>作业（Jobs）<br>文件和控制台标准输入/输出/错误流（File and console standard input/output/error streams）<br>事件（Events）<br>可待待定时器（Waitable timers）<br>信号量（Semaphores）<br>互斥量（Mutexes）</p><p>内核对象线程同步】概述</p><p>用户方式同步的优点是它的 同步速度非常快。但它也有其局限性。</p><h2 id="线程同步方式比较"><a href="#线程同步方式比较" class="headerlink" title="线程同步方式比较"></a><a href="https://www.cnblogs.com/raichen/p/5768752.html" target="_blank" rel="noopener">线程同步方式比较</a></h2><h2 id="windows-多线程：-CreateThread、-beginthread、-beginthreadex、AfxBeginThread-的区别"><a href="#windows-多线程：-CreateThread、-beginthread、-beginthreadex、AfxBeginThread-的区别" class="headerlink" title="windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别"></a><a href="http://www.cnblogs.com/TenosDoIt/archive/2013/04/15/3022036.html" target="_blank" rel="noopener">windows 多线程： CreateThread、_beginthread、_beginthreadex、AfxBeginThread 的区别</a></h2><h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><h1 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a>线程同步：</h1><p>线程可分为UI线程，工作者线程</p><ul><li>临界区(Critical Section)</li><li>互斥量(Mutex)、互斥对象</li><li>信号量(Semaphore)</li><li>事件(Event)</li><li>读写锁shared_mutex、shared_lock、unique_lock</li><li>可等待定时器</li><li>原子锁</li><li>条件变量</li><li>线程池threadpool</li><li>生产者-消费者</li><li>期货future</li></ul><h1 id="进程间的同步"><a href="#进程间的同步" class="headerlink" title="进程间的同步"></a>进程间的同步</h1><p>windows和linux共有的进程间通信方式：1. 消息（linux中叫做信号） 2. 共享内存  3. 邮槽  4. 管道   5.socket</p><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul><li>文件映射</li><li>共享内存（是文件映射的一种特殊情况）</li><li>邮件槽（mailslot）（点对点消息队列）CreateMailSlot</li><li>命名管道 createNamePipe   connectNamePipe</li><li>匿名管道</li><li>剪贴板</li><li>动态数据交换DDE</li><li>对象链接与嵌入OLE</li><li>远程过程调用RPC</li><li>动态链接库DLL</li><li>Socket</li><li>WM_COPYDATA 消息</li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li>无名管道Pipe</li><li>信号量semaphore</li><li>共享内存</li><li>消息队列、报文队列</li><li>套接字</li><li>信号Signal</li><li>D-Bus主要概念是总线</li></ul><p>windows和linux共有的进程间通信方式：1. 消息（linux中叫做信号） 2. 共享内存  3. 邮槽  4. 管道   5.socket</p><h2 id="其他总结："><a href="#其他总结：" class="headerlink" title="其他总结："></a>其他总结：</h2><p>Unix和windows进程间通信的主要方式</p><p>　　linux系统IPC：<br>　　管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>　　命名管道 (named pipe) ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>　　信号量( semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>　　消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>　　信号 ( sinal )：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>　　共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>　　套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>　　windows系统IPC：<br>　　剪贴板(Clipboard)：当用户在应用程序中执行剪切或复制操作时，应用程序将选定的数据以一个或多个标准或应用程序定义的格式放在剪贴板中。</p><p>　　WM_COPYDATA消息：当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage函数， 接收方只需像处理其它消息那样处理WM_COPYDATA消息，这样收发双方就实现了数据共享，它在底层实际上是通过文件映射来实现的。</p><p>　　文件映射(File Mapping )：使进程把文件内容当作进程地址区间一块内存那样来对待。只需简单的指针操作就可读取和修改文件的内容。 允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针，通过使用这些指针，不同进程就可以读写文件的内容，实现了对文件中数据的共享。</p><p>　　共享内存(Shared Memory)是文件映射的一种特殊情况进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的， 所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。</p><p>　　动态数据交换(DDE)：是使用共享内存在应用程序之间进行数据交换的一种进程间通信形式。应用程序可以使用DDE进行一次性数据传输，也可以当出现新数据时， 通过发送更新值在应用程序间动态交换数据。DDE和剪贴板一样既支持标准数据格式(如文本、位图等)，又可以支持自己定义的数据格式。但它们的数据传输机制却不同，一个明显区别是剪贴板操作几乎总是用作对用户指定操作的一次性应答，如从菜单中选择Paste命令。尽管DDE也可以由用户启动，但它继续发挥作用一般不必用户进一步干预。可以发生在单机或网络中不同计算机的应用程序之间。</p><p>　　邮件槽(Mailslot)：提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个 邮件槽实现进程间的双向通信。</p><p>　　管道( pipe )：同上linux系统 &amp; 命名管道</p><p>　　套接字（Sockets ）：同上linux系统</p><p><a href="https://www.cnblogs.com/findumars/p/6329593.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6329593.html</a></p><p><a href="http://blog.163.com/laylau_ll/blog/static/178625909201173131345423/" target="_blank" rel="noopener">http://blog.163.com/laylau_ll/blog/static/178625909201173131345423/</a></p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程，又称微线程，纤程。</p><p>Boost.Coroutine</p><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>原子库为细粒度的原子操作提供组件，允许无锁并发编程。</p><p><a href="http://zh.cppreference.com/w/cpp/atomic" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/atomic</a></p><h1 id="Win32多线程程序设计中关键函数"><a href="#Win32多线程程序设计中关键函数" class="headerlink" title="Win32多线程程序设计中关键函数"></a>Win32多线程程序设计中关键函数</h1><ul><li>_beginthread</li><li>_beginthreadex</li><li>_endthread</li><li>_endthreadex</li><li>AfxBeginThread</li><li>CloseHandle</li><li>CoInitializeEx</li><li>CreateEvent</li><li>CreateFile</li><li>CreateFileMapping</li><li>CreateIoCompletionPort</li><li>CreateMutex</li><li>CreateSemaphore</li><li>CreateThread</li><li>DeleteCriticalSection</li><li>DisableThreadLibraryCalls</li><li>EnterCriticalSection</li><li>ExitThread</li><li>FileIOCompletionRoutine</li><li>GetExitCodeThread</li><li>GetQueuedCompletionStatus</li><li>GetStdHandle</li><li>GetThreadPriority</li><li>InitializeCriticalSection</li><li>InterlockedDecrement</li><li>InterlockedExchange</li><li>InterlockedIncrement</li><li>LeaveCriticalSection</li><li>MapViewOfFile</li><li>MsgWaitForMultipleObjects</li><li>MsgWaitForMultipleObjectsEx</li><li>MsgWaitForMultipleObjects</li><li>OpenFileMapping</li><li>PostThreadMessage</li><li>ReadFile</li><li>ReadFileEx</li><li>ReleaseMutex</li><li>ReleaseSemaphore</li><li>ReplyMessage</li><li>ResumeThread</li><li>SetThreadPriority</li><li>SleepEx</li><li>SuspendThread</li><li>TerminateThread</li><li>TlsAlloc</li><li>TlsFree</li><li>TlsGetValue</li><li>TlsSetValue</li><li>UnmapViewOfFile</li><li>GetOverlappedResult</li><li>WaitForMultipleObjects</li><li>WaitForMultipleObjectsEx</li><li>WaitForSingleObject</li><li>WaitForSingleObjectEx</li><li>WriteFile</li><li>WriteFileEx</li></ul><h1 id="C-11线程"><a href="#C-11线程" class="headerlink" title="C++11线程"></a>C++11线程</h1><p><a href="http://zh.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/thread</a></p><p><a href="https://blog.csdn.net/jiange_zh/article/details/51602938" target="_blank" rel="noopener">C++11 多线程 future/promise简介</a></p><h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h2><p>std::async大概的工作过程：先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果。</p><p>可以说，std::async帮我们将std::future、std::promise和std::packaged_task三者结合了起来。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="一个-Linux-上分析死锁的简单方法"><a href="#一个-Linux-上分析死锁的简单方法" class="headerlink" title="一个 Linux 上分析死锁的简单方法"></a><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-deadlock/index.html" target="_blank" rel="noopener">一个 Linux 上分析死锁的简单方法</a></h3><p>产生死锁的四个必要条件</p><ul><li>（1） 互斥条件：一个资源每次只能被一个进程（线程）使用。</li><li>（2） 请求与保持条件：一个进程（线程）因请求资源而阻塞时，对已获得的资源保持不放。</li><li>（3） 不剥夺条件 : 此进程（线程）已获得的资源，在末使用完之前，不能强行剥夺。</li><li>（4） 循环等待条件 : 多个进程（线程）之间形成一种头尾相接的循环等待资源关系。</li></ul><p>使用 pstack 和 gdb 工具对死锁程序进行分析</p><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><h3 id="LockCop"><a href="#LockCop" class="headerlink" title="LockCop"></a>LockCop</h3><p>LockCop通过下载Windows核心编程的源码编译可以得到</p><p> 多线程程序开发过程中，最难的是对多线程的调试和逻辑分析，特别是与锁相关的缺陷分析，比如：死锁和无限等待。为此，微乳提供了一套API，从系统层面来辅助开发者分析各个线程的运行状态（running or blocking）和线程与锁的等待关系，这就是：Wait Chain Tranversal。</p><p>Windows核心编程》也提供了Lockcop.exe和badlock.exe这一对示例来演示WCT</p><h4 id="WCT"><a href="#WCT" class="headerlink" title="WCT"></a>WCT</h4><p>要检索一个或多个线程的等待链，请使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-openthreadwaitchainsession" target="_blank" rel="noopener">OpenThreadWaitChainSession</a>和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-getthreadwaitchain" target="_blank" rel="noopener">GetThreadWaitChain</a>函数创建WCT会话。WCT会话由HWCT类型的句柄表示。会话本质上可以是同步的，也可以是异步的。同步会话将阻止调用线程，直到检索到等待链。无法取消同步会话。异步会话不会阻塞调用线程，并且可以使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-closethreadwaitchainsession" target="_blank" rel="noopener">CloseThreadWaitChainSession</a>函数由应用程序取消。异步操作的结果通过应用程序提供的<a href="https://msdn.microsoft.com/en-us/library/ms681421(v=VS.85" target="_blank" rel="noopener">WaitChainCallback</a>.aspx)回调函数提供。</p><p>对于异步会话，调用者可以通过<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Wct/nf-wct-getthreadwaitchain" target="_blank" rel="noopener">GetThreadWaitChain</a>指定指向上下文数据结构的指针。相同的指针传递给回调函数。该上下文数据结构是用户定义的并且对WCT不透明。应用程序可以使用它来在WCT查询和回调函数之间传递上下文。一种常见的方法是通过此结构传递事件句柄; 执行回调时，它会发出此事件的信号，并通知某个监控线程查询已完成。</p><p><a href="https://msdn.microsoft.com/en-us/library/cc308564.aspx" target="_blank" rel="noopener">Developing with Wait Chain Traversal</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000006232497" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006232497</a></p><p><a href="http://www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php" target="_blank" rel="noopener">http://www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php</a></p><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul><li>Win32多线程程序设计</li><li>Windows核心编程</li><li>C++并发编程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Boost-Thread&quot;&gt;&lt;a href=&quot;#Boost-Thread&quot; class=&quot;headerlink&quot; title=&quot;Boost.Thread&quot;&gt;&lt;/a&gt;Boost.Thread&lt;/h1&gt;&lt;h2 id=&quot;线程：&quot;&gt;&lt;a href=&quot;#线程：&quot; class
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="并发" scheme="https://caojingyou.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://caojingyou.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="https://caojingyou.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>IO模型</title>
    <link href="https://caojingyou.github.io/2018/05/30/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://caojingyou.github.io/2018/05/30/IO模型/</id>
    <published>2018-05-30T06:20:00.000Z</published>
    <updated>2018-08-03T09:54:29.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><ul><li>阻塞（blocking）模型</li><li>选择（select）模型</li><li>WSAAsyncSelect模型</li><li>WSAEventSelect 模型</li></ul><p>函数:WSAEventSelect 、WSAWaitForMultipleEvents、WSAEnumNetworkEvents </p><ul><li>重叠（overlapped）模型</li></ul><p>overlapped I/O是Win32的一项技术</p><p>函数：WSAGetOverlappedResult </p><ul><li>完成端口（completion port）模型</li></ul><p>函数：CreateIoCompletionPort、GetQueuedCompletionStatus</p><ul><li><p>内核对象</p><p>  Windows提供了几种内核对象可以处于已通知状态和未通知状态：进程、线程、作业、文件、控制台输入/输出/错误流、事件、等待定时器、信号量、互斥对象。</p></li></ul><p>函数：WaitForSingleObject与WaitForMultipleObjects</p><ul><li>线程池 + 完成端口</li></ul><p>函数：CreateThreadpoolIo，StartThreadpoolIo，CloseThreadpoolIo</p><p><a href="https://blog.csdn.net/column/details/windowssocketbyiter.html" target="_blank" rel="noopener">windows socket 网络编程系列</a></p><p>Select(选择)</p><p>WSAAsyncSelect(异步选择)</p><p>WSAEventSelect(事件选择)</p><p>Overlapped(重叠IO)-事件通知</p><p>IOCP Completion port(完成端口) </p><p><a href="https://my.oschina.net/zengjs275/blog/524145" target="_blank" rel="noopener">关于网络编程六种IO模型的形象比喻</a></p><p><a href="https://blog.csdn.net/ithzhang/article/details/8508161" target="_blank" rel="noopener">《Windows核心编程系列》十异步IO之IO完成端口</a></p><p><a href="https://blog.csdn.net/ithzhang/article/details/8316171" target="_blank" rel="noopener">《Windows核心编程系列》十谈谈﻿﻿﻿﻿同步设备IO与异步设备IO之异步IO</a></p><p><a href="https://blog.csdn.net/ithzhang/article/details/8307633" target="_blank" rel="noopener">《Windows核心编程系列》九谈谈同步设备IO与异步设备IO之同步设备IO</a></p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>select、kqueue、poll/epoll、overlapped I/O等</p><p><a href="https://blog.csdn.net/shallwake/article/details/5265287" target="_blank" rel="noopener">再谈select, iocp, epoll,kqueue及各种I/O复用机制</a></p><p>那么，为什么epoll,kqueue比select高级？ </p><p>答案是，他们无轮询。因为他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p>ASIO:</p><p>“C++的I/O框架，逐渐成为Boost库的一部分。it’s like ACE updated for the STL era。”</p><p>支持select、epoll、IOCP等IO模型；</p><p>libevent:</p><p>由Niels Provos用C编写的一个轻量级的I/O框架。它支持kqueue和select、poll和epoll。</p><p>广为人知的有ACE,Libevent这些，他们都是跨平台的，而且他们自动选择最优的I/O复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。</p><p>Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。</p><p>Reactor: </p><p>libevent/libev/libuv/ZeroMQ/Event Library in Redis</p><p>Proactor</p><p>IOCP/Boost.Asio</p><p>linux下还是Reactor把, 没有os支持, Proactor玩不转.</p><p><a href="https://segmentfault.com/a/1190000002715832" target="_blank" rel="noopener">IO设计模式：Reactor和Proactor对比</a></p><p><a href="https://blog.csdn.net/chen8238065/article/details/48315085" target="_blank" rel="noopener">关于同步，异步，阻塞，非阻塞，IOCP/epoll,select/poll,AIO ,NIO ,BIO的总结</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://www.jianshu.com/p/5cf67fab6d61" target="_blank" rel="noopener">https://www.jianshu.com/p/5cf67fab6d61</a></p><p><a href="https://blog.csdn.net/HQ354974212/article/details/76423050?locationNum=2&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/HQ354974212/article/details/76423050?locationNum=2&amp;fps=1</a></p><p><a href="https://blog.csdn.net/zj510/article/details/44652923" target="_blank" rel="noopener">https://blog.csdn.net/zj510/article/details/44652923</a></p><p><a href="https://blog.csdn.net/u010807583/article/details/52433159" target="_blank" rel="noopener">https://blog.csdn.net/u010807583/article/details/52433159</a></p><p><a href="https://blog.csdn.net/zhangzeyuaaa/article/details/42609723" target="_blank" rel="noopener">https://blog.csdn.net/zhangzeyuaaa/article/details/42609723</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows&quot;&gt;&lt;a href=&quot;#windows&quot; class=&quot;headerlink&quot; title=&quot;windows&quot;&gt;&lt;/a&gt;windows&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;阻塞（blocking）模型&lt;/li&gt;
&lt;li&gt;选择（select）模型&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="IO模型" scheme="https://caojingyou.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>COM</title>
    <link href="https://caojingyou.github.io/2018/05/25/COM/"/>
    <id>https://caojingyou.github.io/2018/05/25/COM/</id>
    <published>2018-05-25T03:13:00.000Z</published>
    <updated>2018-08-22T01:39:28.063Z</updated>
    
    <content type="html"><![CDATA[<p>开发ActiveX控件有两种方式，一是MFC,二是ATL,而后者是专门用于COM组件开发</p><h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><ul><li>Visual C++实践与提高-COM和COM+篇</li><li>COM原理与应用</li><li>COM技术内幕</li><li>COM本质论</li></ul><h1 id="网络教程"><a href="#网络教程" class="headerlink" title="网络教程"></a>网络教程</h1><p><a href="https://www.codeproject.com/Articles/633/Introduction-to-COM-What-It-Is-and-How-to-Use-It" target="_blank" rel="noopener">Introduction to COM - What It Is and How to Use It.</a></p><p><a href="https://www.codeproject.com/Articles/901/Introduction-to-COM-Part-II-Behind-the-Scenes-of-a" title="Introduction to COM Part II - Behind the Scenes of a COM Server" target="_blank" rel="noopener">https://www.codeproject.com/Articles/901/Introduction-to-COM-Part-II-Behind-the-Scenes-of-a</a></p><p><a href="https://blog.csdn.net/q5806622/article/category/2846441" title="https://blog.csdn.net/q5806622/article/category/2846441" target="_blank" rel="noopener">https://blog.csdn.net/q5806622/article/category/2846441</a></p><p><a href="https://www.cnblogs.com/hanford/p/6103069.html" title="COM组件（ATL篇）" target="_blank" rel="noopener">COM组件（ATL篇）</a></p><p><a href="http://www.cnblogs.com/hanford/p/6103127.html" title="ActiveX控件(ATL篇)" target="_blank" rel="noopener">ActiveX控件(ATL篇)</a></p><p><a href="http://www.cnblogs.com/hanford/p/6103047.html" title="COM组件（MFC篇）" target="_blank" rel="noopener">COM组件（MFC篇）</a></p><p><a href="http://www.cnblogs.com/hanford/p/6103111.html" title="ActiveX控件(MFC篇)" target="_blank" rel="noopener">ActiveX控件(MFC篇)</a></p><p><a href="https://blog.csdn.net/woshinia/article/details/22300089" title="C++ COM组件的编写" target="_blank" rel="noopener">https://blog.csdn.net/woshinia/article/details/22300089</a></p><p><a href="https://www.cnblogs.com/jyz/archive/2009/03/08/1406229.html" title="进程内COM与进程外COM" target="_blank" rel="noopener">https://www.cnblogs.com/jyz/archive/2009/03/08/1406229.html</a></p><p><a href="http://blog.e-works.net.cn/395307/articles/16044.html" title="C++ 类的动态组件化技术" target="_blank" rel="noopener">http://blog.e-works.net.cn/395307/articles/16044.html</a></p><p><a href="https://blog.csdn.net/q5806622/article/category/2846441" target="_blank" rel="noopener">COM/ActiveX</a></p><p><a href="https://blog.csdn.net/q5806622/article/details/43964673" target="_blank" rel="noopener">使用ATL开发COM组件</a></p><p><a href="https://blog.csdn.net/zj510/article/category/2510453" target="_blank" rel="noopener">https://blog.csdn.net/zj510/article/category/2510453</a></p><h1 id="ATL创建过程"><a href="#ATL创建过程" class="headerlink" title="ATL创建过程"></a>ATL创建过程</h1><p>运行VC++2010，新建”ATL Project”项目</p><p>ATL Simple Object 增加COM类</p><p>鼠标右键单击接口，弹出菜单中添加方法或属性</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="https://i.imgur.com/A3knAl9.jpg" alt=""></p><ul><li>方法<ul><li>参数特性<ul><li>in 指示一个参数从调用过程传入被调用过程</li><li>out 特性标示从被调用过程返回到调用过程(从服务器到客户端)的指针参数</li><li>retval 特性指定接收该成员的返回值的参数</li></ul></li></ul></li></ul><p>[in]类型表明参数是一个输入参数，所以这个参数不会向外界返回结果 </p><p>[out]类型表明参数是个输出参数，所以这个参数会向外界返回结果,参数类型只能是指针类型</p><p>[out，retval]类型表明参数是个输出参数， retval 必须与 out 联用，并且在参数类表中只有最后一个参数可以被指定为 [out，retval] 属性，包装类会用这个参数的类型作为包装类方法的返回值</p><p>我们在 vc 中引入一个COM组件， vc 会分析 com 组件的类型库信息<br>假设有一个方法说明如下</p><p>[id(1), helpstring(“method Foo”)] HRESULT Foo([in] long lIn, [out] BSTR<em> bstrOut, [out,retval] BSTR</em> bstrResult);</p><p>那么vc生成的包装类的方法可能是</p><p>BSTR Foo(long lIn , BSTR&amp; bstrOut);</p><p>我们看到，由于 bstrResult 具有 [out,retval] 属性，所以生成的包装类的方法返回值不再是 HRESULT类型，而是 BSTR 类型，这样，包装类就会更加易于使用</p><p><a href="https://www.cnblogs.com/vedgtar/archive/2014/03/20/3613552.html" target="_blank" rel="noopener">COM 参数有in, out ,retval</a></p><p><a href="https://blog.csdn.net/only_endure/article/details/18698437" target="_blank" rel="noopener">[in][out][retval]</a></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><img src="https://i.imgur.com/lVsUaX2.jpg" alt=""></p><ul><li>属性<ul><li>函数类型<ul><li>Get</li><li>Put<ul><li>PropPut值传递</li><li>PropPutRef引用传递</li></ul></li></ul></li></ul></li></ul><h1 id="ATL代码"><a href="#ATL代码" class="headerlink" title="ATL代码"></a>ATL代码</h1><h2 id="ATL-NO-VTABLE"><a href="#ATL-NO-VTABLE" class="headerlink" title="ATL_NO_VTABLE"></a><code>ATL_NO_VTABLE</code></h2><p>ATL_NO_VTABLE可以让编译器不产生VTable，并且不设置VPointer的值。 基类虚函数表会被派生类覆盖掉，所以我们可以对基类使用 ATL_NO_VTABLE 避免产生虚函数表！    ATL是通过多重继承来实现COM组件的，继承层次中的每个类都有自己的虚函数表，所以在继承层次很深的情况下，虚函数表会变得非常宏大，如果用ATL_NO_VTABLE宏来阻止生成虚函数表，就会有限的减少组件的长度。</p><p>novtable不是去掉了虚函数表，要知道，虚函数表可是COM二进制复用的基础，怎么会去掉呢？这个宏，只是阻止了在多步构造对象时对虚函数表的调整。一般C++在构造一个派生类的时候，会从最初的祖先开始构造，这时该虚函数表指向最初的祖先的虚函数表，然后一步步构造派生类，虚函数表也不断的调整指向相应的派生类的虚函数表，这样能保证各个派生类构造时，调用的是该派生类实现的虚函数，ATL_NO_VTABLE只是阻止了这个过程，在构造过程中虚函数表没有做相应的调整，所以在构造函数中不能调用虚函数，以免产生错误的调用。</p><p><a href="https://www.cnblogs.com/weiqubo/archive/2011/03/16/1985773.html" target="_blank" rel="noopener">__declspec(novtable)作用</a></p><h2 id="CComObjectRootEx类"><a href="#CComObjectRootEx类" class="headerlink" title="CComObjectRootEx类"></a><a href="https://msdn.microsoft.com/en-us/library/8hzca2fs.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">CComObjectRootEx类</a></h2><p>线程模型,CComObjectRootEx类提供了处理非聚合和聚合对象的对象引用计数管理的方法。您可以通过设置ThreadModel为CComSingleThreadModel，CComMultiThreadModel或CComMultiThreadModelNoCS来明确选择线程模型。您可以通过设置ThreadModel为CComObjectThreadModel或CComGlobalsThreadModel来接受服务器的默认线程模型。</p><h2 id="接口映射表"><a href="#接口映射表" class="headerlink" title="接口映射表"></a>接口映射表</h2><p>ATL提供了<code>BEGIN_COM_MAP</code>、<code>END_COM_MAP</code>、<code>COM_INTERFACE_ENTRY</code>与<code>COM_INTERFACE_ENTRY2</code>这4个宏来创建接口映射表。</p><p><a href="https://blog.csdn.net/luckysym/article/details/625615" target="_blank" rel="noopener">COM接口映射表</a></p><h2 id="DECLARE-PROTECT-FINAL-CONSTRUCT"><a href="#DECLARE-PROTECT-FINAL-CONSTRUCT" class="headerlink" title="DECLARE_PROTECT_FINAL_CONSTRUCT"></a><code>DECLARE_PROTECT_FINAL_CONSTRUCT</code></h2><p><code>DECLARE_PROTECT_FINAL_CONSTRUCT    ()</code>    //内部聚合对象增加引用计数然后将计数减少到0，则保护您的对象不被删除。</p><pre><code>#define DECLARE_PROTECT_FINAL_CONSTRUCT()\void InternalFinalConstructAddRef() {InternalAddRef();}\void InternalFinalConstructRelease() {InternalRelease();}</code></pre><h2 id="禁用警告"><a href="#禁用警告" class="headerlink" title="禁用警告"></a>禁用警告</h2><pre><code>#define ATLPREFAST_SUPPRESS(x) __pragma(warning(push)) __pragma(warning(disable: x))#define ATLPREFAST_UNSUPPRESS() __pragma(warning(pop))#pragma warning（push）   #pragma warning（disable：4705）   #pragma warning（disable：4706）   #pragma warning（disable：4707）   //一些代码   #pragma warning（pop）   </code></pre><h2 id="深入解析C-编程中alignof-与uuidof运算符的使用"><a href="#深入解析C-编程中alignof-与uuidof运算符的使用" class="headerlink" title="深入解析C++编程中alignof 与uuidof运算符的使用"></a><a href="https://www.ctolib.com/topics-55778.html" target="_blank" rel="noopener">深入解析C++编程中<strong>alignof 与</strong>uuidof运算符的使用</a></h2><p><strong>alignof 运算符<br>C++11 引入 alignof 运算符，该运算符返回指定类型的对齐方式（以字节为单位）。为实现最大的可移植性，应使用 alignof 运算符，而不是特定于 Microsoft 的 </strong>alignof 运算符。<br>返回一个 size_t 类型的值，该值是类型的对齐要求。</p><p>__uuidof 运算符</p><p>检索 GUID 并附加到表达式。</p><h2 id="OBJECT-ENTRY-AUTO-uuidof-Statistic01-CStatistic01"><a href="#OBJECT-ENTRY-AUTO-uuidof-Statistic01-CStatistic01" class="headerlink" title="OBJECT_ENTRY_AUTO(__uuidof(Statistic01), CStatistic01)"></a><code>OBJECT_ENTRY_AUTO(__uuidof(Statistic01), CStatistic01)</code></h2><p><code>__uuidof</code> 运算符,检索 GUID 并附加到表达式。</p><p><code>OBJECT_ENTRY_AUTO</code> 将ATL对象输入对象映射，更新注册表，并创建对象的实例。</p><h2 id="IUnknown"><a href="#IUnknown" class="headerlink" title="IUnknown"></a>IUnknown</h2><p> IUnknown接口是COM的核心，因为所有其他的COM接口都必须从IUnknown继承。</p><pre><code>class IUnknown{public:     virtual HRESULT __stdcall QueryInterface(const IID&amp; iid, void** ppv) = 0;     virtual ULONG __stdcall AddRef() = 0;     virtual ULONG __stdcall Release() = 0;};</code></pre><h2 id="临界区类"><a href="#临界区类" class="headerlink" title="临界区类"></a>临界区类</h2><p>ATL将Windows临界区封装了一下，即CComCriticalSection和CComAutoCriticalSection类。</p><h1 id="类型库"><a href="#类型库" class="headerlink" title="类型库"></a>类型库</h1><p>作为C/C++程序员，要使用其他程序员编写的动态库或静态库，需要头文件。通过头文件，才能知道动态库或静态库里有什么函数，函数的参数、返回值情况……同样的，客户端程序要使用COM组件，也需要类似头文件功能的东西，这就是类型库。</p><p>可以编写文本格式的odl或idl文件，然后使用midl.exe将其编译为二进制的tlb文件——这就是类型库文件。</p><h1 id="Dual和Custom"><a href="#Dual和Custom" class="headerlink" title="Dual和Custom"></a>Dual和Custom</h1><p>接口：双重，自定义</p><p>实际上Custom接口是从IUnknown继承下来的，而Dual接口是从IDispatch继承下来的（IDispatch从IUnknown继承下来）。</p><p>Dual：接口同时支持IDispatch方式和vtable方式</p><p>vtable调用方式，指的是直接通过接口指针的虚函数表。比如</p><pre><code>CComPtr&lt;IMyCar&gt; spCar;  spCar.CoCreateInstance(CLSID_MyCar, NULL, CLSCTX_INPROC_SERVER);  spCar-&gt;Run();</code></pre><p>Custom：没有支持IDispatch，只支持vtable。</p><p>如果是custom接口，那么只能通过vtable的方式了，就是通过接口指针来调用成员函数，而不能用IDispatch的invoke了。</p><p>那什么时候用Dual，什么时候用Custom呢？</p><p>当com组件只在C++里面被调用的时候，用custom；如果com组件可能被其他语言调用，那么就用dual。</p><p>另外，通过IDispatch::Invoke(),效率会比vtable调用方式低很多，因为它要经过很多转换。如果是C++调用环境，尽可能使用vtable的方式，如果是其他语言就没办法了，只能是IDispatch方式。</p><h1 id="COM线程模型"><a href="#COM线程模型" class="headerlink" title="COM线程模型"></a>COM线程模型</h1><h2 id="STA接口"><a href="#STA接口" class="headerlink" title="STA接口"></a><a href="https://blog.csdn.net/zj510/article/details/38824353" target="_blank" rel="noopener">STA接口</a></h2><p>STA的规则很简单，但是需要小心的遵守这些规则：</p><ul><li>每一个STA COM 对象只能存在于一个线程中 （在一个STA套间内）</li><li>每一个线程都需要初始化COM库</li><li>在套间之间传递com对象指针的时候，需要列集(marshal)</li><li>每一个STA套间必须拥有一个消息循环，用来处理从其他进程或者当前进程的其他套间过来的消息。（后面一句没有理解，就不翻译了，以免误导。）其实，我个人感觉如果一个STA套间创建了一个COM对象，只要这个COM对象不传递到其他线程，消息循环是可以省略的。但是如果COM对象需要传递到其他进程，那么就必须创建一个消息循环。</li><li>COM对象本身并不需要调用COM的初始化函数；相反，他们会把他们的线程模型放在注册表中的一个叫做InprocServer32的键下面。后面的也不是很了解。以后弄明白了再说。</li></ul><p>Apartment类型(单元)，也就是STA。</p><p>COM的线程模型，其实指的是两方面：一个是客户程序的线程模式，一个是组件所支持的线程模式。客户程序的线程模式只有两种，单线程公寓(STA)和多线程公寓(MTA)。组件所支持的线程模式有四种：Single(单线程)、Apartment(STA)、Free(MTA)、Both(STA+MTA)。</p><ul><li>STA客户程序调用STA COM组件</li><li>MTA客户程序调用STA COM组件</li></ul><h3 id="跨线程传递对象，消息循环"><a href="#跨线程传递对象，消息循环" class="headerlink" title="跨线程传递对象，消息循环"></a>跨线程传递对象，消息循环</h3><h3 id="STA客户创建STA对象，然后传递到另外一个线程"><a href="#STA客户创建STA对象，然后传递到另外一个线程" class="headerlink" title="STA客户创建STA对象，然后传递到另外一个线程"></a>STA客户创建STA对象，然后传递到另外一个线程</h3><p>Marshal和Unmarshal</p><p>通常中文翻译成列集和散集</p><pre><code>CoMarshalInterThreadInterfaceInStreamCoGetInterfaceAndReleaseStream</code></pre><h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><p>STA对象的线性调用其实就是通过Windows的消息循环来实现的。</p><p>给我们的主调STA客户加上消息循环</p><pre><code>// TestCom.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;atlbase.h&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;windows.h&gt;#include &quot;../MyCom/MyCom_i.h&quot;#include &quot;../MyCom/MyCom_i.c&quot;LRESULT CALLBACK WndProc_Notify(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam){    return DefWindowProc(hWnd, wMsg, wParam, lParam);}void CreateWnd(void){    WNDCLASS wc = { 0 };    wc.style = 0;    wc.lpfnWndProc = WndProc_Notify;    wc.cbClsExtra = 0;    wc.cbWndExtra = 0;    //    wc.hInstance = g_hInstance;    wc.hIcon = NULL;    wc.hCursor = LoadCursor(NULL, IDC_ARROW);    wc.hbrBackground = (HBRUSH)GetSysColorBrush(COLOR_WINDOW);    wc.lpszMenuName = NULL;    wc.lpszClassName = TEXT(&quot;NOTIFY_MSG_LOOP&quot;);    RegisterClass(&amp;wc);    HWND g_hNotifyMsgLoop = CreateWindowExW(0,        wc.lpszClassName,        wc.lpszClassName,        WS_OVERLAPPEDWINDOW,        0,        0,        200,        200,        NULL,        NULL,        NULL,        0);    //    ShowWindow(g_hNotifyMsgLoop, SW_HIDE);}void Test(LPSTREAM pStream){    CreateWnd();    WCHAR temp[100] = { 0 };    swprintf_s(temp, L&quot;STA calling thread (used passed in com object): %d\n&quot;, ::GetCurrentThreadId());    OutputDebugStringW(temp);    CoInitialize(NULL);    CComPtr&lt;ICircle&gt; spCircle;    HRESULT hr = CoGetInterfaceAndReleaseStream(pStream, IID_ICircle, (LPVOID*)&amp;spCircle);  // unmarshal to get a com object    if (SUCCEEDED(hr))    {        spCircle-&gt;Draw(CComBSTR(L&quot;yellow&quot;));    }    CoUninitialize();}int _tmain(int argc, _TCHAR* argv[]){    CoInitialize(NULL);    WCHAR temp[100] = { 0 };    swprintf_s(temp, L&quot;Main thread: %d\n&quot;, ::GetCurrentThreadId());    OutputDebugStringW(temp);    {        CComPtr&lt;ICircle&gt; spCircle;        spCircle.CoCreateInstance(CLSID_Circle, NULL, CLSCTX_INPROC);        spCircle-&gt;Draw(CComBSTR(L&quot;red&quot;));        std::vector&lt;std::thread&gt; vThreads;        for (int i = 0; i &lt; 5; i++)        {            LPSTREAM pStream = nullptr;            CoMarshalInterThreadInterfaceInStream(IID_ICircle, spCircle, &amp;pStream);  // marshal            vThreads.push_back(std::thread(Test, pStream));  // pass a stream instead of com object        }        MSG msg;        while (GetMessage(&amp;msg, NULL, 0, 0))        {            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        }        for (auto&amp; t: vThreads)        {            t.join();        }    }    CoUninitialize();    return 0;}</code></pre><p>如果想要把一个STA对象往另外一个线程传递，就需要：</p><ol><li><p>列集/散列， (marshal/unmarshal)</p></li><li><p>创建STA对象的线程一定要有个windows消息循环。</p></li></ol><p>COM系统发现有其他线程（套间）调用COM对象的方法，COM系统就会往创建COM对象的线程发送消息，但是如果那个线程没有消息循环来接收，那就永远都处理不了了。</p><h3 id="MTA客户，跨线程传递COM对象"><a href="#MTA客户，跨线程传递COM对象" class="headerlink" title="MTA客户，跨线程传递COM对象"></a>MTA客户，跨线程传递COM对象</h3><p>MTA调用STA对象的时候，STA本来就在一个default STA里面运行的。MTA客户获得的不过是一个代理而已。</p><p>当MTA客户在调用STA对象的时候，本来就涉及到2个套间：MTA和default STA。</p><p>MTA套间里的线程直接调用STA对象，不需要做marshal，MTA里面的线程调用的是STA对象的代理，系统会把这些调用转发给default STA，default STA默认就有个消息循环了，这个是由COM系统创建的，不需要程序员干涉。</p><p>如果我们直接把MTA创建的STA对象指针传递给STA线程，调用对象方法的时候，会得到一个错误：</p><p>RPC_E_WRONG_THREAD The application called an interface that was marshalled for a different thread.</p><p>那么这个地方就碰到一个问题，MTA创建的STA对象存在于一个default STA中，而我们的STA线程如果直接访问COM对象的话，又涉及跨套间的问题了。所有就得mashal，在MTA线程里面，把STA对象（代理）mashal一下，再传给STA线程，会发现调用正常了。而且STA的运行线程就是default STA里面的那个线程。这样就可以实现串行调用了。</p><p>总之对于STA COM 对象，所有方法的调用总是串行的，不会并发，不需要考虑同步问题。</p><ol><li><p>STA客户调用STA对象，是通过消息循环来保证串行的。就是通过往创建对象的套间发送消息，套间线程来接收消息。</p></li><li><p>MTA客户调用STA对象， COM系统会处理marshal，并且在default STA里面创建默认消息循环。</p></li></ol><h2 id="MTA接口"><a href="#MTA接口" class="headerlink" title="MTA接口"></a><a href="https://blog.csdn.net/zj510/article/details/38857239" target="_blank" rel="noopener">MTA接口</a></h2><p>跟STA相比，</p><ol><li><p>COM系统不会帮助序列号，需要程序员自己来处理并发同步问题；</p></li><li><p>不需要消息循环。</p></li></ol><p>另外，一个进程里面只能有一个MTA套间，MTA套间里面可以有多个线程。</p><p>Threading model中选择Free</p><p>MTA组件需要自己实现同步</p><h3 id="传递MTA-COM对象给STA套间线程"><a href="#传递MTA-COM对象给STA套间线程" class="headerlink" title="传递MTA COM对象给STA套间线程"></a>传递MTA COM对象给STA套间线程</h3><p>目前的COM设计允许一个没有显式初始化COM的线程成为MTA套间的一部分。只有当另外一个线程已经调用过CoInitializeEx(NULL, COINIT_MULTITHREADED)后，一个没有初始化COM的线程会在开始使用COM属于MTA套间。（有一个可能性是：COM自己会初始化成MTA但是客户并没有显式初始化；比如，一个STA线程在一个标记为”ThreadingModel=Free”的CLSID上调用CoGetClssObject/CoCreateInstance[x]，COM会隐式创建一个MTA套间）</p><p>ok，针对我们的情况，辅助线程尽管自己没有初始化COM，但是它也是MTA套间里面的一个线程。所以，也不需要marshal。</p><h3 id="STA套间调用MTA对象"><a href="#STA套间调用MTA对象" class="headerlink" title="STA套间调用MTA对象"></a>STA套间调用MTA对象</h3><ol><li>当在STA套间里面创建MTA对象时，系统会自动创建一个MTA套间。</li><li>MTA对象在MTA套间里面运行。</li><li>运行线程由系统来创建，系统会创建几个运行线程，并且挑选某个线程为当前调用服务。</li></ol><h3 id="运行线程"><a href="#运行线程" class="headerlink" title="运行线程"></a>运行线程</h3><p>一个STA对象只能属于一个STA套间，那么一个STA对象一定是在一个线程里面运行的。所以STA对象不需要考虑并发，因为它永远是串行运行的。</p><p>MTA套间调用MTA对象：COM对象都是运行在创建它的线程里面</p><p>STA套间调用MTA对象：MTA对象是运行在系统创建的线程里面</p><h2 id="COM连接点"><a href="#COM连接点" class="headerlink" title="COM连接点"></a><a href="https://blog.csdn.net/zj510/article/details/39056097" target="_blank" rel="noopener">COM连接点</a></h2><p>COM里面的连接点就好像是C语言的回调函数，只不过它是基于面向对象实现的。连接点的作用也就是COM对象将一些事件通知客户（调用者）。</p><h3 id="创建连接点"><a href="#创建连接点" class="headerlink" title="创建连接点"></a>创建连接点</h3><p><a href="https://blog.csdn.net/csfreebird/article/details/1154718" target="_blank" rel="noopener">ATL7.1创建连接点组件</a></p><ul><li>用ATL创建一个工程（DLL COM) CAtlComTest</li><li>然后创建一个COM接口，ATL简单对象，IMyCar. 在options那里选上connection points(连接点)。</li><li>然后在class view那里找到_IMyCarEvents(在CAtlComTestLib下面),右键点击Add Method.如图，增加一个方法OnStop。</li><li>之后在CMyCar上点击右键，选择Add Connection Point(添加连接点)。</li></ul><p>在CProxy_IMyCarEvents里面可以看到多了个函数。如下</p><pre><code>#pragma oncetemplate&lt;class T&gt;class CProxy_IMyCarEvents :    public ATL::IConnectionPointImpl&lt;T, &amp;__uuidof(_IMyCarEvents)&gt;{public:    HRESULT Fire_OnStop( FLOAT Distance)    {        HRESULT hr = S_OK;        T * pThis = static_cast&lt;T *&gt;(this);        int cConnections = m_vec.GetSize();        for (int iConnection = 0; iConnection &lt; cConnections; iConnection++)        {            pThis-&gt;Lock();            CComPtr&lt;IUnknown&gt; punkConnection = m_vec.GetAt(iConnection);            pThis-&gt;Unlock();            IDispatch * pConnection = static_cast&lt;IDispatch *&gt;(punkConnection.p);            if (pConnection)            {                CComVariant avarParams[1];                avarParams[0] = Distance;                avarParams[0].vt = VT_R4;                CComVariant varResult;                DISPPARAMS params = { avarParams, NULL, 1, 0 };                hr = pConnection-&gt;Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &amp;params, &amp;varResult, NULL, NULL);            }        }        return hr;    }};</code></pre><h3 id="使用这个连接点"><a href="#使用这个连接点" class="headerlink" title="使用这个连接点"></a>使用这个连接点</h3><p>IMyCar增加一个方法</p><pre><code>STDMETHODIMP CMyCar::Run(){    // TODO: Add your implementation code here    this-&gt;Fire_OnStop(1000);    return S_OK;}</code></pre><p>然后写个客户程序</p><pre><code>// TestCom.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;atlbase.h&gt;#include &lt;atlcom.h&gt;#include &quot;../MyCOM/MyCOM_i.h&quot;#include &quot;../MyCOM/MyCOM_i.c&quot;#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class CSink :    public CComObjectRoot,    public _IMyCarEvents{    BEGIN_COM_MAP(CSink)        COM_INTERFACE_ENTRY(IDispatch)        COM_INTERFACE_ENTRY(_IMyCarEvents)    END_COM_MAP()public:    virtual ~CSink(){}    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)   { return E_NOTIMPL; }    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)  { return E_NOTIMPL; }    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)    {        printf(&quot;sink, id: %d, parm: %f&quot;, dispIdMember, pDispParams-&gt;rgvarg[0].fltVal);        return S_OK;    }};CComModule m_commodule;int _tmain(int argc, _TCHAR* argv[]){    CoInitializeEx(0, COINIT_APARTMENTTHREADED);    {        CComPtr&lt;IMyCar&gt; spCar;        spCar.CoCreateInstance(CLSID_MyCar, NULL, CLSCTX_INPROC_SERVER);        CComObject&lt;CSink&gt;* sinkptr = nullptr;        CComObject&lt;CSink&gt;::CreateInstance(&amp;sinkptr);        DWORD cookies = 0;        AtlAdvise(spCar, sinkptr, __uuidof(_IMyCarEvents), &amp;cookies);        spCar-&gt;Run();    }    CoUninitialize();    return 0;}</code></pre><p>发现CSink里面的invoke被调用到了<br>其中pDispParams-&gt;rgvarg[0].fltVal就是COM对象触发这个连接点的时候传进来的参数1000.</p><p>主要过程是：</p><ol><li><p>创建sink对象</p></li><li><p>挂载sink对象到一个COM对象上</p></li><li><p>COM对象调用Run函数</p></li><li><p>Run函数内部触发了一个连接点</p></li><li><p>调用者的对应函数会被调用，这里是Invoke。</p></li></ol><p>总结一下：</p><ol><li><p>如果COM对象需要支持连接点，那么这个对象类需要从连接点和连接点容器继承下来；（一个类可以有多个连接点）</p></li><li><p>创建接收对象（sink），接收对象需要从CComObjectRoot(或者类似的其他类）和连接点接口继承下来；</p></li><li><p>使用AtlAdvise来将一个sink对象挂载到相应的COM对象上。（当COM对象释放的时候，会相应释放所有拥有的sink对象）</p></li><li><p>这样，当COM对象需要触发一个事件的时候，就可以遍历所有sink对象，一个一个来触发。</p></li></ol><p>整个过程也还是蛮简单的。其实仔细看看这个结构，这活脱脱就是一个观察者模式的典型例子。sink是观察者，具体COM对象是被观察者。当具体COM对象有事件需要触发的时候，就通过m_vec来通知所有的观察者（sink）。IConnectionPoint::m_vec是一个数组,存放所有的观察者。</p><h2 id="IDispatch接口-GetIDsOfNames和Invoke"><a href="#IDispatch接口-GetIDsOfNames和Invoke" class="headerlink" title="IDispatch接口 - GetIDsOfNames和Invoke"></a><a href="https://blog.csdn.net/zj510/article/details/39494873" target="_blank" rel="noopener">IDispatch接口 - GetIDsOfNames和Invoke</a></h2><p>GetIDsOfNames</p><p>这个函数的主要功能就是：把COM接口的方法名字和参数（可选）映射成一组DISPID。</p><p>Invoke</p><p>Invoke是IDispatch里面非常重要的一样函数，方法调用就靠这个函数了。</p><h3 id="CComDispatchDriver智能指针"><a href="#CComDispatchDriver智能指针" class="headerlink" title="CComDispatchDriver智能指针"></a>CComDispatchDriver智能指针</h3><pre><code>#include &quot;stdafx.h&quot;#include &lt;thread&gt;#include &lt;atlbase.h&gt;#include &lt;atlcom.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &quot;../MyCom/MyCom_i.h&quot;#include &quot;../MyCom/MyCom_i.c&quot;int _tmain(int argc, _TCHAR* argv[]){    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);    CComDispatchDriver dsp;    dsp.CoCreateInstance(CLSID_MyCar);    CComVariant rt;    dsp.GetPropertyByName(L&quot;Gas&quot;, &amp;rt);    LONG total = rt.lVal;    CComVariant p1;    p1.vt = VT_I4;    p1.lVal = 12;    CComVariant p2;    p2.vt = VT_I4 | VT_BYREF;    LONG Gas = 0;    p2.byref = &amp;Gas;    dsp.Invoke2(L&quot;AddGas&quot;, &amp;p1, &amp;p2, NULL);    CComVariant totalGas;    dsp.GetPropertyByName(L&quot;Gas&quot;, &amp;totalGas);    total = totalGas.lVal;    dsp.Release();    CoUninitialize();    return 0;}</code></pre><p>看一下就知道怎么通过CComDispatchDriver来调用支持IDispatch接口的COM组件了。其实CComDispatchDriver内部还是通过GetIDsOfNames和Invoke等函数来调用COM组件的方法的。</p><h3 id="ATL：连接点及接收事件的两种方法"><a href="#ATL：连接点及接收事件的两种方法" class="headerlink" title="ATL：连接点及接收事件的两种方法"></a><a href="https://fanglz.wordpress.com/2011/03/24/connection-point/" target="_blank" rel="noopener">ATL：连接点及接收事件的两种方法</a></h3><p><a href="https://blog.csdn.net/debehe/article/details/2291771" target="_blank" rel="noopener">深入解析连接点</a></p><h1 id="COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch"><a href="#COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch" class="headerlink" title="COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch"></a><a href="https://blog.csdn.net/wangqiulin123456/article/details/8274620?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch</a></h1><p>COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown包含三个函数，分别是 QueryInterface、AddRef、Release。这三个函数是无比重要的，而且它们的排列顺序也是不可改变的。QueryInterface用于查询组件实现的其它接口，说白了也就是看看这个组件的父类中还有哪些接口类，AddRef用于增加引用计数，Release用于减少引用计数。引用计数也是COM中的一个非常重要的概念。大体上简单的说来可以这么理解，COM组件是个DLL，当客户程序要用它时就要把它装到内存里。另一方面，一个组件也不是只给你一个人用的，可能会有很多个程序同时都要用到它。但实际上DLL只装载了一次，即内存中只有一个COM组件，那COM组件由谁来释放？由客户程序吗？不可能，因为如果你释放了组件，那别人怎么用，所以只能由COM组件自己来负责。所以出现了引用计数的概念，COM维持一个计数，记录当前有多少人在用它，每多一次调用计数就加一，少一个客户用它就减一，当最后一个客户释放它的时侯，COM知道已经没有人用它了，它的使用已经结束了，那它就把它自己给释放了。引用计数是COM编程里非常容易出错的一个地方，但所幸VC的各种各样的类库里已经基本上把AddRef的调用给隐含了，在我的印象里，我编程的时侯还从来没有调用过AddRef，我们只需在适当的时侯调用Release。至少有两个时侯要记住调用Release，第一个是调用了 QueryInterface以后，第二个是调用了任何得到一个接口的指针的函数以后，记住多查MSDN 以确定某个函数内部是否调用了AddRef，如果是的话那调用Release的责任就要归你了。 IUnknown的这三个函数的实现非常规范但也非常烦琐，容易出错，所幸的事我们可能永远也不需要自己来实现它们。</p><p>　　IClassFactory的作用是创建COM组件。我们已经知道COM组件实际上就是一个类，那我们平常是怎么实例化一个类对象的？是用‘new’命令!很简单吧，COM组件也一样如此。但是谁来new它呢？不可能是客户程序，因为客户程序不可能知道组件的类名字，如果客户知道组件的类名字那组件的可重用性就要打个大大的折扣了，事实上客户程序只不过知道一个代表着组件的128位的数字串而已，这个等会再介绍。所以客户无法自己创建组件，而且考虑一下，如果组件是在远程的机器上，你还能new出一个对象吗？所以创建组件的责任交给了一个单独的对象，这个对象就是类厂。每个组件都必须有一个与之相关的类厂，这个类厂知道怎么样创建组件，当客户请求一个组件对象的实例时，实际上这个请求交给了类厂，由类厂创建组件实例，然后把实例指针交给客户程序。这个过程在跨进程及远程创建组件时特别有用，因为这时就不是一个简单的new操作就可以的了，它必须要经过调度，而这些复杂的操作都交给类厂对象去做了。IClassFactory最重要的一个函数就是CreateInstance，顾名思议就是创建组件实例，一般情况下我们不会直接调用它，API函数都为我们封装好它了，只有某些特殊情况下才会由我们自己来调用它，这也是VC编写COM组件的好处，使我们有了更多的控制机会，而VB给我们这样的机会则是太少太少了。</p><p>　　IDispatch叫做调度接口。它的作用何在呢？这个世上除了C++还有很多别的语言，比如VB、 VJ、VBScript、JavaScript等等。可以这么说，如果这世上没有这么多乱七八糟的语言，那就不会有IDispatch。:-) 我们知道COM组件是C++类，是靠虚函数表来调用函数的，对于VC来说毫无问题，这本来就是针对C++而设计的，以前VB不行，现在VB也可以用指针了，也可以通过VTable来调用函数了，VJ也可以，但还是有些语言不行，那就是脚本语言，典型的如 VBScript、JavaScript。不行的原因在于它们并不支持指针，连指针都不能用还怎么用多态性啊，还怎么调这些虚函数啊。唉，没办法，也不能置这些脚本语言于不顾吧，现在网页上用的都是这些脚本语言，而分布式应用也是COM组件的一个主要市场，它不得不被这些脚本语言所调用，既然虚函数表的方式行不通，我们只能另寻他法了。时势造英雄，IDispatch应运而生。:-) 调度接口把每一个函数每一个属性都编上号，客户程序要调用这些函数属性的时侯就把这些编号传给IDispatch接口就行了，IDispatch再根据这些编号调用相应的函数，仅此而已。当然实际的过程远比这复杂，仅给一个编号就能让别人知道怎么调用一个函数那不是天方夜潭吗，你总得让别人知道你要调用的函数要带什么参数，参数类型什么以及返回什么东西吧，而要以一种统一的方式来处理这些问题是件很头疼的事。IDispatch接口的主要函数是Invoke，客户程序都调用它，然后Invoke再调用相应的函数，如果看一看MS的类库里实现 Invoke的代码就会惊叹它实现的复杂了，因为你必须考虑各种参数类型的情况，所幸我们不需要自己来做这件事，而且可能永远也没这样的机会。:-) </p><h1 id="ATL-调用COM对象"><a href="#ATL-调用COM对象" class="headerlink" title="ATL 调用COM对象"></a><a href="https://blog.csdn.net/luo_xianming/article/details/40458393?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">ATL 调用COM对象</a></h1><p>创建COM对象一般有三种方法，正常创建一个对象，使用CoCreateInstance函数。若在远程系统中创建一个对象，使用CoCreateInstanceEX函数。而创建多个同一CLSID的对象时，使用CoGetClassObject函数。</p><p>1.先简单的使用CoCreateInstance函数创建一个COM对象。</p><pre><code>//要加载生成的文件和这个c文件。#include &quot;ATLProject1_i.h&quot;#include &quot;ATLProject1_i.c&quot;int _tmain(int argc, _TCHAR* argv[]){    //声明的是接口的指针    ITryCOM *it = NULL;    //声明一个HRESULT变量    HRESULT hr;    //初始化COM，并告诉Windows以单线程的方式创建COM对象    hr = CoInitialize(0);    //使用SUCCEDED宏判断是否初始化成功。    if(SUCCEEDED(hr)){        //加载COM对象        hr = CoCreateInstance(CLSID_TryCOM,NULL,CLSCTX_INPROC_SERVER,IID_ITryCOM,(void**)&amp;it);        //检测是否加载成功        if(SUCCEEDED(hr)){            long ReturnValue ;            printf(&quot;Find DLL\n&quot;);            int a= 1;            int b = 2;            it-&gt;Add(a,b,&amp;ReturnValue);            printf(&quot;%d&quot;,ReturnValue);            //对于com对象，使用后都要使用release进行释放            it-&gt;Release();        }        //关闭当前线程的COM库，卸载所有dll，并释放资源。        CoUninitialize();    }    system(&quot;pause&quot;);    return 0;}</code></pre><p>2.使用CoGetClassObject来创建COM对象。</p><pre><code>//要加载生成的文件和这个c文件。#include &quot;ATLProject1_i.h&quot;#include &quot;ATLProject1_i.c&quot;int _tmain(int argc, _TCHAR* argv[]){    //声明的是接口的指针    ITryCOM *it = NULL;    //一个工厂对象的指针    IClassFactory *ifp = NULL ;    //声明一个HRESULT变量    HRESULT hr;    //初始化COM，并告诉Windows以单线程的方式创建COM对象    hr = CoInitialize(0);    //使用SUCCEDED宏判断是否初始化成功。    if(SUCCEEDED(hr)){        //加载厂类        hr = CoGetClassObject(CLSID_TryCOM,CLSCTX_INPROC_SERVER    ,NULL,IID_IClassFactory,(void**)&amp;ifp);        //检测是否加载成功        if(SUCCEEDED(hr)){            hr = ifp-&gt;CreateInstance(NULL,IID_ITryCOM,(void**)&amp;it);//使用工厂创建COM对象            ifp-&gt;Release();//释放            if(SUCCEEDED(hr)){                long ReturnValue ;                printf(&quot;Find DLL\n&quot;);                int a= 1;                int b = 2;                it-&gt;Add(a,b,&amp;ReturnValue);                printf(&quot;%d&quot;,ReturnValue);                //对于com对象，使用后都要使用release进行释放                it-&gt;Release();//释放            }        }        //关闭当前线程的COM库，卸载所有dll，并释放资源。        CoUninitialize();    }    system(&quot;pause&quot;);    return 0;}</code></pre><p>3.忽略远程创建实例函数EX，最后在来考虑一下不使用CoCreateInstance or CoGetClassObject,直接从dll中得到DllGetClassObject，接着生成类对象及类实例（本方法适合于你想用某个组件，却不想在注册表中注册该组件）。之前的两个函数能调用，是因为其在系统中通过注册表对其唯一的ID进行了DLL的注册，所以调用这两个函数，使其能从系统中获得对应的DLL。最后是一个不注册dll的方法。</p><pre><code>//要加载生成的文件和这个c文件。#include &quot;ATLProject1_i.h&quot;#include &quot;ATLProject1_i.c&quot;int _tmain(int argc, _TCHAR* argv[]){    //定义一个这样的函数指针    typedef HRESULT (__stdcall * pfnGCO) (REFCLSID, REFIID, void**);    //声明一个函数指针    pfnGCO fnGCO = NULL;    //加载dll    HINSTANCE hdllInst = LoadLibrary(&quot;D:/360data/重要数据/我的文档/Visual Studio 2012/Projects/TryDll/TryDll/ATLProject1.dll&quot;);    //在dll中寻找DllGetClassObject函数，并将其赋值给fnGCO指针，是fnGCO指针可以进行创建工厂类的操作    fnGCO = (pfnGCO)GetProcAddress(hdllInst, &quot;DllGetClassObject&quot;);    if (fnGCO != 0)    {        //工厂对象        IClassFactory* pcf = NULL;        //释放fnGCO函数，即DllGetClassObject函数来获得一个工厂类对象，然后就是正常使用工厂类对象创建COM对象的操作了        HRESULT hr= (fnGCO) (CLSID_TryCOM, IID_IClassFactory, (void**)&amp;pcf);        if (SUCCEEDED(hr) &amp;&amp; (pcf != NULL))        {            ITryCOM* iTry = NULL;            hr = pcf-&gt;CreateInstance(NULL, IID_ITryCOM, (void**)&amp;iTry);            if (SUCCEEDED(hr) &amp;&amp; (iTry != NULL))            {                long ReturnValue ;                printf(&quot;Find DLL\n&quot;);                int a= 1;                int b = 2;                iTry-&gt;Add(a,b,&amp;ReturnValue);                printf(&quot;%d&quot;,ReturnValue);                iTry-&gt;Release();            }            pcf-&gt;Release();        }    }    //释放加载的dll    FreeLibrary(hdllInst);    system(&quot;pause&quot;);    return 0;}</code></pre><h2 id="总结一下在VC中调用COM组件的方法"><a href="#总结一下在VC中调用COM组件的方法" class="headerlink" title="总结一下在VC中调用COM组件的方法"></a><a href="https://bbs.csdn.net/topics/50319093" target="_blank" rel="noopener">总结一下在VC中调用COM组件的方法</a></h2><p>一、最简单最常用的一种，用#import导入类型库，利用VC提供的智能指针包装类</p><p>二、引入midl.exe产生的<em>.h,</em>_i.c文件，利用CoCreateInstance函数来调用</p><p>三、不用CoCreateInstance，直接用CoGetClassObejct得到类厂对象接口，然后用该接口的方法CreateInstance来生成实例。</p><p>四、不用CoCreateInstance or CoGetClassObject,直接从dll中得到DllGetClassObject，接着生成类对象及类实例（本方法适合于你想用某个组件，却不想在注册表中注册该组件）</p><p>在MFC中调用</p><p>在MFC中除了上面的几种方法外，还有一种更方便的方法，就是通过ClassWizard利用类型库生成包装类，不过有个前提就是com组件的接口必须是派生自IDispatch</p><p>具体方法：<br>１、按Ctrl+W调出类向导，按Add Class按钮弹出新菜单，选From a type libarary，然后定位到simpCOM.dll，接下来会出来该simpCOM中的所有接口，选择你想生成的接口包装类后，向导会自动生成相应的.cpp和.h文件.<br>这样你就可以在你的MFC工程中像使用普通类那样使用COM组件了.</p><p><a href="http://www.cppblog.com/woaidongmao/archive/2011/01/10/138250.aspx" target="_blank" rel="noopener">vc中调用Com组件的方法详解</a></p><p><a href="http://www.zeroplace.cn/article.asp?id=628" target="_blank" rel="noopener">vc中调用Com组件的方法详解</a></p><h2 id="c-简单的ATL-COM开发和调用实例"><a href="#c-简单的ATL-COM开发和调用实例" class="headerlink" title="c++简单的ATL COM开发和调用实例"></a><a href="https://blog.csdn.net/ghevinn/article/details/31729951?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">c++简单的ATL COM开发和调用实例</a></h2><p>1、在MFC中调用有一种很方便的方法，就是通过ClassWizard利用类型库生成包装类，不过有个前提就是com组件的接口必须是派生自IDispatch。<br>具体方法：</p><p>（1）VS2010新建一个MFC基于对话框程序，调出类向导，点击“添加类”下拉菜单，选择“类型库中的MFC类”（From a type libarary）。</p><p>（2）选“注册表”，然后在“可用类型库”中定位到FirstCOMLib<1.0>，接下来会出来该库中的所有接口，选择你想生成的接口包装类IFirstClass后点击“完成”，向导会自动生成相应的.h文件,这样你就可以在你的MFC工程中像使用普通类那样使用COM组件了.</1.0></p><h1 id="tlb"><a href="#tlb" class="headerlink" title="tlb"></a>tlb</h1><p>类型库文件，一般是COM技术所生成的东东的库，是IDL语言编写的.idl文件编译以后产生的东东，生成这个文件是为了让其他非C语言的程序使用的</p><p>tlb是在生成com时产生的,提供了该com的接口函数。在其他程序中想要引用已经有的COM中的方法<br>就可以import “*.tlb” 之后就可以调用里面的方法和函数了。打开看一下.tlb文件就明白了，<br>里面是一些须函数。</p><h2 id="生成tlb文件："><a href="#生成tlb文件：" class="headerlink" title="生成tlb文件："></a>生成tlb文件：</h2><ul><li>使用命令midl XXX.idl来成成tlb文件即可</li><li>直接使用VC6或者Visual Studio打开dll文件，注意在打开文件对话框中一定要选择Resource方式，VC6默认是auto.找到资源中的TypeLib，其中的文件可以Export成bin，这个bin就是tlb,保存的时候使用将扩展名指定为tlb即可。</li></ul><p>使用Visual Studio的Object Viewer可以直接对tlb文件进行查看。</p><h2 id="使用tlb"><a href="#使用tlb" class="headerlink" title="使用tlb"></a>使用tlb</h2><p><code>#import &quot;ATLProject1.tlb&quot; no_namespace</code>, 然后重新编译生成<code>*.tlh</code>与<code>*.tli</code>。</p><p>Visual Studio有很多内置的支持将类型库导入到C++项目中，并使用这些定义的对象。例如，您可以使用#import指令：</p><pre><code>#import &quot;CANoe.tlb&quot;</code></pre><p>这将导入类型库，并将其转换为头文件和实现文件 - 也会导致实现文件与您的项目和头文件一起构建，因此这里有很多魔术。 然后，为类型库中定义的类型和对象提供了大量针对智能指针包装的typedef。例如，如果有一个名为Application的CoClass实现了IApplication接口，那么可以这样做：</p><pre><code>ApplicationPtr app(__uuidof(Application));</code></pre><p>这会在运行时导致创建coclass应用程序并绑定到变量app，您可以像这样调用它：</p><pre><code>app-&gt;DoSomeCoolStuff();</code></pre><p>通过检查COM调用的结果来完成错误处理，并根据需要抛出相应的<code>_com_error</code>异常，这意味着您需要安全地编写异常。</p><p>更简单的方法是使用 #include 语句将.h和_i.c项目包含在.cpp文件中。</p><p>要创建接口指针，其中一种更安全的方法是使用CComPTR，如下所示：</p><pre><code>CComPtr myPtr;myPtr.CoCreateInstance(__uuidof(&quot;ClassNamehere&quot;));myPtr-&gt;Method(....);</code></pre><h1 id="实现的事件处理接口"><a href="#实现的事件处理接口" class="headerlink" title="实现的事件处理接口"></a><a href="https://docs.microsoft.com/zh-cn/cpp/atl/implementing-the-event-handling-interface" target="_blank" rel="noopener">实现的事件处理接口</a></h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>tlb、oxc、dll文件</p><p>vc6.0项目中：</p><p>Comments:</p><pre><code>regsvr32 /s /c &quot;$(TargetPath)&quot; echo regsvr32 exec. time &gt; &quot;$(OutDir)\regsvr32.trg&quot; </code></pre><p>Outputs:</p><pre><code>$(OutDir)\regsvr32.trg</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>可以<code>include &quot;xx_i.h&quot;、include &quot;xx_i.c&quot;</code>文件</p><p>也可以<code>#import &quot;xx.tlb&quot; no_namespace</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发ActiveX控件有两种方式，一是MFC,二是ATL,而后者是专门用于COM组件开发&lt;/p&gt;
&lt;h1 id=&quot;书&quot;&gt;&lt;a href=&quot;#书&quot; class=&quot;headerlink&quot; title=&quot;书&quot;&gt;&lt;/a&gt;书&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Visual C++实践与提高-
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="COM" scheme="https://caojingyou.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>Boost与设计模式</title>
    <link href="https://caojingyou.github.io/2018/05/24/Boost%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/05/24/Boost与设计模式/</id>
    <published>2018-05-24T01:16:00.000Z</published>
    <updated>2018-05-30T01:03:36.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>面向对象的软件开发的基础是对象。随着系统的不断演化,会出现越来越多的对象,如果单纯使用C++提供的new操作符,将使程序中到处都是硬编码的对象创建代码,很难适应变,化。而创建型模式抽象了类的实例化过程,它封装了对象的创建动作,使对象的创建可以独立.于系统的其他部分。</p><h2 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂(Abstract Factory)"></a>抽象工厂(Abstract Factory)</h2><p>抽象工厂模式把对象的创建封装在一个类中,这个类唯一的任务就是按需生产各种对象,通过派生子类的方式抽象工厂可以生产不同系列的、整套的对象。工厂类通常是单件,以保证,在系统的任何地方都可以访问,其中的每个方法都是工厂方法。在较小的软件系统中,抽象工,厂有时候会退化成一个没有子类的简单工厂。</p><p>xpressive库有一个抽象工厂regex_compiler,可以生产各种正则表达式解析对象,但它用模板技术而不是继承实例化出了具体的工厂。</p><h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器(Builder)"></a>生成器(Builder)</h2><p>生成器模式分解了复杂对象的创建过程,创建过程可以被子类改变,使同样的过程可以生产出不同的对象。生成器与抽象工厂不同,它不是一次性地创建出产品,而是分步骤逐渐地“装配”出对象,因而可以对创建过程进行更精细的控制。</p><p>Boost库没有生成器模式的具体应用,因为生成器模式主要用来构造复杂的对象,对于库来说复杂的创建过程会令库难以使用。</p><p>multi_array对象的创建过程类似生成器模式,它先用模板参数设定基本维数,然后再逐个指定各个维度,最后生成一个多维数组。</p><h2 id="工厂方法-Factory-Method"><a href="#工厂方法-Factory-Method" class="headerlink" title="工厂方法(Factory Method)"></a>工厂方法(Factory Method)</h2><p>工厂方法模式是另一种生产对象的方式,它把对象的创建封装在一个方法中,子类可以改变工厂方法的生产行为生产不同的对象。工厂方法所属的类不一定是工厂类(抽象工厂或者生成器),它可能是一个普通类、一个框架类,或者是一个自由函数。</p><p>Boost 库中的 make_shared () 、make_optional() 、make_tuple ()、regex&lt;&gt;:: complie ()等函数都属于工厂方法模式。而functional/factory组件则实现了对new操作符的完全封装,类似于泛化的make_pair ()、 make_optional()。</p><h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型(Prototype)"></a>原型(Prototype)</h2><p>原型模式使用类的实例通过拷贝的方式创建对象,具体的拷贝行为可以定制,它最常见的用法是为类实现一个clone()成员函数,这个函数创建,个与原型相同或相似的新对象。</p><p>weak_ptr的enable_shared _rom_this用法类似于一个原型模式,它创建了一个指向自身的shared_ptr, exception库提供了一个enable_current_exception()函数,它被用于线程安全地处理异常,返回一个clone的异常对象。</p><p>指针容器库pointer_container容纳的指针不允许共享,如果要拷贝指针容器,则需要被容纳的元素提供clone()操作,使用原型模式创建一个等价的副本。</p><h2 id="单件-Singleton"><a href="#单件-Singleton" class="headerlink" title="单件(Singleton)"></a>单件(Singleton)</h2><p>单件模式保证类有且仅有一个实例,并且提供一个全局的访问点。通常的全局变量技术虽,然也可以提供类似的功能,但它不能防止用户创建多个实例。单件的基本原理很简单,但有很,多实现的变化。</p><p>Boost库目前没有专门的单件库,但在serialization库提供了一个可用的实现。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式专注于如何组合类或对象,进而形成更大更有用的新对象。</p><p>组合对象有两种方式:第一种是C++语言本身提供的继承机制,但它在编译期就已经确定,了对象的关系,无法在运行时改变,缺乏足够的灵活性。第二种方法是运行时对象组合,不同的对象之间彼此互相独立,仅通过定义良好的接口通信协同工作,它更灵活和易于模块化,但因为组合方式富有变化而较难以理解。</p><h2 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器(Adapter)"></a>适配器(Adapter)</h2><p>适配器模式把一个类的接口转换(适配)为另一个接口,从而在不改变原有代码的基础上,复用原代码。它的别名wrapper更清晰地说明了它的实现结构:包装了原有对象,再给出一个新的接口。</p><p>array类是适配器模式的一个很好例子,它把原始数组适配成了符合STL标准的容器,<br>使数组可以与其他标准库组件(算法、迭代器、其他容器)协同工作。同样, multi_ array_ref和const_multi_array_ref把原始数组适配成了Boost的多维数组容器。</p><p>thread库的lockable_adapter是适配器类用法的例子,它工作在编译期,把一个类适配为可以被锁定的类型,用于多线程环境编程。</p><h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接(Bridge )"></a>桥接(Bridge )</h2><p>桥接模式分离了类的抽象和实现,使它们可以彼此独立地变化而互不影响。桥接模式与适配器模式有些相似,在两个对象之间加入了一个中间层次,提供间接联系增加了系统的灵活性。但两者的意图不同,适配器模式关心的是接口不匹配的问题,不关心接口的实现,只要求对象能,够协同工作。桥接模式的侧重点是接口和实现,通常接口是稳定的,桥接解决实现的变化问题。</p><p>智能指针的pimpl用法是桥接模式的一个应用,它向外界提供接口的同时并没有暴露任,何内部的实现信息,因此实现可以任意地改变而不会影响到使用接口的客户代码。</p><p>桥接模式的另一个例子是随机数库random的硬件随机数发生器。random_device的对外,接口不变,而内部的pimpl指针可以采用不同的硬件设备从而有不同的实现。</p><h2 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合(Composite)"></a>组合(Composite)</h2><p>组合模式将小对象组合成树形结构,使用户操作组合对象如同操作一个单个对象。组合模,式定义了“部分一整体”的层次结构,基本对象可以被组合成更大的对象,而且这种操作是可重复的,不断重复下去就可以得到一个非常大的组合对象,但这些组合对象与基本对象拥有相,同的接口,因而组合是透明的,用法完全一致。</p><p>xpressive库就利用了组合模式,它定义了许多小的正则表达式元素,通过重载操作符把它们逐个组合起来,形成一个大的正则表达式,而这些正则表达式又可以被继续组合下去。</p><p>property_tree更好地诠释了组合模式。属性树的每一个子节点也是属性树,属性树可以有任意复杂的组合,但最终呈现给用户的还是一个basic ptree接口,使用时完全不需要关心它内部的复杂结构,这是一个透明的接口。</p><p>multi_array也是组合模式的一个具体应用,它是递归定义的,每个维度都是一个multi_array。</p><h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰(Decorator)"></a>装饰(Decorator)</h2><p>装饰模式可以在运行时动态地给对象增加功能。它也是对对象的包装,但与适配器模式不,同的是它并没有改变被包装对象的接口,只是改变了它的能力范围,而且可以递归组合。<br>通过生成子类的方式也可以为对象增加功能,但它是静态的,而且大量的功能组合很容易,产生“子类爆炸”现象。装饰模式可以动态、透明地给对象增加职责,并且在不需要的时候很,容易去除,使用派生子类的方式无法达到这种灵活程度。</p><p>operators库的基类链技术很类似装饰模式,用后一个运算概念装饰前一个运算概念,不断组,合增加了操作符重载的能力,但它是运用泛型编程技术在编译期实现的。</p><h2 id="外观-Facade"><a href="#外观-Facade" class="headerlink" title="外观(Facade)"></a>外观(Facade)</h2><p>外观模式为系统中的大量对象提供一个一致的对外接口,以简化系统的使用。外观是另-种形式的wrapper,它不是包装一个对象,而是包装一组对象,简化了这组对象间的通信关系,给出一个高层次的易用接口。但外观并不屏蔽系统里的对象,如果需要,用户完全可以越过外观的包装使用底层对象以获得更灵活的功能。</p><p>随机数库random的变量发生器就是一个外观模式,它屏蔽了random库内部的大量细,节,给用户提供一个可轻松生成随机数的operator ()。</p><h2 id="享元-Flyweight"><a href="#享元-Flyweight" class="headerlink" title="享元(Flyweight)"></a>享元(Flyweight)</h2><p>享元模式使用共享的方式节约内存的使用,可以支持大量细粒度的对象。它将对象的内部,状态与外部状态分离,配合工厂模式(抽象工厂或工厂方法)生成仅有内部状态的小对象,工厂内部保持小对象的引用计数从而实现共享,外部状态可以通过计算得到。</p><p>xpressive库的regex_compiler不仅是一个抽象工厂模式,它同时也是享元模式,在内部保存了所有正则表达式对象从而实现共享。Boost里还有一个flyweight库直接实现了享元模式。</p><h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理(Proxy)"></a>代理(Proxy)</h2><p>代理模式与适配器模式、装饰模式很像,也包装对象,但它的意图不是改变接口插入新系统(适配),也不是为对象增加职责(装饰),而是要控制对象。外界不能直接访问对象,必须通过代理才能与被包装的对象通信。</p><p>代理模式的应用非常广泛, smart_ptr库就是代理模式的最佳应用。scoped_ptr.shared_ptr等智能指针包装了原始指针,代理了原始指针的职能,用户只需使用智能指针的代理就可以获得原始指针同样的功能,而且不用担心资源泄漏,因为智能指针控制了原始指针的行为。</p><p>bind. optional, ref和function也属于代理模式,它们都包装了原始的对象或者函数,为它们提供一定程度的控制,在需要时把消息转发给原始的对象或函数完成工作。</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><p>行为模式关注的是程序运行时的对象通信和职责分配,跟踪动态的、复杂的控制流和消息,流,比创建型模式和结构型模式更难于掌握。通常对象一旦创建,它们就立即联系起来,这种联系是动态的,很难甚至不可能从代码中看出来。行为模式以可文档化的形式描述对象通信机,制,可以帮助我们深入了解把握对象之间的关系。</p><p>行为模式大都采用对象组合,封装程序的可变部分。</p><h2 id="职责链-Chain-of-Responsibility"><a href="#职责链-Chain-of-Responsibility" class="headerlink" title="职责链(Chain of Responsibility)"></a>职责链(Chain of Responsibility)</h2><p>职责链模式把对象链成一条链,使链上的每个对象都有机会处理请求。职责链把请求的发,送者和接收者解耦,使两者都互不知情,而且职责链中的对象可以动态地增减,从而增强了处理请求的灵活性。</p><p>assign库的工作原理类似职责链模式,但链上仅有一个对象,它使用重载操作符operator()和operator,,将赋值请求连接成一个链逐个处理,最后完成赋值或初始化工作。</p><p>iostreams库也使用了职责链模式,它定义了source, sink, filter等概念,对象,间可以串联起来,一个的输出作为另一个的输入,完成流处理的功能。</p><h2 id="命令-Command"><a href="#命令-Command" class="headerlink" title="命令(Command)"></a>命令(Command)</h2><p>命令模式把请求封装成一个对象,使请求能够存储更多的信息拥有更多的能力。命令模式,同样能够把请求的发送者和接收者解耦,但它不关心请求将以何种方式被处理。命令模式经常!与职责链模式和组合模式一起使用:职责链模式处理命令模式封装的对象,组合模式可以把简单的命令对象组合成复杂的命令对象。</p><p>exception库是命令模式的一个例子。它把错误信息包装在异常中,使用c++的异常机制传递,直到有一个catch块处理它。</p><h2 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器( Interpreter)"></a>解释器( Interpreter)</h2><p>解释器模式定义了个类体系,用1实现,个小型语言的解释器。它与组合模式很相似,而且常常利用组合模式来实现语法树的构建。</p><p>regex, xpressive, proto, spirit, wave等库都使用了解释器模式,前两者可以解析正则表达式, proto是一个通用的表达式树构建工具, spirit实现了EBNF语法解析器,<br>vave则是C/C++的预处理解析器。</p><p>program_options也是一个解释器模式应用,它可以解析命令行参数这种简单的语法,结构。</p><h2 id="代器-Iterator"><a href="#代器-Iterator" class="headerlink" title="代器(Iterator)"></a>代器(Iterator)</h2><p>迭代器模式把按某种顺序访问一个集合中的元素的方式封装在一个对象中,从而无须知道,售合的内部表示就可以访问集合。</p><p>迭代器模式可能是面向对象软件开发中应用的最广泛的一个设计模式,在STL中就已经有了大量的迭代器实践,它是泛化的指针,被用于以正序或逆序遍历容器内的元素。boost.iterators和boost.range在STL的基础上进一步深化创新了迭代器的概念。</p><h2 id="中介者-Mediator"><a href="#中介者-Mediator" class="headerlink" title="中介者(Mediator)"></a>中介者(Mediator)</h2><p>中介者模式用一个中介对象封装了一系列对象的交互联系,使它们不需要相互了解就可以协同工作。中介者模式在存在大量需要相互通信对象的系统中特别有用,因为对象数量的增加,会使对象间的联系非常复杂,整个系统变得难以理解难以改动。这时中介者可以把这些对象解,耦,每个对象只需要与中介对象通信,中介对象集中了控制逻辑,降低了系统的通信复杂度。</p><p>中介者模式与观察者模式是相互竞争的模式,通常观察者模式比中介者模式更容易生成可,复用的对象,中介者模式如果使用不当很容易导致中介对象过度复杂,抵消了模式带来的好处。</p><p>Boost库暂没有中介者模式的应用例子。</p><h2 id="备忘录-Memento"><a href="#备忘录-Memento" class="headerlink" title="备忘录(Memento)"></a>备忘录(Memento)</h2><p>备忘录模式可以捕获一个对象的内部状态,并在对象之外保存该状态,在之后可以随时把,|对象恢复到之前保存的状态。</p><p>io_state_savers库的实现类似备忘录模式,它可以保存10流的各种状念,在析构时,自动恢复,防止10流因状态异常而发生错误。</p><h2 id="观察者-Observer"><a href="#观察者-Observer" class="headerlink" title="观察者(Observer)"></a>观察者(Observer)</h2><p>观察者模式定义了对象间一对多的联系,当个对象的状态发生变化时,所有与它有联系的观察者对象都会得到通知。观察者模式将被观察的目1标和观察者解糊,个11标可以有任意多的观察者,观察者也可以观察任意多的1标,构成复杂的联系,而每个观察者都不知道其他,观察者的存在。</p><p>观察者模式是一个非常著名、威力强大的设计模式,很多编程语言都有它不同形式的实现,<br>如Java的Observable/observer和C#的event/delegate.Boost库提供signals2,完全实现了观察者模式。</p><h2 id="状态-State"><a href="#状态-State" class="headerlink" title="状态(State)"></a>状态(State)</h2><p>状态模式允许对象在状态发生变化时行为也同时改变。</p><p>状态转换通常的做法是对象内部有一个值来保存当前的状态,根据状态的不同使用,if-else或者switch来执行不同的功能。这样会使类中存在大量结构类似的分支语句,变得难以维护和理解。状态模式消除了分支语句,把状态处理分散到了各个状态子类,每个子类集中处理一种状态,使状态的转换清晰明确。</p><p>boost.statechat和msm库实现了有限状态自动机,它们是状态模式的泛化。</p><h2 id="策略-Strategy"><a href="#策略-Strategy" class="headerlink" title="策略(Strategy)"></a>策略(Strategy)</h2><p>策略模式封装了不同的“算法”,使它们可以在运行时相互替换。它与结构型模式里的装.饰模式功能接近,策略模式改变类的行为内核,而装饰模式改变类的行为外观。如果类的接口很庞大,那么装饰模式的实现代价就过高,而策略模式仅改变类的内核,可能很小。策略模式,的实现结构很像状态模式,但它不改变对象的状态。</p><p>标准库和Boost库中的大量函数对象就是策略模式的应用。函数对象封装了各种操作,标准算法或者其他类使用传入函数对象来动态改变它的行为。</p><p>Boost库中大部分组件的模板类型参数也可以看作是策略模式,通过配置不同的模板类,型,最后实例化的模板类内部的算法都不相同。</p><h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法(Template Method)"></a>模板方法(Template Method)</h2><p>模板方法模式在父类中定义操作的主要步骤,但并不实现,而是留给子类去实现。注意这个模板与C++中泛型编程用的template没有任何联系,不要引起误解。它常见的用法是“钩,子操作”,父类定义了所有的公开方法,在公开方法中调用保护的钩子方法,子类实现不同的,钩子方法来扩展父类的行为。</p><p>模板方法模式是一个非常基本的设计模式,也可能是最容易使用的,个设计模式,许多框!架都使用模板方法定义基本的操作步骤,用户只需实现少量的具体化代码就可以利用框架的全部功能。</p><p>boost. test定义了单元测试的框架,它使用模板方法模式定义了许多可扩展的方法,用户只需要依据test库的规则编写测试用例,就可以插入到UTF中进行测试。</p><h2 id="访问者-Visitor"><a href="#访问者-Visitor" class="headerlink" title="访问者(Visitor)"></a>访问者(Visitor)</h2><p>访问者模式分离了类的内部元素与访问它们的操作,可以在不改变内部元素的情况下增加,作用于它们的新操作。如果一个类有很多内部数据,因此也就有很多访问操作,这样会使它的接口非常庞大,难以变动难以学习。访问者模式可以做到数据的存储与使用分离,不同的访问,者可以集中不同类别的操作,并且可以随时增加新的访问者或者新方法来增加新的操作。</p><p>boost.variant提供static visitor实现了访问者模式,可以对一个很小的variant对象实施各种操作,如果variant对象发生改变, static visitor也可以很容,易地适应变化。</p><h1 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h1><p>推荐书目[11成书于1994年,在那以后软件界开始了广泛的模式运动,在软件开发的各,个领域各个层次都逐步发现了很多新的模式,但最经典最基本的仍然是上面讲到的23个设计模式。本节介绍四个较为常用的其他模式,供读者参考。</p><h2 id="空对象-Null-Object"><a href="#空对象-Null-Object" class="headerlink" title="空对象(Null Object)"></a>空对象(Null Object)</h2><p>空对象模式又称哑对象模式(Dumb object),它是一个行为模式,扩展了空指针的含义,给空指针一个默认的、可接受的行为,通常是空操作,可以说是一个“智能空指针”。使用空对象模式,程序就可以不必用条件语句专门处理空指针或类似的概念,所有的对象都会有一致的、可理解的行为。</p><p>空对象模式可以和许多行为模式配合,充当“哨兵”的角色,完善它们的概念。例如,策略模式有一个空策略对象,它不做任何事情;职责链模式把空对象用在链的末尾,它可以“吞下”所有无法处理的请求;空迭代器对象则适用于叶子节点,表示总完成遍历操作:还可以有空命令、空观察者等等。</p><p>在tuple中的null_type就是个空对象,它表示了一个空的tuple,什么也不做,但它非常重要,没有它就无法完成tuple的部件链。</p><p>空对象模式还可以应用在pointer container库中,使指针容器可以安全地容纳空指,针,用一致的行为处理容器元素。</p><p>空对象模式也不仅用在面向对象的软件构建,操作系统中也有类似的概念,如Linux的,/dev/nul1设备。</p><h2 id="对象池-Object-Pool"><a href="#对象池-Object-Pool" class="headerlink" title="对象池(Object Pool)"></a>对象池(Object Pool)</h2><p>对象池模式属于创建型模式,可以说是一个特殊的工厂模式:它预先创建好若干个可用的.对象,用户向池申请对象,使用完毕归还池而不是直接销毁,所以归还的对象可以被之后的请,求复用。通过这种方式,对象池模式摊平了昂贵的构造成本,消除了对象的销毁成本,可以提,高系统的整体运行效率。</p><p>对象池模式在软件开发中已经得到了广泛的应用,例如耳熟能详的连接池、内存池、线程池等名词。Boost库里的poo1实现了内存池, thread_group则实现了简单的线程池。</p><h2 id="包装外观-Wrapper-Facade"><a href="#包装外观-Wrapper-Facade" class="headerlink" title="包装外观(Wrapper Facade)"></a>包装外观(Wrapper Facade)</h2><p>包装外观模式很类似外观模式,但它包装的目标不是一个面向对象子系统,而是底层的,API。包装外观模式把大量的原始c接口分类整理,给外界一个统一的、面向对象的易用接口,增强了原始底层接口的内聚性,同时又没有效率的损失(可以使用静态成员函数、名字空间和,inline关键字),包装外观模式可以屏蔽系统底层的细节,简化功能调用,有利于外界不受,平台变化的影响,增强可移植性。</p><p>system库是包装外观模式的一个例子,它对UNIX和Windows等操作系统的错误代码,分类包装,对外提供了一个方便使用、易于理解的接口。</p><p>atomic. thread, asio库和interprocess也都在不同的层次上使用了包装外观模,式,提供了可移植的并发处理功能。<br>,</p><h2 id="前摄器模式-Proactor"><a href="#前摄器模式-Proactor" class="headerlink" title="前摄器模式(Proactor)"></a>前摄器模式(Proactor)</h2><p>前摄器模式是应用于异步调用的设计模式,它的核心是前摄器、异步的操作处理器、异步的事件多路分离器和完成事件队列,可以不使用线程实现异步操作。</p><p>前摄器模式的基本流程可以简要描述如下:</p><p>前摄发起器创建一个完成处理器,用于在异步调用完成后的回调,然后发起个异步操作,交给操作处理器异步执行,当是步操作完成时操作处理器将把事件放入宗成事件队列。前摄器调用多路分离器从完成事件队列中获得事件, 分派事件回调完成处理器执行所需的后续操作。</p><p>前摄器模式用于异步调用有很多的好处,它封装了并发机制,将并发机制与线程的执行解耦,简化了功能代码的编写,不需要考虑多线程的同步问题,能够提供高性能的异步操作。但它也有缺点,模式比较复杂,处理流程难以理解和调试。</p><p>asio库基于操作系统的异步调用机制实现了可移植的前摄器模式,解耦了应用程序与操作系统,可以高效地实现异步10操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章结合Boost程序库介绍了附录A推荐书目[1]中的23个经典设计模式和4个常用,的其他设计模式。Boost库应用了以上几乎所有的设计模式,因此学习设计模式有助于更好更快地理解Boost组件的结构和用法。</p><p>设计模式通常分为三类,创建型模式管理面向对象系统中对象的产生,结构型模式管理!面向对象系统中对象的组合,行为模式管理面向对象系统中对象的通信。</p><p>创建型模式是程序的基础,因为面向对象系统就是由许许多多的对象组成的,创建型模式能够使对象的创建独立于系统单独变化。最常用的创建型模式是抽象工厂和单件,而且这两者经常联合使用。</p><p>结构型模式把对象组合起来,以获得功能更强大更灵活的对象。使用结构型模式,我们可以避免继承滥用和“子类爆炸”现象,并在不改变原有类的基础上生成许多新的可用对象。最常用的结构型模式有适配器、组合、装饰、外观和代理。</p><p>行为模式确定了多个对象间通信与合作的最佳方式,它刻画了对象之间的合作机制,这种合,作机制高效且能够适应未来的变化。常用的行为模式有迭代器、观察者、状态、策略和访问者。<br>学习设计模式时理解模式的目的、意图和用途很重要,因为编程语言的语法、语义限制,很多设计模式的实现结构很相似甚至完全相同(例如装饰和代理),但不同的设计出发点(意图)和应用领域导致了模式的用法有很大的区别。</p><p>设计模式也经常与重构联系在一起,重构会导致应用设计模式,而设计模式的目的是为了避免将来的重构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建型模式&quot;&gt;&lt;a href=&quot;#创建型模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式&quot;&gt;&lt;/a&gt;创建型模式&lt;/h1&gt;&lt;p&gt;面向对象的软件开发的基础是对象。随着系统的不断演化,会出现越来越多的对象,如果单纯使用C++提供的new操作符,将使
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="Boost" scheme="https://caojingyou.github.io/tags/Boost/"/>
    
      <category term="设计模式" scheme="https://caojingyou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++调试</title>
    <link href="https://caojingyou.github.io/2018/05/23/C++%E8%B0%83%E8%AF%95/"/>
    <id>https://caojingyou.github.io/2018/05/23/C++调试/</id>
    <published>2018-05-23T09:35:00.000Z</published>
    <updated>2018-09-30T01:07:35.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="err-hr"><a href="#err-hr" class="headerlink" title="err,hr"></a><code>err,hr</code></h1><p>调试代码时，监视窗口里面填入<code>“$err,hr”(@err,hr或err,hr)</code></p><p>它的意义相当于让调试器帮你获取GetLastError的值</p><h2 id="Pseudovariables"><a href="#Pseudovariables" class="headerlink" title="Pseudovariables"></a><a href="https://msdn.microsoft.com/en-us/library/ms164891.aspx" target="_blank" rel="noopener">Pseudovariables</a></h2><ul><li>$err    显示通过SetLastError设置的错误代码，何在代码中调用GetLastError效果一样。可以用$err,hr来显示错误代码对应的文本信息</li><li>$handles    显示应用程序中的句柄数量</li><li>$vframe    显示当前栈帧的地址</li><li>$tid    显示当前的线程ID</li><li>$env    显示当前应用的环境变量</li><li>$cmdline    显示运行当前应用的命令行参数</li><li>$pid    显示进程ID</li><li>$registername或@registername    显示寄存器的内容，如果寄存器的名字不和当前其他变量重名，直接写寄存器的名字也行</li><li>$clk    显示clock cycles</li><li>$user    显示运行当前用户的用户信息</li></ul><p>在C#的程序中可以使用的Pseudovariables</p><ul><li>$exception    显示最后的异常信息</li><li>$user    显示运行当前用户的用户信息</li></ul><h1 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h1><p>使用windbg分析dmp文件定位程序bug</p><p><a href="http://www.windbg.org/" target="_blank" rel="noopener">http://www.windbg.org/</a></p><p><a href="https://debugging.wellisolutions.de/windbg-versions/" target="_blank" rel="noopener">https://debugging.wellisolutions.de/windbg-versions/</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p><p><a href="https://blog.csdn.net/hjing1988/article/details/44399093" target="_blank" rel="noopener">调试相关</a></p><p><a href="http://www.zhimengzhe.com/windows/296803.html" target="_blank" rel="noopener">用GFlags和UMDH发现堆内存泄漏</a></p><p><a href="https://blog.csdn.net/lluozh2015/article/details/73611079" target="_blank" rel="noopener">【性能分析】UMDH分析内存泄露</a></p><p><a href="https://blog.csdn.net/flyingleo1981/article/details/78127625" target="_blank" rel="noopener">windbg小工具umdh查找内存泄露</a></p><h1 id="Dbgview"><a href="#Dbgview" class="headerlink" title="Dbgview"></a>Dbgview</h1><p>DebugView跟踪调试信息</p><h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p>生成dump文件</p><p><a href="http://www.debuginfo.com/articles/effminidumps.html" target="_blank" rel="noopener">http://www.debuginfo.com/articles/effminidumps.html</a></p><p><a href="http://www.cppblog.com/woaidongmao/archive/2011/05/10/146086.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2011/05/10/146086.html</a></p><p><a href="http://www.cppblog.com/woaidongmao/archive/2009/10/22/99210.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2009/10/22/99210.html</a></p><p><a href="http://www.cppblog.com/woaidongmao/archive/2009/10/21/99135.html" target="_blank" rel="noopener">http://www.cppblog.com/woaidongmao/archive/2009/10/21/99135.html</a></p><h2 id="SetUnhandledExceptionFilter"><a href="#SetUnhandledExceptionFilter" class="headerlink" title="SetUnhandledExceptionFilter"></a>SetUnhandledExceptionFilter</h2><p>如果在异常发生之前调用了SetUnhandledExceptionFilter()函数。</p><h2 id="set-purecall-handler"><a href="#set-purecall-handler" class="headerlink" title="_set_purecall_handler"></a>_set_purecall_handler</h2><p>调用纯虚函数是一个错误 </p><h2 id="set-terminate"><a href="#set-terminate" class="headerlink" title="set_terminate"></a>set_terminate</h2><p>当CRT遇到一个未被处理的C++类型化异常时，它会调用terminate()函数</p><h2 id="set-purecall-handler-1"><a href="#set-purecall-handler-1" class="headerlink" title="_set_purecall_handler"></a>_set_purecall_handler</h2><p>使用_set_purecall_handler()函数来处理纯虚函数调用</p><h2 id="set-new-handler"><a href="#set-new-handler" class="headerlink" title="_set_new_handler"></a><a href="https://zh.cppreference.com/w/cpp/memory/new/set_new_handler" target="_blank" rel="noopener">_set_new_handler</a></h2><p>使用_set_new_handler()函数处理内存分配失败。</p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;void handler(){    std::cout &lt;&lt; &quot;Memory allocation failed, terminating\n&quot;;    std::set_new_handler(nullptr);}int main(){    std::set_new_handler(handler);    try {        while (true) {            new int[100000000ul];        }    } catch (const std::bad_alloc&amp; e) {        std::cout &lt;&lt; e.what() &lt;&lt; &apos;\n&apos;;    }}</code></pre><h2 id="set-invalid-parameter-handler"><a href="#set-invalid-parameter-handler" class="headerlink" title="_set_invalid_parameter_handler"></a><code>_set_invalid_parameter_handler</code></h2><p>当系统函数调用检测到非法的参数时，会使用_set_invalid_parameter_handler()函数来处理这种情况</p><h1 id="XCrashReport"><a href="#XCrashReport" class="headerlink" title="XCrashReport"></a>XCrashReport</h1><p><a href="https://www.codeproject.com/Articles/5260/XCrashReport-Exception-Handling-and-Crash-Report" target="_blank" rel="noopener">https://www.codeproject.com/Articles/5260/XCrashReport-Exception-Handling-and-Crash-Report</a></p><p><a href="https://blog.csdn.net/ljmscsq/article/details/4998738" target="_blank" rel="noopener">https://blog.csdn.net/ljmscsq/article/details/4998738</a></p><p><a href="https://www.codeproject.com/Articles/207464/Exception-Handling-in-Visual-Cplusplus" target="_blank" rel="noopener">https://www.codeproject.com/Articles/207464/Exception-Handling-in-Visual-Cplusplus</a>-可成功生成dump</p><p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html" target="_blank" rel="noopener">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p><p><a href="https://www.cnblogs.com/kanego/p/4081287.html" target="_blank" rel="noopener">https://www.cnblogs.com/kanego/p/4081287.html</a></p><h1 id="crashrpt"><a href="#crashrpt" class="headerlink" title="crashrpt"></a>crashrpt</h1><p><img src="http://crashrpt.sourceforge.net/images/maindlg.png" alt=""></p><p>可以使用<code>crashrpt</code>直接集成到自己的项目中，程序崩溃是生成错误报告</p><p><a href="http://crashrpt.sourceforge.net/" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/</a></p><p><a href="http://crashrpt.sourceforge.net/docs/html/index.html" target="_blank" rel="noopener">CrashRpt文档</a></p><p><a href="http://crashrpt.sourceforge.net/docs/html/simple_example.html" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/docs/html/simple_example.html</a></p><p><a href="http://crashrpt.sourceforge.net/docs/html/exception_handling.html#getting_exception_context" target="_blank" rel="noopener">关于异常和异常处理</a></p><p>crashrpt是一个包含能够在程序出现各种类型未处理异常时生成程序错误报告，然后将该报告按照指定的方式(例如HTTP或者SMTP)发送给开发者，最后分析这些信息的工具。crashrpt由3个部分组成，错误报告生成库CrashRpt，我们需要在自己的程序中使用该库捕获我们的程序没有处理的异常，在该库捕获到这些未处理的异常后，CrashRpt会生成MiniDump文件，并将和你使用该库指定的信息(例如日志文件和屏幕截图等)一起打包成错误报告。CrashRpt库支持处理我所知道的所有Windows C/C++程序抛出的各类异常，例如我前面提到过的SEH，它还能捕获C++异常、信号和调用各类CRT库中的函数出现的错误。异常信息发送工具CrashSender，该工具能够按照我们使用CrashRpt设置的方式，将生成的错误报告按照我们指定的方式(HTTP、SMTP或者MAPI)发送给我们。自动异常信息处理工具crprober，该工具能够在后台接收CrashSender发送给我们的错误报告，通过分析错误报告后以文本的形式输出程序的异常信息。</p><p><a href="https://blog.csdn.net/shining100/article/details/7760872" target="_blank" rel="noopener">https://blog.csdn.net/shining100/article/details/7760872</a></p><p><a href="http://crashrpt.sourceforge.net/docs/html/configuring_project.html" target="_blank" rel="noopener">http://crashrpt.sourceforge.net/docs/html/configuring_project.html</a></p><h1 id="crashfix"><a href="#crashfix" class="headerlink" title="crashfix"></a>crashfix</h1><p>crashfix CrashRpt的免费和开源服务器，接收、存储、组织及分析事故报告发送的 C + + 应用程序。</p><p>崩溃报告是一种允许接收用户反馈并提高软件质量和稳定性的技术。当您的应用遇到严重错误（也称为异常或崩溃）时，会生成崩溃报告文件并通过Internet发送到您的服务器。CrashFix服务器允许轻松接收，存储，组织和分析C ++应用程序发送的崩溃报告。</p><p><a href="http://crashfix.sourceforge.net/" target="_blank" rel="noopener">http://crashfix.sourceforge.net/</a></p><p><a href="http://crashfix.sourceforge.net/doc/html/index.html" target="_blank" rel="noopener">http://crashfix.sourceforge.net/doc/html/index.html</a></p><p><a href="https://blog.csdn.net/aa13058219642/article/details/80431100#comments" target="_blank" rel="noopener">CrashFix——CrshRpt的分析工具</a></p><h1 id="http-www-debuginfo-com"><a href="#http-www-debuginfo-com" class="headerlink" title="http://www.debuginfo.com"></a><a href="http://www.debuginfo.com" target="_blank" rel="noopener">http://www.debuginfo.com</a></h1><h2 id="MINIDUMPS"><a href="#MINIDUMPS" class="headerlink" title="MINIDUMPS"></a>MINIDUMPS</h2><p><a href="http://www.debuginfo.com/articles/effminidumps.html" target="_blank" rel="noopener">http://www.debuginfo.com/articles/effminidumps.html</a></p><p><a href="http://www.debuginfo.com/examples/effmdmpexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/effmdmpexamples.html</a></p><p><a href="http://www.debuginfo.com/download/effminidumpexamples.zip" target="_blank" rel="noopener">effminidumpexamples.zip</a></p><h2 id="dbghelp"><a href="#dbghelp" class="headerlink" title="dbghelp"></a>dbghelp</h2><p><a href="http://www.debuginfo.com/examples/dbghelpexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/dbghelpexamples.html</a></p><p><a href="http://www.debuginfo.com/download/dbghelpexamples.zip" target="_blank" rel="noopener">dbghelpexamples.zip</a></p><h2 id="DEBUGGING-API-EXAMPLES"><a href="#DEBUGGING-API-EXAMPLES" class="headerlink" title="DEBUGGING API EXAMPLES"></a>DEBUGGING API EXAMPLES</h2><p><a href="http://www.debuginfo.com/examples/dbgexamples.html" target="_blank" rel="noopener">http://www.debuginfo.com/examples/dbgexamples.html</a></p><p><a href="http://www.debuginfo.com/download/dbgexamples.zip" target="_blank" rel="noopener">dbgexamples.zip</a></p><h2 id="MINIDUMP-WIZARD"><a href="#MINIDUMP-WIZARD" class="headerlink" title="MINIDUMP WIZARD"></a>MINIDUMP WIZARD</h2><p><a href="http://www.debuginfo.com/tools/minidumpwizard.html" target="_blank" rel="noopener">http://www.debuginfo.com/tools/minidumpwizard.html</a></p><p><a href="http://www.debuginfo.com/download/minidumpwizfull.zip" target="_blank" rel="noopener">minidumpwizfull.zip</a></p><p><a href="http://www.debuginfo.com/download/minidumpwiz.zip" target="_blank" rel="noopener">minidumpwiz.zip</a></p><h2 id="UNEXPECTED-USER-BREAKPOINT-IN-NTDLL-DLL"><a href="#UNEXPECTED-USER-BREAKPOINT-IN-NTDLL-DLL" class="headerlink" title="UNEXPECTED USER BREAKPOINT IN NTDLL.DLL"></a>UNEXPECTED USER BREAKPOINT IN NTDLL.DLL</h2><p>用户在断点意外 NTDLL. DLL</p><p><a href="http://www.debuginfo.com/tips/userbpntdll.html" target="_blank" rel="noopener">http://www.debuginfo.com/tips/userbpntdll.html</a></p><p><a href="https://www.cnblogs.com/lidabo/p/3706725.html" title="使用PageHeap.EXE或GFlags.EXE检查内存越界错误" target="_blank" rel="noopener">https://www.cnblogs.com/lidabo/p/3706725.html</a></p><h1 id="About-DbgHelp"><a href="#About-DbgHelp" class="headerlink" title="About DbgHelp"></a>About DbgHelp</h1><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms679267%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MSDN-About DbgHelp</a></p><h1 id="STL扩展库"><a href="#STL扩展库" class="headerlink" title="STL扩展库"></a><a href="http://cplusplus.wikidot.com/cn:stdext" target="_blank" rel="noopener">STL扩展库</a></h1><p><a href="http://cplusplus.wikidot.com/cn:memory-management" target="_blank" rel="noopener">内存管理专题（Memory Management）</a></p><h1 id="关于MFC中的-ifdef-DEBUG-undef-THIS-FILE-static-char-THIS-FILE-FILE-endif"><a href="#关于MFC中的-ifdef-DEBUG-undef-THIS-FILE-static-char-THIS-FILE-FILE-endif" class="headerlink" title="关于MFC中的#ifdef _DEBUG #undef THIS_FILE static char THIS_FILE[]=__FILE__; #endif"></a><a href="https://blog.csdn.net/ZYTTAE/article/details/44926393" target="_blank" rel="noopener">关于MFC中的<code>#ifdef _DEBUG #undef THIS_FILE static char THIS_FILE[]=__FILE__; #endif</code></a></h1><p>情况1:</p><pre><code>#ifdef _DEBUGvirtual void AssertValid() const; //assert(断言)valid(有效的，正确的)virtual void Dump(CDumpContext&amp; dc) const; //存储上下文#endif</code></pre><p>这两个函数是调试用的，第一个函数检查可用性，即是否有效。第二个函数如果未更改的话，最终调用的是Cwnd::Dump();输出窗口类名，标题名等一系列信息（在输出窗口中）。</p><pre><code>#ifdef _DEBUG#endif</code></pre><p>这是条件编译，即如果有#define _DEBUG这两个函数会编译，否则忽略。当你用debug生成时（相对于release）开发环境则自动的加上这个宏定义，这两个函数有效。</p><p>情况2:</p><pre><code>#ifdef _DEBUG // 判断是否定义_DEBUG#undef THIS_FILE // 取消THIS_FILE的定义static char THIS_FILE[]=__FILE__; // 定义THIS_FILE指向文件名#define new DEBUG_NEW // 定义调试new宏，取代new关键字#endif // 结束</code></pre><p>如果定义了_DEBUG，表示在调试状态下编译，因此相应修改了两个符号的定义。<br><code>THIS_FILE</code>是一个char数组全局变量，字符串值为当前文件的全路径，这样在Debug版本中当程序出错时出错处理代码可用这个变量告诉你是哪个文件中的代码有问题。</p><p>定义 _DEBUG后，由于定义了_DEBUG,编译器确定这是一个调试，编译<code>#ifdef _DEBUG</code>和<code>#endif</code>之间的代码。<code>#undef</code> 表示清除当前定义的宏，使得<code>THIS_FILE</code>无定义。<br><code>__FILE__</code> 是编译器能识别的事先定义的ANSI C 的6个宏之一。</p><p>DEBUG_NEW定位内存泄露并且跟踪文件名和行号。</p><p>情况3:</p><pre><code>#ifdef _DEBUG //如果是debug状态#undef THIS_FILE //清除THIS_FILEstatic char THIS_FILE[]=__FILE__; //定义THIS_FILE为__FILE__（这是当前文件全路径名字）#define new DEBUG_NEW //定义new为DEBUG_NEW（这个可以检测到内存泄露之类的问题，其实就是可以使用crt开头的那几个调试函数）#endif</code></pre><p>ANSI C 的6个宏：</p><pre><code>__FILE__为预编译器常量，返回当前编译的文件名，还有比较常用的几个预编译器常量；__LINE__编译器正在编译的文件的第几行；__DATE__返回当前的日期Jul-20-2004；__TIME__返回当前的时间hh:mm:ss； __TIMESTAMP__ 的预定义的编译器宏始终返回时间戳信息。在太平洋标准的时间内无论本地时间和CL.EXE 的运行位置在计算机上的时区。__STDC__条件编译，意思是：如果定义了标准C或c++，那么编译这句话后面直到#endif以前的源代码。_STDC__cplusplus这两个都是标准宏，_STDC_表示是是否符合标准C；_cplusplus表示是否是C++。</code></pre><p>曾经一个解释说，多次使用<code>__FILE__</code>宏，虽然得到字符串的内容相同，但是可能地址不同，即同一个字符串常量多次用到时占用不同的地址，这样导致需要的内存增加了。为了检测内在泄露, Debug 版本的 new 附加上了调用 new 的文件名与调用所在的行号信息, 这是通过 <code>__FILE__</code> 和 <code>__LINE__</code> 来实现的, 这两个属于预定义的内部宏, 而之所以要用 <code>THIS_FILE</code> 来代替 <code>__FILE__</code>, 是为了减少程序大小: 如果你在一个文件中有 10000 次对 new 的调用, 那么会生成 10000 个当前文件名的常量字符串(第一个都是由 <code>__FILE__</code> 宏扩展而来的), 最后生成的目标文件会很大, 而用 <code>THIS_FILE</code> 来代替, 当前文件名只有一份, 传递文件名使用 <code>THIS_FILE</code> 指针就可以了。<br><code>__FILE__</code>和<code>__LINE__</code>一样都是编译器定义的宏。当碰到<code>__FILE__</code>时，编译器会把<code>__FILE__</code>替换成一个字符串，这个字符串就是当前在编译的文件的路径名。在<code>DEBUG_NEW</code>的定义中没有直接使用<code>__FILE__</code>，而是用了<code>THIS_FILE</code>，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用<code>__FILE__</code>，那编译器会产生100个常量字符串，这100个字符串都是这个cpp文件的路径名，显然十分冗余。如果使用<code>THIS_FILE</code>，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。</p><p>在MFC中，可以使用 <code>DEBUG_NEW</code> 宏代替 new 运算符来帮助定位内存泄漏。在程序的“Debug”版本中，<code>DEBUG_NEW</code> 将为所分配的每个对象跟踪文件名和行号。当编译程序的“Release”版本时，<code>DEBUG_NEW</code> 将解析为不包含文件名和行号信息的简单 new 操作。因此，在程序的“Release”版本中不会造成任何速度损失。 </p><h1 id="最快速度找到内存泄漏"><a href="#最快速度找到内存泄漏" class="headerlink" title="最快速度找到内存泄漏"></a><a href="http://cplusplus.wikidot.com/cn:the-fastest-way-to-find-memory-leak" target="_blank" rel="noopener">最快速度找到内存泄漏</a></h1><h1 id="dmp调试"><a href="#dmp调试" class="headerlink" title="dmp调试"></a>dmp调试</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/d5zhxt22.aspx" target="_blank" rel="noopener">使用转储文件在 Visual Studio 中调试应用程序崩溃和挂起</a></p><p>exe + pdb + dmp 在同一目录，然后双击dmp文件VC就可以打开，然后点击右上角的调试按钮就可以直接定位到崩溃的代码了；</p><h1 id="适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）"><a href="#适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）" class="headerlink" title="适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）"></a><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index" target="_blank" rel="noopener">适用于Windows的调试工具（WinDbg，KD，CDB，NTSD）</a></h1><h1 id="SEH（结构化异常处理）"><a href="#SEH（结构化异常处理）" class="headerlink" title="SEH（结构化异常处理）"></a>SEH（结构化异常处理）</h1><p><a href="https://blog.csdn.net/xuhao_xuhao/article/details/49519695" target="_blank" rel="noopener">异常和异常处理（windows平台）</a></p><p><a href="https://blog.csdn.net/aa13058219642/article/details/80253609" target="_blank" rel="noopener">深入解析结构化异常处理(SEH)</a></p><h1 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h1><p><a href="https://blog.csdn.net/hjing1988/article/details/50933735" target="_blank" rel="noopener">CRT内存泄露检测</a></p><p><a href="https://blog.csdn.net/hongxingabc/article/details/49873541?locationNum=4" target="_blank" rel="noopener">内存泄露检测之使用CRT的Debug技术</a></p><h1 id="MemTrack"><a href="#MemTrack" class="headerlink" title="MemTrack"></a><a href="http://www.almostinfinite.com/memtrack.html" target="_blank" rel="noopener">MemTrack</a></h1><p>Appendix A: MemTrack.h</p><pre><code>/*Copyright (c) 2002, 2008 Curtis BartleyAll rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditionsare met:- Redistributions of source code must retain the above copyrightnotice, this list of conditions and the following disclaimer.- Redistributions in binary form must reproduce the above copyrightnotice, this list of conditions and the following disclaimer in thedocumentation and/or other materials provided with thedistribution.- Neither the name of Curtis Bartley nor the names of any othercontributors may be used to endorse or promote products derivedfrom this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOTLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESSFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THECOPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ORSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISEDOF THE POSSIBILITY OF SUCH DAMAGE.*/#ifndef MemTrack_H_#define MemTrack_H_#include &lt;typeinfo&gt;namespace MemTrack{    /* ---------------------------------------- class MemStamp */    class MemStamp    {        public:        // member variables            char const * const filename;            int const lineNum;        public:        // construction/destruction            MemStamp(char const *filename, int lineNum)                : filename(filename), lineNum(lineNum) { }            ~MemStamp() { }    };    /* ---------------------------------------- memory allocation and stamping prototypes */    void *TrackMalloc(size_t size);    void TrackFree(void *p);    void TrackStamp(void *p, const MemStamp &amp;stamp, char const *typeName);    void TrackDumpBlocks();    void TrackListMemoryUsage();    /* ---------------------------------------- operator * (MemStamp, ptr) */    template &lt;class T&gt; inline T *operator*(const MemStamp &amp;stamp, T *p)    {        TrackStamp(p, stamp, typeid(T).name());        return p;    }}    // namespace MemTrack/* ---------------------------------------- new macro */#define MEMTRACK_NEW MemTrack::MemStamp(__FILE__, __LINE__) * new#define new MEMTRACK_NEW#endif    // MemTrack_H_</code></pre><p>Appendix B: MemTrack.cpp</p><pre><code>/*Copyright (c) 2002, 2008 Curtis BartleyAll rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditionsare met:- Redistributions of source code must retain the above copyrightnotice, this list of conditions and the following disclaimer.- Redistributions in binary form must reproduce the above copyrightnotice, this list of conditions and the following disclaimer in thedocumentation and/or other materials provided with thedistribution.- Neither the name of Curtis Bartley nor the names of any othercontributors may be used to endorse or promote products derivedfrom this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOTLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESSFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THECOPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ORSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISEDOF THE POSSIBILITY OF SUCH DAMAGE.*//* ---------------------------------------- includes */#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;new&gt;#include &quot;MemTrack.h&quot;#undef new    // IMPORTANT!/* ------------------------------------------------------------ *//* -------------------- namespace MemTrack -------------------- *//* ------------------------------------------------------------ */namespace MemTrack{    /* ------------------------------------------------------------ */    /* --------------------- class BlockHeader -------------------- */    /* ------------------------------------------------------------ */    class BlockHeader    {        private:    // static member variables            static BlockHeader *ourFirstNode;        private:    // member variables            BlockHeader *myPrevNode;            BlockHeader *myNextNode;            size_t myRequestedSize;            char const *myFilename;            int myLineNum;            char const *myTypeName;        public:     // members            BlockHeader(size_t requestedSize);            ~BlockHeader();            size_t GetRequestedSize() const { return myRequestedSize; }            char const *GetFilename() const { return myFilename; }            int GetLineNum() const { return myLineNum; }            char const *GetTypeName() const { return myTypeName; }            void Stamp(char const *filename, int lineNum, char const *typeName);            static void AddNode(BlockHeader *node);            static void RemoveNode(BlockHeader *node);            static size_t CountBlocks();            static void GetBlocks(BlockHeader **blockHeaderPP);            static bool TypeGreaterThan(BlockHeader *header1, BlockHeader *header2);    };    /* ---------------------------------------- BlockHeader static member variables */    BlockHeader *BlockHeader::ourFirstNode = NULL;    /* ---------------------------------------- BlockHeader constructor */    BlockHeader::BlockHeader(size_t requestedSize)    {        myPrevNode = NULL;        myNextNode = NULL;        myRequestedSize = requestedSize;        myFilename = &quot;[unknown]&quot;;        myLineNum = 0;        myTypeName = &quot;[unknown]&quot;;    }    /* ---------------------------------------- BlockHeader destructor */    BlockHeader::~BlockHeader()    {    }    /* ---------------------------------------- BlockHeader Stamp */    void BlockHeader::Stamp(char const *filename, int lineNum, char const *typeName)    {        myFilename = filename;        myLineNum = lineNum;        myTypeName = typeName;    }    /* ---------------------------------------- BlockHeader AddNode */    void BlockHeader::AddNode(BlockHeader *node)    {        assert(node != NULL);        assert(node-&gt;myPrevNode == NULL);        assert(node-&gt;myNextNode == NULL);        // If we have at least one node in the list ...                if (ourFirstNode != NULL)        {            // ... make the new node the first node&apos;s predecessor.            assert(ourFirstNode-&gt;myPrevNode == NULL);            ourFirstNode-&gt;myPrevNode = node;        }        // Make the first node the new node&apos;s succesor.        node-&gt;myNextNode = ourFirstNode;        // Make the new node the first node.        ourFirstNode = node;    }    /* ---------------------------------------- BlockHeader RemoveNode */    void BlockHeader::RemoveNode(BlockHeader *node)    {        assert(node != NULL);        assert(ourFirstNode != NULL);        // If target node is the first node in the list...        if (ourFirstNode == node)        {            // ... make the target node&apos;s successor the first node.            assert(ourFirstNode-&gt;myPrevNode == NULL);            ourFirstNode = node-&gt;myNextNode;        }        // Link target node&apos;s predecessor, if any, to its successor.        if (node-&gt;myPrevNode != NULL)        {            node-&gt;myPrevNode-&gt;myNextNode = node-&gt;myNextNode;        }        // Link target node&apos;s successor, if any, to its predecessor.        if (node-&gt;myNextNode != NULL)        {            node-&gt;myNextNode-&gt;myPrevNode = node-&gt;myPrevNode;        }        // Clear target node&apos;s previous and next pointers.        node-&gt;myPrevNode = NULL;        node-&gt;myNextNode = NULL;    }    /* ---------------------------------------- BlockHeader CountBlocks */    size_t BlockHeader::CountBlocks()    {        size_t count = 0;        BlockHeader *currNode = ourFirstNode;        while (currNode != NULL)        {            count++;            currNode = currNode-&gt;myNextNode;        }        return count;    }    /* ---------------------------------------- BlockHeader GetBlocks */    void BlockHeader::GetBlocks(BlockHeader **blockHeaderPP)    {        BlockHeader *currNode = ourFirstNode;        while (currNode != NULL)        {            *blockHeaderPP = currNode;            blockHeaderPP++;            currNode = currNode-&gt;myNextNode;        }    }    /* ---------------------------------------- BlockHeader TypeGreaterThan */    bool BlockHeader::TypeGreaterThan(BlockHeader *header1, BlockHeader *header2)    {        return (strcmp(header1-&gt;myTypeName, header2-&gt;myTypeName) &gt; 0);    }    /* ------------------------------------------------------------ */    /* ---------------------- class Signature --------------------- */    /* ------------------------------------------------------------ */    class Signature    {        private:    // constants            static const unsigned int SIGNATURE1 = 0xCAFEBABE;            static const unsigned int SIGNATURE2 = 0xFACEFACE;        private:    // member variables            unsigned int mySignature1;            unsigned int mySignature2;        public:        // construction/destruction            Signature() : mySignature1(SIGNATURE1), mySignature2(SIGNATURE2) {};            ~Signature() { mySignature1 = 0; mySignature2 = 0; }        public:        // static member functions            static bool IsValidSignature(const Signature *pProspectiveSignature)            {                try                {                    if (pProspectiveSignature-&gt;mySignature1 != SIGNATURE1) return false;                    if (pProspectiveSignature-&gt;mySignature2 != SIGNATURE2) return false;                    return true;                }                catch (...)                {                    return false;                }            }    };    /* ------------------------------------------------------------ */    /* -------------------- address conversion -------------------- */    /* ------------------------------------------------------------ */    /* We divide the memory blocks we allocate into two &quot;chunks&quot;, the     * &quot;prolog chunk&quot; where we store information about the allocation,     * and the &quot;user chunk&quot; which we return to the caller to use.     */    /* ---------------------------------------- alignment */    const size_t ALIGNMENT = 4;    /* If &quot;value&quot; (a memory size or offset) falls on an alignment boundary,     * then just return it.  Otherwise return the smallest number larger     * than &quot;value&quot; that falls on an alignment boundary.     */        #define PAD_TO_ALIGNMENT_BOUNDARY(value) \        ((value) + ((ALIGNMENT - ((value) % ALIGNMENT)) % ALIGNMENT))    /* ---------------------------------------- chunk structs */    /* We declare incomplete structures for each chunk, just to      * provide type safety.     */    struct PrologChunk;    struct UserChunk;    /* ---------------------------------------- chunk sizes and offsets */    const size_t SIZE_BlockHeader = PAD_TO_ALIGNMENT_BOUNDARY(sizeof(BlockHeader));    const size_t SIZE_Signature = PAD_TO_ALIGNMENT_BOUNDARY(sizeof(Signature));    const size_t OFFSET_BlockHeader = 0;    const size_t OFFSET_Signature = OFFSET_BlockHeader + SIZE_BlockHeader;    const size_t OFFSET_UserChunk = OFFSET_Signature + SIZE_Signature;    const size_t SIZE_PrologChunk = OFFSET_UserChunk;    /* ---------------------------------------- GetUserAddress */    static UserChunk *GetUserAddress(PrologChunk *pProlog)    {        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);        char *pchUser = pchProlog + OFFSET_UserChunk;        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(pchUser);        return pUser;    }    /* ---------------------------------------- GetPrologAddress */    static PrologChunk *GetPrologAddress(UserChunk *pUser)    {        char *pchUser = reinterpret_cast&lt;char *&gt;(pUser);        char *pchProlog = pchUser - OFFSET_UserChunk;        PrologChunk *pProlog = reinterpret_cast&lt;PrologChunk *&gt;(pchProlog);        return pProlog;    }    /* ---------------------------------------- GetHeaderAddress */    static BlockHeader *GetHeaderAddress(PrologChunk *pProlog)    {        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);        char *pchHeader = pchProlog + OFFSET_BlockHeader;        BlockHeader *pHeader = reinterpret_cast&lt;BlockHeader *&gt;(pchHeader);        return pHeader;    }    /* ---------------------------------------- GetSignatureAddress */    static Signature *GetSignatureAddress(PrologChunk *pProlog)    {        char *pchProlog = reinterpret_cast&lt;char *&gt;(pProlog);        char *pchSignature = pchProlog + OFFSET_Signature;        Signature *pSignature = reinterpret_cast&lt;Signature *&gt;(pchSignature);        return pSignature;    }    /* ------------------------------------------------------------ */    /* -------------- memory allocation and stamping -------------- */    /* ------------------------------------------------------------ */    /* ---------------------------------------- TrackMalloc */    void *TrackMalloc(size_t size)    {        // Allocate the memory, including space for the prolog.        PrologChunk *pProlog = (PrologChunk *)malloc(SIZE_PrologChunk + size);        // If the allocation failed, then return NULL.        if (pProlog == NULL) return NULL;        // Use placement new to construct the block header in place.        BlockHeader *pBlockHeader = new (pProlog) BlockHeader(size);        // Link the block header into the list of extant block headers.        BlockHeader::AddNode(pBlockHeader);        // Use placement new to construct the signature in place.        Signature *pSignature = new (GetSignatureAddress(pProlog)) Signature;        // Get the offset to the user chunk and return it.        UserChunk *pUser = GetUserAddress(pProlog);        return pUser;    }    /* ---------------------------------------- TrackFree */    void TrackFree(void *p)    {        // It&apos;s perfectly valid for &quot;p&quot; to be null; return if it is.        if (p == NULL) return;        // Get the prolog address for this memory block.        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(p);            PrologChunk *pProlog = GetPrologAddress(pUser);        // Check the signature, and if it&apos;s invalid, return immediately.        Signature *pSignature = GetSignatureAddress(pProlog);        if (!Signature::IsValidSignature(pSignature)) return;        // Destroy the signature.        pSignature-&gt;~Signature();        pSignature = NULL;        // Unlink the block header from the list and destroy it.        BlockHeader *pBlockHeader = GetHeaderAddress(pProlog);        BlockHeader::RemoveNode(pBlockHeader);        pBlockHeader-&gt;~BlockHeader();        pBlockHeader = NULL;        // Free the memory block.            free(pProlog);    }    /* ---------------------------------------- TrackStamp */    void TrackStamp(void *p, const MemStamp &amp;stamp, char const *typeName)    {        // Get the header and signature address for this pointer.        UserChunk *pUser = reinterpret_cast&lt;UserChunk *&gt;(p);        PrologChunk *pProlog = GetPrologAddress(pUser);        BlockHeader *pHeader = GetHeaderAddress(pProlog);        Signature *pSignature = GetSignatureAddress(pProlog);        // If the signature is not valid, then return immediately.        if (!Signature::IsValidSignature(pSignature)) return;        // &quot;Stamp&quot; the information onto the header.        pHeader-&gt;Stamp(stamp.filename, stamp.lineNum, typeName);    }    /* ---------------------------------------- TrackDumpBlocks */    void TrackDumpBlocks()    {        // Get an array of pointers to all extant blocks.        size_t numBlocks = BlockHeader::CountBlocks();        BlockHeader **ppBlockHeader =            (BlockHeader **)calloc(numBlocks, sizeof(*ppBlockHeader));        BlockHeader::GetBlocks(ppBlockHeader);        // Dump information about the memory blocks.        printf(&quot;\n&quot;);        printf(&quot;=====================\n&quot;);        printf(&quot;Current Memory Blocks\n&quot;);        printf(&quot;=====================\n&quot;);        printf(&quot;\n&quot;);        for (size_t i = 0; i &lt; numBlocks; i++)        {            BlockHeader *pBlockHeader = ppBlockHeader[i];            char const *typeName = pBlockHeader-&gt;GetTypeName();            size_t size = pBlockHeader-&gt;GetRequestedSize();            char const *fileName = pBlockHeader-&gt;GetFilename();            int lineNum = pBlockHeader-&gt;GetLineNum();            printf(&quot;*** #%-6d %5d bytes %-50s\n&quot;, i, size, typeName);            printf(&quot;... %s:%d\n&quot;, fileName, lineNum);        }        // Clean up.        free(ppBlockHeader);    }    /* ---------------------------------------- struct MemDigest */    struct MemDigest    {        char const *typeName;        int blockCount;        size_t totalSize;        static bool TotalSizeGreaterThan(const MemDigest &amp;md1, const MemDigest &amp;md2)            { return md1.totalSize &gt; md2.totalSize; }    };    /* ---------------------------------------- SummarizeMemoryUsageForType */    static void SummarizeMemoryUsageForType(        MemDigest *pMemDigest,        BlockHeader **ppBlockHeader,        size_t startPost,        size_t endPost    )    {        pMemDigest-&gt;typeName = ppBlockHeader[startPost]-&gt;GetTypeName();        pMemDigest-&gt;blockCount = 0;        pMemDigest-&gt;totalSize = 0;        for (size_t i = startPost; i &lt; endPost; i++)        {            pMemDigest-&gt;blockCount++;            pMemDigest-&gt;totalSize += ppBlockHeader[i]-&gt;GetRequestedSize();            assert(strcmp(ppBlockHeader[i]-&gt;GetTypeName(), pMemDigest-&gt;typeName) == 0);        }    }    /* ---------------------------------------- TrackListMemoryUsage */    void TrackListMemoryUsage()    {        // If there are no allocated blocks, then return now.        size_t numBlocks = BlockHeader::CountBlocks();        if (numBlocks == 0) return;        // Get an array of pointers to all extant blocks.        BlockHeader **ppBlockHeader =            (BlockHeader **)calloc(numBlocks, sizeof(*ppBlockHeader));        BlockHeader::GetBlocks(ppBlockHeader);        // Sort the blocks by type name.        std::sort(            ppBlockHeader,            ppBlockHeader + numBlocks,            BlockHeader::TypeGreaterThan        );        // Find out how many unique types we have.        size_t numUniqueTypes = 1;        for (size_t i = 1; i &lt; numBlocks; i++)        {            char const *prevTypeName = ppBlockHeader[i - 1]-&gt;GetTypeName();            char const *currTypeName = ppBlockHeader[i]-&gt;GetTypeName();            if (strcmp(prevTypeName, currTypeName) != 0) numUniqueTypes++;        }        // Create an array of &quot;digests&quot; summarizing memory usage by type.        size_t startPost = 0;        size_t uniqueTypeIndex = 0;        MemDigest *pMemDigestArray =            (MemDigest *)calloc(numUniqueTypes, sizeof(*pMemDigestArray));        for (size_t i = 1; i &lt;= numBlocks; i++)    // yes, less than or *equal* to        {            char const *prevTypeName = ppBlockHeader[i - 1]-&gt;GetTypeName();            char const *currTypeName = (i &lt; numBlocks) ? ppBlockHeader[i]-&gt;GetTypeName() : &quot;&quot;;            if (strcmp(prevTypeName, currTypeName) != 0)            {                size_t endPost = i;                SummarizeMemoryUsageForType(                    pMemDigestArray + uniqueTypeIndex,                    ppBlockHeader,                    startPost,                    endPost                );                startPost = endPost;                uniqueTypeIndex++;            }        }        assert(uniqueTypeIndex = numUniqueTypes);        // Sort the digests by total memory usage.        std::sort(            pMemDigestArray,            pMemDigestArray + numUniqueTypes,            MemDigest::TotalSizeGreaterThan        );        // Compute the grand total memory usage.        size_t grandTotalNumBlocks = 0;        size_t grandTotalSize = 0;        for (size_t i = 0; i &lt; numUniqueTypes; i++)        {            grandTotalNumBlocks += pMemDigestArray[i].blockCount;            grandTotalSize += pMemDigestArray[i].totalSize;        }        // Dump the memory usage statistics.        printf(&quot;\n&quot;);        printf(&quot;-----------------------\n&quot;);        printf(&quot;Memory Usage Statistics\n&quot;);        printf(&quot;-----------------------\n&quot;);        printf(&quot;\n&quot;);        printf(&quot;%-50s%5s  %5s %7s %s \n&quot;, &quot;allocated type&quot;, &quot;blocks&quot;, &quot;&quot;, &quot;bytes&quot;, &quot;&quot;);        printf(&quot;%-50s%5s  %5s %7s %s \n&quot;, &quot;--------------&quot;, &quot;------&quot;, &quot;&quot;, &quot;-----&quot;, &quot;&quot;);        for (size_t i = 0; i &lt; numUniqueTypes; i++)        {            MemDigest *pMD = pMemDigestArray + i;            size_t blockCount = pMD-&gt;blockCount;            double blockCountPct = 100.0 * blockCount / grandTotalNumBlocks;            size_t totalSize = pMD-&gt;totalSize;            double totalSizePct = 100.0 * totalSize / grandTotalSize;            printf(                &quot;%-50s %5d %5.1f%% %7d %5.1f%%\n&quot;,                pMD-&gt;typeName,                blockCount,                blockCountPct,                totalSize,                totalSizePct            );        }        printf(&quot;%-50s %5s %5s  %7s %s \n&quot;, &quot;--------&quot;, &quot;-----&quot;, &quot;&quot;, &quot;-------&quot;, &quot;&quot;);        printf(&quot;%-50s %5d %5s  %7d %s \n&quot;, &quot;[totals]&quot;, grandTotalNumBlocks, &quot;&quot;, grandTotalSize, &quot;&quot;);        // Clean up.        free(ppBlockHeader);        free(pMemDigestArray);    }}    // namespace MemTrack/* ------------------------------------------------------------ *//* ---------------------- new and delete ---------------------- *//* ------------------------------------------------------------ *//* ---------------------------------------- operator new */void *operator new(size_t size){    void *p = MemTrack::TrackMalloc(size);    if (p == NULL) throw std::bad_alloc();    return p;}/* ---------------------------------------- operator delete */void operator delete(void *p){    MemTrack::TrackFree(p);}/* ---------------------------------------- operator new[] */void *operator new[](size_t size){    void *p = MemTrack::TrackMalloc(size);    if (p == NULL) throw std::bad_alloc();    return p;}/* ---------------------------------------- operator delete[] */void operator delete[](void *p){    MemTrack::TrackFree(p);}</code></pre><h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a><a href="http://valgrind.org/" target="_blank" rel="noopener">Valgrind</a></h1><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="http://blog.chenxu.me/post/detail?id=f4301bf3-3709-4c8f-8a45-9b9015909ce2" target="_blank" rel="noopener">Visual Studio 调试扫盲</a></p><p><a href="https://www.jianshu.com/p/c6f0939d512e" target="_blank" rel="noopener">Dump调试</a></p><p><a href="http://fresky.github.io/tags/Debug/" target="_blank" rel="noopener">http://fresky.github.io/tags/Debug/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;err-hr&quot;&gt;&lt;a href=&quot;#err-hr&quot; class=&quot;headerlink&quot; title=&quot;err,hr&quot;&gt;&lt;/a&gt;&lt;code&gt;err,hr&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;调试代码时，监视窗口里面填入&lt;code&gt;“$err,hr”(@err,hr或err
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="调试" scheme="https://caojingyou.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="错误报告" scheme="https://caojingyou.github.io/tags/%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A/"/>
    
      <category term="内存泄露" scheme="https://caojingyou.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>内存泄露检查</title>
    <link href="https://caojingyou.github.io/2018/05/23/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%8A%E6%A3%80%E6%B5%8B/"/>
    <id>https://caojingyou.github.io/2018/05/23/内存泄漏及检测/</id>
    <published>2018-05-23T07:35:00.000Z</published>
    <updated>2018-09-06T08:43:38.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检测是否存在内存泄漏问题"><a href="#检测是否存在内存泄漏问题" class="headerlink" title="检测是否存在内存泄漏问题"></a>检测是否存在内存泄漏问题</h1><p>Windows平台下面Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏。在vs中启用内存检测的方法如下：</p><ul><li>STEP1，在程序中包括以下语句： （#include 语句必须采用上文所示顺序。 如果更改了顺序，所使用的函数可能无法正常工作。）</li></ul><pre><code>#define _CRTDBG_MAP_ALLOC#include &lt;stdlib.h&gt;#include &lt;crtdbg.h&gt;</code></pre><p>通过包括 crtdbg.h，将 malloc 和 free 函数映射到它们的调试版本，即 _malloc_dbg 和 _free_dbg，这两个函数将跟踪内存分配和释放。 此映射只在调试版本（在其中定义了_DEBUG）中发生。 发布版本使用普通的 malloc和 free函数。</p><p><code>#define</code> 语句将 CRT 堆函数的基版本映射到对应的“Debug”版本。 并非绝对需要该语句；但如果没有该语句，内存泄漏转储包含的有用信息将较少。</p><ul><li><p>STEP2， 在添加了上述语句之后，可以通过在程序中包括以下语句（通常应恰好放在程序退出位置之前）来转储内存泄漏信息：</p><pre><code>_CrtDumpMemoryLeaks();</code></pre></li></ul><p>未定义 _CRTDBG_MAP_ALLOC 时，所显示的会是：</p><pre><code>1. 内存分配编号（在大括号内）。2. 块类型（普通、客户端或 CRT）。3. 十六进制形式的内存位置。4. 以字节为单位的块大小。5. 前 16 字节的内容（亦为十六进制）。</code></pre><p>块类型分为：</p><pre><code>1. “普通块”是由程序分配的普通内存。2. “客户端块”是由 MFC 程序用于需要析构函数的对象的特殊类型内存块。 MFC new 操作根据正在创建的对象的需要创建普通块或客户端块。3. “CRT 块”是由 CRT 库为自己使用而分配的内存块。 CRT 库处理这些块的释放，因此您不大可能在内存泄漏报告中看到这些块，除非出现严重错误（例如 CRT 库损坏）。</code></pre><p>从不会在内存泄漏信息中看到下面两种块类型：</p><pre><code>1. “可用块”是已释放的内存块。2. “忽略块”是您已特别标记的块，因而不出现在内存泄漏报告中。</code></pre><p>定义了 _CRTDBG_MAP_ALLOC 时，还会显示在其中分配泄漏的内存的文件。 文件名后括号中的数字（本示例中为 10）是该文件中的行号。</p><p>如果程序总是在同一位置退出，调用 _CrtDumpMemoryLeaks 将非常容易。 如果程序从多个位置退出，则无需在每个可能退出的位置放置对_CrtDumpMemoryLeaks 的调用，而可以在程序开始处包含以下调用：</p><pre><code>_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );</code></pre><p>该语句在程序退出时自动调用 _CrtDumpMemoryLeaks。 必须同时设置 _CRTDBG_ALLOC_MEM_DF和 _CRTDBG_LEAK_CHECK_DF两个位域</p><h1 id="定位具体的内存泄漏地方"><a href="#定位具体的内存泄漏地方" class="headerlink" title="定位具体的内存泄漏地方"></a>定位具体的内存泄漏地方</h1><p>定位内存泄漏的另一种技术涉及在关键点对应用程序的内存状态拍快照。 CRT 库提供一种结构类型 _CrtMemState，您可用它存储内存状态的快照：</p><pre><code>_CrtMemState s1, s2, s3;</code></pre><p>若要在给定点对内存状态拍快照，请向 _CrtMemCheckpoint 函数传递 _CrtMemState 结构。 该函数用当前内存状态的快照填充此结构：</p><pre><code>_CrtMemCheckpoint( &amp;s1 );</code></pre><p>通过向 _CrtMemDumpStatistics 函数传递 _CrtMemState 结构，可以在任意点转储该结构的内容：</p><pre><code>_CrtMemDumpStatistics( &amp;s1 );</code></pre><p>若要确定代码中某一部分是否发生了内存泄漏，可以在该部分之前和之后对内存状态拍快照，然后使用 _CrtMemDifference 比较这两个状态：</p><pre><code>_CrtMemCheckpoint( &amp;s1 );// memory allocations take place here_CrtMemCheckpoint( &amp;s2 );if ( _CrtMemDifference( &amp;s3, &amp;s1, &amp;s2) )_CrtMemDumpStatistics( &amp;s3 );</code></pre><p>顾名思义，_CrtMemDifference 比较两个内存状态（s1 和 s2），生成这两个状态之间差异的结果（s3）。 在程序的开始和结尾放置 _CrtMemCheckpoint 调用，并使用_CrtMemDifference 比较结果，是检查内存泄漏的另一种方法。 如果检测到泄漏，则可以使用 _CrtMemCheckpoint 调用通过二进制搜索技术来划分程序和定位泄漏。</p><h1 id="VLD"><a href="#VLD" class="headerlink" title="VLD"></a>VLD</h1><p><a href="https://archive.codeplex.com/?p=vld" target="_blank" rel="noopener">https://archive.codeplex.com/?p=vld</a></p><p>Visual Leak Detector是一个免费，强大的开源内存泄漏检测系统，适用于Visual C ++。</p><p>关键api:</p><pre><code>_CrtSetAllocHookStackWalk64SymGetLineFromAddr64SymFromAddr</code></pre><h2 id="Allocation-Hooking"><a href="#Allocation-Hooking" class="headerlink" title="Allocation Hooking"></a>Allocation Hooking</h2><p>对我们来说幸运的是，Microsoft提供了一种简单的方法来监视从调试堆进行的每个分配：分配挂钩。分配钩子只是一个用户提供的回调函数，它将在从调试堆进行每次分配之前调用。Microsoft提供了一个函数，_CrtSetAllocHook它使用调试堆注册分配挂钩函数。当调试堆调用分配挂钩时，传递的参数之一是唯一标识每个分配的ID号 - 它基本上是分配的每个内存块的序列号。内存块标题中没有足够的空间让我们直接在其中记录任何信息，但我们可以使用这个唯一的ID号作为键将每个块映射到我们想要记录的任何数据。</p><h2 id="Walking-the-Stack"><a href="#Walking-the-Stack" class="headerlink" title="Walking the Stack"></a>Walking the Stack</h2><p>现在我们有一种方法可以在每次分配一个块时得到通知，以及一种唯一标识每个分配的方法，剩下要做的就是每次分配时记录调用堆栈。我们可以想象使用内联汇编来尝试展开堆栈。但是堆栈帧可以以不同的方式组织，这取决于编译器优化和调用约定，因此以这种方式执行它可能变得复杂。微软再一次为我们提供了一个帮助我们的工具。这次它是一个函数，我们可以迭代地调用来逐帧遍历堆栈。那个功能是StackWalk64。它是Debug Help Library（dbghelp.dll）的一部分）。只要我们为它提供建立起始“参考框架”所需的信息，可以说，它可以从那里检查我们的堆栈并为我们可靠地解除它。每次StackWalk64调用时，它都会返回一个STACKFRAME64结构，可以将其重新用作下次调用的输入StackWalk64。它可以以这种方式重复调用，直到到达堆栈的末尾。</p><h2 id="Initializing-the-Memory-Leak-Detector"><a href="#Initializing-the-Memory-Leak-Detector" class="headerlink" title="Initializing the Memory Leak Detector"></a>Initializing the Memory Leak Detector</h2><p>我们现在有一个更好的内存泄漏检测器的开始。我们可以监控每个分配，对于每个监控的分配，我们可以获取并记录堆栈跟踪。剩下的唯一挑战是确保在程序开始执行时立即向调试堆注册分配挂钩函数。这可以通过创建C ++类对象的全局实例来非常简单地解决。初始化程序时，构造函数将运行。从构造函数中，我们可以调用_CrtSetAllocHook注册我们的分配钩子函数。但是等等，如果我们正在调试的程序已经有了其他的话分配内存的全局C ++类对象？我们如何确保首先调用构造函数，并且在构造任何其他全局对象之前安装我们的分配钩子函数？不幸的是，C ++规范没有说明决定构造全局对象的顺序的任何规则。因此，没有绝对保证我们的构造函数将首先被调用。但我们可以非常接近保证它。我们可以利用特定于编译器的预处理器指令，该指令明确告诉编译器确保我们的全局变量尽快构建：#pragma init_seg (compiler)。该指令告诉编译器将我们的全局对象放在“编译器”初始化段中。此段中的对象是第一个构造的对象。接下来，构建“库”段中的对象，并且最后构造“用户”段中的对象。“用户”段是全局对象的默认段。一般来说，不应将普通用户对象放在“编译器”段中，因此这提供了在任何用户对象之前构造我们的全局对象的合理确定性。</p><h2 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h2><p>因为全局对象以它们构造的相反顺序被销毁，所以我们的全局对象将在任何用户对象之后被销毁。然后我们可以检查堆，就像内置检测器一样。如果我们在堆上找到一个尚未释放的块，则它是一个泄漏，我们可以使用我们的分配钩子函数记录的唯一ID号查找其调用堆栈。STL映射在这里可以正常工作，用于将ID号映射到调用堆栈。我没有使用STL地图，因为我希望我的库兼容新旧版本的Visual C ++。旧版本的STL与较新版本不兼容，因此我无法使用STL组件。但好消息是，这让我有机会创建一个与STL地图概念相似的数据结构，</p><p>你还记得内置的泄漏检测器在内存块中对等，以获取文件的名称和分配块的行号吗？好吧，我们所有的调用堆栈都是一堆程序地址。将所有这些十六进制数转储到调试器中的用处不大。为了使这些地址更有意义，我们需要将它们转换为人类可读的信息：文件和行号（以及函数名称）。微软再次提供了有助于我们完成工作的工具：符号处理程序API。就像StackWalk64，它们也恰好是Debug Help Library的一部分。我不会在这里详细介绍它们，因为它们有很多，而且使用起来非常简单。他们不需要那么多的聪明才智StackWalk64确实。我们可以使用两个符号处理程序API来获取我们想要的文件名，行号和函数名。恰当命名的SymGetLineFromAddr64地址将地址转换为源文件名和行号。它的姐妹API SymFromAddr将地址转换为符号名称。对于我们所拥有的程序地址，相应的符号名称将是包含该程序地址的函数的名称。</p><h2 id="源代码的关键部分"><a href="#源代码的关键部分" class="headerlink" title="源代码的关键部分"></a>源代码的关键部分</h2><p>如果你对上面的部分感到厌倦并跳过了，我会在这里总结一下。简而言之，这个内存泄漏检测器的工作原理如下：</p><p>自动构建全局对象。它是第一个构建的对象。构造函数注册我们的分配钩子函数。<br>每个分配最终调用我们的分配钩子函数。分配挂钩函数获取并记录每个分配的调用堆栈。调用堆栈信息记录在类似STL的专用映射中。<br>程序终止时，全局对象是最后一个被销毁的对象。它检查堆并识别泄漏。在地图中查找泄漏的块并与其对应的调用堆栈进行匹配。生成的数据将发送到调试器以进行显示。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>VLD不会检测COM泄漏，进程外资源泄漏或与CRT堆无关的任何其他类型的内存泄漏。简单来说，VLD只检测因调用new或导致的内存泄漏malloc。请记住，VLD是作为内置内存泄漏检测器的替代产品而创建的，它也只检测来自new和的泄漏malloc。</p><h1 id="内容转载："><a href="#内容转载：" class="headerlink" title="内容转载："></a>内容转载：</h1><p>太有用了，故直接转载以下链接内容</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;mid=401055447&amp;idx=1&amp;sn=a3d1237c10b7352f827d95110c0f4b61#rd" target="_blank" rel="noopener">C/C++内存泄漏及检测</a></p><h1 id="最快速度找到内存泄漏"><a href="#最快速度找到内存泄漏" class="headerlink" title="最快速度找到内存泄漏"></a><a href="http://cplusplus.wikidot.com/cn:the-fastest-way-to-find-memory-leak" target="_blank" rel="noopener">最快速度找到内存泄漏</a></h1><h2 id="确认是否存在内存泄漏"><a href="#确认是否存在内存泄漏" class="headerlink" title="确认是否存在内存泄漏"></a>确认是否存在内存泄漏</h2><pre><code>inline void EnableMemLeakCheck(){   _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);}#ifdef _DEBUG#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)#endifvoid main(){   EnableMemLeakCheck();   int* leak = new int[10];}</code></pre><p>如果检测到存在内存泄漏，退出程序的时候会在调试窗口提醒内存泄漏。现在内存泄漏报告和MFC没有任何分别了。</p><h2 id="快速找到内存泄漏"><a href="#快速找到内存泄漏" class="headerlink" title="快速找到内存泄漏"></a>快速找到内存泄漏</h2><p>单确定了内存泄漏发生在哪一行，有时候并不足够。特别是同一个new对应有多处释放的情形。在实际的工程中，以下两种情况很典型：</p><p>创建对象的地方是一个类工厂（ClassFactory）模式。很多甚至全部类实例由同一个new创建。对于此，定位到了new出对象的所在行基本没有多大帮助。</p><p>COM对象。我们知道COM对象采用Reference Count维护生命周期。也就是说，对象new的地方只有一个，但是Release的地方很多，你要一个个排除。</p><p>我们让程序运行到第52次内存分配操作的时候，自动停下来，进入调试状态？所幸，crtdbg确实提供了这样的函数：即 long _CrtSetBreakAlloc(long nAllocID)。我们加上它：</p><pre><code>inline void EnableMemLeakCheck(){   _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);}#ifdef _DEBUG#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)#endifvoid main(){   EnableMemLeakCheck();   _CrtSetBreakAlloc(52);   int* leak = new int[10];}</code></pre><h1 id="Aspect-C"><a href="#Aspect-C" class="headerlink" title="Aspect C ++"></a><a href="https://www.aspectc.org/" target="_blank" rel="noopener">Aspect C ++</a></h1><p>面向AOP切面编程</p><p><a href="http://www.cppblog.com/cpunion/archive/2005/12/16/1836.html" target="_blank" rel="noopener">实战Aspect C ++之检查内存泄漏</a></p><p>实现一个内存分配记录管理器：</p><p>memory_recorder.h</p><pre><code>#ifndef __MEMORY_RECORDER_H__#define __MEMORY_RECORDER_H__#include &lt;map&gt;#include &lt;typeinfo&gt;using namespace std;class MemoryRecorder{    map&lt;void *, const type_info *&gt; objects;public:    ~MemoryRecorder ();    void addObject(void *obj, const type_info &amp;ti);    void removeObject(void *obj, const type_info &amp;ti);};extern MemoryRecorder g_memoryRecorder;#endif // __MEMORY_RECORDER_H__</code></pre><p>memory_recorder.cc</p><pre><code>#include &quot;memory_recorder.h&quot;#include &lt;iostream&gt;using namespace std;MemoryRecorder g_memoryRecorder;MemoryRecorder::~MemoryRecorder (){    if (objects.size() &gt; 0)    {        cout &lt;&lt; objects.size() &lt;&lt; &quot; objects not released:&quot; &lt;&lt; endl;        for (map&lt;void *, const type_info *&gt;::const_iterator iter = objects.begin();                iter != objects.end();                iter ++)        {            cout &lt;&lt; &quot;\t&quot; &lt;&lt; iter-&gt;second-&gt;name() &lt;&lt; &quot;: &quot; &lt;&lt; (iter-&gt;first) &lt;&lt; endl;            delete (iter-&gt;first);        }    }}void MemoryRecorder::addObject(void *obj, const type_info &amp;ti){    objects.insert(make_pair(obj, &amp;ti));}void MemoryRecorder::removeObject(void *obj, const type_info &amp;ti){    objects.erase(obj);}</code></pre><p>实现方面，test.ah</p><pre><code>#ifndef __TEST_AH__#define __TEST_AH__#include &quot;memory_recorder.h&quot;#include &lt;iostream&gt;using namespace std;aspect MemberRecorder{    pointcut all_class() = classes(&quot;Test%&quot;);    advice construction (all_class()) : after ()    {        g_memoryRecorder.addObject (tjp-&gt;target(), typeid(*tjp-&gt;target()));    }    advice destruction (all_class()) : after ()    {        g_memoryRecorder.removeObject (tjp-&gt;target(), typeid(*tjp-&gt;target()));    }};#endif // __TEST_AH__</code></pre><p>这个方面实现的功能很简单，首先定义了一个pointcut(切面)，它匹配所有以“Test”开头的类。<br>接下来定义了2个处理方法，分别在这些类的构造函数和析构函数调用之后执行。</p><p>tjp-&gt;target()指向Test*对象实例</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>实际项目中检测内存泄漏通常会十分繁琐，所以有许多工具帮助我们检测内存泄漏，比如 mtrace，valgrind。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://blog.jobbole.com/95375/" target="_blank" rel="noopener">C/C++内存泄漏及检测</a></li><li><a href="http://www.codeproject.com/KB/applications/visualleakdetector.aspx" target="_blank" rel="noopener">Visual Leak Detector Visual C ++增强的内存泄漏检测</a></li><li><a href="http://msdn.microsoft.com/en-us/library/x98tx3cf.aspx" target="_blank" rel="noopener">使用CRT库查找内存泄漏</a></li><li><a href="http://codeyarns.com/2010/09/11/visual-leak-detector-investigate-memory-leaks-in-visual-c/" target="_blank" rel="noopener">Visual Leak Detector：调查Visual C ++中的内存泄漏</a></li><li><a href="https://en.wikipedia.org/wiki/Mtrace" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mtrace</a></li><li><a href="http://valgrind.org/docs/manual/manual.html" target="_blank" rel="noopener">http://valgrind.org/docs/manual/manual.html</a></li><li><a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md</a></li><li><a href="http://fresky.github.io/2015/06/21/how-to-attack-the-memory-leak-issue/" target="_blank" rel="noopener">调试内存泄漏问题的一些经验</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检测是否存在内存泄漏问题&quot;&gt;&lt;a href=&quot;#检测是否存在内存泄漏问题&quot; class=&quot;headerlink&quot; title=&quot;检测是否存在内存泄漏问题&quot;&gt;&lt;/a&gt;检测是否存在内存泄漏问题&lt;/h1&gt;&lt;p&gt;Windows平台下面Visual Studio 调试器和 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="调试" scheme="https://caojingyou.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="内存泄露" scheme="https://caojingyou.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>结巴分词</title>
    <link href="https://caojingyou.github.io/2018/05/22/%E7%BB%93%E5%B7%B4%E5%88%86%E8%AF%8D/"/>
    <id>https://caojingyou.github.io/2018/05/22/结巴分词/</id>
    <published>2018-05-22T02:15:00.000Z</published>
    <updated>2018-05-22T05:34:48.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结巴分词"><a href="#结巴分词" class="headerlink" title="结巴分词"></a>结巴分词</h1><p><a href="https://github.com/fxsjy/jieba" title="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p><p><a href="https://github.com/yanyiwu/cppjieba" title="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">cppjieba C++</a></p><p><a href="https://github.com/anderscui/jieba.NET" title="jieba.NET" target="_blank" rel="noopener">jieba.NET</a></p><p><a href="https://yanyiwu.com/work/2014/02/10/cppjieba-dai-ma-xiang-jie.html" title="CppJieba代码详解" target="_blank" rel="noopener">https://yanyiwu.com/work/2014/02/10/cppjieba-dai-ma-xiang-jie.html</a></p><p><a href="https://www.cnblogs.com/wxquare/p/6666341.html" title="cppjieba分词学习笔记" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/6666341.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结巴分词&quot;&gt;&lt;a href=&quot;#结巴分词&quot; class=&quot;headerlink&quot; title=&quot;结巴分词&quot;&gt;&lt;/a&gt;结巴分词&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fxsjy/jieba&quot; title=&quot;https://github
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="分词" scheme="https://caojingyou.github.io/tags/%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>CShap和C++ Socket通信</title>
    <link href="https://caojingyou.github.io/2018/05/21/CShap%E5%92%8CC++%20Socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2018/05/21/CShap和C++ Socket通信/</id>
    <published>2018-05-21T06:00:00.000Z</published>
    <updated>2018-09-05T10:19:42.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通信传输数据类型"><a href="#通信传输数据类型" class="headerlink" title="通信传输数据类型"></a>通信传输数据类型</h1><pre><code>C++:char*C#:byte[]java:byte[]</code></pre><p>在C++中：<br>在C++中，char是基础数据类型，8位，1个字节。byte不是基础数据类型，一般是typedef unsigned char byte;这样子的，也就是说，byte其实是unsigned char类型，那么也是8位，1个字节。不同的是，char可以表示的范围是-128-127，而byte可以表示的范围是0-255。</p><p>在Java中：<br>在java中，char和byte都是基础数据类型，其中的byte和C++中的char类型是一样的，8位，1个字节，-128-127。但是，char类型，是16位，2个字节，’\u0000’-‘\uFFFF’。</p><p>为什么java里的char是2个字节？</p><p>因为java内部都是用unicode的，所以java其实是支持中文变量名的，比如string 世界 = “我的世界”;这样的语句是可以通过的。</p><h1 id="传输不定长度的数据"><a href="#传输不定长度的数据" class="headerlink" title="传输不定长度的数据"></a>传输不定长度的数据</h1><p>1 以结束符标记<br>2 长度 + 数据</p><pre><code>#pragma pack(push, 1)//协议头struct msg{    char     compressflag;     //压缩标志，如果为1，则启用压缩，反之不启用压缩    int32_t  originsize;       //包体压缩前大小    int32_t  compresssize;     //包体压缩后大小    char     reserved[16];};#pragma pack(pop)int32_t可换成msg</code></pre><p>发送：</p><pre><code>std::string strBuffer,m_strSendBuf；int32_t length = (int32_t)strBuffer.length(); m_strSendBuf.append((const char*)&amp;length, sizeof(length));m_strSendBuf.append(strDestBuf);nRet = ::send(m_hSocket, m_strSendBuf.c_str(), m_strSendBuf.length(), 0);</code></pre><p>接收：</p><pre><code>nRet = ::recv(m_hSocket, buff, 10 * 1024, 0);m_strRecvBuf.append(buff, nRet);int32_t length;memcpy_s(&amp;length, sizeof(int32_t), m_strRecvBuf.data(), sizeof(int32_t));m_strRecvBuf.erase(0, sizeof(int32_t));std::string strTempMsg = m_strRecvBuf.substr(0, length);</code></pre><h2 id="C-和-C-结构体Socket通信"><a href="#C-和-C-结构体Socket通信" class="headerlink" title="C# 和 C++ 结构体Socket通信"></a>C# 和 C++ 结构体Socket通信</h2><p><img src="https://i.imgur.com/RiswVtr.jpg" alt=""></p><pre><code>仿照C++结构体写出C#的结构来using System.Runtime.InteropServices;[Serializable] // 指示可序列化[StructLayout(LayoutKind.Sequential, Pack = 1)] // 按1字节对齐public struct Operator{    public ushort id;    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 11)] // 声明一个字符数组，大小为11    public char[] name;    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 9)]    public char[] pass;    public Operator(string user, string pass) // 初始化    {        this.id = 10000;        this.name = user.PadRight(11, &apos;\0&apos;).ToCharArray();        this.pass = pass.PadRight(9, &apos;\0&apos;).ToCharArray();    }}整个结构的字节数是22bytes。对应的C++结构体是：typedef struct{    WORD id;    CHAR name[11];    CHAR password[9];} Operator;发送的时候先要把结构转换成字节数组using System.Runtime.InteropServices;/// &lt;summary&gt;/// 将结构转换为字节数组/// &lt;/summary&gt;/// &lt;param name=&quot;obj&quot;&gt;结构对象&lt;/param&gt;/// &lt;returns&gt;字节数组&lt;/returns&gt;public byte[] StructToBytes(object obj){    //得到结构体的大小    int size = Marshal.SizeOf(obj);    //创建byte数组    byte[] bytes = new byte[size];    //分配结构体大小的内存空间    IntPtr structPtr = Marshal.AllocHGlobal(size);    //将结构体拷到分配好的内存空间    Marshal.StructureToPtr(obj, structPtr, false);    //从内存空间拷到byte数组    Marshal.Copy(structPtr, bytes, 0, size);    //释放内存空间    Marshal.FreeHGlobal(structPtr);    //返回byte数组    return bytes;}接收的时候需要把字节数组转换成结构/// &lt;summary&gt;/// byte数组转结构/// &lt;/summary&gt;/// &lt;param name=&quot;bytes&quot;&gt;byte数组&lt;/param&gt;/// &lt;param name=&quot;type&quot;&gt;结构类型&lt;/param&gt;/// &lt;returns&gt;转换后的结构&lt;/returns&gt;public object BytesToStruct(byte[] bytes, Type type){    //得到结构的大小    int size = Marshal.SizeOf(type);    Log(size.ToString(), 1);    //byte数组长度小于结构的大小    if (size &gt; bytes.Length)    {        //返回空        return null;    }    //分配结构大小的内存空间    IntPtr structPtr = Marshal.AllocHGlobal(size);    //将byte数组拷到分配好的内存空间    Marshal.Copy(bytes, 0, structPtr, size);    //将内存空间转换为目标结构    object obj = Marshal.PtrToStructure(structPtr, type);    //释放内存空间    Marshal.FreeHGlobal(structPtr);    //返回结构    return obj;}实际操作：using System.Collections;using System.Collections.Generic;using System.Net;using System.Net.Sockets;byte[] Message = StructToBytes(new Operator(&quot;user&quot;, &quot;pass&quot;)); // 将结构转换成字节数组TcpClient socket = new TcpClient();socket.Connect(ip, port);NetworkStream ns = Socket.GetStream();ns.Write(Message, 0, Message.Length); // 发送byte[] Recv = new byte[1024]; // 缓冲int NumberOfRecv = 0;IList&lt;byte&gt; newRecv = new List&lt;byte&gt;();ns.ReadTimeout = 3000;try{    do    {        // 接收响应        NumberOfRecv = ns.Read(Recv, 0, Recv.Length);        for (int i = 0; i &lt; NumberOfRecv; i++)            newRecv.Add(Recv[i]);    }    while (ns.DataAvailable);    byte[] resultRecv = new byte[newRecv.Count];    newRecv.CopyTo(resultRecv, 0);    Operator MyOper = new Operator();    MyOper = (Operator)BytesToStruct(resultRecv, MyOper.GetType()); // 将字节数组转换成结构    在这里取值的时候可能会出现只能取到一个字段，剩余的取不到的问题，怎么回事我也搞不懂，反正我的解决办法就是按照字节的顺序从resultRecv里分别取出对应的字段的字节数组，然后解码，例如：    Operator.name是11个字节，最后一位是0，Operator.id是2个字节，那么从第3位到第12位的字节就是Operator.name的内容，取出另存为一个数组MyOperName，Encoding.Default.GetString(MyOperName)就是MyOper.name的内容。    socket.Close();    ns.Close();    可以看到，该仁兄在接收解析的时候，还是被C#的默认排序给黑到了，这里还是建议暂时用比较笨的方法，等待大牛出来好方法：  所以比较笨的解决办法是，把所有定义好的数据结构先手动进行按名字排序！~~自己对数据结构中的类型名称进行按名字排序</code></pre><h1 id="protobuf或者flatbuffer"><a href="#protobuf或者flatbuffer" class="headerlink" title="protobuf或者flatbuffer"></a>protobuf或者flatbuffer</h1><h2 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h2><p>Protocol Buffers（简称protobuf）是谷歌的一项技术，用于将结构化的数据序列化、反序列化，经常用于网络传输。</p><p><a href="https://github.com/google/protobuf" title="https://github.com/google/protobuf" target="_blank" rel="noopener">https://github.com/google/protobuf</a></p><p><a href="https://github.com/google/protobuf/tree/master/examples" title="https://github.com/google/protobuf/tree/master/examples" target="_blank" rel="noopener">https://github.com/google/protobuf/tree/master/examples</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" title="Google Protocol Buffer 的使用和原理" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html</a></p><p><a href="https://blog.csdn.net/shensky711/article/details/69696392" title="Protocol Buffers 3.0 技术手册" target="_blank" rel="noopener">https://blog.csdn.net/shensky711/article/details/69696392</a></p><p><a href="https://blog.csdn.net/u012391923/article/details/54908464" title="Protocol Buffers编程指南与应用" target="_blank" rel="noopener">https://blog.csdn.net/u012391923/article/details/54908464</a></p><p><a href="https://blog.csdn.net/carson_ho/article/details/70568606" title="Protocol Buffer 序列化原理大揭秘 - 为什么Protocol Buffer性能这么好？" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/70568606</a></p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。</p><p><a href="https://grpc.io/" title="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a></p><p><a href="https://github.com/grpc/grpc" title="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc</a></p><p><a href="https://grpc.io/docs/quickstart/" title="https://grpc.io/docs/quickstart/" target="_blank" rel="noopener">https://grpc.io/docs/quickstart/</a></p><p><a href="http://doc.oschina.net/grpc?t=57966" title="gRPC 官方文档中文版" target="_blank" rel="noopener">http://doc.oschina.net/grpc?t=57966</a></p><h2 id="flatbuffers"><a href="#flatbuffers" class="headerlink" title="flatbuffers"></a>flatbuffers</h2><p>跨平台序列化工具FlatBuffers，提供了C++/Java/Go/C#接口支持，这是一个注重性能和资源使用的序列化类库。相较于Protocol Buffers，其更适用于移动设备，FlatBuffers提供更高的性能以及更低的资源需求。</p><p><a href="https://github.com/google/flatbuffers" title="https://github.com/google/flatbuffers" target="_blank" rel="noopener">https://github.com/google/flatbuffers</a></p><p><a href="http://google.github.io/flatbuffers/index.html" title="http://google.github.io/flatbuffers/index.html" target="_blank" rel="noopener">http://google.github.io/flatbuffers/index.html</a></p><p><a href="https://www.jianshu.com/p/6eb04a149cd8" target="_blank" rel="noopener">FlatBuffers使用简介</a></p><p><a href="https://blog.csdn.net/linuxheik/article/details/70743394" title="FlatBuffers学习总结" target="_blank" rel="noopener">https://blog.csdn.net/linuxheik/article/details/70743394</a></p><p><a href="https://www.race604.com/flatbuffers-intro/" title="FlatBuffers 体验" target="_blank" rel="noopener">https://www.race604.com/flatbuffers-intro/</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://blog.sina.com.cn/s/blog_668aae7801019mdf.html" title="http://blog.sina.com.cn/s/blog_668aae7801019mdf.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_668aae7801019mdf.html</a></p><p><a href="https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html" title="https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html" target="_blank" rel="noopener">https://www.cnblogs.com/dudulang971/archive/2010/04/13/1710844.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通信传输数据类型&quot;&gt;&lt;a href=&quot;#通信传输数据类型&quot; class=&quot;headerlink&quot; title=&quot;通信传输数据类型&quot;&gt;&lt;/a&gt;通信传输数据类型&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;C++:char*

C#:byte[]

java:byte[]
&lt;/co
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="Socket" scheme="https://caojingyou.github.io/tags/Socket/"/>
    
      <category term="Java" scheme="https://caojingyou.github.io/tags/Java/"/>
    
      <category term="protobuf" scheme="https://caojingyou.github.io/tags/protobuf/"/>
    
      <category term="grpc" scheme="https://caojingyou.github.io/tags/grpc/"/>
    
      <category term="flatbuffer" scheme="https://caojingyou.github.io/tags/flatbuffer/"/>
    
  </entry>
  
  <entry>
    <title>X3框架</title>
    <link href="https://caojingyou.github.io/2018/05/18/X3%E6%A1%86%E6%9E%B6/"/>
    <id>https://caojingyou.github.io/2018/05/18/X3框架/</id>
    <published>2018-05-18T01:26:00.000Z</published>
    <updated>2018-08-01T07:49:12.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><p>所有插件都是普通DLL，通过在工程内包含辅助文件自动实现了统一的导出函数，通过该导出函数就能获取到在该插件内所实现的所有接口的信息及对象创建函数地址；主程序使用插件管理器（PluginManager）加载这些DLL，插件管理器通过这个导出函数将各个类ID、对象创建函数地址统一管理起来，从而在插件管理器的中介作用下让各个插件能相互使用各种接口函数。</p><h2 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h2><p>对外提供接口文件，在插件内部用类来实现一个或多个接口，不需要对外导出该类或暴露实现细节。这样还有一个好处是只有约定了接口就可以让多个模块并行开发，模块相互之间不存在编译依赖（不需要其他插件的LIB等文件），这可用于测试驱动开发模式。</p><h2 id="多接口转换、引用计数管理"><a href="#多接口转换、引用计数管理" class="headerlink" title="多接口转换、引用计数管理"></a>多接口转换、引用计数管理</h2><p>采用智能指针类来管理接口的引用计数及生命期，可从一个接口动态转换为另一个接口（内部采用C++的RTTI机制动态转换），可以区分插件内部的接口引用和插件外部的接口引用。</p><h2 id="模块透明部署"><a href="#模块透明部署" class="headerlink" title="模块透明部署"></a>模块透明部署</h2><p>一个模块只需要使用其他模块的接口，不需要关心该接口是在哪个插件中实现的。可以根据需要将各个实现类进行合并或拆分，使其分布到不同插件中，而接口使用者不受影响。另外，插件部署于哪个目录也不影响插件接口的使用。</p><h2 id="模块可替换、可扩展"><a href="#模块可替换、可扩展" class="headerlink" title="模块可替换、可扩展"></a>模块可替换、可扩展</h2><p>可根据需要替换某个插件，只有该插件实现了相同的接口，即使内部功能不相同，这样就实现了插件可替换、按需组合。通过在新的插件中支持更多的接口，可扩展更多的功能。可以在新插件中局部替换原有插件的某些接口或部分函数，实现重用和扩展。</p><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>本插件机制所提供的内部实现文件考虑了线程安全性，允许多线程访问而不冲突，同时采用的是轻量级的锁定机制（计数原子锁定），运行开销很小。</p><h2 id="跨版本"><a href="#跨版本" class="headerlink" title="跨版本"></a>跨版本</h2><p>允许不同版本的VC++开发的插件相互调用对方的接口，虽然实际中一般不需要这样做。由于没有采用VC++特殊的编译指令，因此容易移植到其他开发平台下。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><pre><code>interface Ix_Example{    virtual void Foo() = 0;    virtual void* GetData(std::vector&lt;int&gt;&amp; items) = 0;};</code></pre><h2 id="定义类UID"><a href="#定义类UID" class="headerlink" title="定义类UID"></a>定义类UID</h2><pre><code>const XCLSID CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);</code></pre><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>下面的例子是在Cx_Example.h中定义了Cx_Example类，实现了两个接口。</p><pre><code>#pragma once#include &lt;Ix_Example.h&gt;class Cx_Example    : public Ix_Example    , public Ix_Example2{protected:    Cx_Example();    ~Cx_Example();protected:    // Ix_Example    virtual void Foo();    // Ix_Example2    virtual void Foo2();};</code></pre><p>上面的例子中有两个地方值得留意（不是必须要这样，但推荐这样）：（1）构造函数和析构函数是保护类型，表示不允许直接实例化对象，也不允许直接删除销毁对象，通过智能指针类Cx_Interface或Cx_Ptr来自动实例化和销毁对象；（2）所实现的接口函数申明为保护类型，表示不允许直接调用该对象实例的函数，当然也可以申明为私有类型，表示不允许派生实现类调用其函数。</p><h2 id="在插件中登记实现类"><a href="#在插件中登记实现类" class="headerlink" title="在插件中登记实现类"></a>在插件中登记实现类</h2><p>通过智能指针类Cx_Interface或Cx_Ptr来实例化对象，需要在插件内登记该插件中有哪些可供实例化的类、实现类对应的类UID、是否为单实例类。例如下面的Module.cpp：</p><pre><code>// 登记有哪些可供实例化的类、实现类对应的类UID、是否为单实例类XBEGIN_DEFINE_MODULE()    XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)    XDEFINE_CLASSMAP_ENTRY_Singleton(CLSID_ExamTool, Cx_ExampleTool)XEND_DEFINE_MODULE()</code></pre><p>其中包含XModuleImpl.h 用于自动实现插件内部机制，插件机制如何实现对插件开发者来说不用关心，宏XDEFINE_CLASSMAP_ENTRY 用于登记普通类及其类UID，可实例化出多个对象，XDEFINE_CLASSMAP_ENTRY_Singleton 用于登记单实例类及其类UID，在一个进程中不论创建多少次都会得到同一个对象实例。</p><p>对于以MFC扩展动态库或Win32动态库类型创建插件工程的情况，由于DLL入口函数基本上都相同，为了避免在多个插件中重复出现这样类似的DLL入口函数代码，可以将上面例子中的 XEND_DEFINE_MODULE() 换为下面两个宏之一：</p><pre><code>XEND_DEFINE_MODULE_MFCEXTDLL()XEND_DEFINE_MODULE_WIN32DLL()</code></pre><h1 id="框架核心代码以及测试"><a href="#框架核心代码以及测试" class="headerlink" title="框架核心代码以及测试"></a>框架核心代码以及测试</h1><pre><code>#pragma once#include &lt;objbase.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;interface Ix_Object{    virtual void AddRef(HMODULE fromdll) = 0;    virtual void Release(HMODULE fromdll) = 0;    virtual const char* GetClassName() const = 0;};//! class factory function.typedef Ix_Object* (STDMETHODCALLTYPE *PFNXObjectCreator)(HMODULE);//! object count of a class.typedef long (STDMETHODCALLTYPE *PFNXGetObjectCount)();//! object (used by other modules) count of a class.typedef long (STDMETHODCALLTYPE *PFNXRefCountByOthers)();#define MIN_SINGLETON_TYPE  10#pragma pack(push, 8)/*! \ingroup _GROUP_PLUGIN_CORE2_*  \brief class factory registry.*  \see   _xGetClassEntryTable, XBEGIN_DEFINE_MODULE*  \internal*/struct _XCLASSMETA_ENTRY{    BYTE                type;               //!&lt; see MIN_SINGLETON_TYPE and XModuleMacro.h    const char*         className;          //!&lt; implement class name    std::string              clsid;              //!&lt; class id. may be empty if iidSpecial is valid.    const char*         iidSpecial;         //!&lt; special interface name, see XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton.    PFNXObjectCreator   pfnObjectCreator;   //!&lt; class factory function    PFNXGetObjectCount  pfnGetObjectCount;  //!&lt; object count of this class    PFNXRefCountByOthers    pfnRefCountByOthers;    //!&lt; count of objects used by other modules                                                    //! Used by XDEFINE_CLASSMAP_ENTRY, XDEFINE_CLASSMAP_ENTRY_Singleton    _XCLASSMETA_ENTRY(BYTE      _type,        const char*             _className,        const std::string &amp;           _clsid,        const char*             _iidSpecial,        PFNXObjectCreator       _pfnObjectCreator,        PFNXGetObjectCount      _pfnGetObjectCount = NULL,        PFNXRefCountByOthers    _pfnRefCountByOthers = NULL)        : type(_type), className(_className)        , clsid(_clsid), iidSpecial(_iidSpecial)        , pfnObjectCreator(_pfnObjectCreator)        , pfnGetObjectCount(_pfnGetObjectCount)        , pfnRefCountByOthers(_pfnRefCountByOthers)    {    }    //! Used by XEND_DEFINE_MODULE    _XCLASSMETA_ENTRY()        : type(0), className(&quot;&quot;), clsid(&quot;&quot;), iidSpecial(&quot;&quot;)        , pfnObjectCreator(NULL), pfnGetObjectCount(NULL)        , pfnRefCountByOthers(NULL)    {    }    //! class factory registries. filled by XBEGIN_DEFINE_MODULE.    static const _XCLASSMETA_ENTRY s_classes[];};#pragma pack(pop)std::string GuidToString(){    GUID guid;    CoCreateGuid(&amp;guid);    char buf[64] = { 0 };    _snprintf_s(        buf,        sizeof(buf),        &quot;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&quot;,        guid.Data1, guid.Data2, guid.Data3,        guid.Data4[0], guid.Data4[1],        guid.Data4[2], guid.Data4[3],        guid.Data4[4], guid.Data4[5],        guid.Data4[6], guid.Data4[7]);    return std::string(buf);}//注意：TRUE会导致DLL引用计数加1，FALSE不会改变引用计数，通常用FALSEHMODULE GetCurrentModule(BOOL bRef = FALSE){    HMODULE hModule = NULL;    if (GetModuleHandleEx(bRef ? GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS : (GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS        | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT), (LPCTSTR)GetCurrentModule, &amp;hModule))    {        return hModule;    }    return NULL;}// Return the current module handle for making a distinction between plugins.HMODULE xGetModuleHandle(){    return GetCurrentModule();};// Create an object with the class id.HRESULT xCreateObject(const std::string&amp; clsid, Ix_Object** ppv){    *ppv = NULL;    const _XCLASSMETA_ENTRY* pCls = _XCLASSMETA_ENTRY::s_classes;    for (; pCls-&gt;pfnObjectCreator; ++pCls)    {        if (clsid == pCls-&gt;clsid)        {            *ppv = (*pCls-&gt;pfnObjectCreator)(xGetModuleHandle());            return S_OK;        }    }    return E_NOTIMPL;}template &lt;class ClsType&gt;class Cx_Object    : public ClsType    , public Ix_Object{protected:    Cx_Object(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)    {        InterlockedIncrement(&amp;ObjectCount());    }    virtual ~Cx_Object()    {        InterlockedDecrement(&amp;ObjectCount());    }protected:    virtual void AddRef(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedIncrement(&amp;RefCountByOthers());        }        InterlockedIncrement(&amp;m_lRefCount);    }    virtual void Release(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedDecrement(&amp;RefCountByOthers());        }        if (0 == InterlockedDecrement(&amp;m_lRefCount))        {            delete this;        }    }    virtual const char* GetClassName() const    {        return typeid(*this).name();    }public:    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)    {        Cx_Object&lt;ClsType&gt;* p = new Cx_Object&lt;ClsType&gt;(false);        p-&gt;AddRef(fromdll);        return p;    }    static long STDMETHODCALLTYPE GetObjectCount()    {        return ObjectCount();    }    static long STDMETHODCALLTYPE GetRefCountByOthers()    {        return RefCountByOthers();    }private:    long        m_lRefCount;    static long&amp; ObjectCount()    {        static long s_lObjCount = 0;        return s_lObjCount;    }    static long&amp; RefCountByOthers()    {        static long s_lRefCount = 0;        return s_lRefCount;    }};#if defined(_MSC_VER) &amp;&amp; !defined(_CPPRTTI)#error must enable RTTI (compiled with /GR)#endifclass Cx_Ptr;//! An autoptr class with a specified interface.template &lt;class IF_Type&gt;class Cx_Interface{    typedef Cx_Interface&lt;IF_Type&gt; thisClass;public:    Cx_Interface() : m_pInterface(NULL), m_pObj(NULL)    {    }    Cx_Interface(const Cx_Ptr&amp; src);#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt; 1200 // not VC60    Cx_Interface(const thisClass&amp; src)        : m_pInterface(src.m_pInterface), m_pObj(src.m_pObj)    {        if (m_pInterface)        {            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }    Cx_Interface(IF_Type* pInterface) : m_pInterface(pInterface), m_pObj(NULL)    {        if (m_pInterface)        {            m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);            //ASSERT(m_pObj != NULL);            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }#endif // _MSC_VER    template &lt;class IF_Type2&gt;    explicit Cx_Interface(IF_Type2* pInterface) : m_pInterface(NULL), m_pObj(NULL)    {        if (pInterface)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }    }    template &lt;class IF_Type2&gt;    explicit Cx_Interface(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)        : m_pInterface(NULL), m_pObj(NULL)    {        if (pIF)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF.P());            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }    }    explicit Cx_Interface(const std::string&amp; clsid) : m_pInterface(NULL), m_pObj(NULL)    {        if (S_OK == xCreateObject(clsid, &amp;m_pObj))        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);            if (NULL == m_pInterface)            {                m_pObj-&gt;Release(xGetModuleHandle());                m_pObj = NULL;            }        }    }    ~Cx_Interface()    {        Unload();    }    inline IF_Type* P() const    {        return m_pInterface;    }    inline IF_Type* operator-&gt;() const    {        return m_pInterface;    }    template &lt;class IF_Type2&gt;    thisClass&amp; operator=(IF_Type2* pInterface)    {        Unload();        if (pInterface)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pInterface);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);                m_pObj-&gt;AddRef(xGetModuleHandle());            }        }        return *this;    }    template &lt;class IF_Type2&gt;    thisClass&amp; operator=(const Cx_Interface&lt;IF_Type2&gt;&amp; pIF)    {        return operator=(pIF.P());    }    thisClass&amp; operator=(const thisClass&amp; src)    {        if (this != &amp;src)        {            Load(src.m_pInterface);        }        return *this;    }    thisClass&amp; operator=(const Cx_Ptr&amp; src);    thisClass&amp; operator=(const int)    {        //ASSERT(0 == nul);        Unload();        return *this;    }    bool operator==(const int) const    {        //ASSERT(0 == nul);        return m_pInterface == NULL;    }    bool operator!=(const int) const    {        //ASSERT(0 == nul);        return m_pInterface != NULL;    }    bool operator==(const IF_Type* pInterface) const    {        return m_pInterface == pInterface;    }    bool operator!=(const IF_Type* pInterface) const    {        return m_pInterface != pInterface;    }    bool operator==(const thisClass&amp; src) const    {        return m_pInterface == src.m_pInterface;    }    bool operator!=(const thisClass&amp; src) const    {        return m_pInterface != src.m_pInterface;    }    inline operator bool() const    {        return m_pInterface != NULL;    }    inline bool operator!() const    {        return NULL == m_pInterface;    }    inline bool IsNull() const    {        return NULL == m_pInterface;    }    inline bool IsNotNull() const    {        return m_pInterface != NULL;    }    void Release()    {        Unload();    }    IF_Type* DetachInterface()    {        IF_Type* pIF = m_pInterface;        m_pInterface = NULL;        m_pObj = NULL;        return pIF;    }    bool AttachInterface(IF_Type* pIF)    {        Unload();        m_pInterface = pIF;        m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);        return (m_pObj != NULL || NULL == m_pInterface);    }    bool AttachInterface(Ix_Object* pIF)    {        Unload();        if (pIF)        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(pIF);            if (m_pInterface)            {                m_pObj = dynamic_cast&lt;Ix_Object*&gt;(m_pInterface);                //ASSERT(m_pObj != NULL);            }            else            {                pIF-&gt;Release(xGetModuleHandle());                pIF = NULL;                return false;            }        }        return true;    }    bool Create(const std::string&amp; clsid)    {        Unload();        if (S_OK == xCreateObject(clsid, &amp;m_pObj))        {            m_pInterface = dynamic_cast&lt;IF_Type*&gt;(m_pObj);            if (NULL == m_pInterface)            {                m_pObj-&gt;Release(xGetModuleHandle());                m_pObj = NULL;            }        }        return m_pInterface != NULL;    }private:    void Unload()    {        if (m_pObj)        {            m_pObj-&gt;Release(xGetModuleHandle());            m_pObj = NULL;            m_pInterface = NULL;        }    }    void Load(IF_Type* pIF)    {        Ix_Object* pObj = dynamic_cast&lt;Ix_Object*&gt;(pIF);        if (m_pObj != pObj)        {            if (pObj)            {                pObj-&gt;AddRef(xGetModuleHandle());            }            if (m_pObj)            {                m_pObj-&gt;Release(xGetModuleHandle());            }            m_pObj = pObj;            m_pInterface = pIF;        }    }private:    IF_Type*    m_pInterface;    Ix_Object*  m_pObj;};//! An autoptr class with the Ix_Object interface.class Cx_Ptr{public:    Cx_Ptr() : m_pInterface(NULL)    {    }    Cx_Ptr(const Cx_Ptr&amp; src) : m_pInterface(src.m_pInterface)    {        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    template &lt;class IF_Type&gt;    explicit Cx_Ptr(IF_Type* pInterface) : m_pInterface(NULL)    {        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    template &lt;class IF_Type&gt;    explicit Cx_Ptr(const Cx_Interface&lt;IF_Type&gt;&amp; pIF) : m_pInterface(NULL)    {        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pIF.P());        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }    }    explicit Cx_Ptr(const std::string&amp; clsid) : m_pInterface(NULL)    {        xCreateObject(clsid, &amp;m_pInterface);    }    ~Cx_Ptr()    {        Unload();    }    Ix_Object* P() const    {        return m_pInterface;    }    template &lt;class IF_Type&gt;    Cx_Ptr&amp; operator=(IF_Type* pInterface)    {        Unload();        m_pInterface = dynamic_cast&lt;Ix_Object*&gt;(pInterface);        if (m_pInterface)        {            m_pInterface-&gt;AddRef(xGetModuleHandle());        }        return *this;    }    template &lt;class IF_Type&gt;    Cx_Ptr&amp; operator=(const Cx_Interface&lt;IF_Type&gt;&amp; pIF)    {        return operator=(pIF.P());    }    Cx_Ptr&amp; operator=(const Cx_Ptr&amp; src)    {        if (this != &amp;src)        {            Load(src.m_pInterface);        }        return *this;    }    Cx_Ptr&amp; operator=(const int)    {        //ASSERT(0 == nul);        Unload();        return *this;    }    bool operator==(const int) const    {        //ASSERT(0 == nul);        return m_pInterface == NULL;    }    bool operator!=(const int) const    {        //ASSERT(0 == nul);        return m_pInterface != NULL;    }    bool operator==(const Ix_Object* pInterface) const    {        return m_pInterface == pInterface;    }    bool operator!=(const Ix_Object* pInterface) const    {        return m_pInterface != pInterface;    }    bool operator==(const Cx_Ptr&amp; src) const    {        return m_pInterface == src.m_pInterface;    }    bool operator!=(const Cx_Ptr&amp; src) const    {        return m_pInterface != src.m_pInterface;    }    inline operator bool() const    {        return m_pInterface != NULL;    }    inline bool operator!() const    {        return NULL == m_pInterface;    }    inline bool IsNull() const    {        return NULL == m_pInterface;    }    inline bool IsNotNull() const    {        return m_pInterface != NULL;    }    void Release()    {        Unload();    }    Ix_Object* DetachInterface()    {        Ix_Object* pIF = m_pInterface;        m_pInterface = NULL;        return pIF;    }    void AttachInterface(Ix_Object* pIF)    {        Unload();        m_pInterface = pIF;    }    bool Create(const std::string&amp; clsid)    {        Unload();        return S_OK == xCreateObject(clsid, &amp;m_pInterface);    }private:    void Unload()    {        if (m_pInterface)        {            m_pInterface-&gt;Release(xGetModuleHandle());            m_pInterface = NULL;        }    }    void Load(Ix_Object* pIF)    {        if (m_pInterface != pIF)        {            if (pIF)            {                pIF-&gt;AddRef(xGetModuleHandle());            }            if (m_pInterface)            {                m_pInterface-&gt;Release(xGetModuleHandle());            }            m_pInterface = pIF;        }    }private:    Ix_Object*  m_pInterface;};// Inlines for Cx_Interface//template &lt;class IF_Type&gt; inlineCx_Interface&lt;IF_Type&gt;::Cx_Interface(const Cx_Ptr&amp; src) : m_pInterface(NULL), m_pObj(NULL){    if (src.P())    {        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());        if (m_pInterface)        {            m_pObj = src.P();            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }}template &lt;class IF_Type&gt; inlineCx_Interface&lt;IF_Type&gt;&amp; Cx_Interface&lt;IF_Type&gt;::operator=(const Cx_Ptr&amp; src){    Unload();    if (src.P())    {        m_pInterface = dynamic_cast&lt;IF_Type*&gt;(src.P());        if (m_pInterface)        {            m_pObj = src.P();            m_pObj-&gt;AddRef(xGetModuleHandle());        }    }    return *this;}template &lt;class ClsType&gt;class Cx_SingletonObject    : public ClsType    , public Ix_Object    , public CModuleItem{protected:    Cx_SingletonObject(bool bRef = true) : m_lRefCount(bRef ? 1 : 0)    {    }    virtual ~Cx_SingletonObject()    {        if (Instance() == this)        {            Instance() = NULL;        }    }protected:    virtual void AddRef(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedIncrement(&amp;RefCountByOthers());        }        InterlockedIncrement(&amp;m_lRefCount);    }    virtual void Release(HMODULE fromdll)    {        if (fromdll != xGetModuleHandle())        {            InterlockedDecrement(&amp;RefCountByOthers());        }        InterlockedDecrement(&amp;m_lRefCount);    }    virtual const char* GetClassName() const    {        return typeid(*this).name();    }public:    static Ix_Object* STDMETHODCALLTYPE CreateObject(HMODULE fromdll)    {        if (NULL == Instance())        {            Cx_SingletonObject&lt;ClsType&gt;* p = new Cx_SingletonObject&lt;ClsType&gt;(false);#ifdef InterlockedCompareExchangePointer            if (InterlockedCompareExchangePointer(                (PVOID volatile *)(&amp;Instance()), p, NULL) == NULL)#else            if (InterlockedCompareExchange((void**)(&amp;Instance()), p, NULL) == NULL)#endif            {                p-&gt;AddRef(fromdll);                p-&gt;AddModuleItem();            }            else            {                delete p;   // has created by another thread            }        }        return Instance();    }    static long STDMETHODCALLTYPE GetObjectCount()    {        return (Instance() &amp;&amp; Instance()-&gt;m_lRefCount &gt; 0) ? 1 : 0;    }    static long STDMETHODCALLTYPE GetRefCountByOthers()    {        return RefCountByOthers();    }private:    long        m_lRefCount;    static Cx_SingletonObject&lt;ClsType&gt;*&amp; Instance()    {        static Cx_SingletonObject&lt;ClsType&gt;* s_pSingleton = NULL;        return s_pSingleton;    }    static long&amp; RefCountByOthers()    {        static long s_lRefCount = 0;        return s_lRefCount;    }};// XBEGIN_DEFINE_MODULE()//     XDEFINE_CLASSMAP_ENTRY(clsid, cls)//     XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)//     XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(clsid, iid, cls)// XEND_DEFINE_MODULE()// XEND_DEFINE_MODULE_WIN32DLL()// XEND_DEFINE_MODULE_MFCEXTDLL()// XEND_DEFINE_MODULE_MFCDLL()//! Begin group of class factory registry./*!\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XBEGIN_DEFINE_MODULE()  \    const _XCLASSMETA_ENTRY _XCLASSMETA_ENTRY::s_classes[] = {//! Register a regular class./*!\ingroup _GROUP_PLUGIN_CORE_\param clsid class unique id, XCLSID constant.\param cls implement class*/#define XDEFINE_CLASSMAP_ENTRY(clsid, cls)      \    _XCLASSMETA_ENTRY(1, &quot;Cx_Object&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_Object&lt;cls&gt;::CreateObject), \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_Object&lt;cls&gt;::GetObjectCount),  \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_Object&lt;cls&gt;::GetRefCountByOthers)),//! Register a single instance class./*!\ingroup _GROUP_PLUGIN_CORE_\param clsid class unique id, XCLSID constant.\param cls implement class*/#define XDEFINE_CLASSMAP_ENTRY_Singleton(clsid, cls)    \    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE,   \        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, clsid, &quot;&quot;,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),//! Register a single instance class that support the specific interface./*!\ingroup _GROUP_PLUGIN_CORE_\param iid the specific interface id name. char array constant.\param cls implement class*/#define XDEFINE_SPECIAL_INTERFACE_ENTRY_Singleton(iid, cls)     \    _XCLASSMETA_ENTRY(MIN_SINGLETON_TYPE + 1,   \        &quot;Cx_SingletonObject&lt;&quot; #cls &quot;&gt;&quot;, XCLSID(), iid,  \        reinterpret_cast&lt;PFNXObjectCreator&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::CreateObject),    \        reinterpret_cast&lt;PFNXGetObjectCount&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetObjectCount), \        reinterpret_cast&lt;PFNXRefCountByOthers&gt;(&amp;Cx_SingletonObject&lt;cls&gt;::GetRefCountByOthers)),//! End group of class factory registry./*!\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XEND_DEFINE_MODULE() \        _XCLASSMETA_ENTRY() \    };#pragma warning(disable:4710)   // inline function not expanded//! End group of class factory registry and implement entry function of Win32DLL(USRDLL)./*! Using this macro need include this file and XModuleImpl.h file.\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_MFCEXTDLL, XEND_DEFINE_MODULE_MFCDLL*/#define XEND_DEFINE_MODULE_WIN32DLL() \        _XCLASSMETA_ENTRY() \    };  \BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID)   \{   \    if (dwReason == DLL_PROCESS_ATTACH) \    {   \        _xGetModuleInterface(NULL, (HMODULE)hModule);   \    }   \    else if (dwReason == DLL_PROCESS_DETACH)    \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();    \    }   \    return TRUE;    \}//! End group of class factory registry and implement entry function of MFC Extension DLL./*! Using this macro need include this file and XModuleImpl.h file.\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCDLL*/#define XEND_DEFINE_MODULE_MFCEXTDLL() \        _XCLASSMETA_ENTRY() \    };  \static AFX_EXTENSION_MODULE MFCExtDLL = { NULL, NULL }; \extern &quot;C&quot; int APIENTRY \DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)    \{   \    if (dwReason == DLL_PROCESS_ATTACH) \    {   \        if (!AfxInitExtensionModule(MFCExtDLL, hInstance))  \            return 0;   \        new CDynLinkLibrary(MFCExtDLL); \        _xGetModuleInterface(NULL, MFCExtDLL.hModule);  \    }   \    else if (dwReason == DLL_PROCESS_DETACH)    \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();        \        AfxTermExtensionModule(MFCExtDLL);  \    }   \    return 1;   \}//! End group of class factory registry and implement entry function of MFC regular DLL./*! This macro implements CPluginApp class.\nUsing this macro need include this file and XModuleImpl.h file.\note Call the following statemant before call any MFC function: \nAFX_MANAGE_STATE(AfxGetStaticModuleState());\ingroup _GROUP_PLUGIN_CORE_\see XEND_DEFINE_MODULE_WIN32DLL, XEND_DEFINE_MODULE_MFCEXTDLL*/#define XEND_DEFINE_MODULE_MFCDLL() \        _XCLASSMETA_ENTRY() \    };  \class CPluginApp : public CWinApp   \{   \public: \    CPluginApp()    \    {   \    }   \    virtual BOOL InitInstance() \    {   \        CWinApp::InitInstance();    \        _xGetModuleInterface(NULL, m_hInstance);    \        return TRUE;    \    }   \    virtual int ExitInstance()  \    {   \        xGetCurrentModule()-&gt;ClearModuleItems();    \        return CWinApp::ExitInstance(); \    }   \};//以上为基础核心代码，以下为例子const std::string CLSID_Example(&quot;86347b32-64e4-490c-b273-ec7e010f244e&quot;);interface Ix_Example{    virtual void Foo() = 0;};interface Ix_Example2{    virtual void Foo2() = 0;};class Cx_Example    : public Ix_Example    , public Ix_Example2{protected:    Cx_Example() {};    virtual ~Cx_Example() {};private:    // From Ix_Example    virtual void Foo()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    };    // From Ix_Example2    virtual void Foo2()    {        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    };};XBEGIN_DEFINE_MODULE()XDEFINE_CLASSMAP_ENTRY(CLSID_Example, Cx_Example)XEND_DEFINE_MODULE()void MyFunc2(const Cx_Ptr&amp; obj){    // Cx_Interface与Cx_Ptr互转，转为特定接口    Cx_Interface&lt;Ix_Example&gt; pIFExample(obj);    if (pIFExample)    {        pIFExample-&gt;Foo();    }}Cx_Ptr MyFunc1(){    // 使用类ID和接口类型创建对象    Cx_Interface&lt;Ix_Example&gt; pIFExample(CLSID_Example);    if (pIFExample)    {        pIFExample-&gt;Foo();    // 调用接口函数    }    // 从一个接口转换为其他接口    Cx_Interface&lt;Ix_Example2&gt; pIFExample2(pIFExample);    if (pIFExample2.IsNotNull())    {        pIFExample2-&gt;Foo2();    }    MyFunc2(Cx_Ptr(pIFExample));    return Cx_Ptr(pIFExample);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;插件原理&quot;&gt;&lt;a href=&quot;#插件原理&quot; class=&quot;headerlink&quot; title=&quot;插件原理&quot;&gt;&lt;/a&gt;插件原理&lt;/h
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="X3框架" scheme="https://caojingyou.github.io/tags/X3%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>NLog</title>
    <link href="https://caojingyou.github.io/2018/05/17/NLog/"/>
    <id>https://caojingyou.github.io/2018/05/17/NLog/</id>
    <published>2018-05-17T01:37:00.000Z</published>
    <updated>2018-05-17T02:30:57.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NLog"><a href="#NLog" class="headerlink" title="NLog"></a>NLog</h1><p><a href="http://nlog-project.org/" target="_blank" rel="noopener">Nlog</a></p><p><a href="https://github.com/NLog/NLog" title="https://github.com/NLog/NLog" target="_blank" rel="noopener">https://github.com/NLog/NLog</a></p><p>Nlog是.net平台下的开源日志组件，相当于log4net用法配置更简单。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>Install-Package NLog.Config -Version 4.5.4</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>获取一个Logger实例，取名为NLogConsoleExample（名字可任意），也可采用 LogManager.GetCurrentClassLogger()来获取一个以当前类名为名称的Logger实例；然后我们在main方法中添加几行简单调用NLog输出不同级别的日志信息的代码</p><p>下面的代码将会创建一个和class有着相同名字的Logger。</p><pre><code>namespace MyNamespace{  public class MyClass  {        private static Logger logger = LogManager.GetCurrentClassLogger();  }}</code></pre><p>管理Logger的名字也是可以的：</p><pre><code>using NLog;Logger logger = LogManager.GetLogger(&quot;MyClassName&quot;);</code></pre><h1 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h1><p>每一个日志消息都用一个日志级别来修饰，它们用来识别消息的重要性和具体细节。NLog可以以Logger对象的名称和日志级别为主，路由日志消息。</p><p>NLog支持下面的日志级别：</p><ul><li>Trace 特别细节的日志，可能包含大量的信息，比如说协议的负载。这个日志级别通常只会在开发期间被启用。</li><li>Debug Debug信息，比Trace的信息量要少一些，通常不会在生产环境下使用。</li><li>Info 信息消息，这个是在生产环境下经常使用到的。</li><li>Warn 警告消息，通常用来指示非关键性的问题，这些问题可以被恢复或者只是临时错误。</li><li>Error 错误消息 大多数时候，他们都是Exception（异常）。</li><li>Fatal 特别严重的错误！</li></ul><h1 id="书写日志消息"><a href="#书写日志消息" class="headerlink" title="书写日志消息"></a>书写日志消息</h1><pre><code>using NLog;public class MyClass{  private static Logger logger = LogManager.GetCurrentClassLogger();  public void MyMethod1()  {    logger.Trace(&quot;Sample trace message&quot;);    logger.Debug(&quot;Sample debug message&quot;);    logger.Info(&quot;Sample informational message&quot;);    logger.Warn(&quot;Sample warning message&quot;);    logger.Error(&quot;Sample error message&quot;);    logger.Fatal(&quot;Sample fatal error message&quot;);    // alternatively you can call the Log() method     // and pass log level as the parameter.    logger.Log(LogLevel.Info, &quot;Sample informational message&quot;);  }}</code></pre><p>日志消息也可以被参数化 - 你可以使用字符串格式，就像你在Console.WriteLine()和String.Format()中一样：</p><pre><code>using NLog;public class MyClass{  private static Logger logger = LogManager.GetCurrentClassLogger();  public void MyMethod1()  {    int k = 42;    int l = 100;    logger.Trace(&quot;Sample trace message, k={0}, l={1}&quot;, k, l);    logger.Debug(&quot;Sample debug message, k={0}, l={1}&quot;, k, l);    logger.Info(&quot;Sample informational message, k={0}, l={1}&quot;, k, l);    logger.Warn(&quot;Sample warning message, k={0}, l={1}&quot;, k, l);    logger.Error(&quot;Sample error message, k={0}, l={1}&quot;, k, l);    logger.Fatal(&quot;Sample fatal error message, k={0}, l={1}&quot;, k, l);    logger.Log(LogLevel.Info, &quot;Sample informational message, k={0}, l={1}&quot;, k, l);  }}</code></pre><h1 id="NLog配置文件支持两种方式"><a href="#NLog配置文件支持两种方式" class="headerlink" title="NLog配置文件支持两种方式"></a>NLog配置文件支持两种方式</h1><ul><li>是将配置写到应用程序的配置文件（通常是applicationName.exe.config）或者Web.config文件中；</li><li><p>独配置到一个文件，通常是NLog.config</p><p>  &lt;?xml version=”1.0” encoding=”utf-8” ?&gt;</p>  <nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><br><br>      <targets><br>          <target name="logfile" xsi:type="File" filename="file.txt"><br>      </target></targets><br><br>      <rules><br>          <logger name="*" minlevel="Info" writeto="logfile"><br>      </logger></rules><br>  </nlog></li></ul><p>多个目标</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;targets&gt;        &lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; /&gt;        &lt;target name=&quot;console&quot; xsi:type=&quot;Console&quot; /&gt;    &lt;/targets&gt;    &lt;rules&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;logfile&quot; /&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Info&quot; writeTo=&quot;console&quot; /&gt;    &lt;/rules&gt;&lt;/nlog&gt;</code></pre><p>还有一个比较常见的应用场景则是，需要为当前正在开发的组件提供更多细节的日志，而其他的组件将会减少输出。我们就可以用这样的配置文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;targets&gt;        &lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; /&gt;    &lt;/targets&gt;    &lt;rules&gt;        &lt;logger name=&quot;SomeNamespace.Component.*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;logfile&quot; final=&quot;true&quot; /&gt;        &lt;logger name=&quot;*&quot; minlevel=&quot;Info&quot; writeTo=&quot;logfile&quot; /&gt;    &lt;/rules&gt;&lt;/nlog&gt;</code></pre><p>第一个规则将会将以SomeNamespace.Component开头的Logger对象的Trace级别及以上级别的日志发送到日志文件。属性final=true将会使得在写入操作之后停止进一步处理。<br>第二个规则将会将剩下的日志发送到同一个日志文件，但是这些日志有一个约束，那就是级别需要是Info或更高。</p><h1 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h1><p>层级提供了一个当日志被写入文件时，指定日志内容格式的方法。主要有两种层级：</p><pre><code>简单层级 - 使用层级渲染器撰写。结构层级 - 可以输出XML、CSV、以及其他复杂的格式。</code></pre><p>简单层级就是一个字符串，在${和}中嵌入一些特殊的标记。比如下面的声明将会使得每一条日志消息都是用一个格式为yyyMMddHHmmss:的日期前缀：</p><pre><code>&lt;target name=&quot;logfile&quot; xsi:type=&quot;File&quot; fileName=&quot;file.txt&quot; layout=&quot;${date:format=yyyyMMddHHmmss} ${message}&quot; /&gt;</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/Toshiya14/article/details/52098088" title="NLog简易入门" target="_blank" rel="noopener">https://blog.csdn.net/Toshiya14/article/details/52098088</a></p><p><a href="https://github.com/NLog/NLog/wiki/Configuration-file" title="https://github.com/NLog/NLog/wiki/Configuration-file" target="_blank" rel="noopener">https://github.com/NLog/NLog/wiki/Configuration-file</a></p><p><a href="https://github.com/NLog/NLog/wiki/Configuration-API" title="https://github.com/NLog/NLog/wiki/Configuration-API" target="_blank" rel="noopener">https://github.com/NLog/NLog/wiki/Configuration-API</a></p><p><a href="https://blog.csdn.net/dsnq2011/article/details/51920265" target="_blank" rel="noopener">NLog的配置和使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NLog&quot;&gt;&lt;a href=&quot;#NLog&quot; class=&quot;headerlink&quot; title=&quot;NLog&quot;&gt;&lt;/a&gt;NLog&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://nlog-project.org/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="NLog" scheme="https://caojingyou.github.io/tags/NLog/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之禅-笔记</title>
    <link href="https://caojingyou.github.io/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"/>
    <id>https://caojingyou.github.io/2018/05/15/设计模式之禅/</id>
    <published>2018-05-15T01:32:00.000Z</published>
    <updated>2018-05-15T01:32:36.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><h2 id="秦小波"><a href="#秦小波" class="headerlink" title="秦小波"></a>秦小波</h2><h3 id="Citation-APA-秦小波-2010-设计模式之禅-Kindle-Android-version-Retrieved-from-Amazon-com"><a href="#Citation-APA-秦小波-2010-设计模式之禅-Kindle-Android-version-Retrieved-from-Amazon-com" class="headerlink" title="Citation (APA): 秦小波. (2010). 设计模式之禅 [Kindle Android version]. Retrieved from Amazon.com"></a>Citation (APA): 秦小波. (2010). 设计模式之禅 [Kindle Android version]. Retrieved from Amazon.com</h3><p>单例模式和原型模式非常容易理解，单例模式是要保持在内存中只有一个对象，原型模式是要求通过复制的方式产生一个新的对象，这两个不容易混淆。</p><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步的精确构造创建出一个复杂的对象。</p><p>一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。</p><p>如果需要详细关注一个产品部件的生产、安装步骤，则选择建造者，否则选择工厂方法模式。</p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>为什么叫结构类模式呢？因为它们都是通过组合类或对象产生更大结构以适应更高层次的逻辑需求。</p><p>装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口，不同点则是代理模式着重对代理过程的控制，而装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化，</p><p>代理模式和装饰模式有非常相似的地方，甚至代码实现都非常相似，特别是装饰模式中省略抽象装饰角色后，两者代码基本上相同，但是还是有细微的差别。代理模式是把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，它不对被主题角色（也就是被代理类）的功能做任何处理，保证原汁原味的调用。代理模式使用到极致开发就是AOP，这是各位采用Spring架构开发必然要使用到的技术，它就是使用了代理和反射的技术。装饰模式是在要保证接口不变的情况下加强类的功能，它保证的是被修饰的对象功能比原始对象丰富（当然，也可以减弱），但不做准入条件判断和准入参数过滤，如是否可以执行类的功能，过滤输入参数是否合规等，这不是装饰模式关心的。</p><p>装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。</p><p>装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。</p><p>行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。</p><p>命令模式和策略模式的类图确实很相似，只是命令模式多了一个接收者（Receiver）角色。它们虽然同为行为类模式，但是两者的区别还是很明显的。策略模式的意图是封装算法，它认为“算法”已经是一个完整的、不可拆分的原子业务（注意这里是原子业务，而不是原子对象），即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象（接收者角色）、执行行为（命令角色），让两者相互独立而不相互影响。</p><p>策略模式和命令模式相似，特别是命令模式退化时，比如无接收者（接收者非常简单或者接收者是一个Java的基础操作，无需专门编写一个接收者），在这种情况下，命令模式和策略模式的类图完全一样，代码实现也比较类似，但是两者还是有区别的。</p><p>策略模式关注的是算法替换的问题，一个新的算法投产，旧算法退休，或者提供多种算法由调用者自己选择使用，算法的自由更替是它实现的要点。换句话说，策略模式关注的是算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换。命令模式则关注的是解耦问题，如何让请求者和执行者解耦是它需要首先解决的，解耦的要求就是把请求的内容封装为一个一个的命令，由接收者执行。由于封装成了命令，就同时可以对命令进行多种处理，例如撤销、记录等。</p><p>策略模式中的抽象算法和具体算法与命令模式的接收者非常相似，但是它们的职责不同。策略模式中的具体算法是负责一个完整算法逻辑，它是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。</p><p>策略模式适用于算法要求变换的场景，而命令模式适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景。</p><p>策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；而状态模式封装的是不同的状态，以达到状态切换行为随之发生改变的目的。这两种模式虽然都有变换的行为，但是两者的目标却是不同的。</p><p>策略模式的环境角色只是一个委托作用，负责算法的替换；而状态模式的环境角色不仅仅是委托行为，它还具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。</p><p>策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模式对外暴露的是行为，状态的变化一般是由环境角色和具体状态共同完成的，也就是说状态模式封装了状态的变化而暴露了不同的行为或行为结果。</p><p>在责任链模式中，上下节点没有关系，都是接收同样的对象，所有传递的对象都是从链首传递过来，上一节点是什么没有关系，只要按照自己的逻辑处理就成。而触发链模式就不同了，它的上下级关系很亲密，下级对上级顶礼膜拜，上级对下级绝对信任，链中的任意两个相邻节点都是一个牢固的独立团体。</p><p>在责任链模式中，一个消息从链首传递进来后，就开始沿着链条向链尾运动，方向是单一的、固定的；而触发链模式则不同，由于它采用的是观察者模式，所以有非常大的灵活性，一个消息传递到链首后，具体怎么传递是不固定的，可以以广播方式传递，也可以以跳跃方式传递，这取决于处理消息的逻辑。</p><p>创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着重于如何建立一个软件结构，虽然三种模式的着重点不同，</p><p>策略模式实现两种算法的自由切换，它提供了这样的保证：封装邮件的两种行为是可选择的，至于选择哪个算法是由上层模块决定的。策略模式要完成的任务就是提供两种可以替换的算法。</p><p>桥梁模式关注的是抽象和实现的分离，它是结构型模式，</p><p>简单来说，策略模式是使用继承和多态建立一套可以自由切换算法的模式，桥梁模式是在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。桥梁模式必然有两个“桥墩”——抽象化角色和实现化角色，只要桥墩搭建好，桥就有了，而策略模式只有一个抽象角色，可以没有实现，也可以有很多实现。</p><p>门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的问题。中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构。</p><p>门面模式和中介者模式之间的区别还是比较明显的，门面模式是以封装和隔离为主要任务，而中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务逻辑控制。</p><p>门面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门面模式是完全可以独立运行的。而中介者模式则增加了业务功能，它把各个同事类中的原有耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂性和降低扩展性。</p><p>门面模式是一种简单的封装，所有的请求处理都委托给子系统完成，而中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的业务功能封装。</p><p>包装模式包括：装饰模式、适配器模式、门面模式、代理模式、桥梁模式。</p><p>5个包装模式是大家在系统设计中经常会用到的模式，它们具有相似的特征：都是通过委托的方式对一个对象或一系列对象（例如门面模式）施行包装，有了包装，设计的系统才更加灵活、稳定，并且极具扩展性。从实现的角度来看，它们都是代理的一种具体表现形式，</p><p>装饰模式是一种特殊的代理模式，它倡导的是在不改变接口的前提下为对象增强功能，或者动态添加额外职责。就扩展性而言，它比子类更加灵活，例如在一个已经运行的项目中，可以很轻松地通过增加装饰类来扩展系统的功能。适配器模式的主要意图是接口转换，把一个对象的接口转换成系统希望的另外一个接口，这里的系统指的不仅仅是一个应用，也可能是某个环境，比如通过接口转换可以屏蔽外界接口，以免外界接口深入系统内部，从而提高系统的稳定性和可靠性。桥梁模式是在抽象层产生耦合，解决的是自行扩展的问题，它可以使两个有耦合关系的对象互不影响地扩展，比如对于使用笔画图这样的需求，可以采用桥梁模式设计成用什么笔（铅笔、毛笔）画什么图（圆形、方形）的方案，至于以后需求的变更，如增加笔的类型，增加图形等，对该设计来说是小菜一碟。门面模式是一个粗粒度的封装，它提供一个方便访问子系统的接口，不具有任何的业务逻辑，仅仅是一个访问复杂系统的快速通道，没有它，子系统照样运行，有了它，只是更方便访问而已。</p><h1 id="23种设计模式彩图"><a href="#23种设计模式彩图" class="headerlink" title="23种设计模式彩图"></a>23种设计模式彩图</h1><p><img src="https://i.imgur.com/WT9XrQv.png" alt=""></p><p><img src="https://i.imgur.com/oOq0ZC4.png" alt=""></p><p><img src="https://i.imgur.com/ujyOLJH.png" alt=""></p><p><img src="https://i.imgur.com/fAc8qmZ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式之禅&quot;&gt;&lt;a href=&quot;#设计模式之禅&quot; class=&quot;headerlink&quot; title=&quot;设计模式之禅&quot;&gt;&lt;/a&gt;设计模式之禅&lt;/h1&gt;&lt;h2 id=&quot;秦小波&quot;&gt;&lt;a href=&quot;#秦小波&quot; class=&quot;headerlink&quot; title=&quot;秦小波
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="设计模式" scheme="https://caojingyou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="笔记" scheme="https://caojingyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>史上最全设计模式导学目录笔记</title>
    <link href="https://caojingyou.github.io/2018/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/05/09/设计模式/</id>
    <published>2018-05-09T10:10:00.000Z</published>
    <updated>2018-07-16T07:57:10.332Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录（完整版）</a></p><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责，在GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。</p><ol><li>创建型模式-Creational Pattern[(122434),(435532)]<ol><li>单例模式-Singleton Pattern</li><li>简单工厂模式-Simple Factory Pattern</li><li>工厂方法模式-Factory Method Pattern</li><li>抽象工厂模式-Abstract  Factory Pattern</li><li>原型模式-Prototype Pattern</li><li>建造者模式-Builder Pattern</li></ol></li><li>结构型模式-Structural Pattern[(2333143),(4343515)]<ol><li>适配器模式-Adapter Pattern</li><li>桥接模式-Bridge  Pattern</li><li>组合模式-Composite  Pattern</li><li>装饰模式-Decorator  Pattern</li><li>外观模式-Façade  Pattern</li><li>享元模式-Flyweight  Pattern</li><li>代理模式-Proxy  Pattern</li></ol></li><li>行为型模式-Behavioral Pattern [(33533233124),(24152253431)]<ol><li>职责链模式-Chain  of Responsibility Pattern</li><li>命令模式-Command  Pattern</li><li>解释器模式-Interpreter  Pattern</li><li>迭代器模式-Iterator  Pattern</li><li>中介者模式-Mediator  Pattern</li><li>备忘录模式-Memento  Pattern</li><li>观察者模式-Observer  Pattern</li><li>状态模式-State  Pattern</li><li>策略模式-Strategy  Pattern</li><li>模板方法模式-Template  Method Pattern</li><li>访问者模式-Visitor  Pattern</li></ol></li></ol><p>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。当你能够回答上述所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做。</p><h1 id="设计模式概述-1"><a href="#设计模式概述-1" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><pre><code>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</code></pre><p>设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。模式名称(Pattern Name)通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名）；问题(Problem)描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；解决方案(Solution)描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；效果(Consequences)描述了模式的优缺点以及在使用模式时应权衡的问题。</p><p>学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="7种常用的面向对象设计原则"><a href="#7种常用的面向对象设计原则" class="headerlink" title="7种常用的面向对象设计原则"></a>7种常用的面向对象设计原则</h2><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责</p><p>★★★★☆</p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则</p><h3 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h3><p>软件实体应对扩展开放，而对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>★★★★★</p><p>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p><p>抽象化是开闭原则的关键</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle, LSP)"></a>里氏代换原则(Liskov Substitution Principle, LSP)</h3><p>所有引用基类对象的地方能够透明地使用其子类的对象</p><p>★★★★★</p><p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence  Inversion Principle, DIP)"></a>依赖倒转原则(Dependence  Inversion Principle, DIP)</h3><p>抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p>★★★★★</p><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><p>★★☆☆☆</p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</p><p>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</p><h3 id="合成复用原则-Composite-Reuse-Principle-CRP"><a href="#合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle, CRP)"></a>合成复用原则(Composite Reuse Principle, CRP)</h3><p>尽量使用对象组合，而不是继承来达到复用的目的</p><p>★★★★☆</p><p>复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p><p>一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p><h3 id="迪米特法则-Law-of-Demeter-LoD"><a href="#迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="迪米特法则(Law of Demeter, LoD)"></a>迪米特法则(Law of Demeter, LoD)</h3><p>一个软件实体应当尽可能少地与其他实体发生相互作用</p><p>★★★☆☆</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><h1 id="六个创建型模式"><a href="#六个创建型模式" class="headerlink" title="六个创建型模式"></a>六个创建型模式</h1><h2 id="简单工厂模式-Simple-Factory-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"><a href="#简单工厂模式-Simple-Factory-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】" class="headerlink" title="简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"></a>简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】</h2><pre><code>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</code></pre><p><img src="https://i.imgur.com/ktolWfk.jpg" alt="简单工厂模式结构图"></p><p>在简单工厂模式结构图中包含如下几个角色：</p><pre><code>● Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。● Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通的工厂方法，因为所有创建的具体产品对象都是其子类对象。● ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</code></pre><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p><p><img src="https://i.imgur.com/qYqQ1oO.jpg" alt="简化的简单工厂模式"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用简单工厂模式：(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</code></pre><h2 id="工厂方法模式-Factory-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】"><a href="#工厂方法模式-Factory-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】" class="headerlink" title="工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】"></a>工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】</h2><p>针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p><pre><code>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</code></pre><p>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p><p><img src="https://i.imgur.com/DCe0loP.jpg" alt="工厂方法模式结构图"></p><p>在工厂方法模式结构图中包含如下几个角色：</p><pre><code>● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</code></pre><p>工厂方法可重载、隐藏</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用工厂方法模式：(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</code></pre><h2 id="抽象工厂模式-Abstract-Factory-Pattern【学习难度：★★★★☆，使用频率：★★★★★】"><a href="#抽象工厂模式-Abstract-Factory-Pattern【学习难度：★★★★☆，使用频率：★★★★★】" class="headerlink" title="抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】"></a>抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】</h2><p>将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产</p><p>两个概念：</p><pre><code>(1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。(2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</code></pre><p> 当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。</p><p><img src="https://i.imgur.com/uqacKB3.jpg" alt="抽象工厂模式示意图"></p><pre><code>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</code></pre><p><img src="https://i.imgur.com/3Cs7ReY.jpg" alt="抽象工厂模式结构图"></p><p>在抽象工厂模式结构图中包含如下几个角色：</p><pre><code>● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</code></pre><p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><pre><code>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用抽象工厂模式：(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。(4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</code></pre><h2 id="单例模式-Singleton-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"><a href="#单例模式-Singleton-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】" class="headerlink" title="单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"></a>单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】</h2><p>为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个唯一实例创建成功之后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一实例。为了确保对象的唯一性，我们可以通过单例模式来实现，这就是单例模式的动机所在。</p><pre><code>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</code></pre><p><img src="https://i.imgur.com/hOf5w5n.gif" alt="单例模式结构图"></p><p><img src="https://i.imgur.com/igHfk94.gif" alt="饿汉"></p><p><img src="https://i.imgur.com/b0dMu0n.gif" alt="懒汉"></p><p>饿汉式单例类与懒汉式单例类比较</p><pre><code>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用单例模式：(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</code></pre><h2 id="原型模式-Prototype-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#原型模式-Prototype-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><pre><code>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</code></pre><p><img src="https://i.imgur.com/6ZnEE7F.gif" alt="原型模式结构图"></p><p>在原型模式结构图中包含如下几个角色：</p><pre><code>●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</code></pre><p>3.适用场景</p><pre><code>在以下情况下可以考虑使用原型模式：(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</code></pre><h2 id="建造者模式-Builder-Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】"><a href="#建造者模式-Builder-Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】" class="headerlink" title="建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】"></a>建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】</h2><pre><code>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</code></pre><p><img src="https://i.imgur.com/dje8jpN.gif" alt="建造者模式结构图"></p><p>在建造者模式结构图中包含如下几个角色：</p><pre><code>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用建造者模式：(1) 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。(2) 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。(3) 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。(4) 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</code></pre><h1 id="七个结构型模式"><a href="#七个结构型模式" class="headerlink" title="七个结构型模式"></a>七个结构型模式</h1><h2 id="适配器模式-Adapter-Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】"><a href="#适配器模式-Adapter-Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】" class="headerlink" title="适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】"></a>适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】</h2><pre><code>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</code></pre><p>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p><p><img src="https://i.imgur.com/hBaeja9.jpg" alt="对象适配器模式结构图"></p><p>在对象适配器模式结构图中包含如下几个角色：</p><pre><code>● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</code></pre><p>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系</p><p><img src="https://i.imgur.com/yh4hVHL.jpg" alt="类适配器模式结构图"></p><p>在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器</p><p><img src="https://i.imgur.com/TwfQRn4.jpg" alt="双向适配器结构示意图"></p><p>在实际开发中，我们很少使用双向适配器。</p><pre><code>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</code></pre><p><img src="https://i.imgur.com/a6Jq0qP.jpg" alt="缺省适配器模式结构图"></p><p>在缺省适配器模式中，包含如下三个角色：</p><pre><code>● ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。● AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。● ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用适配器模式：(1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。(2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</code></pre><h2 id="桥接模式-Bridge-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#桥接模式-Bridge-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p><p>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。</p><pre><code>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</code></pre><p><img src="https://i.imgur.com/g3pbWhd.gif" alt="桥接模式"></p><p>在桥接模式结构图中包含如下几个角色：</p><pre><code>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</code></pre><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用桥接模式：(1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。(2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。(3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。(4)对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</code></pre><h2 id="组合模式-Composite-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#组合模式-Composite-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"></a>组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】</h2><p>组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子。</p><pre><code>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</code></pre><p><img src="https://i.imgur.com/vY4z3uM.jpg" alt="组合模式结构图"></p><p>在组合模式结构图中包含如下几个角色：</p><pre><code>● Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</code></pre><p> 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。</p><p><img src="https://i.imgur.com/F4tBofj.jpg" alt="透明组合模式结构图"></p><p><img src="https://i.imgur.com/q0IliKP.jpg" alt="安全组合模式结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用组合模式：(1) 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。(2) 在一个使用面向对象语言开发的系统中需要处理一个树形结构。(3) 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</code></pre><h2 id="装饰模式-Decorator-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#装饰模式-Decorator-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为</p><p>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p><pre><code>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</code></pre><p><img src="https://i.imgur.com/jWvDFcW.gif" alt="装饰模式结构图"></p><p>在装饰模式结构图中包含如下几个角色：</p><pre><code>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。● Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</code></pre><p>如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类</p><p><img src="https://i.imgur.com/as41KJw.gif" alt="没有抽象构件类的装饰模式"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用装饰模式：(1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</code></pre><h2 id="外观模式-Facade-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】"><a href="#外观模式-Facade-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】" class="headerlink" title="外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】"></a>外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】</h2><p>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</p><pre><code>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</code></pre><p><img src="https://i.imgur.com/InaRiIy.jpg" alt="外观模式结构图"></p><p>外观模式包含如下两个角色：</p><pre><code>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</code></pre><p>模式适用场景</p><pre><code>在以下情况下可以考虑使用外观模式：(1) 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。(2) 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。(3) 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</code></pre><h2 id="享元模式-Flyweight-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"><a href="#享元模式-Flyweight-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】" class="headerlink" title="享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"></a>享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】</h2><p>享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。</p><pre><code>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</code></pre><p><img src="https://i.imgur.com/U2OBnLa.jpg" alt="享元模式结构图"></p><p>在享元模式结构图中包含如下几个角色：</p><pre><code>● Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。● ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。● UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。● FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</code></pre><p>标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式</p><p><img src="https://i.imgur.com/6zGVrnG.jpg" alt="单纯享元模式结构图"></p><p><img src="https://i.imgur.com/OlPRQt4.jpg" alt="复合享元模式结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用享元模式：(1) 一个系统有大量相同或者相似的对象，造成内存的大量耗费。(2) 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。(3) 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</code></pre><h2 id="代理模式-Proxy-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#代理模式-Proxy-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"></a>代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】</h2><p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理、智能引用代理等，它们应用于不同的场合，满足用户的不同需求。</p><pre><code>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</code></pre><p><img src="https://i.imgur.com/cetGMGu.jpg" alt="代理模式结构图"></p><p>代理模式包含如下三个角色：</p><pre><code>(1) Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。(2) Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。(3) RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</code></pre><p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p><pre><code>(1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。(2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。(3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。(4) 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。(5) 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</code></pre><p>模式适用场景</p><pre><code>代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：(1) 当客户端对象需要访问远程主机中的对象时可以使用远程代理。(2) 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。(3) 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。(4) 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。(5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</code></pre><h1 id="十一个行为型模式"><a href="#十一个行为型模式" class="headerlink" title="十一个行为型模式"></a>十一个行为型模式</h1><h2 id="职责链模式-Chain-of-Responsibility-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"><a href="#职责链模式-Chain-of-Responsibility-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】" class="headerlink" title="职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"></a>职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】</h2><pre><code>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/CfxiiOk.gif" alt="职责链模式"></p><p>在职责链模式结构图中包含如下几个角色：</p><pre><code>● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。● ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</code></pre><p>职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用职责链模式：(1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。(2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。(3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </code></pre><h2 id="命令模式-Command-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"><a href="#命令模式-Command-Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】" class="headerlink" title="命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】"></a>命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】</h2><pre><code>命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</code></pre><p><img src="https://i.imgur.com/9QmNFgZ.jpg" alt="命令模式结构图"></p><p>在命令模式结构图中包含如下几个角色：</p><pre><code>● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</code></pre><p>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。</p><p>有时候我们需要将多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，我们可以通过命令队列来实现。</p><p>在命令模式中，我们可以通过调用一个命令对象的execute()方法来实现对请求的处理，如果需要撤销(Undo)请求，可通过在命令类中增加一个逆向操作来实现。</p><p>除了通过一个逆向操作来实现撤销(Undo)外，还可以通过保存对象的历史状态来实现撤销，后者可使用备忘录模式(Memento Pattern)来实现。</p><p>请求日志</p><pre><code>请求日志就是将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件、Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，常用功能如下：(1) “天有不测风云”，一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态；(2) 请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列；(3) 可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取请求日志文件，再继续执行文件中剩余的命令即可。</code></pre><p>宏命令</p><pre><code>宏命令(Macro Command)又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</code></pre><p><img src="https://i.imgur.com/0aqdNao.jpg" alt="宏命令结构图"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用命令模式：(1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。(2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。(3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。(4) 系统需要将一组操作组合在一起形成宏命令。</code></pre><h2 id="解释器模式-Interpreter-Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】"><a href="#解释器模式-Interpreter-Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】" class="headerlink" title="解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】"></a>解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】</h2><p><img src="https://i.imgur.com/tS0J1Vl.jpg" alt="抽象语法树示意图"></p><p>在该抽象语法树中，可以通过终结符表达式value和非终结符表达式operation组成复杂的语句，每个文法规则的语言实例都可以表示为一个抽象语法树，即每一条具体的语句都可以用类似上图所示的抽象语法树来表示，在图中终结符表达式类的实例作为树的叶子节点，而非终结符表达式类的实例作为非叶子节点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子节点。抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。</p><pre><code>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</code></pre><p> 由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素</p><p><img src="https://i.imgur.com/QwlLayp.jpg" alt="解释器模式结构图"></p><p>在解释器模式结构图中包含如下几个角色：</p><pre><code>● AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。● TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。● NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。● Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</code></pre><p> 在解释器模式中，环境类Context用于存储解释器之外的一些全局信息，它通常作为参数被传递到所有表达式的解释方法interpret()中，可以在Context对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外还可以在Context中增加一些所有表达式解释器都共有的功能，减轻解释器的职责。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用解释器模式：(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。(2) 一些重复出现的问题可以用一种简单的语言来进行表达。(3) 一个语言的文法较为简单。(4) 执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】</code></pre><h2 id="迭代器模式-Iterator-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"><a href="#迭代器模式-Iterator-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】" class="headerlink" title="迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"></a>迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】</h2><p>将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，无须暴露聚合类的内部属性即可对其进行操作，而这正是迭代器模式的意图所在。</p><p> 在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。</p><pre><code>迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/AFTxJbd.jpg" alt="迭代器模式结构图"></p><p>在迭代器模式结构图中包含如下几个角色：</p><pre><code>● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</code></pre><p>需要注意的是抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法都提供声明，另一方面又不能包含太多方法，接口中方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避免之后修改接口。</p><p>除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，我们还可以将迭代器类设计为聚合类的内部类</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用迭代器模式：(1) 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。(2) 需要为一个聚合对象提供多种遍历方式。(3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</code></pre><h2 id="中介者模式-Mediator-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"><a href="#中介者模式-Mediator-Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】" class="headerlink" title="中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】"></a>中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】</h2><pre><code>中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/lv7HWAY.jpg" alt="中介者模式结构图"></p><p>在中介者模式结构图中包含如下几个角色：</p><pre><code>● Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。● ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。● Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。● ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</code></pre><p>中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：</p><pre><code>(1) 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。(2) 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</code></pre><p>在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需要修改少许代码（如果引入配置文件的话有时可以不修改任何代码）就可以实现中介者的更换。</p><p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用中介者模式：(1) 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。(2) 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。(3) 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</code></pre><h2 id="备忘录模式-Memento-Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】"><a href="#备忘录模式-Memento-Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】" class="headerlink" title="备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】"></a>备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】</h2><pre><code>备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</code></pre><p><img src="https://i.imgur.com/hYBu3rR.jpg" alt="备忘录模式"></p><p>在备忘录模式结构图中包含如下几个角色：</p><pre><code>● Originator（原发器）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。●Memento（备忘录)：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。●Caretaker（负责人）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</code></pre><p>在设计备忘录类时需要考虑其封装性，除了Originator类，不允许其他类来调用备忘录类Memento的构造函数与相关方法，如果不考虑封装性，允许其他类调用setState()等方法，将导致在备忘录中保存的历史状态发生改变，通过撤销操作所恢复的状态就不再是真实的历史状态，备忘录模式也就失去了本身的意义。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用备忘录模式：(1)保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。(2)防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</code></pre><h2 id="观察者模式-Observer-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"><a href="#观察者模式-Observer-Pattern【学习难度：★★★☆☆，使用频率：★★★★★】" class="headerlink" title="观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】"></a>观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】</h2><pre><code>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/p5T9C4N.jpg" alt="观察者模式结构图"></p><p>在观察者模式结构图中包含如下几个角色：</p><pre><code>● Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。● ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。● ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</code></pre><p>在有些更加复杂的情况下，具体观察者类ConcreteObserver的update()方法在执行时需要使用到具体目标类ConcreteSubject中的状态（属性），因此在ConcreteObserver与ConcreteSubject之间有时候还存在关联或依赖关系，在ConcreteObserver中定义一个ConcreteSubject实例，通过该实例获取存储在ConcreteSubject中的状态。如果ConcreteObserver的update()方法不需要使用到ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。如果在具体层具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违反了“开闭原则”，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。</p><p>观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用观察者模式：(1) 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。(2) 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。(3) 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</code></pre><h2 id="状态模式-State-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"><a href="#状态模式-State-Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】" class="headerlink" title="状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】"></a>状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</h2><p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。</p><pre><code>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/mC0AUst.jpg" alt="状态模式结构图"></p><p>在状态模式结构图中包含如下几个角色：</p><pre><code>● Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。● State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。● ConcreteState（具体状态类）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</code></pre><p>环境类实际上是真正拥有状态的对象，我们只是将环境类中与状态有关的代码提取出来封装到专门的状态类中。在状态模式结构图中，环境类Context与抽象状态类State之间存在单向关联关系，在Context中定义了一个State对象。在实际使用时，它们之间可能存在更为复杂的关系，State与Context之间可能也存在依赖或者关联关系。</p><p>在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式：</p><pre><code>(1) 统一由环境类来负责状态之间的转换，此时，环境类还充当了状态管理器(State Manager)角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换(2) 由具体状态类来负责状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性值再根据情况为环境类设置新的状态对象，实现状态转换，同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间就将存在依赖或关联关系，因为状态类需要访问环境类中的属性值</code></pre><p>在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。</p><p>在状态模式中实现状态转换时，具体状态类可通过调用环境类Context的setState()方法进行状态的转换操作，也可以统一由环境类Context来实现状态的转换。</p><p>适用场景</p><pre><code>在以下情况下可以考虑使用状态模式：(1) 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。(2) 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</code></pre><h2 id="策略模式-Strategy-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"><a href="#策略模式-Strategy-Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】" class="headerlink" title="策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】"></a>策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】</h2><p>在软件开发中，我们也常常会遇到类似的情况，实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开</p><pre><code>策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/64iq1fG.jpg" alt="策略模式"></p><p>在策略模式结构图中包含如下几个角色：</p><pre><code>● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</code></pre><p>适用场景</p><pre><code>在以下情况下可以考虑使用策略模式：(1) 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。(2) 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。(3) 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</code></pre><h2 id="模板方法模式-Template-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"><a href="#模板方法模式-Template-Method-Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】" class="headerlink" title="模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】"></a>模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】</h2><pre><code>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</code></pre><p>模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p><p><img src="https://i.imgur.com/kbvXaVL.jpg" alt="模板方法模式结构图"></p><p>模板方法模式包含如下两个角色：</p><pre><code>(1) AbstractClass（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。(2) ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</code></pre><ol><li><p>模板方法</p><p> 一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模<br> 板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽<br> 象层只能是抽象类，而不是接口。</p></li><li><p>基本方法</p><p> 基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook<br> Method)。</p><p> (1) 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。在C#语言里一个抽象方法以abstract关键字标识。</p><p> (2) 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p><p> (3) 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现（可使用virtual关键字将其定义为虚函<br> 数），并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。</p></li></ol><p>模式适用场景</p><pre><code>在以下情况下可以考虑使用模板方法模式：(1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</code></pre><h2 id="访问者模式-Visitor-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"><a href="#访问者模式-Visitor-Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】" class="headerlink" title="访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】"></a>访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】</h2><p>访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。</p><p>在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。</p><pre><code>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</code></pre><p><img src="https://i.imgur.com/TeCXWot.gif" alt="访问者模式"></p><p>在访问者模式结构图中包含如下几个角色：</p><pre><code>●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。【稍后将介绍为什么要这样设计。】●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。</code></pre><p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</p><p>在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementA elementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，则可以将操作代码移到抽象访问者类中</p><p><img src="https://i.imgur.com/GXzKhaB.gif" alt="访问者模式与组合模式联用"></p><p>适用场景</p><pre><code>在以下情况下可以考虑使用访问者模式：(1) 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。(2) 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。(3) 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lovelion/article/details/17517213&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;史上最全设计模式导学目录（完整版）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;设计模式概述
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="设计模式" scheme="https://caojingyou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="笔记" scheme="https://caojingyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>自动构建</title>
    <link href="https://caojingyou.github.io/2018/05/07/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    <id>https://caojingyou.github.io/2018/05/07/自动构建/</id>
    <published>2018-05-07T01:47:00.000Z</published>
    <updated>2018-09-05T02:27:30.116Z</updated>
    
    <content type="html"><![CDATA[<p>有许多持续集成服务器供你使用。知名的工具包括：Jenkins、buildbot、CruiseControl和<br>TeamCity。要根据环境及构建脚本选择最适合的。</p><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p><a href="https://caojingyou.github.io/2018/03/02/Jenkins/" title="https://caojingyou.github.io/2018/03/02/Jenkins/">https://caojingyou.github.io/2018/03/02/Jenkins/</a></p><h1 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a>MSBuild</h1><p><a href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++">https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/</a>/ “<a href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/">https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/</a>“)</p><h1 id="CCNET"><a href="#CCNET" class="headerlink" title="CCNET"></a>CCNET</h1><p><a href="http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/" title="http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/" target="_blank" rel="noopener">http://build.nauck-it.de/download/CruiseControl.NET-package/1.8.5.0/</a></p><p><a href="http://www.cnblogs.com/hnlong1/p/4664978.html" title="http://www.cnblogs.com/hnlong1/p/4664978.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnlong1/p/4664978.html</a></p><p><a href="http://www.mamicode.com/info-detail-1690848.html" title="http://www.mamicode.com/info-detail-1690848.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1690848.html</a></p><h1 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h1><h1 id="Cabie"><a href="#Cabie" class="headerlink" title="Cabie"></a>Cabie</h1><p><a href="http://www.yolinux.com/TUTORIALS/CabieBuildSystem.html" target="_blank" rel="noopener">Cabie自动构建系统</a></p><p>Cabie是一个构建系统，具有分布式构建服务器，可在各种硬件平台上执行软件构建。Cabie支持“持续集成”（使用每个CM构建，即Subversion签入）或“夜间构建”，以及自动回归测试。Cabie是“开源”，并根据GNU通用公共许可证版本2的条款进行分发。</p><h1 id="SCons"><a href="#SCons" class="headerlink" title="SCons"></a>SCons</h1><p><a href="https://www.scons.org/" target="_blank" rel="noopener">https://www.scons.org/</a></p><p><a href="https://github.com/SCons/scons" target="_blank" rel="noopener">https://github.com/SCons/scons</a></p><p><a href="使用 SCons 轻松建造程序">使用 SCons 轻松建造程序</a></p><h1 id="Nant"><a href="#Nant" class="headerlink" title="Nant"></a>Nant</h1><p>开源免费项目，可以方便快捷对自己的.NET项目或解决方案进行自动构建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有许多持续集成服务器供你使用。知名的工具包括：Jenkins、buildbot、CruiseControl和&lt;br&gt;TeamCity。要根据环境及构建脚本选择最适合的。&lt;/p&gt;
&lt;h1 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MSBuild" scheme="https://caojingyou.github.io/tags/MSBuild/"/>
    
      <category term="Jenkins" scheme="https://caojingyou.github.io/tags/Jenkins/"/>
    
      <category term="自动构建" scheme="https://caojingyou.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="CCNET" scheme="https://caojingyou.github.io/tags/CCNET/"/>
    
      <category term="持续集成" scheme="https://caojingyou.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>linux下C开发</title>
    <link href="https://caojingyou.github.io/2018/05/02/linux%E4%B8%8BC%E5%BC%80%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/05/02/linux下C开发/</id>
    <published>2018-05-02T10:09:00.000Z</published>
    <updated>2018-10-09T08:03:01.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>刚装好的系统中已经有GCC了，但是这个GCC几乎什么文件都不能编译，因为缺少一些必须的头文件，所以要安装build-essential这个软件包输入下面命令：</p><pre><code>sudo apt-get install build-essential</code></pre><p><a href="http://wiki.ubuntu.org.cn/C_Cpp_IDE" target="_blank" rel="noopener">C Cpp IDE</a></p><p>eclipse CDT</p><pre><code>#apt-get install eclipse-cdt</code></pre><p>CodeBlocks、CodeLite、Qt跨平台</p><p>kdevelop</p><pre><code>sudo apt-get install kdevelop</code></pre><p>make是用来完成自动编译的工具</p><p>gcc/g++/gcc port/g++ port</p><p>在Linux系统中开发C、C++语言程序，可选择的集成开发环境有Eclipse和Kdevelop,分别运行在GNOME和KDE桌面环境。</p><p><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#GUIFRAMEWORKS" target="_blank" rel="noopener">适用于Linux的C / C ++ IDE（集成开发环境）</a></p><ul><li><h1 id="Eclipse-CDT"><a href="#Eclipse-CDT" class="headerlink" title="Eclipse/CDT"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#ECLIPSE" target="_blank" rel="noopener">Eclipse/CDT</a></h1></li><li><h1 id="NetBeans-Sun"><a href="#NetBeans-Sun" class="headerlink" title="NetBeans (Sun)"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#NETBEANS" target="_blank" rel="noopener">NetBeans (Sun)</a></h1></li><li><h1 id="KDevelop-KDE-Qt"><a href="#KDevelop-KDE-Qt" class="headerlink" title="KDevelop (KDE/Qt)"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#KDEVELOP" target="_blank" rel="noopener">KDevelop (KDE/Qt)</a></h1></li><li><h1 id="Anjuta-Gnome-GTK"><a href="#Anjuta-Gnome-GTK" class="headerlink" title="Anjuta (Gnome/GTK)"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#ANJUTA" target="_blank" rel="noopener">Anjuta (Gnome/GTK)</a></h1></li><li><h1 id="Code-Dragon-for-wxWindows-development"><a href="#Code-Dragon-for-wxWindows-development" class="headerlink" title="Code Dragon (for wxWindows development)"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#CODEDRAGON" target="_blank" rel="noopener">Code Dragon (for wxWindows development)</a></h1></li><li><h1 id="Code-Warrior-by-Freescale"><a href="#Code-Warrior-by-Freescale" class="headerlink" title="Code Warrior (by Freescale)"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#CODEWARRIOR" target="_blank" rel="noopener">Code Warrior (by Freescale)</a></h1></li><li><h1 id="IDE-Links"><a href="#IDE-Links" class="headerlink" title="IDE Links"></a><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++.html#IDELINKS" target="_blank" rel="noopener">IDE Links</a></h1></li></ul><p><a href="https://www.geany.org/" target="_blank" rel="noopener">Geany</a>是一个使用GTK +工具包的文本编辑器，具有集成开发环境的基本功能。它的开发目的是提供一个小而快速的IDE，它与其他软件包只有很少的依赖关系。它支持许多文件类型，并具有一些很好的功能。</p><h2 id="ubuntukylin编程环境"><a href="#ubuntukylin编程环境" class="headerlink" title="ubuntukylin编程环境"></a><a href="http://www.ubuntukylin.com/ukd/home/app.php" target="_blank" rel="noopener">ubuntukylin编程环境</a></h2><h3 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h3><pre><code>$ sudo apt-get update &amp;&amp; sudo apt-get install qtcreator</code></pre><p>提示: 在Ubuntu Kylin1404以后，执行上面的命令，软件源默认安装的是Qt5，如果你想使用Qt4进行开发，请执行下面的命令：</p><pre><code>$ sudo apt-get install qt4-default libqt4-dev</code></pre><p>如果想继续使用Qt5进行开发，请执行下面的命令：</p><pre><code>$ sudo apt-get install qt5-default</code></pre><p>使用QtCreator</p><pre><code>$ qtcreator</code></pre><h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><p>安装Eclipse</p><pre><code>$ sudo apt-get install eclipse</code></pre><p>使用Eclipse</p><pre><code>$ eclipse</code></pre><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>fork</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>POSIX标准线程库，Pthread线程对应的函数库为libpthread.</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://i.imgur.com/0AuPUYT.jpg" alt=""></p><h2 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h2><ul><li>libcurl    url</li><li>libESMTP    SMTP</li><li>libspopc    POP</li><li>mailutils    IMAP</li><li>libpurple或Telepathy    即时通讯</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>Berkley与PostgreSQL</p><p>SQLite</p><p>MySQL</p><p>Oracle    库：OCI，Libsqlora8</p><p>通用数据库接口数据库：SQL Relay</p><p>数据库连接池：unixODBC</p><h1 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h1><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><h3 id="GNOME"><a href="#GNOME" class="headerlink" title="GNOME"></a>GNOME</h3><p>工作站</p><p>开发界面函数库：GTK+、X11、Cairo</p><p>Glib库是GTK+和GNOME工程的基础低层核心程序库。</p><p>GLib为C语言提供面向对象的GObject对象系统。</p><h3 id="KDE"><a href="#KDE" class="headerlink" title="KDE"></a>KDE</h3><p>服务器</p><p>KDE桌面核心为Qt程序库。</p><h3 id="Xfce"><a href="#Xfce" class="headerlink" title="Xfce"></a>Xfce</h3><h3 id="HILDON"><a href="#HILDON" class="headerlink" title="HILDON"></a>HILDON</h3><p>移动设备</p><p>HILDON是GNOME的裁切版</p><h2 id="2D图形引擎Cairo"><a href="#2D图形引擎Cairo" class="headerlink" title="2D图形引擎Cairo"></a>2D图形引擎Cairo</h2><p>支持PDF格式</p><h2 id="GStreamer"><a href="#GStreamer" class="headerlink" title="GStreamer"></a>GStreamer</h2><p>可处理MP3、RM、WMA、MPEG、MPEG2、AVI和Quicktime等多种格式的多媒体数据。</p><h2 id="搭建GTK-开发环境"><a href="#搭建GTK-开发环境" class="headerlink" title="搭建GTK+开发环境"></a>搭建GTK+开发环境</h2><p>DEB:</p><pre><code>apt-get install gnome-core-devel//安装libgtk2.0-dev libglib2.0-dev等开发相关的函数库文件apt-get install devhelp//安装开发帮助文档查看程序apt-get install libglib2.0-doc libgtk2.0-doc//安装GTK/GLIB的API参考手册及其他帮助文档apt-get install libgtk2.0*//安装GTK+2所需的所有文件</code></pre><p>YUM:</p><pre><code>yum install devhelpyum install gtk2-devel//安装GTK+2所需的开发文件</code></pre><p>需要：</p><ul><li>pkg-config</li><li>GLib</li><li>libpng</li><li>JPEG</li><li>libtiff</li><li>ATK</li><li>Cairo</li><li>Pango</li><li>GTK+</li></ul><p>所见即所得工具Glade</p><h1 id="界面构件开发"><a href="#界面构件开发" class="headerlink" title="界面构件开发"></a>界面构件开发</h1><p>GtkWidget</p><ul><li>基本构件<ul><li>GtkButton</li><li>调整对象，由GtkObject派生。</li><li>范围构件，包括滚动条与比例构件</li><li>标签构件</li><li>箭头构件，上下左右箭头</li><li>工具提示对象</li><li>进度条</li><li>对话框</li><li>标尺</li><li>状态栏</li><li>文本输入构件</li><li>微调按钮</li><li>组合输入框</li><li>日历</li><li>颜色选择</li><li>文件选择</li></ul></li><li>复合构件<ul><li>快捷标签</li><li>绘图区</li><li>字体选择对话框</li><li>消息对话框</li><li>图像构件</li><li>文本视区</li></ul></li><li>菜单构件<ul><li>菜单栏</li><li>菜单构件</li><li>菜单项</li><li>图形菜单项</li><li>复合菜单项</li><li>单菜单项</li><li>分隔菜单项</li></ul></li></ul><p>RC文件，是用来定义界面构件的字体、颜色和背景图等样式风格的配置文件。</p><h1 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h1><ul><li>窗体构件-GtkWindow</li><li>组装盒构件-GtkVBox与GtkHBox</li><li>表构件-GtkTabel</li><li>容器构件-GtkContainer<ul><li>事件盒-GtkEventBox</li><li>对齐构件-GtkAlignment</li><li>固定容器-GtkFixed</li><li>布局容器-GtkLayout</li><li>框架构件-GtkFrame</li><li>比例框架-GtkAspectFrame</li><li>分栏窗体构件-GtkPaned</li><li>视角构件-GtkViewport</li><li>滚动条窗体-GtkScrolledWindow</li><li>按钮盒-GtkButtonBox</li><li>工具栏构件-GtkToolbar<ul><li>工具项构件-GtkToolItem<ul><li>GtkToolButton</li><li>GtkSeparatorToolItem</li></ul></li></ul></li><li>笔记本构件(选项卡)-GtkNotebook</li></ul></li></ul><h1 id="信号与事件"><a href="#信号与事件" class="headerlink" title="信号与事件"></a>信号与事件</h1><pre><code>g_signal_connect()g_signal_handler_disconnect()g_signal_connect_after()g_signal_connect_swapped()g_signal_handler_disconnect_by_func()</code></pre><h1 id="Glade"><a href="#Glade" class="headerlink" title="Glade"></a>Glade</h1><p>Glade所设计的界面以XML格式保存。</p><p>安装：</p><pre><code>apt-get install glade</code></pre><h1 id="学习："><a href="#学习：" class="headerlink" title="学习："></a>学习：</h1><ul><li><a href="https://i.linuxtoy.org/docs/guide/index.html" title="开源世界旅行手册" target="_blank" rel="noopener">开源世界旅行手册</a></li><li><a href="https://tobegit3hub1.gitbooks.io/understanding-linux-processes/content/" target="_blank" rel="noopener">理解Linux进程</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/" title="Linux C编程一站式学习" target="_blank" rel="noopener">Linux C编程一站式学习</a></li><li><a href="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md" title="100-gcc-tips" target="_blank" rel="noopener">100-gcc-tips</a></li><li><a href="http://wiki.ubuntu.org.cn/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">Ubuntu 中文 Wiki</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Ubuntu 中文 Wiki-编程语言</a></li><li><a href="http://wiki.ubuntu.org.cn/Gcchowto#.E7.AE.80.E5.8D.95.E7.9A.84_Makefile_.E6.96.87.E4.BB.B6" target="_blank" rel="noopener">gcc</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">用GDB调试程序</a></li><li><a href="http://wiki.ubuntu.org.cn/Gtk%E4%B8%8EQt%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">Gtk与Qt编译环境安装与配置</a></li><li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile" target="_blank" rel="noopener">跟我一起写Makefile</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85" target="_blank" rel="noopener">编译打包</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wuweifeng_2017/article/details/78322249" target="_blank" rel="noopener">Ubuntu下安装Qt5.8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;刚装好的系统中已经有GCC了，但是这个GCC几乎什么文件都不能编译，因为缺少一些必须的头文件，所以要安装build-essential这个软
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="linux" scheme="https://caojingyou.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下C程序设计-读书笔记</title>
    <link href="https://caojingyou.github.io/2018/05/02/linux%E7%8E%AF%E5%A2%83%E4%B8%8BC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://caojingyou.github.io/2018/05/02/linux环境下C程序设计-读书笔记/</id>
    <published>2018-05-02T10:09:00.000Z</published>
    <updated>2018-06-21T02:04:12.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>刚装好的系统中已经有GCC了，但是这个GCC几乎什么文件都不能编译，因为缺少一些必须的头文件，所以要安装build-essential这个软件包输入下面命令：</p><pre><code>sudo apt-get install build-essential</code></pre><p><a href="http://wiki.ubuntu.org.cn/C_Cpp_IDE" target="_blank" rel="noopener">C Cpp IDE</a></p><p>eclipse CDT</p><pre><code>#apt-get install eclipse-cdt</code></pre><p>CodeBlocks、CodeLite、Qt跨平台</p><p>kdevelop</p><pre><code>sudo apt-get install kdevelop</code></pre><p>make是用来完成自动编译的工具</p><p>gcc/g++/gcc port/g++ port</p><p>在Linux系统中开发C、C++语言程序，可选择的集成开发环境有Eclipse和Kdevelop,分别运行在GNOME和KDE桌面环境。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>fork</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>POSIX标准线程库，Pthread线程对应的函数库为libpthread.</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://i.imgur.com/0AuPUYT.jpg" alt=""></p><h2 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h2><ul><li>libcurl    url</li><li>libESMTP    SMTP</li><li>libspopc    POP</li><li>mailutils    IMAP</li><li>libpurple或Telepathy    即时通讯</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>Berkley与PostgreSQL</p><p>SQLite</p><p>MySQL</p><p>Oracle    库：OCI，Libsqlora8</p><p>通用数据库接口数据库：SQL Relay</p><p>数据库连接池：unixODBC</p><h1 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h1><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><h3 id="GNOME"><a href="#GNOME" class="headerlink" title="GNOME"></a>GNOME</h3><p>工作站</p><p>开发界面函数库：GTK+、X11、Cairo</p><p>Glib库是GTK+和GNOME工程的基础低层核心程序库。</p><p>GLib为C语言提供面向对象的GObject对象系统。</p><h3 id="KDE"><a href="#KDE" class="headerlink" title="KDE"></a>KDE</h3><p>服务器</p><p>KDE桌面核心为Qt程序库。</p><h3 id="Xfce"><a href="#Xfce" class="headerlink" title="Xfce"></a>Xfce</h3><h3 id="HILDON"><a href="#HILDON" class="headerlink" title="HILDON"></a>HILDON</h3><p>移动设备</p><p>HILDON是GNOME的裁切版</p><h2 id="2D图形引擎Cairo"><a href="#2D图形引擎Cairo" class="headerlink" title="2D图形引擎Cairo"></a>2D图形引擎Cairo</h2><p>支持PDF格式</p><h2 id="GStreamer"><a href="#GStreamer" class="headerlink" title="GStreamer"></a>GStreamer</h2><p>可处理MP3、RM、WMA、MPEG、MPEG2、AVI和Quicktime等多种格式的多媒体数据。</p><h2 id="搭建GTK-开发环境"><a href="#搭建GTK-开发环境" class="headerlink" title="搭建GTK+开发环境"></a>搭建GTK+开发环境</h2><p>DEB:</p><pre><code>apt-get install gnome-core-devel//安装libgtk2.0-dev libglib2.0-dev等开发相关的函数库文件apt-get install devhelp//安装开发帮助文档查看程序apt-get install libglib2.0-doc libgtk2.0-doc//安装GTK/GLIB的API参考手册及其他帮助文档apt-get install libgtk2.0*//安装GTK+2所需的所有文件</code></pre><p>YUM:</p><pre><code>yum install devhelpyum install gtk2-devel//安装GTK+2所需的开发文件</code></pre><p>需要：</p><ul><li>pkg-config</li><li>GLib</li><li>libpng</li><li>JPEG</li><li>libtiff</li><li>ATK</li><li>Cairo</li><li>Pango</li><li>GTK+</li></ul><p>所见即所得工具Glade</p><h1 id="界面构件开发"><a href="#界面构件开发" class="headerlink" title="界面构件开发"></a>界面构件开发</h1><p>GtkWidget</p><ul><li>基本构件<ul><li>GtkButton</li><li>调整对象，由GtkObject派生。</li><li>范围构件，包括滚动条与比例构件</li><li>标签构件</li><li>箭头构件，上下左右箭头</li><li>工具提示对象</li><li>进度条</li><li>对话框</li><li>标尺</li><li>状态栏</li><li>文本输入构件</li><li>微调按钮</li><li>组合输入框</li><li>日历</li><li>颜色选择</li><li>文件选择</li></ul></li><li>复合构件<ul><li>快捷标签</li><li>绘图区</li><li>字体选择对话框</li><li>消息对话框</li><li>图像构件</li><li>文本视区</li></ul></li><li>菜单构件<ul><li>菜单栏</li><li>菜单构件</li><li>菜单项</li><li>图形菜单项</li><li>复合菜单项</li><li>单菜单项</li><li>分隔菜单项</li></ul></li></ul><p>RC文件，是用来定义界面构件的字体、颜色和背景图等样式风格的配置文件。</p><h1 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h1><ul><li>窗体构件-GtkWindow</li><li>组装盒构件-GtkVBox与GtkHBox</li><li>表构件-GtkTabel</li><li>容器构件-GtkContainer<ul><li>事件盒-GtkEventBox</li><li>对齐构件-GtkAlignment</li><li>固定容器-GtkFixed</li><li>布局容器-GtkLayout</li><li>框架构件-GtkFrame</li><li>比例框架-GtkAspectFrame</li><li>分栏窗体构件-GtkPaned</li><li>视角构件-GtkViewport</li><li>滚动条窗体-GtkScrolledWindow</li><li>按钮盒-GtkButtonBox</li><li>工具栏构件-GtkToolbar<ul><li>工具项构件-GtkToolItem<ul><li>GtkToolButton</li><li>GtkSeparatorToolItem</li></ul></li></ul></li><li>笔记本构件(选项卡)-GtkNotebook</li></ul></li></ul><h1 id="信号与事件"><a href="#信号与事件" class="headerlink" title="信号与事件"></a>信号与事件</h1><pre><code>g_signal_connect()g_signal_handler_disconnect()g_signal_connect_after()g_signal_connect_swapped()g_signal_handler_disconnect_by_func()</code></pre><h1 id="Glade"><a href="#Glade" class="headerlink" title="Glade"></a>Glade</h1><p>Glade所设计的界面以XML格式保存。</p><p>安装：</p><pre><code>apt-get install glade</code></pre><p>Glade项目文件是一个单独的.glade文件，可通过GTK+库将该文件添加到C语言源代码种。</p><pre><code>#include &lt;qtk/gtk.h&gt;#include &lt;qlib-2.0/glib.h&gt;#include &lt;libglade-2.0/glade/glade.h&gt;    //包含libglade函数库int main (int argc, char *argv[]){    gtk_init(&amp;argc, &amp;argv);    //初始化GTK+库    GtkBuilder *ui;    //声明GtkBuilder类型变量    GtkWidget *window;    //声明GtkWidget类型变量    ui = gtk_builder_new();    //初始化GTKBuilder环境    gtk_builder_add_from_file(ui, &quot;ui.glade&quot;, NULL);    //读取qlade文件    GtkWidget *window;    //声明GtkWidget类型变量    window = GTK_WIDGET (gtk_builder_get_object (gtkBuilder, &quot;MainWindow&quot;));    //从GtkBuilder对象获得GtkWidget界面构件    GtkWidget *label;    label = GTK_WIDGET (gtk_builder_get_object (gtkBuilder, &quot;label&quot;));    gtk_label_set_label (GTK_LABEL (label), &quot;Hello World!&quot;);    //修改界面构件的属性    gtk_widget_show_all (window);    //显示window内的所有构件,    gtk_builder_connect_signals (ui, NULL); //连接GtkBuilder对象所有己定义信号    gtk_main ();    //开始GTK+主循环    return 0;}</code></pre><p>在编译参数中加入编译参数<code>pkg-config --cflags --llibs gtk+-3.0</code>-export -dynamic,编译该程序。</p><h1 id="国际化与本地化"><a href="#国际化与本地化" class="headerlink" title="国际化与本地化"></a>国际化与本地化</h1><p>po文件意为可移植对象；mo文件意为机器对象。</p><p>在包含Glade项目文件的目录中创建名为po的目录，进入po目录，创建POTFILES.in新文件。打开文件，输入Glade项目文件的文件名后保存，如：</p><pre><code>ui.glade</code></pre><p>安装inttool工具集，其中包含gettext软件包。</p><pre><code>apt-get install intltool</code></pre><p>安装后，将工作目录设置为POTFILES.in文件的目录。输入下列命令创建po文件：</p><pre><code>intltool-update --pot gettext-package=ui</code></pre><p>gettext-package参数的名称为Glade项目文件的前缀名。命令执行成功创建untitled.pot文件，该文件是po文件的模版。复制改文件，创建名为zh_CH.po的副本。打开，将charset=CHARSET改为utf-8,将msgid后的英文字符串翻译到下一行的msgstr后。</p><p>将po文件编译为mo文件：</p><pre><code>msgfmt zh_CH.po</code></pre><p>在po中创建zh_CH/LC_MESSAGES目录，复制zh_CH.mo到新建立的目录，改名为ui.mo</p><pre><code>#include &lt;gtk/qtk.h&gt;#include &lt;glib-2.0/glib.h&gt;#include &lt;libinti.h&gt;    //提供gettext支持#define (String) gettext(String)    //翻译字符串#define N (String) String#define PACKAGE &quot;ui&quot;    //定义mo文件前缀名#define LOCALEDIR &quot;./po&quot;    //定义mo文件搜索路径int main (int argc, char *argv[]){    setlocale (LC ALL, &quot;&quot;);    //设置本地语言和字符集    bindtextdomain (PACKAGE, LOCALEDIR);    //设置mo文件的路径    textdomain (PACKAGE);    //设置mo文件前缀名    gtk_init (&amp;argc, &amp;argv);    GtkBuilder *ui;    ui = qtk_builder_new ();    qtk_builder_add_from_file (ui, &quot;ui.glade&quot;, NULL);    GtkWidget *window;    window = GTK_WIDGET (gtk_builder_get_object (ui, &quot;User Information&quot;));    gtk_widget_show_all (window);    //显示window内的所有构件,    gtk_builder_connect_signals (ui, NULL); //连接GtkBuilder对象所有己定义信号    gtk_main ();    //开始GTK+主循环    return 0;}</code></pre><p>修改环境变量：</p><p>单个用户：用户主目录下的.profile文件；所有用户：/etc目录下的environment文件</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>libid3dtag可以很容易读取mp3文件信息。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>linux可使用CVS版本控制工具。</p><h3 id="CVS服务器配置"><a href="#CVS服务器配置" class="headerlink" title="CVS服务器配置"></a>CVS服务器配置</h3><p>安装<br>    apt-get install cvs cvsd</p><p>配置</p><pre><code>dpkg-reconfigure cvsd</code></pre><p>建立代码仓库</p><pre><code>cd /var/cvsroot    //进入虚拟系统目录sudo mkdir mycvs    //建立代码仓库文件夹</code></pre><p>初始化代码仓库</p><pre><code>sudo cvs -d /var/lib/cvsd init</code></pre><p>改变目录权限</p><pre><code>sudo chown cvsd:cvsd -R /var/lib/cvsd/cvsrepo</code></pre><p>修改用户密码</p><pre><code>sudo cvsd-passwd /var/cvsroot/mycvs cvsd    //修改文件夹所有者密码</code></pre><p>修改认证方式</p><pre><code>sudo vi /var/cvsroot/mycvs/CVSROOT/config    //在配置文件中将“SystemAuto=no”前面的#号去掉</code></pre><p>重启服务</p><pre><code>/etc/init.d/cvsd restart</code></pre><p>配置环境变量</p><pre><code>export CVSROOT=:pserver:cvsd@localhost:/mycvs</code></pre><p>登录服务器</p><pre><code>cvs login</code></pre><h3 id="CVS服务器管理"><a href="#CVS服务器管理" class="headerlink" title="CVS服务器管理"></a>CVS服务器管理</h3><p>查看当前仓库中的模块名称</p><pre><code>ls $CVSROOT</code></pre><p>导入</p><pre><code>cd /home/mp3playercvs import -m &quot;MP3 Player Test&quot; mp3player me start</code></pre><p>签出</p><pre><code>cvs co mp3player</code></pre><p>签入</p><pre><code>cvs commit</code></pre><p>添加和删除</p><pre><code>cvs add test .ccvs commitcvs rm test.ccvs commit</code></pre><p>历史</p><pre><code>cvs history -c interface.c</code></pre><p>冲突解决</p><pre><code>svs update</code></pre><p>标记</p><pre><code>cvs tag release</code></pre><p>分支</p><pre><code>cvs rtag -b release mp3player</code></pre><p>远程访问</p><pre><code>export CVS_RSH=sshexport CVSROOT=&lt;用户名&gt;@&lt;服务器地址&gt;:&lt;端口号&gt;&lt;CVS资源目录路径&gt;export CVSROOT=:pserver:&lt;用户名&gt;@&lt;服务器地址&gt;:&lt;端口号&gt;&lt;CVS资源目录路径&gt;</code></pre><h1 id="学习："><a href="#学习：" class="headerlink" title="学习："></a>学习：</h1><ul><li><a href="https://i.linuxtoy.org/docs/guide/index.html" title="开源世界旅行手册" target="_blank" rel="noopener">开源世界旅行手册</a></li><li><a href="https://tobegit3hub1.gitbooks.io/understanding-linux-processes/content/" target="_blank" rel="noopener">理解Linux进程</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/" title="Linux C编程一站式学习" target="_blank" rel="noopener">Linux C编程一站式学习</a></li><li><a href="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md" title="100-gcc-tips" target="_blank" rel="noopener">100-gcc-tips</a></li><li><a href="http://wiki.ubuntu.org.cn/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">Ubuntu 中文 Wiki</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Ubuntu 中文 Wiki-编程语言</a></li><li><a href="http://wiki.ubuntu.org.cn/Gcchowto#.E7.AE.80.E5.8D.95.E7.9A.84_Makefile_.E6.96.87.E4.BB.B6" target="_blank" rel="noopener">gcc</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">用GDB调试程序</a></li><li><a href="http://wiki.ubuntu.org.cn/Gtk%E4%B8%8EQt%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">Gtk与Qt编译环境安装与配置</a></li><li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile" target="_blank" rel="noopener">跟我一起写Makefile</a></li><li><a href="http://wiki.ubuntu.org.cn/%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85" target="_blank" rel="noopener">编译打包</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wuweifeng_2017/article/details/78322249" target="_blank" rel="noopener">Ubuntu下安装Qt5.8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;刚装好的系统中已经有GCC了，但是这个GCC几乎什么文件都不能编译，因为缺少一些必须的头文件，所以要安装build-essential这个软
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="linux" scheme="https://caojingyou.github.io/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://caojingyou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++单元测试</title>
    <link href="https://caojingyou.github.io/2018/05/02/C++%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://caojingyou.github.io/2018/05/02/C++单元测试/</id>
    <published>2018-05-02T09:03:00.000Z</published>
    <updated>2018-08-27T05:47:20.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cppunit"><a href="#cppunit" class="headerlink" title="cppunit"></a>cppunit</h1><p><a href="https://caojingyou.github.io/2018/01/18/cppunit/" title="https://caojingyou.github.io/2018/01/18/cppunit/">https://caojingyou.github.io/2018/01/18/cppunit/</a></p><h1 id="CppUTest"><a href="#CppUTest" class="headerlink" title="CppUTest"></a>CppUTest</h1><p><a href="http://cpputest.github.io/" title="http://cpputest.github.io/" target="_blank" rel="noopener">http://cpputest.github.io/</a></p><p><a href="https://github.com/cpputest/cpputest" title="https://github.com/cpputest/cpputest" target="_blank" rel="noopener">https://github.com/cpputest/cpputest</a></p><p><a href="http://cpputest.github.io/manual.html" target="_blank" rel="noopener">http://cpputest.github.io/manual.html</a></p><p><a href="http://www.yolinux.com/TUTORIALS/CppUnit.html" target="_blank" rel="noopener">http://www.yolinux.com/TUTORIALS/CppUnit.html</a></p><h2 id="Quick-introduction-some-code"><a href="#Quick-introduction-some-code" class="headerlink" title="Quick introduction (some code!)"></a>Quick introduction (some code!)</h2><p>To write your first test, all you need is a new cpp file with a TEST_GROUP and a TEST, like:</p><pre><code>TEST_GROUP(FirstTestGroup){};TEST(FirstTestGroup, FirstTest){   FAIL(&quot;Fail me!&quot;);}</code></pre><p>This test will fail.</p><p>You can add new tests to the test group by just writing more tests in the file, like this:</p><pre><code>TEST(FirstTestGroup, SecondTest){   STRCMP_EQUAL(&quot;hello&quot;, &quot;world&quot;);   LONGS_EQUAL(1, 2);   CHECK(false);}</code></pre><p>You do need to create a main where you run all the unit tests. Such a main will look like this:</p><pre><code>int main(int ac, char** av){   return CommandLineTestRunner::RunAllTests(ac, av);}</code></pre><h2 id="Most-commonly-used-Test-Macros"><a href="#Most-commonly-used-Test-Macros" class="headerlink" title="Most commonly used Test Macros"></a>Most commonly used Test Macros</h2><pre><code>TEST(group, name) - define a testIGNORE_TEST(group, name) - turn off the execution of a testTEST_GROUP(group) - Declare a test group to which certain tests belong. This will also create the link needed from another library.TEST_GROUP_BASE(group, base) - Same as TEST_GROUP, just use a different base class than UtestIMPORT_TEST_GROUP(group) - Export the name of a test group so it can be linked in from a library (also see Advanced Stuff)</code></pre><h2 id="Set-up-and-tear-down-support"><a href="#Set-up-and-tear-down-support" class="headerlink" title="Set up and tear down support"></a>Set up and tear down support</h2><pre><code>Each TEST_GROUP may contain setup or teardown methodsSetup is called prior to each TEST body and Teardown is called after the test body</code></pre><p>Every test group can have a setup and a teardown method. The setup method is called before each test and the teardown method is called after each test.</p><p>You can define setup and teardown like this:</p><pre><code>TEST_GROUP(FooTestGroup){   void setup()   {      // Init stuff   }   void teardown()   {      // Uninit stuff   }};TEST(FooTestGroup, Foo){   // Test FOO}TEST(FooTestGroup, MoreFoo){   // Test more FOO}TEST_GROUP(BarTestGroup){   void setup()   {      // Init Bar   }};TEST(BarTestGroup, Bar){   // Test Bar}</code></pre><h2 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h2><p>The failure of one of these macros causes the current test to immediately exit:</p><pre><code>CHECK(boolean condition) - checks any boolean result.CHECK_TEXT(boolean condition, text) - checks any boolean result and prints text on failure.CHECK_FALSE(condition) - checks any boolean resultCHECK_EQUAL(expected, actual) - checks for equality between entities using ==. So if you have a class that supports operator==() you can use this macro to compare two instances. You will also need to add a StringFrom() function like those found in SimpleString. This is for printing the objects when the check failed.CHECK_COMPARE(first, relop, second) - checks thats a relational operator holds between two entities. On failure, prints what both operands evaluate to.CHECK_THROWS(expected_exception, expression) - checks if expression throws expected_exception (e.g. std::exception). CHECK_THROWS is only available if CppUTest is built with the Standard C++ Library (default).STRCMP_EQUAL(expected, actual) - checks const char* strings for equality using strcmp().STRNCMP_EQUAL(expected, actual, length) - checks const char* strings for equality using strncmp().STRCMP_NOCASE_EQUAL(expected, actual) - checks const char* strings for equality, not considering case.STRCMP_CONTAINS(expected, actual) - checks whether const char* actual contains const char* expected.LONGS_EQUAL(expected, actual) - compares two numbers.UNSIGNED_LONGS_EQUAL(expected, actual) - compares two positive numbers.BYTES_EQUAL(expected, actual) - compares two numbers, eight bits wide.POINTERS_EQUAL(expected, actual) - compares two pointers.DOUBLES_EQUAL(expected, actual, tolerance) - compares two floating point numbers within some toleranceFUNCTIONPOINTERS_EQUAL(expected, actual) - compares two void (*)() function pointersMEMCMP_EQUAL(expected, actual, size) - compares two areas of memoryBITS_EQUAL(expected, actual, mask) - compares expected to actual bit by bit, applying maskFAIL(text) - always fails</code></pre><p>NOTE Most macros have _TEXT() equivalents like CHECK_TEXT(), which are not explicitly listed here.</p><p>CHECK_EQUAL Warning:</p><p>CHECK_EQUAL(expected, actual) can produce misleading error reports as it will evaluate expected and actual more than once. This especially leads to confusions when used with mocks. This happens if the mock function expects to be called exactly once, since the macro needs to evaluate the actual expression more than once. The problem does not occur with type specific checks (e.g. LONGS_EQUAL()), so it is recommended to use them if possible. Instead of:</p><pre><code>CHECK_EQUAL(10, mock_returning_11())</code></pre><p>which reports: Mock Failure: Unexpected additional call, rather use</p><pre><code>LONGS_EQUAL(10, mock_returning_11()) // reports actual different from expected</code></pre><p>This issue could only be avoided with advanced language features like C++ templates, which would violate the CppUTest design goal portability to old environments.</p><h2 id="C-程序设计实践与技巧：测试驱动开发"><a href="#C-程序设计实践与技巧：测试驱动开发" class="headerlink" title="C++程序设计实践与技巧：测试驱动开发"></a>C++程序设计实践与技巧：测试驱动开发</h2><p>CppUTest内建的模拟框架可以使处理<br>遗留代码的测试更容易些。可根据自己的喜好继续使用Google Test/Google Mock，只需要针对单<br>元测试代码做些相对简单的改动即可。</p><p>CppUTest提供了对TDD单元测试工具来说非常重要的绝大多数特性，同时也支持通过命令行<br>切换的方式运行测试的一个子集，和Google Test的过滤器非常类似，但没有那么稳定。<br>CppUTest还具有一个非常重要的特性——支持内存泄漏监测，这个特性可以和其他单元测试<br>工具结合起来使用。</p><h1 id="Google-Test-与-Google-Mock"><a href="#Google-Test-与-Google-Mock" class="headerlink" title="Google Test 与  Google Mock"></a>Google Test 与  Google Mock</h1><p><a href="https://github.com/google/googletest" title="https://github.com/google/googletest" target="_blank" rel="noopener">https://github.com/google/googletest</a></p><p><a href="https://code/google.com/p/googlemock/" target="_blank" rel="noopener">https://code/google.com/p/googlemock/</a></p><h2 id="C-程序设计实践与技巧：测试驱动开发-1"><a href="#C-程序设计实践与技巧：测试驱动开发-1" class="headerlink" title="C++程序设计实践与技巧：测试驱动开发"></a>C++程序设计实践与技巧：测试驱动开发</h2><h3 id="自定义断言"><a href="#自定义断言" class="headerlink" title="自定义断言"></a>自定义断言</h3><p>Google Mock还提供MATCHER_P2，MATCHER_P3，…，MATCHER_P10以来支持多参数的匹配器</p><pre><code>class ARetweetCollection: public Test {public:   RetweetCollection collection;};MATCHER_P(HasSize, expected, &quot;&quot;) {    return       arg.size() == expected &amp;&amp;       arg.isEmpty() == (0 == expected); }TEST_F(ARetweetCollection, DecreasesSizeAfterRemovingTweet) {   collection.add(Tweet());   collection.remove(Tweet());   ASSERT_THAT(collection, HasSize(0u));}</code></pre><h3 id="禁用测试"><a href="#禁用测试" class="headerlink" title="禁用测试"></a>禁用测试</h3><p>在Google Mock中，你可以给测试名称加上 DISABLED_ 前缀来禁用测试。</p><pre><code>TEST(ATweet, DISABLED_RequiresUserNameToStartWithAnAtSign)</code></pre><p>当运行测试集时，Google Mock会在末尾打印出提示，这样就可以知道哪些测试被禁用了。</p><h3 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h3><p>文件组织、fixture、setup、teardown、过滤器、断言和基于异常的断言</p><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><p>在测试驱动开发相关行为时，我们会将相关的测试定义在同一个测试文件中。例如，为了测<br>试 驱 动 开 发 一 个 RetweetCollection 类 （ 在 RetweetCollection.cpp/.h 中 实 现 ）， 从<br>RetweetCollectionTest.cpp开始。不要立刻给测试创建一个头文件，这是吃力不讨好的。</p><p>基于所包含的测试来给文件命名。概括相关的行为，并据此给测试命名。选定一个命名体系，<br>诸如BehaviorDescriptionTest.cpp、BehaviorDescriptionTests.cpp或者TestBehavriorDescription.cpp。<br>只要你的代码一致地遵守此标准即可。一致的命名约定可以让开发人员更容易地找到需要的<br>测试。</p><h4 id="fixture"><a href="#fixture" class="headerlink" title="fixture"></a>fixture</h4><p>在Google Mock中，你可以使用Google<br>所谓的测试用例名称来将相关测试分组。</p><p>定义一个派生自::testing::Test的fixture。</p><p>使用 TEST_F</p><h4 id="运行测试的一个子集"><a href="#运行测试的一个子集" class="headerlink" title="运行测试的一个子集"></a>运行测试的一个子集</h4><p>Google Mock可以通过指定一个测试过滤器轻松地做到只运行一个测试子集。你可以把测试<br>过滤器作为执行测试的命令行参数。过滤器的语法是：测试用例名.测试名称。例如，如果想要<br>运行一个特定的测试，可以使用下面的命令：</p><pre><code>./test --gtest_filter=ATweet.CanBeCopyConstructed # weak</code></pre><p>但是不要养成每次只运行一个测试的习惯。可以使用通配符（ * ）运行多个测试。让我们运<br>行一下ATweet测试用例中所有的测试。</p><pre><code>./test --gtest_filter=ATweet.* # slightly less weak</code></pre><p>如果你在开发和tweet相关的类，那么最好找到一个方法来运行所有和tweet相关的测试。使<br>用多个通配符吧！</p><pre><code>./test --gtest_filter=*weet*.*</code></pre><p>这个过滤器包含了RetweetCollection中所有的测试。（我省略写 T ，因为它不能和Retweet-<br>Collection中的小写 t 匹配。）<br>如果你想在不运行Tweet类的任何构造测试的情况下运行和tweet相关的所有测试，该怎么做<br>呢？这时，Google Mock允许你创建复杂的过滤器。</p><pre><code>./test --gtest_filter=*Retweet*.*:ATweet.*:-ATweet*.*Construct*</code></pre><p>可以使用冒号（ : ）来分隔不同的过滤器。如果Google Mock遇到一个负号（-），那么其后的<br>所有过滤器匹配的测试都将被忽略。在上面的例子中， -ATweet<em>.</em>Construct* 告诉Google Mock<br>忽略名称中含 Construct 的所有ATweet测试。</p><h4 id="测试分类：快、慢"><a href="#测试分类：快、慢" class="headerlink" title="测试分类：快、慢"></a>测试分类：快、慢</h4><p>使运行时间超过给定值的测试失败（通过一个名为<br>slow_test_threshold 的命令行选项）。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>Google Mock，提供了另一种断言机制，它允许测试在遇到断言失败的情况<br>下继续运行。这些断言又称作非致命性断言，与致命性断言相对，后者会中止测试。</p><pre><code>ASSERT_TRUE (表达式) 表达式返回假（或0）时，测试失败    ASSERT_TRUE(4&lt;7)ASSERT_EQ( 期待值，实际值) 期待值和实际值不等时，测试失败    ASSERT_EQ(4, 20/5)</code></pre><p>ASSERT_FALSE、 ASSERT_GT、 ASSERT_LT、SSERT<em>STREQ 、 ASSERT</em><br>STRNE 、 ASSERT_STRCASEEQ 和 ASSERT_STRCASENE</p><h4 id="Hamcrest-断言"><a href="#Hamcrest-断言" class="headerlink" title="Hamcrest 断言"></a>Hamcrest 断言</h4><p>几年前引入Hamcrest断言就是为了提升测试的表达力、创建复杂断言的灵活性，以及测试错<br>误所提供的信息。Hamcrest使用匹配器（matcher，Hamcrest是Matchers的衍生词）比较实际结果。<br>匹配器可以组合成复杂但易懂的比较表达式。你也可以自定义匹配器。<br>几个简单的示例胜过千言万语，至少可以省去不少篇幅。</p><pre><code>string actual = string(&quot;al&quot;) + &quot;pha&quot;;ASSERT_THAT(actual, Eq(&quot;alpha&quot;));</code></pre><p>这个断言从左至右读作：断定实际值等于 “alpha” 。对于一个简单的相等比较而言，区区几<br>个额外的字符就能够提升可阅读性。<br>起初，Hamcrest断言貌似过于炫技。但是匹配器的价值在于它能极大地提升测试的表达力。<br>许多匹配器既能减少所需的代码量，同时也能提升测试的抽象层次。</p><pre><code>ASSERT_THAT(actual, StartsWith(&quot;alx&quot;));</code></pre><p>Google Mock的文档列出了一些内置的匹配器<br>① 。<br>使用它们时需要在测试文件中加入 using 声明。</p><pre><code>using namespace ::testing;</code></pre><p>否则本意用来提升表达力的断言读起来会有些啰嗦卡顿。如下：</p><pre><code>ASSERT_THAT(actual, ::testing::StartsWith(&quot;al&quot;));</code></pre><p>Hamcrest断言在提升失败信息的可读性方面意义更大。</p><pre><code>Expected: starts with &quot;alx&quot;Actual: &quot;alpha&quot; (of type std::string)</code></pre><p>匹配器的组合能力使你用一行断言就能表达本来需要多行断言才能做到的事情。</p><pre><code>ASSERT_THAT(actual,AllOf(StartsWith(&quot;al&quot;), EndsWith(&quot;ha&quot;), Ne(&quot;aloha&quot;)));</code></pre><p>上述例子中的 AllOf 表明只有当所有匹配器都成功时，整个断言才算通过。因而 actual 必须<br>以 “al” 开头，以 “ha” 结尾，且不等于 “aloha” 。<br>对于布尔值的断言而言，大部分开发者都会避开Hamcrest断言而使用经典的断言形式。</p><pre><code>ASSERT_TRUE(someBooleanExpression);ASSERT_FALSE(someBooleanExpression);</code></pre><h4 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h4><pre><code>#include &quot;gmock/gmock.h&quot;using namespace ::testing;struct SumCase {   int a, b, expected;   SumCase(int anA, int aB, int anExpected)       : a(anA), b(aB), expected(anExpected) {}};//先定义一个衍生自TestWithParam&lt;T&gt;的fixture，这里的 T 是参数类型。class AnAdder: public TestWithParam&lt;SumCase&gt; {//这里的参数类型为SumCase，用来描述两个输入值和一个期望的和。};class Adder {public:   static int sum(int a, int b) {      return a + b;   }};TEST(AnAdder, GeneratesASumFromTwoNumbers) {   ASSERT_THAT(Adder::sum(1, 1), Eq(2));}// TEST_P 宏来声明测试，其中 P 表示参数化。TEST_P(AnAdder, GeneratesLotsOfSumsFromTwoNumbers) {   SumCase input = GetParam();   ASSERT_THAT(Adder::sum(input.a, input.b), Eq(input.expected));}SumCase sums[] = {    SumCase(1, 1, 2),    SumCase(1, 2, 3),   SumCase(2, 2, 4) };INSTANTIATE_TEST_CASE_P(BulkTest, AnAdder, ValuesIn(sums));</code></pre><p>最后一行代码使用事先准备好的参数运行测试。 INSTANTIATE_TEST_CASE_P 的第二个参数<br>是fixture的名称，第三个参数是准备好的测试值。（第一个参数 BulkTest 是Google Mock加在测试<br>名称前的前缀。） ValuesIn() 函数指示在每次运行测试时，其输入的测试值是来自名为 sums 的数<br>组（GeneratesLotsOfSumsFromTwoNumbers）。测试中的第一行调用了 GetParam() 函数，它返回<br>输入的测试值（一个 SumCase 对象）。</p><h3 id="选择测试用例"><a href="#选择测试用例" class="headerlink" title="选择测试用例"></a>选择测试用例</h3><p><a href="https://blog.csdn.net/dreamstone_xiaoqw/article/details/77019158" target="_blank" rel="noopener">https://blog.csdn.net/dreamstone_xiaoqw/article/details/77019158</a></p><p>列出所有的测试用例，但并不执行。代码中的用例TEST(Foo, Bar) 显示出的结果是 “Foo.Bar”.</p><pre><code>--gtest_list_tests</code></pre><p>只运行名字与正模式匹配的测试用例，但不运行与负模式名字相同的用例。</p><pre><code>--gtest_filter=POSTIVE_PATTERNS[-NEGATIVE_PATTERNS]</code></pre><p>PS：–gtest_filter=执行用例名[-不执行的用例名]，用例名可使用部分能配符。</p><pre><code>&apos;?&apos; 匹配任意单字符；&apos;*&apos; 匹配任意字符串；&apos;:&apos; 来分隔不同的过滤器.</code></pre><p> 运行所有用例，包括禁用的用例。</p><pre><code>--gtest_also_run_disabled_tests</code></pre><h2 id="Google-Test"><a href="#Google-Test" class="headerlink" title="Google Test"></a>Google Test</h2><p><a href="https://www.cnblogs.com/jycboy/p/6057677.html" title="https://www.cnblogs.com/jycboy/p/6057677.html" target="_blank" rel="noopener">https://www.cnblogs.com/jycboy/p/6057677.html</a></p><p><a href="https://segmentfault.com/a/1190000002454946" title="https://segmentfault.com/a/1190000002454946" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002454946</a></p><p><a href="http://developer.51cto.com/art/201108/285290.htm" title="http://developer.51cto.com/art/201108/285290.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201108/285290.htm</a></p><p><a href="http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html" title="http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html" target="_blank" rel="noopener">http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.html</a></p><h3 id="常用例子："><a href="#常用例子：" class="headerlink" title="常用例子："></a>常用例子：</h3><pre><code>#include &quot;gmock/gmock.h&quot;int main(int argc, char** argv) {    testing::InitGoogleMock(&amp;argc, argv);    int nRet = RUN_ALL_TESTS();    system(&quot;pause&quot;);    return nRet;}#include &quot;gmock/gmock.h&quot;#include &quot;gtest/gtest.h&quot;TEST(xxxTest, xxx){}class QuickTest : public testing::Test { protected:  // Remember that SetUp() is run immediately before a test starts.  // This is a good place to record the start time.  virtual void SetUp() {    start_time_ = time(NULL);  }  // TearDown() is invoked immediately after a test finishes.  Here we  // check if the test was too slow.  virtual void TearDown() {    // Gets the time when the test finishes    const time_t end_time = time(NULL);    // Asserts that the test took no more than ~5 seconds.  Did you    // know that you can use assertions in SetUp() and TearDown() as    // well?    EXPECT_TRUE(end_time - start_time_ &lt;= 5) &lt;&lt; &quot;The test took too long.&quot;;  }  // The UTC time (in seconds) when the test starts  time_t start_time_;};class QueueTest : public QuickTest{protected:    virtual void SetUp()    {        // First, we need to set up the super fixture (QuickTest).        QuickTest::SetUp();        // Second, some additional setup for this fixture.        q1_.Enqueue(1);        q2_.Enqueue(2);        q2_.Enqueue(3);    }    // By default, TearDown() inherits the behavior of    // QuickTest::TearDown().  As we have no additional cleaning work    // for QueueTest, we omit it here.    //    // virtual void TearDown() {    //   QuickTest::TearDown();    // }    Queue&lt;int&gt; q0_;    Queue&lt;int&gt; q1_;    Queue&lt;int&gt; q2_;};TEST_F(QueueTest, DefaultConstructor){    EXPECT_EQ(0u, q0_.Size());}</code></pre><h3 id="simple代码"><a href="#simple代码" class="headerlink" title="simple代码:"></a>simple代码:</h3><pre><code>#ifndef GTEST_SAMPLES_PRIME_TABLES_H_#define GTEST_SAMPLES_PRIME_TABLES_H_#include &lt;algorithm&gt;// The prime table interface.class PrimeTable { public:  virtual ~PrimeTable() {}  // Returns true iff n is a prime number.  virtual bool IsPrime(int n) const = 0;  // Returns the smallest prime number greater than p; or returns -1  // if the next prime is beyond the capacity of the table.  virtual int GetNextPrime(int p) const = 0;};// Implementation #1 calculates the primes on-the-fly.class OnTheFlyPrimeTable : public PrimeTable { public:  virtual bool IsPrime(int n) const {    if (n &lt;= 1) return false;    for (int i = 2; i*i &lt;= n; i++) {      // n is divisible by an integer other than 1 and itself.      if ((n % i) == 0) return false;    }    return true;  }  virtual int GetNextPrime(int p) const {    for (int n = p + 1; n &gt; 0; n++) {      if (IsPrime(n)) return n;    }    return -1;  }};// Implementation #2 pre-calculates the primes and stores the result// in an array.class PreCalculatedPrimeTable : public PrimeTable { public:  // &apos;max&apos; specifies the maximum number the prime table holds.  explicit PreCalculatedPrimeTable(int max)      : is_prime_size_(max + 1), is_prime_(new bool[max + 1]) {    CalculatePrimesUpTo(max);  }  virtual ~PreCalculatedPrimeTable() { delete[] is_prime_; }  virtual bool IsPrime(int n) const {    return 0 &lt;= n &amp;&amp; n &lt; is_prime_size_ &amp;&amp; is_prime_[n];  }  virtual int GetNextPrime(int p) const {    for (int n = p + 1; n &lt; is_prime_size_; n++) {      if (is_prime_[n]) return n;    }    return -1;  } private:  void CalculatePrimesUpTo(int max) {    ::std::fill(is_prime_, is_prime_ + is_prime_size_, true);    is_prime_[0] = is_prime_[1] = false;    for (int i = 2; i &lt;= max; i++) {      if (!is_prime_[i]) continue;      // Marks all multiples of i (except i itself) as non-prime.      for (int j = 2*i; j &lt;= max; j += i) {        is_prime_[j] = false;      }    }  }  const int is_prime_size_;  bool* const is_prime_;  // Disables compiler warning &quot;assignment operator could not be generated.&quot;  void operator=(const PreCalculatedPrimeTable&amp; rhs);};#endif  // GTEST_SAMPLES_PRIME_TABLES_H_#ifndef GTEST_SAMPLES_SAMPLE1_H_#define GTEST_SAMPLES_SAMPLE1_H_// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.int Factorial(int n);// Returns true iff n is a prime number.bool IsPrime(int n);#endif  // GTEST_SAMPLES_SAMPLE1_H_#include &quot;sample1.h&quot;// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.int Factorial(int n) {  int result = 1;  for (int i = 1; i &lt;= n; i++) {    result *= i;  }  return result;}// Returns true iff n is a prime number.bool IsPrime(int n) {  // Trivial case 1: small numbers  if (n &lt;= 1) return false;  // Trivial case 2: even numbers  if (n % 2 == 0) return n == 2;  // Now, we have that n is odd and n &gt;= 3.  // Try to divide n by every odd number i, starting from 3  for (int i = 3; ; i += 2) {    // We only have to try i up to the squre root of n    if (i &gt; n/i) break;    // Now, we have i &lt;= n/i &lt; n.    // If n is divisible by i, n is not prime.    if (n % i == 0) return false;  }  // n has no integer factor in the range (1, n), and thus is prime.  return true;}// This sample shows how to write a simple unit test for a function,// using Google C++ testing framework.//// Writing a unit test using Google C++ testing framework is easy as 1-2-3:// Step 1. Include necessary header files such that the stuff your// test logic needs is declared.//// Don&apos;t forget gtest.h, which declares the testing framework.#include &lt;limits.h&gt;#include &quot;sample1.h&quot;#include &quot;gtest/gtest.h&quot;// Step 2. Use the TEST macro to define your tests.//// TEST has two parameters: the test case name and the test name.// After using the macro, you should define your test logic between a// pair of braces.  You can use a bunch of macros to indicate the// success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are// examples of such macros.  For a complete list, see gtest.h.//// &lt;TechnicalDetails&gt;//// In Google Test, tests are grouped into test cases.  This is how we// keep test code organized.  You should put logically related tests// into the same test case.//// The test case name and the test name should both be valid C++// identifiers.  And you should not use underscore (_) in the names.//// Google Test guarantees that each test you define is run exactly// once, but it makes no guarantee on the order the tests are// executed.  Therefore, you should write your tests in such a way// that their results don&apos;t depend on their order.//// &lt;/TechnicalDetails&gt;// Tests Factorial().// Tests factorial of negative numbers.TEST(FactorialTest, Negative) {  // This test is named &quot;Negative&quot;, and belongs to the &quot;FactorialTest&quot;  // test case.  EXPECT_EQ(1, Factorial(-5));  EXPECT_EQ(1, Factorial(-1));  EXPECT_GT(Factorial(-10), 0);  // &lt;TechnicalDetails&gt;  //  // EXPECT_EQ(expected, actual) is the same as  //  //   EXPECT_TRUE((expected) == (actual))  //  // except that it will print both the expected value and the actual  // value when the assertion fails.  This is very helpful for  // debugging.  Therefore in this case EXPECT_EQ is preferred.  //  // On the other hand, EXPECT_TRUE accepts any Boolean expression,  // and is thus more general.  //  // &lt;/TechnicalDetails&gt;}// Tests factorial of 0.TEST(FactorialTest, Zero) {  EXPECT_EQ(1, Factorial(0));}// Tests factorial of positive numbers.TEST(FactorialTest, Positive) {  EXPECT_EQ(1, Factorial(1));  EXPECT_EQ(2, Factorial(2));  EXPECT_EQ(6, Factorial(3));  EXPECT_EQ(40320, Factorial(8));}// Tests IsPrime()// Tests negative input.TEST(IsPrimeTest, Negative) {  // This test belongs to the IsPrimeTest test case.  EXPECT_FALSE(IsPrime(-1));  EXPECT_FALSE(IsPrime(-2));  EXPECT_FALSE(IsPrime(INT_MIN));}// Tests some trivial cases.TEST(IsPrimeTest, Trivial) {  EXPECT_FALSE(IsPrime(0));  EXPECT_FALSE(IsPrime(1));  EXPECT_TRUE(IsPrime(2));  EXPECT_TRUE(IsPrime(3));}// Tests positive input.TEST(IsPrimeTest, Positive) {  EXPECT_FALSE(IsPrime(4));  EXPECT_TRUE(IsPrime(5));  EXPECT_FALSE(IsPrime(6));  EXPECT_TRUE(IsPrime(23));}// Step 3. Call RUN_ALL_TESTS() in main().//// We do this by linking in src/gtest_main.cc file, which consists of// a main() function which calls RUN_ALL_TESTS() for us.//// This runs all the tests you&apos;ve defined, prints the result, and// returns 0 if successful, or 1 otherwise.//// Did you notice that we didn&apos;t register the tests?  The// RUN_ALL_TESTS() macro magically knows about all the tests we// defined.  Isn&apos;t this convenient?#ifndef GTEST_SAMPLES_SAMPLE2_H_#define GTEST_SAMPLES_SAMPLE2_H_#include &lt;string.h&gt;// A simple string class.class MyString { private:  const char* c_string_;  const MyString&amp; operator=(const MyString&amp; rhs); public:  // Clones a 0-terminated C string, allocating memory using new.  static const char* CloneCString(const char* a_c_string);  ////////////////////////////////////////////////////////////  //  // C&apos;tors  // The default c&apos;tor constructs a NULL string.  MyString() : c_string_(NULL) {}  // Constructs a MyString by cloning a 0-terminated C string.  explicit MyString(const char* a_c_string) : c_string_(NULL) {    Set(a_c_string);  }  // Copy c&apos;tor  MyString(const MyString&amp; string) : c_string_(NULL) {    Set(string.c_string_);  }  ////////////////////////////////////////////////////////////  //  // D&apos;tor.  MyString is intended to be a final class, so the d&apos;tor  // doesn&apos;t need to be virtual.  ~MyString() { delete[] c_string_; }  // Gets the 0-terminated C string this MyString object represents.  const char* c_string() const { return c_string_; }  size_t Length() const {    return c_string_ == NULL ? 0 : strlen(c_string_);  }  // Sets the 0-terminated C string this MyString object represents.  void Set(const char* c_string);};#endif  // GTEST_SAMPLES_SAMPLE2_H_#include &quot;sample2.h&quot;#include &lt;string.h&gt;// Clones a 0-terminated C string, allocating memory using new.const char* MyString::CloneCString(const char* a_c_string) {  if (a_c_string == NULL) return NULL;  const size_t len = strlen(a_c_string);  char* const clone = new char[ len + 1 ];  memcpy(clone, a_c_string, len + 1);  return clone;}// Sets the 0-terminated C string this MyString object// represents.void MyString::Set(const char* a_c_string) {  // Makes sure this works when c_string == c_string_  const char* const temp = MyString::CloneCString(a_c_string);  delete[] c_string_;  c_string_ = temp;}// This sample shows how to write a more complex unit test for a class// that has multiple member functions.//// Usually, it&apos;s a good idea to have one test for each method in your// class.  You don&apos;t have to do that exactly, but it helps to keep// your tests organized.  You may also throw in additional tests as// needed.#include &quot;sample2.h&quot;#include &quot;gtest/gtest.h&quot;// In this example, we test the MyString class (a simple string).// Tests the default c&apos;tor.TEST(MyString, DefaultConstructor) {  const MyString s;  // Asserts that s.c_string() returns NULL.  //  // &lt;TechnicalDetails&gt;  //  // If we write NULL instead of  //  //   static_cast&lt;const char *&gt;(NULL)  //  // in this assertion, it will generate a warning on gcc 3.4.  The  // reason is that EXPECT_EQ needs to know the types of its  // arguments in order to print them when it fails.  Since NULL is  // #defined as 0, the compiler will use the formatter function for  // int to print it.  However, gcc thinks that NULL should be used as  // a pointer, not an int, and therefore complains.  //  // The root of the problem is C++&apos;s lack of distinction between the  // integer number 0 and the null pointer constant.  Unfortunately,  // we have to live with this fact.  //  // &lt;/TechnicalDetails&gt;  EXPECT_STREQ(NULL, s.c_string());  EXPECT_EQ(0u, s.Length());}const char kHelloString[] = &quot;Hello, world!&quot;;// Tests the c&apos;tor that accepts a C string.TEST(MyString, ConstructorFromCString) {  const MyString s(kHelloString);  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1,            s.Length());}// Tests the copy c&apos;tor.TEST(MyString, CopyConstructor) {  const MyString s1(kHelloString);  const MyString s2 = s1;  EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString));}// Tests the Set method.TEST(MyString, Set) {  MyString s;  s.Set(kHelloString);  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  // Set should work when the input pointer is the same as the one  // already in the MyString object.  s.Set(s.c_string());  EXPECT_EQ(0, strcmp(s.c_string(), kHelloString));  // Can we set the MyString to NULL?  s.Set(NULL);  EXPECT_STREQ(NULL, s.c_string());}#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_#define GTEST_SAMPLES_SAMPLE3_INL_H_#include &lt;stddef.h&gt;// Queue is a simple queue implemented as a singled-linked list.//// The element type must support copy constructor.template &lt;typename E&gt;  // E is the element typeclass Queue;// QueueNode is a node in a Queue, which consists of an element of// type E and a pointer to the next node.template &lt;typename E&gt;  // E is the element typeclass QueueNode {  friend class Queue&lt;E&gt;; public:  // Gets the element in this node.  const E&amp; element() const { return element_; }  // Gets the next node in the queue.  QueueNode* next() { return next_; }  const QueueNode* next() const { return next_; } private:  // Creates a node with a given element value.  The next pointer is  // set to NULL.  explicit QueueNode(const E&amp; an_element) : element_(an_element), next_(NULL) {}  // We disable the default assignment operator and copy c&apos;tor.  const QueueNode&amp; operator = (const QueueNode&amp;);  QueueNode(const QueueNode&amp;);  E element_;  QueueNode* next_;};template &lt;typename E&gt;  // E is the element type.class Queue { public:  // Creates an empty queue.  Queue() : head_(NULL), last_(NULL), size_(0) {}  // D&apos;tor.  Clears the queue.  ~Queue() { Clear(); }  // Clears the queue.  void Clear() {    if (size_ &gt; 0) {      // 1. Deletes every node.      QueueNode&lt;E&gt;* node = head_;      QueueNode&lt;E&gt;* next = node-&gt;next();      for (; ;) {        delete node;        node = next;        if (node == NULL) break;        next = node-&gt;next();      }      // 2. Resets the member variables.      head_ = last_ = NULL;      size_ = 0;    }  }  // Gets the number of elements.  size_t Size() const { return size_; }  // Gets the first element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Head() { return head_; }  const QueueNode&lt;E&gt;* Head() const { return head_; }  // Gets the last element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Last() { return last_; }  const QueueNode&lt;E&gt;* Last() const { return last_; }  // Adds an element to the end of the queue.  A copy of the element is  // created using the copy constructor, and then stored in the queue.  // Changes made to the element in the queue doesn&apos;t affect the source  // object, and vice versa.  void Enqueue(const E&amp; element) {    QueueNode&lt;E&gt;* new_node = new QueueNode&lt;E&gt;(element);    if (size_ == 0) {      head_ = last_ = new_node;      size_ = 1;    } else {      last_-&gt;next_ = new_node;      last_ = new_node;      size_++;    }  }  // Removes the head of the queue and returns it.  Returns NULL if  // the queue is empty.  E* Dequeue() {    if (size_ == 0) {      return NULL;    }    const QueueNode&lt;E&gt;* const old_head = head_;    head_ = head_-&gt;next_;    size_--;    if (size_ == 0) {      last_ = NULL;    }    E* element = new E(old_head-&gt;element());    delete old_head;    return element;  }  // Applies a function/functor on each element of the queue, and  // returns the result in a new queue.  The original queue is not  // affected.  template &lt;typename F&gt;  Queue* Map(F function) const {    Queue* new_queue = new Queue();    for (const QueueNode&lt;E&gt;* node = head_; node != NULL; node = node-&gt;next_) {      new_queue-&gt;Enqueue(function(node-&gt;element()));    }    return new_queue;  } private:  QueueNode&lt;E&gt;* head_;  // The first node of the queue.  QueueNode&lt;E&gt;* last_;  // The last node of the queue.  size_t size_;  // The number of elements in the queue.  // We disallow copying a queue.  Queue(const Queue&amp;);  const Queue&amp; operator = (const Queue&amp;);};#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_#define GTEST_SAMPLES_SAMPLE3_INL_H_#include &lt;stddef.h&gt;// Queue is a simple queue implemented as a singled-linked list.//// The element type must support copy constructor.template &lt;typename E&gt;  // E is the element typeclass Queue;// QueueNode is a node in a Queue, which consists of an element of// type E and a pointer to the next node.template &lt;typename E&gt;  // E is the element typeclass QueueNode {  friend class Queue&lt;E&gt;; public:  // Gets the element in this node.  const E&amp; element() const { return element_; }  // Gets the next node in the queue.  QueueNode* next() { return next_; }  const QueueNode* next() const { return next_; } private:  // Creates a node with a given element value.  The next pointer is  // set to NULL.  explicit QueueNode(const E&amp; an_element) : element_(an_element), next_(NULL) {}  // We disable the default assignment operator and copy c&apos;tor.  const QueueNode&amp; operator = (const QueueNode&amp;);  QueueNode(const QueueNode&amp;);  E element_;  QueueNode* next_;};template &lt;typename E&gt;  // E is the element type.class Queue { public:  // Creates an empty queue.  Queue() : head_(NULL), last_(NULL), size_(0) {}  // D&apos;tor.  Clears the queue.  ~Queue() { Clear(); }  // Clears the queue.  void Clear() {    if (size_ &gt; 0) {      // 1. Deletes every node.      QueueNode&lt;E&gt;* node = head_;      QueueNode&lt;E&gt;* next = node-&gt;next();      for (; ;) {        delete node;        node = next;        if (node == NULL) break;        next = node-&gt;next();      }      // 2. Resets the member variables.      head_ = last_ = NULL;      size_ = 0;    }  }  // Gets the number of elements.  size_t Size() const { return size_; }  // Gets the first element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Head() { return head_; }  const QueueNode&lt;E&gt;* Head() const { return head_; }  // Gets the last element of the queue, or NULL if the queue is empty.  QueueNode&lt;E&gt;* Last() { return last_; }  const QueueNode&lt;E&gt;* Last() const { return last_; }  // Adds an element to the end of the queue.  A copy of the element is  // created using the copy constructor, and then stored in the queue.  // Changes made to the element in the queue doesn&apos;t affect the source  // object, and vice versa.  void Enqueue(const E&amp; element) {    QueueNode&lt;E&gt;* new_node = new QueueNode&lt;E&gt;(element);    if (size_ == 0) {      head_ = last_ = new_node;      size_ = 1;    } else {      last_-&gt;next_ = new_node;      last_ = new_node;      size_++;    }  }  // Removes the head of the queue and returns it.  Returns NULL if  // the queue is empty.  E* Dequeue() {    if (size_ == 0) {      return NULL;    }    const QueueNode&lt;E&gt;* const old_head = head_;    head_ = head_-&gt;next_;    size_--;    if (size_ == 0) {      last_ = NULL;    }    E* element = new E(old_head-&gt;element());    delete old_head;    return element;  }  // Applies a function/functor on each element of the queue, and  // returns the result in a new queue.  The original queue is not  // affected.  template &lt;typename F&gt;  Queue* Map(F function) const {    Queue* new_queue = new Queue();    for (const QueueNode&lt;E&gt;* node = head_; node != NULL; node = node-&gt;next_) {      new_queue-&gt;Enqueue(function(node-&gt;element()));    }    return new_queue;  } private:  QueueNode&lt;E&gt;* head_;  // The first node of the queue.  QueueNode&lt;E&gt;* last_;  // The last node of the queue.  size_t size_;  // The number of elements in the queue.  // We disallow copying a queue.  Queue(const Queue&amp;);  const Queue&amp; operator = (const Queue&amp;);};#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_#ifndef GTEST_SAMPLES_SAMPLE4_H_#define GTEST_SAMPLES_SAMPLE4_H_// A simple monotonic counter.class Counter { private:  int counter_; public:  // Creates a counter that starts at 0.  Counter() : counter_(0) {}  // Returns the current counter value, and increments it.  int Increment();  // Prints the current counter value to STDOUT.  void Print() const;};#endif  // GTEST_SAMPLES_SAMPLE4_H_#include &lt;stdio.h&gt;#include &quot;sample4.h&quot;// Returns the current counter value, and increments it.int Counter::Increment() {  return counter_++;}// Prints the current counter value to STDOUT.void Counter::Print() const {  printf(&quot;%d&quot;, counter_);}#include &quot;gtest/gtest.h&quot;#include &quot;sample4.h&quot;// Tests the Increment() method.TEST(Counter, Increment) {  Counter c;  // EXPECT_EQ() evaluates its arguments exactly once, so they  // can have side effects.  EXPECT_EQ(0, c.Increment());  EXPECT_EQ(1, c.Increment());  EXPECT_EQ(2, c.Increment());}// This sample teaches how to reuse a test fixture in multiple test// cases by deriving sub-fixtures from it.//// When you define a test fixture, you specify the name of the test// case that will use this fixture.  Therefore, a test fixture can// be used by only one test case.//// Sometimes, more than one test cases may want to use the same or// slightly different test fixtures.  For example, you may want to// make sure that all tests for a GUI library don&apos;t leak important// system resources like fonts and brushes.  In Google Test, you do// this by putting the shared logic in a super (as in &quot;super class&quot;)// test fixture, and then have each test case use a fixture derived// from this super fixture.#include &lt;limits.h&gt;#include &lt;time.h&gt;#include &quot;sample3-inl.h&quot;#include &quot;gtest/gtest.h&quot;#include &quot;sample1.h&quot;// In this sample, we want to ensure that every test finishes within// ~5 seconds.  If a test takes longer to run, we consider it a// failure.//// We put the code for timing a test in a test fixture called// &quot;QuickTest&quot;.  QuickTest is intended to be the super fixture that// other fixtures derive from, therefore there is no test case with// the name &quot;QuickTest&quot;.  This is OK.//// Later, we will derive multiple test fixtures from QuickTest.class QuickTest : public testing::Test { protected:  // Remember that SetUp() is run immediately before a test starts.  // This is a good place to record the start time.  virtual void SetUp() {    start_time_ = time(NULL);  }  // TearDown() is invoked immediately after a test finishes.  Here we  // check if the test was too slow.  virtual void TearDown() {    // Gets the time when the test finishes    const time_t end_time = time(NULL);    // Asserts that the test took no more than ~5 seconds.  Did you    // know that you can use assertions in SetUp() and TearDown() as    // well?    EXPECT_TRUE(end_time - start_time_ &lt;= 5) &lt;&lt; &quot;The test took too long.&quot;;  }  // The UTC time (in seconds) when the test starts  time_t start_time_;};// We derive a fixture named IntegerFunctionTest from the QuickTest// fixture.  All tests using this fixture will be automatically// required to be quick.class IntegerFunctionTest : public QuickTest {  // We don&apos;t need any more logic than already in the QuickTest fixture.  // Therefore the body is empty.};// Now we can write tests in the IntegerFunctionTest test case.// Tests Factorial()TEST_F(IntegerFunctionTest, Factorial) {  // Tests factorial of negative numbers.  EXPECT_EQ(1, Factorial(-5));  EXPECT_EQ(1, Factorial(-1));  EXPECT_GT(Factorial(-10), 0);  // Tests factorial of 0.  EXPECT_EQ(1, Factorial(0));  // Tests factorial of positive numbers.  EXPECT_EQ(1, Factorial(1));  EXPECT_EQ(2, Factorial(2));  EXPECT_EQ(6, Factorial(3));  EXPECT_EQ(40320, Factorial(8));}// Tests IsPrime()TEST_F(IntegerFunctionTest, IsPrime) {  // Tests negative input.  EXPECT_FALSE(IsPrime(-1));  EXPECT_FALSE(IsPrime(-2));  EXPECT_FALSE(IsPrime(INT_MIN));  // Tests some trivial cases.  EXPECT_FALSE(IsPrime(0));  EXPECT_FALSE(IsPrime(1));  EXPECT_TRUE(IsPrime(2));  EXPECT_TRUE(IsPrime(3));  // Tests positive input.  EXPECT_FALSE(IsPrime(4));  EXPECT_TRUE(IsPrime(5));  EXPECT_FALSE(IsPrime(6));  EXPECT_TRUE(IsPrime(23));}// The next test case (named &quot;QueueTest&quot;) also needs to be quick, so// we derive another fixture from QuickTest.//// The QueueTest test fixture has some logic and shared objects in// addition to what&apos;s in QuickTest already.  We define the additional// stuff inside the body of the test fixture, as usual.class QueueTest : public QuickTest { protected:  virtual void SetUp() {    // First, we need to set up the super fixture (QuickTest).    QuickTest::SetUp();    // Second, some additional setup for this fixture.    q1_.Enqueue(1);    q2_.Enqueue(2);    q2_.Enqueue(3);  }  // By default, TearDown() inherits the behavior of  // QuickTest::TearDown().  As we have no additional cleaning work  // for QueueTest, we omit it here.  //  // virtual void TearDown() {  //   QuickTest::TearDown();  // }  Queue&lt;int&gt; q0_;  Queue&lt;int&gt; q1_;  Queue&lt;int&gt; q2_;};// Now, let&apos;s write tests using the QueueTest fixture.// Tests the default constructor.TEST_F(QueueTest, DefaultConstructor) {  EXPECT_EQ(0u, q0_.Size());}// Tests Dequeue().TEST_F(QueueTest, Dequeue) {  int* n = q0_.Dequeue();  EXPECT_TRUE(n == NULL);  n = q1_.Dequeue();  EXPECT_TRUE(n != NULL);  EXPECT_EQ(1, *n);  EXPECT_EQ(0u, q1_.Size());  delete n;  n = q2_.Dequeue();  EXPECT_TRUE(n != NULL);  EXPECT_EQ(2, *n);  EXPECT_EQ(1u, q2_.Size());  delete n;}// If necessary, you can derive further test fixtures from a derived// fixture itself.  For example, you can derive another fixture from// QueueTest.  Google Test imposes no limit on how deep the hierarchy// can be.  In practice, however, you probably don&apos;t want it to be too// deep as to be confusing.// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: wan@google.com (Zhanyong Wan)// This sample shows how to test common properties of multiple// implementations of the same interface (aka interface tests).// The interface and its implementations are in this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;// First, we define some factory functions for creating instances of// the implementations.  You may be able to skip this step if all your// implementations can be constructed the same way.template &lt;class T&gt;PrimeTable* CreatePrimeTable();template &lt;&gt;PrimeTable* CreatePrimeTable&lt;OnTheFlyPrimeTable&gt;() {  return new OnTheFlyPrimeTable;}template &lt;&gt;PrimeTable* CreatePrimeTable&lt;PreCalculatedPrimeTable&gt;() {  return new PreCalculatedPrimeTable(10000);}// Then we define a test fixture class template.template &lt;class T&gt;class PrimeTableTest : public testing::Test { protected:  // The ctor calls the factory function to create a prime table  // implemented by T.  PrimeTableTest() : table_(CreatePrimeTable&lt;T&gt;()) {}  virtual ~PrimeTableTest() { delete table_; }  // Note that we test an implementation via the base interface  // instead of the actual implementation class.  This is important  // for keeping the tests close to the real world scenario, where the  // implementation is invoked via the base interface.  It avoids  // got-yas where the implementation class has a method that shadows  // a method with the same name (but slightly different argument  // types) in the base interface, for example.  PrimeTable* const table_;};#if GTEST_HAS_TYPED_TESTusing testing::Types;// Google Test offers two ways for reusing tests for different types.// The first is called &quot;typed tests&quot;.  You should use it if you// already know *all* the types you are gonna exercise when you write// the tests.// To write a typed test case, first use////   TYPED_TEST_CASE(TestCaseName, TypeList);//// to declare it and specify the type parameters.  As with TEST_F,// TestCaseName must match the test fixture name.// The list of types we want to test.typedef Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt; Implementations;TYPED_TEST_CASE(PrimeTableTest, Implementations);// Then use TYPED_TEST(TestCaseName, TestName) to define a typed test,// similar to TEST_F.TYPED_TEST(PrimeTableTest, ReturnsFalseForNonPrimes) {  // Inside the test body, you can refer to the type parameter by  // TypeParam, and refer to the fixture class by TestFixture.  We  // don&apos;t need them in this example.  // Since we are in the template world, C++ requires explicitly  // writing &apos;this-&gt;&apos; when referring to members of the fixture class.  // This is something you have to learn to live with.  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(-5));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(0));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(1));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(4));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(6));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(100));}TYPED_TEST(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(2));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(3));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(5));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(7));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(11));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(131));}TYPED_TEST(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, this-&gt;table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, this-&gt;table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, this-&gt;table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, this-&gt;table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, this-&gt;table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, this-&gt;table_-&gt;GetNextPrime(128));}// That&apos;s it!  Google Test will repeat each TYPED_TEST for each type// in the type list specified in TYPED_TEST_CASE.  Sit back and be// happy that you don&apos;t have to define them multiple times.#endif  // GTEST_HAS_TYPED_TEST#if GTEST_HAS_TYPED_TEST_Pusing testing::Types;// Sometimes, however, you don&apos;t yet know all the types that you want// to test when you write the tests.  For example, if you are the// author of an interface and expect other people to implement it, you// might want to write a set of tests to make sure each implementation// conforms to some basic requirements, but you don&apos;t know what// implementations will be written in the future.//// How can you write the tests without committing to the type// parameters?  That&apos;s what &quot;type-parameterized tests&quot; can do for you.// It is a bit more involved than typed tests, but in return you get a// test pattern that can be reused in many contexts, which is a big// win.  Here&apos;s how you do it:// First, define a test fixture class template.  Here we just reuse// the PrimeTableTest fixture defined earlier:template &lt;class T&gt;class PrimeTableTest2 : public PrimeTableTest&lt;T&gt; {};// Then, declare the test case.  The argument is the name of the test// fixture, and also the name of the test case (as usual).  The _P// suffix is for &quot;parameterized&quot; or &quot;pattern&quot;.TYPED_TEST_CASE_P(PrimeTableTest2);// Next, use TYPED_TEST_P(TestCaseName, TestName) to define a test,// similar to what you do with TEST_F.TYPED_TEST_P(PrimeTableTest2, ReturnsFalseForNonPrimes) {  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(-5));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(0));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(1));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(4));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(6));  EXPECT_FALSE(this-&gt;table_-&gt;IsPrime(100));}TYPED_TEST_P(PrimeTableTest2, ReturnsTrueForPrimes) {  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(2));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(3));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(5));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(7));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(11));  EXPECT_TRUE(this-&gt;table_-&gt;IsPrime(131));}TYPED_TEST_P(PrimeTableTest2, CanGetNextPrime) {  EXPECT_EQ(2, this-&gt;table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, this-&gt;table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, this-&gt;table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, this-&gt;table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, this-&gt;table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, this-&gt;table_-&gt;GetNextPrime(128));}// Type-parameterized tests involve one extra step: you have to// enumerate the tests you defined:REGISTER_TYPED_TEST_CASE_P(    PrimeTableTest2,  // The first argument is the test case name.    // The rest of the arguments are the test names.    ReturnsFalseForNonPrimes, ReturnsTrueForPrimes, CanGetNextPrime);// At this point the test pattern is done.  However, you don&apos;t have// any real test yet as you haven&apos;t said which types you want to run// the tests with.// To turn the abstract test pattern into real tests, you instantiate// it with a list of types.  Usually the test pattern will be defined// in a .h file, and anyone can #include and instantiate it.  You can// even instantiate it more than once in the same program.  To tell// different instances apart, you give each of them a name, which will// become part of the test case name and can be used in test filters.// The list of types we want to test.  Note that it doesn&apos;t have to be// defined at the time we write the TYPED_TEST_P()s.typedef Types&lt;OnTheFlyPrimeTable, PreCalculatedPrimeTable&gt;    PrimeTableImplementations;INSTANTIATE_TYPED_TEST_CASE_P(OnTheFlyAndPreCalculated,    // Instance name                              PrimeTableTest2,             // Test case name                              PrimeTableImplementations);  // Type list#endif  // GTEST_HAS_TYPED_TEST_P// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to test common properties of multiple// implementations of an interface (aka interface tests) using// value-parameterized tests. Each test in the test case has// a parameter that is an interface pointer to an implementation// tested.// The interface and its implementations are in this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;#if GTEST_HAS_PARAM_TESTusing ::testing::TestWithParam;using ::testing::Values;// As a general rule, to prevent a test from affecting the tests that come// after it, you should create and destroy the tested objects for each test// instead of reusing them.  In this sample we will define a simple factory// function for PrimeTable objects.  We will instantiate objects in test&apos;s// SetUp() method and delete them in TearDown() method.typedef PrimeTable* CreatePrimeTableFunc();PrimeTable* CreateOnTheFlyPrimeTable() {  return new OnTheFlyPrimeTable();}template &lt;size_t max_precalculated&gt;PrimeTable* CreatePreCalculatedPrimeTable() {  return new PreCalculatedPrimeTable(max_precalculated);}// Inside the test body, fixture constructor, SetUp(), and TearDown() you// can refer to the test parameter by GetParam().  In this case, the test// parameter is a factory function which we call in fixture&apos;s SetUp() to// create and store an instance of PrimeTable.class PrimeTableTest : public TestWithParam&lt;CreatePrimeTableFunc*&gt; { public:  virtual ~PrimeTableTest() { delete table_; }  virtual void SetUp() { table_ = (*GetParam())(); }  virtual void TearDown() {    delete table_;    table_ = NULL;  } protected:  PrimeTable* table_;};TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {  EXPECT_FALSE(table_-&gt;IsPrime(-5));  EXPECT_FALSE(table_-&gt;IsPrime(0));  EXPECT_FALSE(table_-&gt;IsPrime(1));  EXPECT_FALSE(table_-&gt;IsPrime(4));  EXPECT_FALSE(table_-&gt;IsPrime(6));  EXPECT_FALSE(table_-&gt;IsPrime(100));}TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(table_-&gt;IsPrime(2));  EXPECT_TRUE(table_-&gt;IsPrime(3));  EXPECT_TRUE(table_-&gt;IsPrime(5));  EXPECT_TRUE(table_-&gt;IsPrime(7));  EXPECT_TRUE(table_-&gt;IsPrime(11));  EXPECT_TRUE(table_-&gt;IsPrime(131));}TEST_P(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, table_-&gt;GetNextPrime(128));}// In order to run value-parameterized tests, you need to instantiate them,// or bind them to a list of values which will be used as test parameters.// You can instantiate them in a different translation module, or even// instantiate them several times.//// Here, we instantiate our tests with a list of two PrimeTable object// factory functions:INSTANTIATE_TEST_CASE_P(    OnTheFlyAndPreCalculated,    PrimeTableTest,    Values(&amp;CreateOnTheFlyPrimeTable, &amp;CreatePreCalculatedPrimeTable&lt;1000&gt;));#else// Google Test may not support value-parameterized tests with some// compilers. If we use conditional compilation to compile out all// code referring to the gtest_main library, MSVC linker will not link// that library at all and consequently complain about missing entry// point defined in that library (fatal error LNK1561: entry point// must be defined). This dummy test keeps gtest_main linked in.TEST(DummyTest, ValueParameterizedTestsAreNotSupportedOnThisPlatform) {}#endif  // GTEST_HAS_PARAM_TEST// Copyright 2008 Google Inc.// All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to test code relying on some global flag variables.// Combine() helps with generating all possible combinations of such flags,// and each test is given one combination as a parameter.// Use class definitions to test from this header.#include &quot;prime_tables.h&quot;#include &quot;gtest/gtest.h&quot;#if GTEST_HAS_COMBINE// Suppose we want to introduce a new, improved implementation of PrimeTable// which combines speed of PrecalcPrimeTable and versatility of// OnTheFlyPrimeTable (see prime_tables.h). Inside it instantiates both// PrecalcPrimeTable and OnTheFlyPrimeTable and uses the one that is more// appropriate under the circumstances. But in low memory conditions, it can be// told to instantiate without PrecalcPrimeTable instance at all and use only// OnTheFlyPrimeTable.class HybridPrimeTable : public PrimeTable { public:  HybridPrimeTable(bool force_on_the_fly, int max_precalculated)      : on_the_fly_impl_(new OnTheFlyPrimeTable),        precalc_impl_(force_on_the_fly ? NULL :                          new PreCalculatedPrimeTable(max_precalculated)),        max_precalculated_(max_precalculated) {}  virtual ~HybridPrimeTable() {    delete on_the_fly_impl_;    delete precalc_impl_;  }  virtual bool IsPrime(int n) const {    if (precalc_impl_ != NULL &amp;&amp; n &lt; max_precalculated_)      return precalc_impl_-&gt;IsPrime(n);    else      return on_the_fly_impl_-&gt;IsPrime(n);  }  virtual int GetNextPrime(int p) const {    int next_prime = -1;    if (precalc_impl_ != NULL &amp;&amp; p &lt; max_precalculated_)      next_prime = precalc_impl_-&gt;GetNextPrime(p);    return next_prime != -1 ? next_prime : on_the_fly_impl_-&gt;GetNextPrime(p);  } private:  OnTheFlyPrimeTable* on_the_fly_impl_;  PreCalculatedPrimeTable* precalc_impl_;  int max_precalculated_;};using ::testing::TestWithParam;using ::testing::Bool;using ::testing::Values;using ::testing::Combine;// To test all code paths for HybridPrimeTable we must test it with numbers// both within and outside PreCalculatedPrimeTable&apos;s capacity and also with// PreCalculatedPrimeTable disabled. We do this by defining fixture which will// accept different combinations of parameters for instantiating a// HybridPrimeTable instance.class PrimeTableTest : public TestWithParam&lt; ::testing::tuple&lt;bool, int&gt; &gt; { protected:  virtual void SetUp() {    // This can be written as    //    // bool force_on_the_fly;    // int max_precalculated;    // tie(force_on_the_fly, max_precalculated) = GetParam();    //    // once the Google C++ Style Guide allows use of ::std::tr1::tie.    //    bool force_on_the_fly = ::testing::get&lt;0&gt;(GetParam());    int max_precalculated = ::testing::get&lt;1&gt;(GetParam());    table_ = new HybridPrimeTable(force_on_the_fly, max_precalculated);  }  virtual void TearDown() {    delete table_;    table_ = NULL;  }  HybridPrimeTable* table_;};TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {  // Inside the test body, you can refer to the test parameter by GetParam().  // In this case, the test parameter is a PrimeTable interface pointer which  // we can use directly.  // Please note that you can also save it in the fixture&apos;s SetUp() method  // or constructor and use saved copy in the tests.  EXPECT_FALSE(table_-&gt;IsPrime(-5));  EXPECT_FALSE(table_-&gt;IsPrime(0));  EXPECT_FALSE(table_-&gt;IsPrime(1));  EXPECT_FALSE(table_-&gt;IsPrime(4));  EXPECT_FALSE(table_-&gt;IsPrime(6));  EXPECT_FALSE(table_-&gt;IsPrime(100));}TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {  EXPECT_TRUE(table_-&gt;IsPrime(2));  EXPECT_TRUE(table_-&gt;IsPrime(3));  EXPECT_TRUE(table_-&gt;IsPrime(5));  EXPECT_TRUE(table_-&gt;IsPrime(7));  EXPECT_TRUE(table_-&gt;IsPrime(11));  EXPECT_TRUE(table_-&gt;IsPrime(131));}TEST_P(PrimeTableTest, CanGetNextPrime) {  EXPECT_EQ(2, table_-&gt;GetNextPrime(0));  EXPECT_EQ(3, table_-&gt;GetNextPrime(2));  EXPECT_EQ(5, table_-&gt;GetNextPrime(3));  EXPECT_EQ(7, table_-&gt;GetNextPrime(5));  EXPECT_EQ(11, table_-&gt;GetNextPrime(7));  EXPECT_EQ(131, table_-&gt;GetNextPrime(128));}// In order to run value-parameterized tests, you need to instantiate them,// or bind them to a list of values which will be used as test parameters.// You can instantiate them in a different translation module, or even// instantiate them several times.//// Here, we instantiate our tests with a list of parameters. We must combine// all variations of the boolean flag suppressing PrecalcPrimeTable and some// meaningful values for tests. We choose a small value (1), and a value that// will put some of the tested numbers beyond the capability of the// PrecalcPrimeTable instance and some inside it (10). Combine will produce all// possible combinations.INSTANTIATE_TEST_CASE_P(MeaningfulTestParameters,                        PrimeTableTest,                        Combine(Bool(), Values(1, 10)));#else// Google Test may not support Combine() with some compilers. If we// use conditional compilation to compile out all code referring to// the gtest_main library, MSVC linker will not link that library at// all and consequently complain about missing entry point defined in// that library (fatal error LNK1561: entry point must be// defined). This dummy test keeps gtest_main linked in.TEST(DummyTest, CombineIsNotSupportedOnThisPlatform) {}#endif  // GTEST_HAS_COMBINE// Copyright 2009 Google Inc. All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to use Google Test listener API to implement// an alternative console output and how to use the UnitTest reflection API// to enumerate test cases and tests and to inspect their results.#include &lt;stdio.h&gt;#include &quot;gtest/gtest.h&quot;using ::testing::EmptyTestEventListener;using ::testing::InitGoogleTest;using ::testing::Test;using ::testing::TestCase;using ::testing::TestEventListeners;using ::testing::TestInfo;using ::testing::TestPartResult;using ::testing::UnitTest;namespace {// Provides alternative output mode which produces minimal amount of// information about tests.class TersePrinter : public EmptyTestEventListener { private:  // Called before any test activity starts.  virtual void OnTestProgramStart(const UnitTest&amp; /* unit_test */) {}  // Called after all test activities have ended.  virtual void OnTestProgramEnd(const UnitTest&amp; unit_test) {    fprintf(stdout, &quot;TEST %s\n&quot;, unit_test.Passed() ? &quot;PASSED&quot; : &quot;FAILED&quot;);    fflush(stdout);  }  // Called before a test starts.  virtual void OnTestStart(const TestInfo&amp; test_info) {    fprintf(stdout,            &quot;*** Test %s.%s starting.\n&quot;,            test_info.test_case_name(),            test_info.name());    fflush(stdout);  }  // Called after a failed assertion or a SUCCEED() invocation.  virtual void OnTestPartResult(const TestPartResult&amp; test_part_result) {    fprintf(stdout,            &quot;%s in %s:%d\n%s\n&quot;,            test_part_result.failed() ? &quot;*** Failure&quot; : &quot;Success&quot;,            test_part_result.file_name(),            test_part_result.line_number(),            test_part_result.summary());    fflush(stdout);  }  // Called after a test ends.  virtual void OnTestEnd(const TestInfo&amp; test_info) {    fprintf(stdout,            &quot;*** Test %s.%s ending.\n&quot;,            test_info.test_case_name(),            test_info.name());    fflush(stdout);  }};  // class TersePrinterTEST(CustomOutputTest, PrintsMessage) {  printf(&quot;Printing something from the test body...\n&quot;);}TEST(CustomOutputTest, Succeeds) {  SUCCEED() &lt;&lt; &quot;SUCCEED() has been invoked from here&quot;;}TEST(CustomOutputTest, Fails) {  EXPECT_EQ(1, 2)      &lt;&lt; &quot;This test fails in order to demonstrate alternative failure messages&quot;;}}  // namespaceint main(int argc, char **argv) {  InitGoogleTest(&amp;argc, argv);  bool terse_output = false;  if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;--terse_output&quot;) == 0 )    terse_output = true;  else    printf(&quot;%s\n&quot;, &quot;Run this program with --terse_output to change the way &quot;           &quot;it prints its output.&quot;);  UnitTest&amp; unit_test = *UnitTest::GetInstance();  // If we are given the --terse_output command line flag, suppresses the  // standard output and attaches own result printer.  if (terse_output) {    TestEventListeners&amp; listeners = unit_test.listeners();    // Removes the default console output listener from the list so it will    // not receive events from Google Test and won&apos;t print any output. Since    // this operation transfers ownership of the listener to the caller we    // have to delete it as well.    delete listeners.Release(listeners.default_result_printer());    // Adds the custom output listener to the list. It will now receive    // events from Google Test and print the alternative output. We don&apos;t    // have to worry about deleting it since Google Test assumes ownership    // over it after adding it to the list.    listeners.Append(new TersePrinter);  }  int ret_val = RUN_ALL_TESTS();  // This is an example of using the UnitTest reflection API to inspect test  // results. Here we discount failures from the tests we expected to fail.  int unexpectedly_failed_tests = 0;  for (int i = 0; i &lt; unit_test.total_test_case_count(); ++i) {    const TestCase&amp; test_case = *unit_test.GetTestCase(i);    for (int j = 0; j &lt; test_case.total_test_count(); ++j) {      const TestInfo&amp; test_info = *test_case.GetTestInfo(j);      // Counts failed tests that were not meant to fail (those without      // &apos;Fails&apos; in the name).      if (test_info.result()-&gt;Failed() &amp;&amp;          strcmp(test_info.name(), &quot;Fails&quot;) != 0) {        unexpectedly_failed_tests++;      }    }  }  // Test that were meant to fail should not affect the test program outcome.  if (unexpectedly_failed_tests == 0)    ret_val = 0;  return ret_val;}// Copyright 2009 Google Inc. All Rights Reserved.//// Redistribution and use in source and binary forms, with or without// modification, are permitted provided that the following conditions are// met:////     * Redistributions of source code must retain the above copyright// notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above// copyright notice, this list of conditions and the following disclaimer// in the documentation and/or other materials provided with the// distribution.//     * Neither the name of Google Inc. nor the names of its// contributors may be used to endorse or promote products derived from// this software without specific prior written permission.//// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.//// Author: vladl@google.com (Vlad Losev)// This sample shows how to use Google Test listener API to implement// a primitive leak checker.#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;gtest/gtest.h&quot;using ::testing::EmptyTestEventListener;using ::testing::InitGoogleTest;using ::testing::Test;using ::testing::TestCase;using ::testing::TestEventListeners;using ::testing::TestInfo;using ::testing::TestPartResult;using ::testing::UnitTest;namespace {// We will track memory used by this class.class Water { public:  // Normal Water declarations go here.  // operator new and operator delete help us control water allocation.  void* operator new(size_t allocation_size) {    allocated_++;    return malloc(allocation_size);  }  void operator delete(void* block, size_t /* allocation_size */) {    allocated_--;    free(block);  }  static int allocated() { return allocated_; } private:  static int allocated_;};int Water::allocated_ = 0;// This event listener monitors how many Water objects are created and// destroyed by each test, and reports a failure if a test leaks some Water// objects. It does this by comparing the number of live Water objects at// the beginning of a test and at the end of a test.class LeakChecker : public EmptyTestEventListener { private:  // Called before a test starts.  virtual void OnTestStart(const TestInfo&amp; /* test_info */) {    initially_allocated_ = Water::allocated();  }  // Called after a test ends.  virtual void OnTestEnd(const TestInfo&amp; /* test_info */) {    int difference = Water::allocated() - initially_allocated_;    // You can generate a failure in any event handler except    // OnTestPartResult. Just use an appropriate Google Test assertion to do    // it.    EXPECT_LE(difference, 0) &lt;&lt; &quot;Leaked &quot; &lt;&lt; difference &lt;&lt; &quot; unit(s) of Water!&quot;;  }  int initially_allocated_;};TEST(ListenersTest, DoesNotLeak) {  Water* water = new Water;  delete water;}// This should fail when the --check_for_leaks command line flag is// specified.TEST(ListenersTest, LeaksWater) {  Water* water = new Water;  EXPECT_TRUE(water != NULL);}}  // namespaceint main(int argc, char **argv) {  InitGoogleTest(&amp;argc, argv);  bool check_for_leaks = false;  if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;--check_for_leaks&quot;) == 0 )    check_for_leaks = true;  else    printf(&quot;%s\n&quot;, &quot;Run this program with --check_for_leaks to enable &quot;           &quot;custom leak checking in the tests.&quot;);  // If we are given the --check_for_leaks command line flag, installs the  // leak checker.  if (check_for_leaks) {    TestEventListeners&amp; listeners = UnitTest::GetInstance()-&gt;listeners();    // Adds the leak checker to the end of the test event listener list,    // after the default text output printer and the default XML report    // generator.    //    // The order is important - it ensures that failures generated in the    // leak checker&apos;s OnTestEnd() method are processed by the text and XML    // printers *before* their OnTestEnd() methods are called, such that    // they are attributed to the right test. Remember that a listener    // receives an OnXyzStart event *after* listeners preceding it in the    // list received that event, and receives an OnXyzEnd event *before*    // listeners preceding it.    //    // We don&apos;t need to worry about deleting the new listener later, as    // Google Test will do it.    listeners.Append(new LeakChecker);  }  return RUN_ALL_TESTS();}</code></pre><h2 id="Google-Mock"><a href="#Google-Mock" class="headerlink" title="Google Mock"></a>Google Mock</h2><p><a href="https://www.cnblogs.com/jycboy/p/gmock_summary.html" title="https://www.cnblogs.com/jycboy/p/gmock_summary.html" target="_blank" rel="noopener">https://www.cnblogs.com/jycboy/p/gmock_summary.html</a></p><p><a href="https://blog.csdn.net/noahzuo/article/details/60136467" title="https://blog.csdn.net/noahzuo/article/details/60136467" target="_blank" rel="noopener">https://blog.csdn.net/noahzuo/article/details/60136467</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md" title="https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md" target="_blank" rel="noopener">https://github.com/google/googletest/blob/master/googlemock/docs/CheatSheet.md</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md" title="https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md" target="_blank" rel="noopener">https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md</a></p><p><a href="http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html" title="http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html" target="_blank" rel="noopener">http://www.cnblogs.com/jycboy/p/gmock_cheatsheet.html</a></p><h3 id="CookBook"><a href="#CookBook" class="headerlink" title="CookBook"></a>CookBook</h3><h4 id="Mocking-Private-or-Protected-Methods"><a href="#Mocking-Private-or-Protected-Methods" class="headerlink" title="Mocking Private or Protected Methods"></a>Mocking Private or Protected Methods</h4><pre><code>class Foo { public:  ...  virtual bool Transform(Gadget* g) = 0; protected:  virtual void Resume(); private:  virtual int GetTimeOut();};class MockFoo : public Foo { public:  ...  MOCK_METHOD1(Transform, bool(Gadget* g));  // The following must be in the public section, even though the  // methods are protected or private in the base class.  MOCK_METHOD0(Resume, void());  MOCK_METHOD0(GetTimeOut, int());};</code></pre><h4 id="Mocking-Overloaded-Methods"><a href="#Mocking-Overloaded-Methods" class="headerlink" title="Mocking Overloaded Methods"></a>Mocking Overloaded Methods</h4><pre><code>class Foo {  ...  // Must be virtual as we&apos;ll inherit from Foo.  virtual ~Foo();  // Overloaded on the types and/or numbers of arguments.  virtual int Add(Element x);  virtual int Add(int times, Element x);  // Overloaded on the const-ness of this object.  virtual Bar&amp; GetBar();  virtual const Bar&amp; GetBar() const;};class MockFoo : public Foo {  ...  MOCK_METHOD1(Add, int(Element x));  MOCK_METHOD2(Add, int(int times, Element x);  MOCK_METHOD0(GetBar, Bar&amp;());  MOCK_CONST_METHOD0(GetBar, const Bar&amp;());};</code></pre><h4 id="Mocking-Class-Templates"><a href="#Mocking-Class-Templates" class="headerlink" title="Mocking Class Templates"></a>Mocking Class Templates</h4><pre><code>template &lt;typename Elem&gt;class StackInterface {  ...  // Must be virtual as we&apos;ll inherit from StackInterface.  virtual ~StackInterface();  virtual int GetSize() const = 0;  virtual void Push(const Elem&amp; x) = 0;};template &lt;typename Elem&gt;class MockStack : public StackInterface&lt;Elem&gt; {  ...  MOCK_CONST_METHOD0_T(GetSize, int());  MOCK_METHOD1_T(Push, void(const Elem&amp; x));};</code></pre><h4 id="Mocking-Nonvirtual-Methods"><a href="#Mocking-Nonvirtual-Methods" class="headerlink" title="Mocking Nonvirtual Methods"></a>Mocking Nonvirtual Methods</h4><pre><code>// A simple packet stream class.  None of its members is virtual.class ConcretePacketStream { public:  void AppendPacket(Packet* new_packet);  const Packet* GetPacket(size_t packet_number) const;  size_t NumberOfPackets() const;  ...};// A mock packet stream class.  It inherits from no other, but defines// GetPacket() and NumberOfPackets().class MockPacketStream { public:  MOCK_CONST_METHOD1(GetPacket, const Packet*(size_t packet_number));  MOCK_CONST_METHOD0(NumberOfPackets, size_t());  ...};</code></pre><p>EXPECT_CALL 宏支持许多修饰符。它的语法是：</p><pre><code>EXPECT_CALL(mock_object, method(matchers)).With(multi_argument_matcher) ?.Times(cardinality) ?.InSequence(sequences) *.After(expectations) *.WillOnce(action) *.WillRepeatedly(action) ?.RetiresOnSaturation(); ?</code></pre><p>（ ? 和 <em> 代表每个修饰符的基数： ? 表示可以选用修饰符一次； </em> 表示可以多次使用修饰符。）</p><p>最有用的修饰符是 Times() ，它可以让你指定一个方法被调用的次数。即使你知道一个方法<br>会被调用多次，但不知道具体多少次，那么你也可以使用 WillRepeatedly() 。</p><h1 id="Boost-Test"><a href="#Boost-Test" class="headerlink" title="Boost.Test"></a>Boost.Test</h1><p><a href="https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html" title="https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html" target="_blank" rel="noopener">https://www.boost.org/doc/libs/1_67_0/libs/test/doc/html/index.html</a></p><p><a href="https://www.cnblogs.com/moon1992/p/7482033.html" title="https://www.cnblogs.com/moon1992/p/7482033.html" target="_blank" rel="noopener">https://www.cnblogs.com/moon1992/p/7482033.html</a></p><p><a href="https://ask.helplib.com/c++/post_1311306" title="https://ask.helplib.com/c++/post_1311306" target="_blank" rel="noopener">https://ask.helplib.com/c++/post_1311306</a></p><p><a href="https://blogs.msdn.microsoft.com/c/2018/01/12/boost-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8A%A8%E6%80%81%E5%BA%93%E6%94%AF%E6%8C%81%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/" title="https://blogs.msdn.microsoft.com/c/2018/01/12/boost-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%8A%A8%E6%80%81%E5%BA%93%E6%94%AF%E6%8C%81%E5%92%8C%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/" target="_blank" rel="noopener">Boost.Test单元测试：动态库支持和新项目模板</a></p><h1 id="UnitTest-CppUnitTestFramework"><a href="#UnitTest-CppUnitTestFramework" class="headerlink" title="UnitTest CppUnitTestFramework"></a>UnitTest CppUnitTestFramework</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/hh419385.aspx" title="https://msdn.microsoft.com/zh-cn/library/hh419385.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/hh419385.aspx</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396" title="https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/hh694604.aspx?f=255&amp;MSPPError=-2147217396</a></p><ul><li>Assert.Inconclusive()//表示一个未验证的测试；</li><li>Assert.AreEqual() //测试指定的值是否相等，如果相等，则测试通过；</li><li>AreSame() //用于验证指定的两个对象变量是指向相同的对象，否则认为是错误</li><li>AreNotSame() //用于验证指定的两个对象变量是指向不同的对象，否则认为是错误</li><li>Assert.IsTrue() //测试指定的条件是否为True，如果为True，则测试通过；</li><li>Assert.IsFalse() //测试指定的条件是否为False，如果为False，则测试通过；</li><li>Assert.IsNull() //测试指定的对象是否为空引用，如果为空，则测试通过；</li><li>Assert.IsNotNull() //测试指定的对象是否为非空，如果不为空，则测试通过；</li></ul><h2 id="simple"><a href="#simple" class="headerlink" title="simple:"></a>simple:</h2><pre><code>#include &quot;stdafx.h&quot;#include &quot;CppUnitTest.h&quot;using namespace Microsoft::VisualStudio::CppUnitTestFramework;namespace MyUnitTest{            TEST_CLASS(UnitTest1)    {    public:        TEST_METHOD(TestMethod1)        {            // TODO: 在此输入测试代码        }    };}namespace MyTest{    TEST_CLASS(MyTests)    {    public:        TEST_METHOD(MyTestMethod)        {            Assert::AreEqual(6, 6);        }    };}#include &quot;stdafx.h&quot;#include &quot;CppUnitTest.h&quot; using namespace Microsoft::VisualStudio::CppUnitTestFramework;BEGIN_TEST_MODULE_ATTRIBUTE()TEST_MODULE_ATTRIBUTE(L&quot;Date&quot;, L&quot;2010/6/12&quot;)END_TEST_MODULE_ATTRIBUTE()TEST_MODULE_INITIALIZE(ModuleInitialize){    Logger::WriteMessage(&quot;In Module Initialize&quot;);}TEST_MODULE_CLEANUP(ModuleCleanup){    Logger::WriteMessage(&quot;In Module Cleanup&quot;);}TEST_CLASS(Class1){public:    Class1()    {        Logger::WriteMessage(&quot;In Class1&quot;);    }    ~Class1()    {        Logger::WriteMessage(&quot;In ~Class1&quot;);    }    TEST_CLASS_INITIALIZE(ClassInitialize)    {        Logger::WriteMessage(&quot;In Class Initialize&quot;);    }    TEST_CLASS_CLEANUP(ClassCleanup)    {        Logger::WriteMessage(&quot;In Class Cleanup&quot;);    }    BEGIN_TEST_METHOD_ATTRIBUTE(Method1)        TEST_OWNER(L&quot;OwnerName&quot;)        TEST_PRIORITY(1)        END_TEST_METHOD_ATTRIBUTE()        TEST_METHOD(Method1)    {        Logger::WriteMessage(&quot;In Method1&quot;);        Assert::AreEqual(0, 0);    }    TEST_METHOD(Method2)    {        Assert::Fail(L&quot;Fail&quot;);    }};</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://docs.microsoft.com/en-us/visualstudio/test/writing-unit-tests-for-c-cpp" title="https://docs.microsoft.com/en-us/visualstudio/test/writing-unit-tests-for-c-cpp" target="_blank" rel="noopener">编写 单元测试 用于 C / C + + 在 Visual Studio</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" title="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks</a></p><h1 id="其他单元测试框架"><a href="#其他单元测试框架" class="headerlink" title="其他单元测试框架"></a>其他单元测试框架</h1><pre><code>Boost.Test http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.htmlCppUnit http://cppunit.sourceforge.net/doc/1.11.6/cppunit_cookbook.htmlCppUnitLite http://c2.com/cgi/wiki?CppUnitLiteCUTE http://cute-test.com/CxxTest http://cxxtest.com/Unit++ http://unitpp.sourceforge.net/</code></pre><h1 id="BOOK"><a href="#BOOK" class="headerlink" title="BOOK"></a>BOOK</h1><p>C++程序设计实践与技巧：测试驱动开发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cppunit&quot;&gt;&lt;a href=&quot;#cppunit&quot; class=&quot;headerlink&quot; title=&quot;cppunit&quot;&gt;&lt;/a&gt;cppunit&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://caojingyou.github.io/2018/01/18/c
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="CppUnit" scheme="https://caojingyou.github.io/tags/CppUnit/"/>
    
      <category term="单元测试" scheme="https://caojingyou.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="CppUTest" scheme="https://caojingyou.github.io/tags/CppUTest/"/>
    
      <category term="Google Test" scheme="https://caojingyou.github.io/tags/Google-Test/"/>
    
      <category term="Google Mock" scheme="https://caojingyou.github.io/tags/Google-Mock/"/>
    
      <category term="Boost.Test" scheme="https://caojingyou.github.io/tags/Boost-Test/"/>
    
      <category term="MicrosoftCppUnitTest" scheme="https://caojingyou.github.io/tags/MicrosoftCppUnitTest/"/>
    
  </entry>
  
  <entry>
    <title>目录监控</title>
    <link href="https://caojingyou.github.io/2018/04/27/%E7%9B%AE%E5%BD%95%E7%9B%91%E6%8E%A7/"/>
    <id>https://caojingyou.github.io/2018/04/27/目录监控/</id>
    <published>2018-04-27T08:03:00.000Z</published>
    <updated>2018-08-01T00:45:41.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileSystemWatcher"><a href="#FileSystemWatcher" class="headerlink" title="FileSystemWatcher"></a>FileSystemWatcher</h1><pre><code>// &lt;https://msdn.microsoft.com/zh-cn/library/chzww271.aspx&gt;// monitor_fs.cpp// compile with: /clr#using &lt;system.dll&gt;using namespace System;using namespace System::IO;ref class FSEventHandler{public:    void OnChanged (Object ^source, FileSystemEventArgs ^e)    {        Console::WriteLine(&quot;File: {0} {1}&quot;,                           e-&gt;FullPath, e-&gt;ChangeType);    }    void OnRenamed(Object ^source, RenamedEventArgs ^e)    {        Console::WriteLine(&quot;File: {0} renamed to {1}&quot;,                           e-&gt;OldFullPath, e-&gt;FullPath);    }};int main(){    array&lt;String ^&gt; ^args = Environment::GetCommandLineArgs();    if(args-&gt;Length &lt; 2)    {        Console::WriteLine(&quot;Usage: Watcher.exe &lt;directory&gt;&quot;);        return -1;    }    FileSystemWatcher ^fsWatcher = gcnew FileSystemWatcher( );    fsWatcher-&gt;Path = args[1];    fsWatcher-&gt;NotifyFilter = static_cast&lt;NotifyFilters&gt;                              (NotifyFilters::FileName |                               NotifyFilters::Attributes |                               NotifyFilters::LastAccess |                               NotifyFilters::LastWrite |                               NotifyFilters::Security |                               NotifyFilters::Size );    FSEventHandler ^handler = gcnew FSEventHandler();    fsWatcher-&gt;Changed += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Created += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Deleted += gcnew FileSystemEventHandler(                              handler, &amp;FSEventHandler::OnChanged);    fsWatcher-&gt;Renamed += gcnew RenamedEventHandler(                              handler, &amp;FSEventHandler::OnRenamed);    fsWatcher-&gt;EnableRaisingEvents = true;    Console::WriteLine(&quot;Press Enter to quit the sample.&quot;);    Console::ReadLine( );}</code></pre><h1 id="目录监视器-Directory-Monitor"><a href="#目录监视器-Directory-Monitor" class="headerlink" title="目录监视器(Directory Monitor)"></a>目录监视器(Directory Monitor)</h1><p>使用Boost.Asio扩展<br><a href="http://www.highscore.de/boost/dir_monitor.zip" title="http://www.highscore.de/boost/dir_monitor.zip" target="_blank" rel="noopener">http://www.highscore.de/boost/dir_monitor.zip</a></p><h1 id="SHChangeNotifyRegister"><a href="#SHChangeNotifyRegister" class="headerlink" title="SHChangeNotifyRegister"></a>SHChangeNotifyRegister</h1><p>Win SDK Samples 下 ChangeNotifyWatcher 项目，使用<code>SHChangeNotifyRegister</code></p><p>使用SHChangeNotifyRegister、FindFirstChangeNotification、ReadDirectoryChangesW</p><p><a href="https://blog.csdn.net/miss_acha/article/details/7745216" target="_blank" rel="noopener">windows下文件的监控–ReadDirectoryChangesW函数的使用</a></p><h2 id="监控文件和目录的四种方式"><a href="#监控文件和目录的四种方式" class="headerlink" title="监控文件和目录的四种方式"></a>监控文件和目录的四种方式</h2><p>以下内容引用<a href="https://blog.csdn.net/rankun1/article/details/53509628" target="_blank" rel="noopener">理解 ReadDirectoryChangesW</a></p><p>在 Windows Vista 中，SHChangeNotifyRegister 已经可以报告所有文件的所有变更。但问题是，还存在上亿不打算立即升级的 Windows XP 用户。</p><p>　　由于 SHChangeNotifyRegister 基于窗口消息，所以还会带来性能上的问题。如果发生了太多文件变更，应用程序会不断接收到变更消息，你必须自己确认实际发生的事情。对于一部分应用程序来说，这实在是相当的囧。</p><p>　　Windows 2000 引入了两个新接口，<a href="http://msdn.microsoft.com/en-us/library/aa364417(VS.85" target="_blank" rel="noopener">FindFirstChangeNotification</a>.aspx) 和 <a href="http://msdn.microsoft.com/en-us/library/aa365465(v=VS.85" target="_blank" rel="noopener">ReadDirectoryChangesW</a>.aspx)。 FindFirstChangeNotification 很容易使用，但没有给出变更文件的信息。即便如此，这个函数对某些应用程序还是很有用的，比如传真服务和 SMTP 服务可以通过拖拽一个文件到一个目录来接受任务队列。ReadDirectoryChangesW 会给出变更的内容和方式, 不过相对的，在使用上也更复杂一些。</p><p>　　同 SHChangeNotifyRegister 一样，这两个新函数也会有性能问题。与 Shell 通知相比，它们的运行速度有明显提升，但在不同目录间移动上千个文件仍然会导致你丢失一部分(或者很多)通知。丢失通知的原因很<a href="http://social.msdn.microsoft.com/forums/en-US/netfxbcl/thread/4465cafb-f4ed-434f-89d8-c85ced6ffaa8/" target="_blank" rel="noopener">复杂</a>。令人惊讶的是，似乎与你处理通知的速度有关。</p><p>　　注意，FindFirstChangeNotification 和 ReadDirectoryChangesW 是互斥的，不能同时使用。</p><p>　　Windows XP 引入了最终解决方案，变更日志(<a href="http://msdn.microsoft.com/en-us/library/aa363803(VS.85" target="_blank" rel="noopener">Change Journal</a>.aspx))可以跟踪每一个变更的细节，即使你的软件没有运行。很帅的技术，但也相当难用。</p><p>　　第四个，同时也是最后一个解决方案需要安装<a href="http://msdn.microsoft.com/en-us/library/ff548202.aspx" target="_blank" rel="noopener">文件系统过滤驱动</a>，Sysinternals 的 FileMon 就使用了这种技术。在 Windows 驱动开发包(WDK)中有一个例子。这个方案本质上是一个<a href="http://msdn.microsoft.com/en-us/library/ff548084.aspx" target="_blank" rel="noopener">设备驱动</a>，如果没有正确的实现，有可能导致系统稳定性方面的问题。</p><p>　　对我来说，使用 ReadDirectoryChangesW，在性能和复杂度上会是一个很好的平衡。</p><p>　　使用 ReadDirectoryChangesW 的最大挑战在于，在IO模式，处理信号，等待方式，以及线程模型这几个问题的整合上，存在数百种可能性。如果你不是 Win32 I/O 方面的专家，即使最简单的场景，你也很难搞定。</p><p>A. I/O模式:</p><pre><code>阻塞同步(Blocking synchronous)触发式同步(Signaled synchronous)重叠异步(Overlapped asynchronous)完成例程(Completion Routine) (又名 Asynchronous Procedure Call or APC)</code></pre><p>B. 当调用 WaitForXxx 函数的时候:</p><pre><code>等待目录句柄等待 OVERLAPPED 结构体里的 Event 对象什么都不等 (APCs)</code></pre><p>C. 处理通知:</p><pre><code>阻塞WaitForSingleObjectWaitForMultipleObjectsWaitForMultipleObjectsExMsgWaitForMultipleObjectsExIO完成端口(I/O Completion Ports)</code></pre><p>D. 线程模型:</p><pre><code>每个工作线程调用一次 ReadDirectoryChangesW.每个工作线程调用多次 ReadDirectoryChangesW.在主线程上调用多次 ReadDirectoryChangesW.多个线程进行多个调用. (I/O Completion Ports)</code></pre><p>　　最后，当调用 ReadDirectoryChangesW 的时候，你可以通过 flags 选择你要监控的内容，包括文件创建，内容变更，属性变更等等。你可以多次调用，每次一个 flag，也可以在一次调用中使用多个 flag。多个 flag 总是正确的解决方案。但如果你为了调试方便，需要一个 flag 一个 flag 的调用的话，那就需要从 ReadDirectoryChangesW 返回的通知缓冲区中读取更多的数据。</p><h1 id="QFileSystemWatcher"><a href="#QFileSystemWatcher" class="headerlink" title="QFileSystemWatcher"></a>QFileSystemWatcher</h1><p>Qt的QFileSystemWatcher也可监控目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FileSystemWatcher&quot;&gt;&lt;a href=&quot;#FileSystemWatcher&quot; class=&quot;headerlink&quot; title=&quot;FileSystemWatcher&quot;&gt;&lt;/a&gt;FileSystemWatcher&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="boost" scheme="https://caojingyou.github.io/tags/boost/"/>
    
      <category term="目录监控" scheme="https://caojingyou.github.io/tags/%E7%9B%AE%E5%BD%95%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cryptlib</title>
    <link href="https://caojingyou.github.io/2018/04/18/Cryptlib/"/>
    <id>https://caojingyou.github.io/2018/04/18/Cryptlib/</id>
    <published>2018-04-18T09:28:00.000Z</published>
    <updated>2018-04-18T09:29:33.323Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cs.auckland.ac.nz/~pgut001/cryptlib/" title="https://www.cs.auckland.ac.nz/~pgut001/cryptlib/" target="_blank" rel="noopener">https://www.cs.auckland.ac.nz/~pgut001/cryptlib/</a></p><p><a href="http://www.cypherpunks.to/~peter/cl344.zip" title="http://www.cypherpunks.to/~peter/cl344.zip" target="_blank" rel="noopener">http://www.cypherpunks.to/~peter/cl344.zip</a></p><p><a href="http://www.cypherpunks.to/~peter/manual.pdf" title="http://www.cypherpunks.to/~peter/manual.pdf" target="_blank" rel="noopener">http://www.cypherpunks.to/~peter/manual.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cs.auckland.ac.nz/~pgut001/cryptlib/&quot; title=&quot;https://www.cs.auckland.ac.nz/~pgut001/cryptlib/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="密码" scheme="https://caojingyou.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="Cryptlib" scheme="https://caojingyou.github.io/tags/Cryptlib/"/>
    
  </entry>
  
  <entry>
    <title>插件框架</title>
    <link href="https://caojingyou.github.io/2018/04/18/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    <id>https://caojingyou.github.io/2018/04/18/插件框架/</id>
    <published>2018-04-18T06:48:00.000Z</published>
    <updated>2018-07-18T06:02:49.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件框架"><a href="#插件框架" class="headerlink" title="插件框架"></a>插件框架</h1><p><a href="pluma-framework" title="http://pluma-framework.sourceforge.net">pluma-framework</a></p><p><a href="https://www.devbean.net/category/plugin/" title="https://www.devbean.net/category/plugin/" target="_blank" rel="noopener">自己动手写插件框架</a></p><p><a href="http://files.devbean.net/code/plugin.zip" target="_blank" rel="noopener">自己动手写插件框架-源代码</a></p><p><a href="https://github.com/sld666666/cptf" target="_blank" rel="noopener">cpp plugin template framework</a></p><p><a href="https://download.csdn.net/download/zhouxuguang236/7466253" target="_blank" rel="noopener">C++跨平台插件实例</a></p><p><a href="https://github.com/linuxzjh/traditionalDevelopment" target="_blank" rel="noopener">traditionalDevelopment</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-gtkplgin/l-gtkplgin-pdf.pdf" target="_blank" rel="noopener">GTK+中的插件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插件框架&quot;&gt;&lt;a href=&quot;#插件框架&quot; class=&quot;headerlink&quot; title=&quot;插件框架&quot;&gt;&lt;/a&gt;插件框架&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;pluma-framework&quot; title=&quot;http://pluma-framework.source
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="插件框架" scheme="https://caojingyou.github.io/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>CEF</title>
    <link href="https://caojingyou.github.io/2018/04/16/CEF/"/>
    <id>https://caojingyou.github.io/2018/04/16/CEF/</id>
    <published>2018-04-16T01:53:00.000Z</published>
    <updated>2018-06-08T08:18:18.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>主页：<a href="http://opensource.spotify.com/cefbuilds/index.html" target="_blank" rel="noopener">http://opensource.spotify.com/cefbuilds/index.html</a></p><p>CEF 全称是 Chromium Embedded Framework（Chromium 嵌入式框架），它主要目的是开发一个基于 Google Chromium 的 Webbrowser 控件。CEF 支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。</p><p>它的设计思想政治就是易用且兼顾性能。CEF 基本的框架包含 C/C++ 程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和 Chromium &amp; Webkit 的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，JavaScript 对象以及 javascript 扩展，宿主程序可以随意地控件资源下载，导航，下下文内容和打印等，并且可以跟 Google Chrome 浏览器一起，支持高性能和 HTML5 技术。</p><p>CEF3文档：<a href="http://magpcss.org/ceforum/apidocs3/" title="http://magpcss.org/ceforum/apidocs3/" target="_blank" rel="noopener">http://magpcss.org/ceforum/apidocs3/</a></p><p>CEF的典型应用场景包括：</p><pre><code>嵌入一个兼容HTML5的浏览器控件到一个已经存在的本地应用。创建一个轻量化的壳浏览器，用以托管主要用Web技术开发的应用。有些应用有独立的绘制框架，使用CEF对Web内容做离线渲染。使用CEF做自动化Web测试。</code></pre><p>CEF3是基于Chomuim Content API多进程构架的下一代CEF，拥有下列优势：</p><pre><code>改进的性能和稳定性（JavaScript和插件在一个独立的进程内执行）。支持Retina显示器支持WebGL和3D CSS的GPU加速类似WebRTC和语音输入这样的前卫特性。通过DevTools远程调试协议以及ChromeDriver2提供更好的自动化UI测试更快获得当前以及未来的Web特性和标准的能力</code></pre><p>二进制发布包目录结构大致如下:</p><pre><code>[解压目录]  |-include -- 头文件目录  |-Debug   -- 编译好的CEF库，Debug版  |-Release -- 编译好的CEF库，Release版  |-Resources   -- CEF库需要的资源文件  |-libcef_dll  -- CEF的C++包装类库源代码，需要手动编译  |-tests   -- 包含了一些测试工程  |-CMakeLists.txt  --CMake工程文件</code></pre><p>使用CMake生成vs项目</p><h1 id="cefsimple"><a href="#cefsimple" class="headerlink" title="cefsimple"></a>cefsimple</h1><p>cefsimple_win.cc</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#include &lt;windows.h&gt;#include &quot;include/cef_sandbox_win.h&quot;#include &quot;tests/cefsimple/simple_app.h&quot;// When generating projects with CMake the CEF_USE_SANDBOX value will be defined// automatically if using the required compiler version. Pass -DUSE_SANDBOX=OFF// to the CMake command-line to disable use of the sandbox.// Uncomment this line to manually enable sandbox support.// #define CEF_USE_SANDBOX 1#if defined(CEF_USE_SANDBOX)// The cef_sandbox.lib static library is currently built with VS2013. It may not// link successfully with other VS versions.#pragma comment(lib, &quot;cef_sandbox.lib&quot;)#endif// Entry point function for all processes.int APIENTRY wWinMain(HINSTANCE hInstance,                      HINSTANCE hPrevInstance,                      LPTSTR lpCmdLine,                      int nCmdShow) {  UNREFERENCED_PARAMETER(hPrevInstance);  UNREFERENCED_PARAMETER(lpCmdLine);  // Enable High-DPI support on Windows 7 or newer.  CefEnableHighDPISupport();  void* sandbox_info = NULL;#if defined(CEF_USE_SANDBOX)  // Manage the life span of the sandbox information object. This is necessary  // for sandbox support on Windows. See cef_sandbox_win.h for complete details.  CefScopedSandboxInfo scoped_sandbox;  sandbox_info = scoped_sandbox.sandbox_info();#endif  // Provide CEF with command-line arguments.  CefMainArgs main_args(hInstance);  // CEF applications have multiple sub-processes (render, plugin, GPU, etc)  // that share the same executable. This function checks the command-line and,  // if this is a sub-process, executes the appropriate logic.  int exit_code = CefExecuteProcess(main_args, NULL, sandbox_info);  if (exit_code &gt;= 0) {    // The sub-process has completed so return here.    return exit_code;  }  // Specify CEF global settings here.  CefSettings settings;#if !defined(CEF_USE_SANDBOX)  settings.no_sandbox = true;#endif  // SimpleApp implements application-level callbacks for the browser process.  // It will create the first browser instance in OnContextInitialized() after  // CEF has initialized.  CefRefPtr&lt;SimpleApp&gt; app(new SimpleApp);  // Initialize CEF.  CefInitialize(main_args, settings, app.get(), sandbox_info);  // Run the CEF message loop. This will block until CefQuitMessageLoop() is  // called.  CefRunMessageLoop();  // Shut down CEF.  CefShutdown();  return 0;}</code></pre><p>simple_app.h</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#ifndef CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_#define CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_#include &quot;include/cef_app.h&quot;// Implement application-level callbacks for the browser process.class SimpleApp : public CefApp, public CefBrowserProcessHandler { public:  SimpleApp();  // CefApp methods:  virtual CefRefPtr&lt;CefBrowserProcessHandler&gt; GetBrowserProcessHandler()      OVERRIDE {    return this;  }  // CefBrowserProcessHandler methods:  virtual void OnContextInitialized() OVERRIDE; private:  // Include the default reference counting implementation.  IMPLEMENT_REFCOUNTING(SimpleApp);};#endif  // CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_</code></pre><p>simple_app.cc</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#include &quot;tests/cefsimple/simple_app.h&quot;#include &lt;string&gt;#include &quot;include/cef_browser.h&quot;#include &quot;include/cef_command_line.h&quot;#include &quot;include/views/cef_browser_view.h&quot;#include &quot;include/views/cef_window.h&quot;#include &quot;include/wrapper/cef_helpers.h&quot;#include &quot;tests/cefsimple/simple_handler.h&quot;namespace {// When using the Views framework this object provides the delegate// implementation for the CefWindow that hosts the Views-based browser.class SimpleWindowDelegate : public CefWindowDelegate { public:  explicit SimpleWindowDelegate(CefRefPtr&lt;CefBrowserView&gt; browser_view)      : browser_view_(browser_view) {}  void OnWindowCreated(CefRefPtr&lt;CefWindow&gt; window) OVERRIDE {    // Add the browser view and show the window.    window-&gt;AddChildView(browser_view_);    window-&gt;Show();    // Give keyboard focus to the browser view.    browser_view_-&gt;RequestFocus();  }  void OnWindowDestroyed(CefRefPtr&lt;CefWindow&gt; window) OVERRIDE {    browser_view_ = NULL;  }  bool CanClose(CefRefPtr&lt;CefWindow&gt; window) OVERRIDE {    // Allow the window to close if the browser says it&apos;s OK.    CefRefPtr&lt;CefBrowser&gt; browser = browser_view_-&gt;GetBrowser();    if (browser)      return browser-&gt;GetHost()-&gt;TryCloseBrowser();    return true;  } private:  CefRefPtr&lt;CefBrowserView&gt; browser_view_;  IMPLEMENT_REFCOUNTING(SimpleWindowDelegate);  DISALLOW_COPY_AND_ASSIGN(SimpleWindowDelegate);};}  // namespaceSimpleApp::SimpleApp() {}void SimpleApp::OnContextInitialized() {  CEF_REQUIRE_UI_THREAD();  CefRefPtr&lt;CefCommandLine&gt; command_line =      CefCommandLine::GetGlobalCommandLine();#if defined(OS_WIN) || defined(OS_LINUX)  // Create the browser using the Views framework if &quot;--use-views&quot; is specified  // via the command-line. Otherwise, create the browser using the native  // platform framework. The Views framework is currently only supported on  // Windows and Linux.  const bool use_views = command_line-&gt;HasSwitch(&quot;use-views&quot;);#else  const bool use_views = false;#endif  // SimpleHandler implements browser-level callbacks.  CefRefPtr&lt;SimpleHandler&gt; handler(new SimpleHandler(use_views));  // Specify CEF browser settings here.  CefBrowserSettings browser_settings;  std::string url;  // Check if a &quot;--url=&quot; value was provided via the command-line. If so, use  // that instead of the default URL.  url = command_line-&gt;GetSwitchValue(&quot;url&quot;);  if (url.empty())    url = &quot;http://www.google.com&quot;;  if (use_views) {    // Create the BrowserView.    CefRefPtr&lt;CefBrowserView&gt; browser_view = CefBrowserView::CreateBrowserView(        handler, url, browser_settings, NULL, NULL);    // Create the Window. It will show itself after creation.    CefWindow::CreateTopLevelWindow(new SimpleWindowDelegate(browser_view));  } else {    // Information used when creating the native window.    CefWindowInfo window_info;#if defined(OS_WIN)    // On Windows we need to specify certain flags that will be passed to    // CreateWindowEx().    window_info.SetAsPopup(NULL, &quot;cefsimple&quot;);#endif    // Create the first browser window.    CefBrowserHost::CreateBrowser(window_info, handler, url, browser_settings,                                  NULL);  }}</code></pre><p>simple_handler.h</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#ifndef CEF_TESTS_CEFSIMPLE_SIMPLE_HANDLER_H_#define CEF_TESTS_CEFSIMPLE_SIMPLE_HANDLER_H_#include &quot;include/cef_client.h&quot;#include &lt;list&gt;class SimpleHandler : public CefClient,                      public CefDisplayHandler,                      public CefLifeSpanHandler,                      public CefLoadHandler { public:  explicit SimpleHandler(bool use_views);  ~SimpleHandler();  // Provide access to the single global instance of this object.  static SimpleHandler* GetInstance();  // CefClient methods:  virtual CefRefPtr&lt;CefDisplayHandler&gt; GetDisplayHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefLifeSpanHandler&gt; GetLifeSpanHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefLoadHandler&gt; GetLoadHandler() OVERRIDE { return this; }  // CefDisplayHandler methods:  virtual void OnTitleChange(CefRefPtr&lt;CefBrowser&gt; browser,                             const CefString&amp; title) OVERRIDE;  // CefLifeSpanHandler methods:  virtual void OnAfterCreated(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE;  virtual bool DoClose(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE;  virtual void OnBeforeClose(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE;  // CefLoadHandler methods:  virtual void OnLoadError(CefRefPtr&lt;CefBrowser&gt; browser,                           CefRefPtr&lt;CefFrame&gt; frame,                           ErrorCode errorCode,                           const CefString&amp; errorText,                           const CefString&amp; failedUrl) OVERRIDE;  // Request that all existing browser windows close.  void CloseAllBrowsers(bool force_close);  bool IsClosing() const { return is_closing_; } private:  // Platform-specific implementation.  void PlatformTitleChange(CefRefPtr&lt;CefBrowser&gt; browser,                           const CefString&amp; title);  // True if the application is using the Views framework.  const bool use_views_;  // List of existing browser windows. Only accessed on the CEF UI thread.  typedef std::list&lt;CefRefPtr&lt;CefBrowser&gt;&gt; BrowserList;  BrowserList browser_list_;  bool is_closing_;  // Include the default reference counting implementation.  IMPLEMENT_REFCOUNTING(SimpleHandler);};#endif  // CEF_TESTS_CEFSIMPLE_SIMPLE_HANDLER_H_</code></pre><p>simple_handler.cc</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#include &quot;tests/cefsimple/simple_handler.h&quot;#include &lt;sstream&gt;#include &lt;string&gt;#include &quot;include/base/cef_bind.h&quot;#include &quot;include/cef_app.h&quot;#include &quot;include/views/cef_browser_view.h&quot;#include &quot;include/views/cef_window.h&quot;#include &quot;include/wrapper/cef_closure_task.h&quot;#include &quot;include/wrapper/cef_helpers.h&quot;namespace {SimpleHandler* g_instance = NULL;}  // namespaceSimpleHandler::SimpleHandler(bool use_views)    : use_views_(use_views), is_closing_(false) {  DCHECK(!g_instance);  g_instance = this;}SimpleHandler::~SimpleHandler() {  g_instance = NULL;}// staticSimpleHandler* SimpleHandler::GetInstance() {  return g_instance;}void SimpleHandler::OnTitleChange(CefRefPtr&lt;CefBrowser&gt; browser,                                  const CefString&amp; title) {  CEF_REQUIRE_UI_THREAD();  if (use_views_) {    // Set the title of the window using the Views framework.    CefRefPtr&lt;CefBrowserView&gt; browser_view =        CefBrowserView::GetForBrowser(browser);    if (browser_view) {      CefRefPtr&lt;CefWindow&gt; window = browser_view-&gt;GetWindow();      if (window)        window-&gt;SetTitle(title);    }  } else {    // Set the title of the window using platform APIs.    PlatformTitleChange(browser, title);  }}void SimpleHandler::OnAfterCreated(CefRefPtr&lt;CefBrowser&gt; browser) {  CEF_REQUIRE_UI_THREAD();  // Add to the list of existing browsers.  browser_list_.push_back(browser);}bool SimpleHandler::DoClose(CefRefPtr&lt;CefBrowser&gt; browser) {  CEF_REQUIRE_UI_THREAD();  // Closing the main window requires special handling. See the DoClose()  // documentation in the CEF header for a detailed destription of this  // process.  if (browser_list_.size() == 1) {    // Set a flag to indicate that the window close should be allowed.    is_closing_ = true;  }  // Allow the close. For windowed browsers this will result in the OS close  // event being sent.  return false;}void SimpleHandler::OnBeforeClose(CefRefPtr&lt;CefBrowser&gt; browser) {  CEF_REQUIRE_UI_THREAD();  // Remove from the list of existing browsers.  BrowserList::iterator bit = browser_list_.begin();  for (; bit != browser_list_.end(); ++bit) {    if ((*bit)-&gt;IsSame(browser)) {      browser_list_.erase(bit);      break;    }  }  if (browser_list_.empty()) {    // All browser windows have closed. Quit the application message loop.    CefQuitMessageLoop();  }}void SimpleHandler::OnLoadError(CefRefPtr&lt;CefBrowser&gt; browser,                                CefRefPtr&lt;CefFrame&gt; frame,                                ErrorCode errorCode,                                const CefString&amp; errorText,                                const CefString&amp; failedUrl) {  CEF_REQUIRE_UI_THREAD();  // Don&apos;t display an error for downloaded files.  if (errorCode == ERR_ABORTED)    return;  // Display a load error message.  std::stringstream ss;  ss &lt;&lt; &quot;&lt;html&gt;&lt;body bgcolor=\&quot;white\&quot;&gt;&quot;        &quot;&lt;h2&gt;Failed to load URL &quot;     &lt;&lt; std::string(failedUrl) &lt;&lt; &quot; with error &quot; &lt;&lt; std::string(errorText)     &lt;&lt; &quot; (&quot; &lt;&lt; errorCode &lt;&lt; &quot;).&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&quot;;  frame-&gt;LoadString(ss.str(), failedUrl);}void SimpleHandler::CloseAllBrowsers(bool force_close) {  if (!CefCurrentlyOn(TID_UI)) {    // Execute on the UI thread.    CefPostTask(TID_UI, base::Bind(&amp;SimpleHandler::CloseAllBrowsers, this,                                   force_close));    return;  }  if (browser_list_.empty())    return;  BrowserList::const_iterator it = browser_list_.begin();  for (; it != browser_list_.end(); ++it)    (*it)-&gt;GetHost()-&gt;CloseBrowser(force_close);}</code></pre><p>simple_handler_win.cc</p><pre><code>// Copyright (c) 2013 The Chromium Embedded Framework Authors. All rights// reserved. Use of this source code is governed by a BSD-style license that// can be found in the LICENSE file.#include &quot;tests/cefsimple/simple_handler.h&quot;#include &lt;windows.h&gt;#include &lt;string&gt;#include &quot;include/cef_browser.h&quot;void SimpleHandler::PlatformTitleChange(CefRefPtr&lt;CefBrowser&gt; browser,                                        const CefString&amp; title) {  CefWindowHandle hwnd = browser-&gt;GetHost()-&gt;GetWindowHandle();  SetWindowText(hwnd, std::wstring(title).c_str());}</code></pre><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h2 id="C-Wrapper"><a href="#C-Wrapper" class="headerlink" title="C++ Wrapper"></a>C++ Wrapper</h2><p>C++ 封装</p><p>libcef 动态链接库导出 C API 使得使用者不用关心CEF运行库和基础代码。libcef_dll_wrapper 工程把 C API 封装成 C++ API同时包含在客户端应用程序工程中，与cefclient一样，源代码作为CEF二进制发布包的一部份共同发布。C/C++ API的转换层代码是由转换工具自动生成。</p><h2 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h2><p>进程</p><p>CEF3是多进程架构的。”browser”被定义为主进程，负责窗口管理，界面绘制和网络交互。Blink的渲染和Js的执行被放在一个独立的”render” 进程中；除此之外，render进程还负责Js Binding和对Dom节点的访问。 默认的进程模型中，会为每个标签页创建一个新的”render”进程。其他进程按需创建，象管理插件的进程和处理合成加速的进程。</p><p>默认情况下，主应用程序会被多次启动运行各自独立的进程。这是通过传递不同的命令行参数给CefExecuteProcess函数做到的。如果主应用程序很大，加载时间比较长，或者不能在非浏览器进程里使用，则宿主程序可使用独立的可执行文件去运行这些进程。这可以通过配置CefSettings.browser_subprocess_path变量做到。</p><p>CEF3的进程之间可以通过IPC进行通信。”Browser”和”Render”进程可以通过发送异步消息进行双向通信。甚至在Render进程可以注册在Browser进程响应的异步JavaScript API。</p><p>通过设置命令行的”–single-process”，CEF3就可以支持用于调试目的的单进程运行模型。支持的平台为：Windows，Mac OS X 和Linux。</p><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>线程</p><p>在CEF3中，每个进程都会运行多个线程。完整的线程类型表请参照cef_thread_id_t。例如，在browser进程中包含如下主要的线程：</p><pre><code>TID_UI 线程是浏览器的主线程。如果应用程序在调用CefInitialize()时，传递CefSettings.multi_threaded_message_loop=false，这个线程也是应用程序的主线程。TID_IO 线程主要负责处理IPC消息以及网络通信。TID_FILE 线程负责与文件系统交互。</code></pre><p>由于CEF采用多线程架构，有必要使用锁和闭包来保证在多不同线程安全的传递数据。IMPLEMENT_LOCKING定义提供了Lock()和Unlock()方法以及AutoLock对象来保证不同代码块同步访问数据。CefPostTask函数组支持简易的线程间异步消息传递。</p><h2 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h2><p>引用计数</p><p>所有的框架类从CefBase继承，实例指针由CefRefPtr管理，CefRefPtr通过调用AddRef()和Release()方法自动管理引用计数。</p><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>字符串</p><p>CEF为字符串定义了自己的数据结构。下面是这样做的理由：</p><pre><code>libcef包和宿主程序可能使用不同的运行时，对堆管理的方式也不同。所有的对象，包括字符串，需要确保和申请堆内存使用相同的运行时环境。libcef包可以编译为支持不同的字符串类型(UTF8，UTF16以及WIDE)。默认采用的是UTF16，默认字符集可以通过更改cef_string.h文件中的定义，然后重新编译来修改。当使用宽字节集的时候，切记字符的长度由当前使用的平台决定。</code></pre><p>在C++中，通常使用CefString类来管理CEF的字符串。CefString支持与std::string(UTF8)、std::wstring(wide)类型的相互转换。也可以用来包裹一个cef_string_t结构来对其进行赋值。</p><h2 id="Application-Structure"><a href="#Application-Structure" class="headerlink" title="Application Structure"></a>Application Structure</h2><p>应用程序结构</p><p>每个CEF3应用程序都是相同的结构</p><pre><code>提供入口函数，用于初始化CEF、运行子进程执行逻辑或者CEF消息循环。提供CefApp实现，用于处理进程相关的回调。提供CefClient实现，用于处理browser实例相关的回调执行CefBrowserHost::CreateBrowser()创建一个browser实例，使用CefLifeSpanHandler管理browser对象生命周期。</code></pre><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>当执行子进程是，CEF将使用命令行参数指定配置信息，这些命令行参数必须通过CefMainArgs结构体传入到CefExecuteProcess函数。CefMainArgs的定义与平台相关，在Linux、Mac OS X平台下，它接收main函数传入的argc和argv参数值。</p><pre><code>CefMainArgs main_args(argc, argv);</code></pre><p>在Windows平台下，它接收wWinMain函数传入的参数：实例句柄（HINSTANCE），这个实例能够通过函数GetModuleHandle(NULL)获取。</p><pre><code>CefMainArgs main_args(hInstance);</code></pre><h3 id="单一执行体"><a href="#单一执行体" class="headerlink" title="单一执行体"></a>单一执行体</h3><pre><code>int main(int argc, char* argv[]) {  // Structure for passing command-line arguments.  // The definition of this structure is platform-specific.  CefMainArgs main_args(argc, argv);  // Optional implementation of the CefApp interface.  CefRefPtr&lt;MyApp&gt; app(new MyApp);  // Execute the sub-process logic, if any. This will either return immediately for the browser  // process or block until the sub-process should exit.  int exit_code = CefExecuteProcess(main_args, app.get());  if (exit_code &gt;= 0) {    // The sub-process terminated, exit now.    return exit_code;  }  // Populate this structure to customize CEF behavior.  CefSettings settings;  // Initialize CEF in the main process.  CefInitialize(main_args, settings, app.get());  // Run the CEF message loop. This will block until CefQuitMessageLoop() is called.  CefRunMessageLoop();  // Shut down CEF.  CefShutdown();  return 0;}</code></pre><h3 id="独立的子进程执行体"><a href="#独立的子进程执行体" class="headerlink" title="独立的子进程执行体"></a>独立的子进程执行体</h3><p>主程序的入口函数：</p><pre><code>// Program entry-point function.// 程序入口函数int main(int argc, char* argv[]) {  // Structure for passing command-line arguments.  // The definition of this structure is platform-specific.  // 传递命令行参数的结构体。  // 这个结构体的定义与平台相关。  CefMainArgs main_args(argc, argv);  // Optional implementation of the CefApp interface.  // 可选择性地实现CefApp接口  CefRefPtr&lt;MyApp&gt; app(new MyApp);  // Populate this structure to customize CEF behavior.  // 填充这个结构体，用于定制CEF的行为。  CefSettings settings;  // Specify the path for the sub-process executable.  // 指定子进程的执行路径  CefString(&amp;settings.browser_subprocess_path).FromASCII(“/path/to/subprocess”);  // Initialize CEF in the main process.  // 在主进程中初始化CEF   CefInitialize(main_args, settings, app.get());  // Run the CEF message loop. This will block until CefQuitMessageLoop() is called.  // 执行消息循环，此时会堵塞，直到CefQuitMessageLoop()函数被调用。  CefRunMessageLoop();  // Shut down CEF.  // 关闭CEF  CefShutdown();  return 0;}</code></pre><p>子进程程序的入口函数：</p><pre><code>// Program entry-point function.// 程序入口函数int main(int argc, char* argv[]) {  // Structure for passing command-line arguments.  // The definition of this structure is platform-specific.  // 传递命令行参数的结构体。  // 这个结构体的定义与平台相关。  CefMainArgs main_args(argc, argv);  // Optional implementation of the CefApp interface.  // 可选择性地实现CefApp接口  CefRefPtr&lt;MyApp&gt; app(new MyApp);  // Execute the sub-process logic. This will block until the sub-process should exit.  // 执行子进程逻辑，此时会堵塞直到子进程退出。  return CefExecuteProcess(main_args, app.get());}</code></pre><h2 id="集成消息循环"><a href="#集成消息循环" class="headerlink" title="集成消息循环"></a>集成消息循环</h2><p>CEF可以不用它自己提供的消息循环，而与已经存在的程序中消息环境集成在一起，有两种方式可以做到：</p><pre><code>周期性执行CefDoMessageLoopWork()函数，替代调用CefRunMessageLoop()。CefDoMessageLoopWork()的每一次调用，都将执行一次CEF消息循环的单次迭代。需要注意的是，此方法调用次数太少时，CEF消息循环会饿死，将极大的影响browser的性能，调用次数太频繁又将影响CPU使用率。设置CefSettings.multi_threaded_message_loop=true（Windows平台下有效），这个设置项将导致CEF运行browser UI运行在单独的线程上，而不是在主线程上，这种场景下CefDoMessageLoopWork()或者CefRunMessageLoop()都不需要调用，CefInitialze()、CefShutdown()仍然在主线程中调用。你需要提供主程序线程通信的机制（查看cefclient_win.cpp中提供的消息窗口实例）。在Windows平台下，你可以通过命令行参数“--multi-threaded-message-loop”测试上述消息模型。</code></pre><h2 id="CefBrowser-and-CefFrame"><a href="#CefBrowser-and-CefFrame" class="headerlink" title="CefBrowser and CefFrame"></a>CefBrowser and CefFrame</h2><p>CefBrowser和CefFrame对象被用来发送命令给浏览器以及在回调函数里获取状态信息。每个CefBrowser对象包含一个主CefFrame对象，主CefFrame对象代表页面的顶层frame；同时每个CefBrowser对象可以包含零个或多个的CefFrame对象，分别代表不同的子Frame。例如，一个浏览器加载了两个iframe，则该CefBrowser对象拥有三个CefFrame对象（顶层frame和两个iframe）。</p><p>下面的代码在浏览器的主frame里加载一个URL：</p><pre><code>browser-&gt;GetMainFrame()-&gt;LoadURL(some_url);</code></pre><p>下面的代码执行浏览器的回退操作：</p><pre><code>browser-&gt;GoBack();</code></pre><p>下面的代码从主frame里获取HTML内容：</p><pre><code>// Implementation of the CefStringVisitor interface.class Visitor : public CefStringVisitor { public:  Visitor() {}  // Called asynchronously when the HTML contents are available.  virtual void Visit(const CefString&amp; string) OVERRIDE {    // Do something with |string|...  }  IMPLEMENT_REFCOUNTING(Visitor);};browser-&gt;GetMainFrame()-&gt;GetSource(new Visitor());</code></pre><p>CefBrowser和CefFrame对象在Browser进程和Render进程都有对等的代理对象。在Browser进程里，Host（宿主）行为控制可以通过CefBrowser::GetHost()方法控制。例如，浏览器窗口的原生句柄可以用下面的代码获取：</p><pre><code>// CefWindowHandle is defined as HWND on Windows, NSView* on Mac OS X// and GtkWidget* on Linux.CefWindowHandle window_handle = browser-&gt;GetHost()-&gt;GetWindowHandle();</code></pre><h2 id="CefApp"><a href="#CefApp" class="headerlink" title="CefApp"></a>CefApp</h2><p>CefApp接口提供了不同进程的可定制回调函数。重要的回调函数如下:</p><pre><code>OnBeforeCommandLineProcessing 提供了以编程方式设置命令行参数的机会，更多细节，请参考Command Line Arguments一节。OnRegisterCustomSchemes 提供了注册自定义schemes的机会，更多细节，请参考Request Handling一节。GetBrowserProcessHandler 返回定制Browser进程的Handler，该Handler包括了诸如OnContextInitialized的回调。GetRenderProcessHandler 返回定制Render进程的Handler，该Handler包含了JavaScript相关的一些回调以及消息处理的回调。更多细节，请参考JavascriptIntegration和Inter-Process Communication两节。</code></pre><p>CefApp子类的例子：</p><pre><code>// MyApp implements CefApp and the process-specific interfaces.class MyApp : public CefApp,              public CefBrowserProcessHandler,              public CefRenderProcessHandler { public:  MyApp() {}  // CefApp methods. Important to return |this| for the handler callbacks.  virtual void OnBeforeCommandLineProcessing(      const CefString&amp; process_type,      CefRefPtr&lt;CefCommandLine&gt; command_line) {    // Programmatically configure command-line arguments...  }  virtual void OnRegisterCustomSchemes(      CefRefPtr&lt;CefSchemeRegistrar&gt; registrar) OVERRIDE {    // Register custom schemes...  }  virtual CefRefPtr&lt;CefBrowserProcessHandler&gt; GetBrowserProcessHandler()      OVERRIDE { return this; }  virtual CefRefPtr&lt;CefRenderProcessHandler&gt; GetRenderProcessHandler()      OVERRIDE { return this; }  // CefBrowserProcessHandler methods.  virtual void OnContextInitialized() OVERRIDE {    // The browser process UI thread has been initialized...  }  virtual void OnRenderProcessThreadCreated(CefRefPtr&lt;CefListValue&gt; extra_info)                                            OVERRIDE {    // Send startup information to a new render process...  }  // CefRenderProcessHandler methods.  virtual void OnRenderThreadCreated(CefRefPtr&lt;CefListValue&gt; extra_info)                                     OVERRIDE {    // The render process main thread has been initialized...    // Receive startup information in the new render process...  }  virtual void OnWebKitInitialized(CefRefPtr&lt;ClientApp&gt; app) OVERRIDE {    // WebKit has been initialized, register V8 extensions...  }  virtual void OnBrowserCreated(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE {    // Browser created in this render process...  }  virtual void OnBrowserDestroyed(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE {    // Browser destroyed in this render process...  }  virtual bool OnBeforeNavigation(CefRefPtr&lt;CefBrowser&gt; browser,                                  CefRefPtr&lt;CefFrame&gt; frame,                                  CefRefPtr&lt;CefRequest&gt; request,                                  NavigationType navigation_type,                                  bool is_redirect) OVERRIDE {    // Allow or block different types of navigation...  }  virtual void OnContextCreated(CefRefPtr&lt;CefBrowser&gt; browser,                                CefRefPtr&lt;CefFrame&gt; frame,                                CefRefPtr&lt;CefV8Context&gt; context) OVERRIDE {    // JavaScript context created, add V8 bindings here...  }  virtual void OnContextReleased(CefRefPtr&lt;CefBrowser&gt; browser,                                 CefRefPtr&lt;CefFrame&gt; frame,                                 CefRefPtr&lt;CefV8Context&gt; context) OVERRIDE {    // JavaScript context released, release V8 references here...  }  virtual bool OnProcessMessageReceived(      CefRefPtr&lt;CefBrowser&gt; browser,      CefProcessId source_process,      CefRefPtr&lt;CefProcessMessage&gt; message) OVERRIDE {    // Handle IPC messages from the browser process...  }  IMPLEMENT_REFCOUNTING(MyApp);};</code></pre><h2 id="CefClient"><a href="#CefClient" class="headerlink" title="CefClient"></a>CefClient</h2><p>CefClient提供访问browser-instance-specific的回调接口。单实例CefClient可以共数任意数量的浏览器进程。以下为几个重要的回调：</p><pre><code>比如处理browser的生命周期，右键菜单，对话框，通知显示， 拖曳事件，焦点事件，键盘事件等等。如果没有对某个特定的处理接口进行实现会造成什么影响，请查看cef_client.h文件中相关说明。</code></pre><p>CefClient子类的例子：</p><pre><code>// MyHandler implements CefClient and a number of other interfaces.class MyHandler : public CefClient,                  public CefContextMenuHandler,                  public CefDisplayHandler,                  public CefDownloadHandler,                  public CefDragHandler,                  public CefGeolocationHandler,                  public CefKeyboardHandler,                  public CefLifeSpanHandler,                  public CefLoadHandler,                  public CefRequestHandler { public:  MyHandler();  // CefClient methods. Important to return |this| for the handler callbacks.  virtual CefRefPtr&lt;CefContextMenuHandler&gt; GetContextMenuHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefDisplayHandler&gt; GetDisplayHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefDownloadHandler&gt; GetDownloadHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefDragHandler&gt; GetDragHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefGeolocationHandler&gt; GetGeolocationHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefKeyboardHandler&gt; GetKeyboardHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefLifeSpanHandler&gt; GetLifeSpanHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefLoadHandler&gt; GetLoadHandler() OVERRIDE {    return this;  }  virtual CefRefPtr&lt;CefRequestHandler&gt; GetRequestHandler() OVERRIDE {    return this;  }  virtual bool OnProcessMessageReceived(CefRefPtr&lt;CefBrowser&gt; browser,                                        CefProcessId source_process,                                        CefRefPtr&lt;CefProcessMessage&gt; message)                                        OVERRIDE {    // Handle IPC messages from the render process...  }  // CefContextMenuHandler methods  virtual void OnBeforeContextMenu(CefRefPtr&lt;CefBrowser&gt; browser,                                   CefRefPtr&lt;CefFrame&gt; frame,                                   CefRefPtr&lt;CefContextMenuParams&gt; params,                                   CefRefPtr&lt;CefMenuModel&gt; model) OVERRIDE {    // Customize the context menu...  }  virtual bool OnContextMenuCommand(CefRefPtr&lt;CefBrowser&gt; browser,                                    CefRefPtr&lt;CefFrame&gt; frame,                                    CefRefPtr&lt;CefContextMenuParams&gt; params,                                    int command_id,                                    EventFlags event_flags) OVERRIDE {    // Handle a context menu command...  }  // CefDisplayHandler methods  virtual void OnLoadingStateChange(CefRefPtr&lt;CefBrowser&gt; browser,                                    bool isLoading,                                    bool canGoBack,                                    bool canGoForward) OVERRIDE {    // Update UI for browser state...  }  virtual void OnAddressChange(CefRefPtr&lt;CefBrowser&gt; browser,                               CefRefPtr&lt;CefFrame&gt; frame,                               const CefString&amp; url) OVERRIDE {    // Update the URL in the address bar...  }  virtual void OnTitleChange(CefRefPtr&lt;CefBrowser&gt; browser,                             const CefString&amp; title) OVERRIDE {    // Update the browser window title...  }  virtual bool OnConsoleMessage(CefRefPtr&lt;CefBrowser&gt; browser,                                const CefString&amp; message,                                const CefString&amp; source,                                int line) OVERRIDE {    // Log a console message...  }  // CefDownloadHandler methods  virtual void OnBeforeDownload(      CefRefPtr&lt;CefBrowser&gt; browser,      CefRefPtr&lt;CefDownloadItem&gt; download_item,      const CefString&amp; suggested_name,      CefRefPtr&lt;CefBeforeDownloadCallback&gt; callback) OVERRIDE {    // Specify a file path or cancel the download...  }  virtual void OnDownloadUpdated(      CefRefPtr&lt;CefBrowser&gt; browser,      CefRefPtr&lt;CefDownloadItem&gt; download_item,      CefRefPtr&lt;CefDownloadItemCallback&gt; callback) OVERRIDE {    // Update the download status...  }  // CefDragHandler methods  virtual bool OnDragEnter(CefRefPtr&lt;CefBrowser&gt; browser,                           CefRefPtr&lt;CefDragData&gt; dragData,                           DragOperationsMask mask) OVERRIDE {    // Allow or deny drag events...  }  // CefGeolocationHandler methods  virtual void OnRequestGeolocationPermission(      CefRefPtr&lt;CefBrowser&gt; browser,      const CefString&amp; requesting_url,      int request_id,      CefRefPtr&lt;CefGeolocationCallback&gt; callback) OVERRIDE {    // Allow or deny geolocation API access...  }  // CefKeyboardHandler methods  virtual bool OnPreKeyEvent(CefRefPtr&lt;CefBrowser&gt; browser,                             const CefKeyEvent&amp; event,                             CefEventHandle os_event,                             bool* is_keyboard_shortcut) OVERRIDE {    // Perform custom handling of key events...  }  // CefLifeSpanHandler methods  virtual bool OnBeforePopup(CefRefPtr&lt;CefBrowser&gt; browser,                             CefRefPtr&lt;CefFrame&gt; frame,                             const CefString&amp; target_url,                             const CefString&amp; target_frame_name,                             const CefPopupFeatures&amp; popupFeatures,                             CefWindowInfo&amp; windowInfo,                             CefRefPtr&lt;CefClient&gt;&amp; client,                             CefBrowserSettings&amp; settings,                             bool* no_javascript_access) OVERRIDE {    // Allow or block popup windows, customize popup window creation...  }  virtual void OnAfterCreated(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE {    // Browser window created successfully...  }  virtual bool DoClose(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE {    // Allow or block browser window close...  }  virtual void OnBeforeClose(CefRefPtr&lt;CefBrowser&gt; browser) OVERRIDE {    // Browser window is closed, perform cleanup...  }  // CefLoadHandler methods  virtual void OnLoadStart(CefRefPtr&lt;CefBrowser&gt; browser,                           CefRefPtr&lt;CefFrame&gt; frame) OVERRIDE {    // A frame has started loading content...  }  virtual void OnLoadEnd(CefRefPtr&lt;CefBrowser&gt; browser,                         CefRefPtr&lt;CefFrame&gt; frame,                         int httpStatusCode) OVERRIDE {    // A frame has finished loading content...  }  virtual void OnLoadError(CefRefPtr&lt;CefBrowser&gt; browser,                           CefRefPtr&lt;CefFrame&gt; frame,                           ErrorCode errorCode,                           const CefString&amp; errorText,                           const CefString&amp; failedUrl) OVERRIDE {    // A frame has failed to load content...  }  virtual void OnRenderProcessTerminated(CefRefPtr&lt;CefBrowser&gt; browser,                                         TerminationStatus status) OVERRIDE {    // A render process has crashed...  }  // CefRequestHandler methods  virtual CefRefPtr&lt;CefResourceHandler&gt; GetResourceHandler(      CefRefPtr&lt;CefBrowser&gt; browser,      CefRefPtr&lt;CefFrame&gt; frame,      CefRefPtr&lt;CefRequest&gt; request) OVERRIDE {    // Optionally intercept resource requests...  }  virtual bool OnQuotaRequest(CefRefPtr&lt;CefBrowser&gt; browser,                              const CefString&amp; origin_url,                              int64 new_size,                              CefRefPtr&lt;CefQuotaCallback&gt; callback) OVERRIDE {    // Allow or block quota requests...  }  virtual void OnProtocolExecution(CefRefPtr&lt;CefBrowser&gt; browser,                                   const CefString&amp; url,                                   bool&amp; allow_os_execution) OVERRIDE {    // Handle execution of external protocols...  }  IMPLEMENT_REFCOUNTING(MyHandler);};</code></pre><h1 id="JavaScript和Cpp交互示例"><a href="#JavaScript和Cpp交互示例" class="headerlink" title="JavaScript和Cpp交互示例"></a><a href="https://github.com/fanfeilong/cefutil/blob/master/doc/CEF_JavaScript_Cpp.md" target="_blank" rel="noopener">JavaScript和Cpp交互示例</a></h1><p>一个CEF应用程序也可以提供自己的异步JavaScript绑定。</p><p>此处演示：</p><ul><li>JavaScript注册函数给Render进程，Render进程保存该JavaScript函数</li><li>Render进程发消息通知Browser进程</li><li>Browser进程处理后，回发消息给Render进程</li><li>Render进程调用之前保存的JavaScript函数</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>首先在CefRenderProcessHandler的子类里覆写虚方法OnWebKitInitialized，并在该方法的实现里注册一个C++方法给JavaScript</li></ol><pre><code>//假设CefRenderProcessHandler的子类为CefRenderProcessHandlerImplvoid CefRenderProcessHandlerImpl::OnWebKitInitialized(){    std::string app_code =    //-----------------------------------    //声明JavaScript里要调用的Cpp方法    &quot;var app;&quot;    &quot;if (!app)&quot;    &quot;  app = {};&quot;    &quot;(function() {&quot;    //  Send message     &quot;  app.sendMessage = function(name, arguments) {&quot;    &quot;    native function sendMessage();&quot;    &quot;    return sendMessage(name, arguments);&quot;    &quot;  };&quot;    // Registered Javascript Function, which will be called by Cpp    &quot;  app.registerJavascriptFunction = function(name,callback) {&quot;    &quot;    native function registerJavascriptFunction();&quot;    &quot;    return registerJavascriptFunction(name,callback);&quot;    &quot;  };&quot;    &quot;})();&quot;;    //------------------------------------    // Register app extension module    // JavaScript里调用app.registerJavascriptFunction时，就会去通过CefRegisterExtension注册的CefV8Handler列表里查找    // 找到&quot;v8/app&quot;对应的CefV8HandlerImpl，就调用它的Execute方法    // 假设m_v8Handler是CefRenderProcessHandlerImpl的一个成员变量    m_v8Handler = new CefV8HandlerImpl();    CefRegisterExtension(&quot;v8/app&quot;, app_code,m_v8Handler);}</code></pre><ol><li><p>在CefV8Handler的子类的Execute方法里实现sendMessage和registerJavascriptFunction</p><pre><code>// in CefV8HandlerImpl.hclass CefV8HandlerImpl : publice CefV8Handler{public:    CefV8HandlerImpl();    ~CefV8HandlerImpl();public:    /**     *    CefV8Handler Methods, Which will be called when the V8 extension      *  is called in the Javascript environment     */    virtual bool Execute(const CefString&amp; name        ,CefRefPtr&lt;CefV8Value&gt; object        ,const CefV8ValueList&amp; arguments        ,CefRefPtr&lt;CefV8Value&gt;&amp; retval        ,CefString&amp; exception);private:    // Map of message callbacks.typedef std::map&lt;std::pair&lt;std::string, int&gt;,                 std::pair&lt;CefRefPtr&lt;CefV8Context&gt;, CefRefPtr&lt;CefV8Value&gt; &gt; &gt;                 CallbackMap;CallbackMap callback_map_;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>CefV8HandlerImpl::CefV8HandlerImpl(){}CefV8HandlerImpl::~CefV8HandlerImpl(){  // Remove any JavaScript callbacks registered for the context that has been released.  if (!callback_map_.empty()) {    CallbackMap::iterator it = callback_map_.begin();    for (; it != callback_map_.end();) {      if (it-&gt;second.first-&gt;IsSame(context))        callback_map_.erase(it++);      else        ++it;    }  }}// in CefV8HandlerImpl.cppbool CefV8HandlerImpl::Execute(const CefString&amp; name  //JavaScript调用的C++方法名字        ,CefRefPtr&lt;CefV8Value&gt; object                 //JavaScript调用者对象        ,const CefV8ValueList&amp; arguments              //JavaScript传递的参数        ,CefRefPtr&lt;CefV8Value&gt;&amp; retval                //需要返回给JavaScript的值设置给这个对象        ,CefString&amp; exception)                        //通知异常信息给JavaScript{    // In the CefV8Handler::Execute implementation for “registerJavascriptFunction”.    bool handle=false;    if(name==&quot;registerJavascriptFunction&quot;){        //保存JavaScript设置的回答函数        if (arguments.size() == 2 &amp;&amp; arguments[0]-&gt;IsString() &amp;&amp;            arguments[1]-&gt;IsFunction()) {          std::string message_name = arguments[0]-&gt;GetStringValue();          CefRefPtr&lt;CefV8Context&gt; context = CefV8Context::GetCurrentContext();          int browser_id = context-&gt;GetBrowser()-&gt;GetIdentifier();          callback_map_.insert(              std::make_pair(std::make_pair(message_name, browser_id),                             std::make_pair(context, arguments[1])));        handle = true;        // 此时可以发送一个信息给Browser进程，见第4个步骤    }    if(name==&quot;sendMessage&quot;){        //处理SendMessage，        handle = true;    }    // 如果没有处理，则发异常信息给js    if(!handle){        exception=&quot;not implement function&quot;;    }    return true;}</code></pre></li><li><p>在HTML的JavaScript里，通过上面注册的方法向Render进程注册一个回调函数。</p></li></ol><pre><code>// In JavaScript register the callback function.app.setMessageCallback(&apos;binding_test&apos;, function(name, args) {  document.getElementById(&apos;result&apos;).value = &quot;Response: &quot;+args[0];});</code></pre><ol><li>Render进程发送异步进程间通信到Browser进程。</li><li>Browser进程接收到进程间消息，并处理。</li><li>Browser进程处理完毕后，发送一个异步进程间消息给Render进程，返回结果。</li><li><p>Render进程接收到进程间消息，则调用最开始保存的JavaScript注册的回调函数处理之。</p><pre><code>// Execute the registered JavaScript callback if any.if (!callback_map_.empty()) {  const CefString&amp; message_name = message-&gt;GetName();  CallbackMap::const_iterator it = callback_map_.find(      std::make_pair(message_name.ToString(),                     browser-&gt;GetIdentifier()));  if (it != callback_map_.end()) {    // Keep a local reference to the objects. The callback may remove itself    // from the callback map.    CefRefPtr&lt;CefV8Context&gt; context = it-&gt;second.first;    CefRefPtr&lt;CefV8Value&gt; callback = it-&gt;second.second;    // Enter the context.    context-&gt;Enter();    CefV8ValueList arguments;    // First argument is the message name.    arguments.push_back(CefV8Value::CreateString(message_name));    // Second argument is the list of message arguments.    CefRefPtr&lt;CefListValue&gt; list = message-&gt;GetArgumentList();    CefRefPtr&lt;CefV8Value&gt; args = CefV8Value::CreateArray(list-&gt;GetSize());    SetList(list, args);  // Helper function to convert CefListValue to CefV8Value.    arguments.push_back(args);    // Execute the callback.    CefRefPtr&lt;CefV8Value&gt; retval = callback-&gt;ExecuteFunction(NULL, arguments);    if (retval.get()) {      if (retval-&gt;IsBool())        handled = retval-&gt;GetBoolValue();    }    // Exit the context.    context-&gt;Exit();  }}</code></pre></li><li><p>在CefRenderProcessHandlerImpl::OnContextReleased()里释放JavaScript注册的回调函数以及其他V8资源。</p></li></ol><pre><code>void CefRenderProcessHandlerImpl::OnContextReleased(CefRefPtr&lt;CefBrowser&gt; browser,                                  CefRefPtr&lt;CefFrame&gt; frame,                                  CefRefPtr&lt;CefV8Context&gt; context) {    if(m_v8Handler-&gt;Get()){        m_v8Handler-&gt;Release();    }}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://github.com/fanfeilong/cefutil" title="https://github.com/fanfeilong/cefutil" target="_blank" rel="noopener">https://github.com/fanfeilong/cefutil</a></p><p><a href="https://github.com/fanfeilong/cefutil/blob/master/doc/CEF%20General%20Usage.md" title="CEF General Usage(CEF3预览)" target="_blank" rel="noopener">CEF General Usage(CEF3预览)</a></p><p><a href="https://github.com/fanfeilong/cefutil/blob/master/doc/CEF_JavaScript_Cpp.md" target="_blank" rel="noopener">JavaScript和Cpp交互示例</a></p><p><a href="https://github.com/karllen/cef3-duilib-YDDemo" target="_blank" rel="noopener">https://github.com/karllen/cef3-duilib-YDDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;主页：&lt;a href=&quot;http://opensource.spotify.com/cefbuilds/index.html&quot; target
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="CEF" scheme="https://caojingyou.github.io/tags/CEF/"/>
    
  </entry>
  
  <entry>
    <title>ATL与WTL</title>
    <link href="https://caojingyou.github.io/2018/04/12/ATL%E4%B8%8EWTL/"/>
    <id>https://caojingyou.github.io/2018/04/12/ATL与WTL/</id>
    <published>2018-04-12T01:53:00.000Z</published>
    <updated>2018-08-21T09:56:05.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATL"><a href="#ATL" class="headerlink" title="ATL"></a>ATL</h1><p>ATL中所使用的基本技术包括以下几个方面：</p><ul><li>COM技术</li><li>C++模板类技术（Template)</li><li>C++多继承技术（Multi-Inheritance)</li></ul><p><a href="https://msdn.microsoft.com/zh-cn/library/hh967573.aspx" target="_blank" rel="noopener">MFC 和 ATL</a></p><h1 id="WTL"><a href="#WTL" class="headerlink" title="WTL"></a>WTL</h1><p><a href="https://sourceforge.net/projects/wtl/" target="_blank" rel="noopener">https://sourceforge.net/projects/wtl/</a></p><p>安装WTL向导</p><p>AppWizard目录执行</p><pre><code>wscript Setup.js</code></pre><p><a href="https://sourceforge.net/projects/visualfc/" title="https://sourceforge.net/projects/visualfc/" target="_blank" rel="noopener">visualfc</a></p><p><a href="http://www.winmsg.com/cn/orbit.htm" title="http://www.winmsg.com/cn/orbit.htm" target="_blank" rel="noopener">WTL for MFC programmer 系列文章(翻译)</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="添加按钮事件"><a href="#添加按钮事件" class="headerlink" title="添加按钮事件"></a>添加按钮事件</h3><p>对话框中添加button，id为IDC_BUTTON1</p><pre><code>BEGIN_MSG_MAP(xx)    COMMAND_ID_HANDLER(IDC_BUTTON1, OnButton1)END_MSG_MAP()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ATL&quot;&gt;&lt;a href=&quot;#ATL&quot; class=&quot;headerlink&quot; title=&quot;ATL&quot;&gt;&lt;/a&gt;ATL&lt;/h1&gt;&lt;p&gt;ATL中所使用的基本技术包括以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COM技术&lt;/li&gt;
&lt;li&gt;C++模板类技术（Templat
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="c++" scheme="https://caojingyou.github.io/tags/c/"/>
    
      <category term="ATL" scheme="https://caojingyou.github.io/tags/ATL/"/>
    
      <category term="WTL" scheme="https://caojingyou.github.io/tags/WTL/"/>
    
  </entry>
  
  <entry>
    <title>duilib</title>
    <link href="https://caojingyou.github.io/2018/04/12/duilib/"/>
    <id>https://caojingyou.github.io/2018/04/12/duilib/</id>
    <published>2018-04-12T01:53:00.000Z</published>
    <updated>2018-06-08T06:16:37.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="duilib"><a href="#duilib" class="headerlink" title="duilib"></a>duilib</h1><p><a href="https://github.com/duilib/duilib" target="_blank" rel="noopener">https://github.com/duilib/duilib</a></p><h2 id="设计器："><a href="#设计器：" class="headerlink" title="设计器："></a>设计器：</h2><p>DuiDesigner</p><h2 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h2><p><a href="http://www.cnblogs.com/Alberl/p/3354459.html" target="_blank" rel="noopener">2013 duilib入门简明教程</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>直接打开DuiLib.sln</p><p>提取DuiLib生成的dll与lib文件以及DuiLib目录。</p><h1 id="Win32DuiLibTest"><a href="#Win32DuiLibTest" class="headerlink" title="Win32DuiLibTest"></a>Win32DuiLibTest</h1><pre><code>#pragma once#include &lt;UIlib.h&gt;using namespace DuiLib;#ifdef _DEBUG#   ifdef _UNICODE#       pragma comment(lib, &quot;DuiLib_ud.lib&quot;)#   else#       pragma comment(lib, &quot;DuiLib_d.lib&quot;)#   endif#else#   ifdef _UNICODE#       pragma comment(lib, &quot;DuiLib_u.lib&quot;)#   else#       pragma comment(lib, &quot;DuiLib.lib&quot;)#   endif#endifclass CDuiFrameWnd : public CWindowWnd, public INotifyUI{public:    virtual LPCTSTR GetWindowClassName() const { return _T(&quot;DUIMainFrame&quot;); }    virtual void    Notify(TNotifyUI&amp; msg)    {        if (msg.sType == _T(&quot;click&quot;))        {            if (msg.pSender-&gt;GetName() == _T(&quot;btnHello&quot;))            {                ::MessageBox(NULL, _T(&quot;我是按钮&quot;), _T(&quot;点击了按钮&quot;), NULL);            }        }    }    virtual LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)    {        LRESULT lRes = 0;        if (uMsg == WM_CREATE)        {            m_PaintManager.Init(m_hWnd);            //CControlUI *pWnd = new CButtonUI;            //pWnd-&gt;SetName(_T(&quot;btnHello&quot;));            //pWnd-&gt;SetText(_T(&quot;Hello World&quot;));   // 设置文字            //pWnd-&gt;SetBkColor(0xFF00FF00);       // 设置背景色            //m_PaintManager.AttachDialog(pWnd);            CDialogBuilder builder;            CControlUI* pRoot = builder.Create(_T(&quot;duilib.xml&quot;), (UINT)0, NULL, &amp;m_PaintManager);   // duilib.xml需要放到exe目录下            ASSERT(pRoot &amp;&amp; &quot;Failed to parse XML&quot;);            m_PaintManager.AttachDialog(pRoot);            m_PaintManager.AddNotifier(this);   // 添加控件等消息响应，这样消息就会传达到duilib的消息循环，我们可以在Notify函数里做消息处理            return lRes;        }        // 以下3个消息WM_NCACTIVATE、WM_NCCALCSIZE、WM_NCPAINT用于屏蔽系统标题栏        else if (uMsg == WM_NCACTIVATE)        {            if (!::IsIconic(m_hWnd))            {                return (wParam == 0) ? TRUE : FALSE;            }        }        else if (uMsg == WM_NCCALCSIZE)        {            return 0;        }        else if (uMsg == WM_NCPAINT)        {            return 0;        }        if (m_PaintManager.MessageHandler(uMsg, wParam, lParam, lRes))        {            return lRes;        }        return __super::HandleMessage(uMsg, wParam, lParam);    }protected:    CPaintManagerUI m_PaintManager;};class CDuiFrameWndBase : public WindowImplBase{public:    virtual LPCTSTR    GetWindowClassName() const   { return _T(&quot;DUIMainFrame&quot;); }    virtual CDuiString GetSkinFile()                { return _T(&quot;duilib.xml&quot;); }    virtual CDuiString GetSkinFolder()              { return _T(&quot;&quot;); }};int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow){    CPaintManagerUI::SetInstance(hInstance);    CPaintManagerUI::SetResourcePath(CPaintManagerUI::GetInstancePath());   // 设置资源的默认路径（此处设置为和exe在同一目录）    CDuiFrameWndBase/*CDuiFrameWnd*/ duiFrame;    duiFrame.Create(NULL, _T(&quot;DUIWnd&quot;), UI_WNDSTYLE_FRAME, WS_EX_WINDOWEDGE);    duiFrame.CenterWindow();    duiFrame.ShowModal();    return 0;}</code></pre><h1 id="在MFC中使用duilib"><a href="#在MFC中使用duilib" class="headerlink" title="在MFC中使用duilib"></a>在MFC中使用duilib</h1><p>只需要将前面教程的CDuiFrameWnd的父窗口指定为MFC的窗口就好啦，将CDuiFrameWnd m_duiFrame; 定义为MFC的成员变量，在MFC的初始化函数OnInitDialog里面创建duilib的窗口，代码如下：</p><pre><code>// TODO: 在此添加额外的初始化代码CPaintManagerUI::SetInstance(AfxGetInstanceHandle());                    // 指定duilib的实例CPaintManagerUI::SetResourcePath(CPaintManagerUI::GetInstancePath());    // 指定duilib资源的路径，这里指定为和exe同目录::CoInitialize(NULL);  // 记得释放::CoUninitialize();m_duiFrame.Create(*this, _T(&quot;DUIWnd&quot;), UI_WNDSTYLE_CHILD, 0, 0, 0, 800, 600); m_duiFrame.ShowWindow(TRUE); return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE</code></pre><p>duilib中的例子：<br>    CDuiFrameWnd m_dlgWnd;<br>    this-&gt;MoveWindow(0, 0, 800, 572);<br>    ::SetWindowLongPtr(this-&gt;GetSafeHwnd(), GWLP_USERDATA, reinterpret_cast<lparam>(&amp;m_dlgWnd));<br>    m_dlgWnd.Subclass(this-&gt;GetSafeHwnd());<br>    m_dlgWnd.LoadSkin()</lparam></p><h1 id="在duilib中使用MFC控件"><a href="#在duilib中使用MFC控件" class="headerlink" title="在duilib中使用MFC控件"></a>在duilib中使用MFC控件</h1><p>准备好一个duilib控件来容纳MFC控件</p><pre><code>// 将带句柄HWND的控件显示到CControlUI上面class CWndUI: public CControlUI{public:    CWndUI(): m_hWnd(NULL){}    virtual void SetInternVisible(bool bVisible = true)    {        __super::SetInternVisible(bVisible);        ::ShowWindow(m_hWnd, bVisible);    }    virtual void SetPos(RECT rc)    {        __super::SetPos(rc);        ::SetWindowPos(m_hWnd, NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE);    }    BOOL Attach(HWND hWndNew)    {        if (! ::IsWindow(hWndNew))        {            return FALSE;        }        m_hWnd = hWndNew;        return TRUE;    }    HWND Detach()    {        HWND hWnd = m_hWnd;        m_hWnd = NULL;        return hWnd;    }protected:    HWND m_hWnd;};</code></pre><p>将XML中Slider节点换成Wnd，并且只保留位置信息</p><pre><code>&lt;Wnd float=&quot;true&quot; pos=&quot;30,77,0,0&quot; width=&quot;139&quot; height=&quot;18&quot; /&gt;</code></pre><p>创建Wnd控件：由于Slider是duilib内置的控件，所以duilib会根据XML信息自动创建Slider控件，而CWndUI是我们自定义的控件，所以需要自己创建，只需要响应CreateControl函数（如果duilib发现自定义控件，会自动调用此函数来获取控件），在CDuiFrameWnd加上如下函数</p><pre><code>virtual CControlUI* CreateControl(LPCTSTR pstrClassName){    if (_tcsicmp(pstrClassName, _T(&quot;Wnd&quot;)) == 0)    {        CWndUI  *pUI  = new CWndUI;                    HWND    hWnd  = CreateWindow(_T(&quot;BUTTON&quot;), _T(&quot;win32&quot;), WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, 0, 0, 0, 0, m_PaintManager.GetPaintWindow(), NULL, NULL, NULL);        pUI-&gt;Attach(hWnd);          //// 上面用的是win32的按钮，下面这段用MFC的按钮        //CButton *pBtn = new CButton;    // 记得释放内存        //pBtn-&gt;Create(_T(&quot;MFC&quot;), WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, CRect(0, 0, 0, 0), CWnd::FromHandle(m_PaintManager.GetPaintWindow()), 0);        //pUI-&gt;Attach(*pBtn);                    return pUI;    }    return NULL;}</code></pre><h1 id="复杂控件"><a href="#复杂控件" class="headerlink" title="复杂控件"></a>复杂控件</h1><p><a href="http://www.cnblogs.com/Alberl/p/3345102.html" target="_blank" rel="noopener">http://www.cnblogs.com/Alberl/p/3345102.html</a>或直接看DuiLib中提供的例子。</p><h1 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h1><p>duilib参考了MFC、ATL/WTL的消息机制，都有消息映射</p><h1 id="XML属性列表"><a href="#XML属性列表" class="headerlink" title="XML属性列表"></a>XML属性列表</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 可能有错漏，欢迎补充。wangchyz(wangchyz@gmail.com) --&gt;&lt;Controls&gt;    &lt;Window parent=&quot;&quot;&gt;        &lt;Attribute name=&quot;size&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;窗口的初始化大小,如(800,600)&quot;/&gt;        &lt;Attribute name=&quot;sizebox&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;窗口可拖动改变窗口大小的边距,如(4,4,6,6)&quot;/&gt;        &lt;Attribute name=&quot;caption&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;窗口可拖动的标题栏大小的边距,最后一个参数是指离上边框的距离,如(0,0,0,28)&quot;/&gt;        &lt;Attribute name=&quot;roundcorner&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;窗口圆角大小,如(4,4)&quot;/&gt;        &lt;Attribute name=&quot;mininfo&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;窗口最小大小,如(320,240)&quot;/&gt;        &lt;Attribute name=&quot;maxinfo&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;窗口最大大小,如(1600,1200)&quot;/&gt;        &lt;Attribute name=&quot;alpha&quot; default=&quot;255&quot; type=&quot;BYTE&quot; comment=&quot;窗口的alpha值(0-255),如(100)&quot;/&gt;        &lt;Attribute name=&quot;bktrans&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;窗口是否使用静态透明背景,如(false)&quot;/&gt;        &lt;Attribute name=&quot;disabledfontcolor&quot; default=&quot;0xFFA7A6AA&quot; type=&quot;DWORD&quot; comment=&quot;默认的disabled字体颜色,如(0xFFA7A6AA)&quot;/&gt;        &lt;Attribute name=&quot;defaultfontcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;默认的字体颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;linkfontcolor&quot; default=&quot;0xFF0000FF&quot; type=&quot;DWORD&quot; comment=&quot;默认的link字体颜色,如(0xFF0000FF)&quot;/&gt;        &lt;Attribute name=&quot;linkhoverfontcolor&quot; default=&quot;0xFFD3215F&quot; type=&quot;DWORD&quot; comment=&quot;默认的linkhoverfont字体颜色,如(0xFFD3215F)&quot;/&gt;        &lt;Attribute name=&quot;selectedcolor&quot; default=&quot;0xFFBAE4FF&quot; type=&quot;DWORD&quot; comment=&quot;默认的selected字体颜色,如(0xFFBAE4FF)&quot;/&gt;        &lt;Attribute name=&quot;showdirty&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;绘制脏矩形(屏幕上更新的区域被称为脏矩形)&quot;/&gt;    &lt;/Window&gt;    &lt;ChildLayout parent=&quot;Container&quot; &gt;        &lt;Attribute name=&quot;xmlfile&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;子窗体XML布局文件&quot;/&gt;    &lt;/ChildLayout&gt;    &lt;Control parent=&quot;&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;0&quot; type=&quot;INT | RECT&quot; comment=&quot;可以设置INT或RECT类型的值。当值为ING时则左、上、右、下都用该值作为宽。值为RECT类型时则分别设置左、上、右、下的边框&quot;/&gt;        &lt;Attribute name=&quot;leftbordersize&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;左边边框大小，如(1)，设置该值大于0，则将忽略bordersize属性的设置&quot;/&gt;        &lt;Attribute name=&quot;topbordersize&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;顶部边框大小，如(1)，设置该值大于0，则将忽略bordersize属性的设置&quot;/&gt;        &lt;Attribute name=&quot;rightbordersize&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;右边边框大小，如(1)，设置该值大于0，则将忽略bordersize属性的设置&quot;/&gt;        &lt;Attribute name=&quot;bottombordersize&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;底部边框大小，如(1)，设置该值大于0，则将忽略bordersize属性的设置&quot;/&gt;        &lt;Attribute name=&quot;borderstyle&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;边框样式的设置,数值范围0-5&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;keyboard&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;非CButtonUI类忽略该值，为false时不支持TAB_STOP,且该对象不处理键盘信息&quot;/&gt;    &lt;/Control&gt;    &lt;Container parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;    &lt;/Container&gt;    &lt;VerticalLayout parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;分隔符高度,正负表示分隔符在顶部还是底部,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepimm&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;拖动分隔符是否立即改变大小,如(false)&quot;/&gt;    &lt;/VerticalLayout&gt;    &lt;HorizontalLayout parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;分隔符宽,正负表示分隔符在左边还是右边,如(-4)&quot;/&gt;        &lt;Attribute name=&quot;sepimm&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;拖动分隔符是否立即改变大小,如(false)&quot;/&gt;    &lt;/HorizontalLayout&gt;    &lt;TileLayout parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;columns&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;列数,如(4)&quot;/&gt;        &lt;Attribute name=&quot;itemsize&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;子项固定大小，如(128,128)&quot;/&gt;    &lt;/TileLayout&gt;    &lt;TabLayout parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu tabselect windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;DWORD&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;selectedid&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;默认选中的页面id,如(0)&quot;/&gt;    &lt;/TabLayout&gt;    &lt;ActiveX parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer menu showactivex windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;clsid&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;activex的clsid,如({8856F961-340A-11D0-A96B-00C04FD705A2})&quot;/&gt;        &lt;Attribute name=&quot;modulename&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;activex从指定位置加载,如(flash/flash.ocx)&quot;/&gt;        &lt;Attribute name=&quot;delaycreate&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否需要延迟创建activex,如(false)&quot;/&gt;    &lt;/ActiveX&gt;    &lt;WebBrowser parent=&quot;ActiveX&quot; &gt;        &lt;Attribute name=&quot;homepage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;默认首页&quot; /&gt;        &lt;Attribute name=&quot;autonavi&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否打开默认首页&quot; /&gt;    &lt;/WebBrowser&gt;    &lt;Combo parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu dropdown itemselect windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮的状态图片&quot;/&gt;        &lt;Attribute name=&quot;pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标按下的状态图片&quot;/&gt;        &lt;Attribute name=&quot;focusedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;获得焦点时的状态图片&quot;/&gt;        &lt;Attribute name=&quot;disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;禁用的状态图片&quot;/&gt;        &lt;Attribute name=&quot;dropboxsize&quot; default=&quot;0,150&quot; type=&quot;STRING&quot; comment=&quot;弹出框大小设置&quot;/&gt;        &lt;Attribute name=&quot;itemfont&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;item的字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;itemalign&quot; default=&quot;center&quot; type=&quot;STRING&quot; comment=&quot;item对齐方式,取值left、right、center，如(center)&quot;/&gt;        &lt;Attribute name=&quot;itemendellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item句末显示不全是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;itemtextpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;item文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;itemtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemaltbk&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用隔行交替背景&quot;/&gt;        &lt;Attribute name=&quot;itemselectedtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedbkcolor&quot; default=&quot;0xFFC1E3FF&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item被选中时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemhottextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotbkcolor&quot; default=&quot;0xFFE9F5FF&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item鼠标悬浮时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledtextcolor&quot; default=&quot;0xFFCCCCCC&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledbkcolor&quot; default=&quot;0xFFFFFFFF&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item禁用时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemlinecolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item行分割线颜色&quot;/&gt;        &lt;Attribute name=&quot;itemshowhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;multiexpanding&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否支持多个item同时打开,如(false)&quot;/&gt;    &lt;/Combo&gt;    &lt;Label parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、bottom，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不全是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;enabledeffect&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用字体特效，使用下面文字特效属性必须该属性设置为true方有效&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字横向对齐方式,取值left、center、right&quot;/&gt;        &lt;Attribute name=&quot;valign&quot; default=&quot;center&quot; type=&quot;STRING&quot; comment=&quot;文字纵向对齐方式,取值top、center、bottom&quot;/&gt;        &lt;Attribute name=&quot;rhaa&quot; default=&quot;0&quot; type=&quot;STRING&quot; comment=&quot;字体质量0-5&quot;/&gt;        &lt;Attribute name=&quot;enabledstroke&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用描边效果&quot;/&gt;        &lt;Attribute name=&quot;strokecolor&quot; default=&quot;0x00000000&quot; type=&quot;STRING&quot; comment=&quot;字体描边的颜色&quot;/&gt;        &lt;Attribute name=&quot;transstroke&quot; default=&quot;255&quot; type=&quot;STRING&quot; comment=&quot;字体描边的颜色透明度 0-255&quot;/&gt;        &lt;Attribute name=&quot;enabledshadow&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用阴影效果&quot;/&gt;        &lt;Attribute name=&quot;gradientangle&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;渐变色渲染角度&quot;/&gt;        &lt;Attribute name=&quot;gradientlength&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;渐变距离&quot;/&gt;        &lt;Attribute name=&quot;textcolor1&quot; default=&quot;0x00000000&quot; type=&quot;STRING&quot; comment=&quot;字体渐变色&quot;/&gt;        &lt;Attribute name=&quot;textshadowcolora&quot; default=&quot;0xff000000&quot; type=&quot;STRING&quot; comment=&quot;字体阴影渐变色&quot;/&gt;        &lt;Attribute name=&quot;textshadowcolorb&quot; default=&quot;0xff000000&quot; type=&quot;STRING&quot; comment=&quot;字体阴影渐变色&quot;/&gt;        &lt;Attribute name=&quot;transshadow&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;阴影透明度&quot;/&gt;        &lt;Attribute name=&quot;transshadow1&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;阴影透明度&quot;/&gt;        &lt;Attribute name=&quot;transtext&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;字体色彩透明度&quot;/&gt;        &lt;Attribute name=&quot;transtext1&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;字体色彩透明度&quot;/&gt;    &lt;/Label&gt;    &lt;Button parent=&quot;Label&quot; notifies=&quot;setfocus killfocus timer menu click windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮的状态图片&quot;/&gt;        &lt;Attribute name=&quot;pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标按下的状态图片&quot;/&gt;        &lt;Attribute name=&quot;focusedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;获得焦点时的状态图片&quot;/&gt;        &lt;Attribute name=&quot;disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;禁用的状态图片&quot;/&gt;        &lt;Attribute name=&quot;hottextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标悬浮字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;pushedtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标按下字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;focusedtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;    &lt;/Button&gt;    &lt;Option parent=&quot;Button&quot; notifies=&quot;setfocus killfocus timer menu click selectchanged windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮的状态图片&quot;/&gt;        &lt;Attribute name=&quot;pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标按下的状态图片&quot;/&gt;        &lt;Attribute name=&quot;focusedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;获得焦点时的状态图片&quot;/&gt;        &lt;Attribute name=&quot;disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;禁用的状态图片&quot;/&gt;        &lt;Attribute name=&quot;selectedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;选中的状态图片&quot;/&gt;        &lt;Attribute name=&quot;foreimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;前景图片&quot;/&gt;        &lt;Attribute name=&quot;hottextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标悬浮字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;pushedtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标按下字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;focusedtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;selectedtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;选中状态字体颜色，0表示不使用此颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;group&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;所属组的名称，可不设&quot;/&gt;        &lt;Attribute name=&quot;selected&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否选中&quot;/&gt;    &lt;/Option&gt;    &lt;Text parent=&quot;Label&quot; notifies=&quot;setfocus killfocus timer menu link windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;2,0,2,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,0,2,0)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;    &lt;/Text&gt;    &lt;Progress parent=&quot;Label&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;certer&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;2,0,2,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,0,2,0)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;foreimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;前景图片&quot;/&gt;        &lt;Attribute name=&quot;hor&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;水平或垂直,如(true)&quot;/&gt;        &lt;Attribute name=&quot;min&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;进度最小值，如(0)&quot;/&gt;        &lt;Attribute name=&quot;max&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;进度最大值，如(100)&quot;/&gt;        &lt;Attribute name=&quot;value&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;进度值，如(50)&quot;/&gt;        &lt;Attribute name=&quot;isstretchfore&quot; default=&quot;TRUE&quot; type=&quot;BOOL&quot; comment=&quot;指定前景图片是否缩放显示&quot;/&gt;    &lt;/Progress&gt;    &lt;Slider parent=&quot;Progress&quot; notifies=&quot;setfocus killfocus timer menu valuechanged windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;center&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;2,0,2,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,0,2,0)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;foreimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;前景图片&quot;/&gt;        &lt;Attribute name=&quot;hor&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;水平或垂直,如(true)&quot;/&gt;        &lt;Attribute name=&quot;min&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;进度最小值，如(0)&quot;/&gt;        &lt;Attribute name=&quot;max&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;进度最大值，如(100)&quot;/&gt;        &lt;Attribute name=&quot;value&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;进度值，如(50)&quot;/&gt;        &lt;Attribute name=&quot;thumbimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;拖动滑块普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;拖动滑块鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbpushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;拖动滑块鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbsize&quot; default=&quot;10,10&quot; type=&quot;SIZE&quot; comment=&quot;拖动滑块大小,如(10,10)&quot;/&gt;        &lt;Attribute name=&quot;step&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;进度步长，如(1)&quot;/&gt;    &lt;/Slider&gt;    &lt;Edit parent=&quot;Label&quot; notifies=&quot;setfocus killfocus timer menu return textchanged windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、center、top、button，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不完是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;disabledtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;disabled字体颜色，0表示使用默认disabled字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;readonly&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否只读,如(false)&quot;/&gt;        &lt;Attribute name=&quot;password&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否显示密码字符,如(false)&quot;/&gt;        &lt;Attribute name=&quot;maxchar&quot; default=&quot;255&quot; type=&quot;INT&quot; comment=&quot;输入字符最大长度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;focusedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;获得焦点状态图片&quot;/&gt;        &lt;Attribute name=&quot;disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;nativebkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;windows原生edit控件的背景颜色,如(0xFFFFFFFF)&quot;/&gt;    &lt;/Edit&gt;    &lt;ScrollBar parent=&quot;Control&quot; notifies=&quot;timer menu scrolled windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;button1normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;左或上按钮普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;button1hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;左或上按钮鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;button1pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;左或上按钮鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;button1disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;左或上按钮禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;button2normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;右或下按钮普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;button2hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;右或下按钮鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;button2pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;右或下按钮鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;button2disabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;右或下按钮禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbnormalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbpushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;thumbdisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;railnormalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块中间标识普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;railhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块中间标识鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;railpushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块中间标识鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;raildisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;滑块中间标识禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;bknormalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;bkhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景鼠标悬浮状态图片&quot;/&gt;        &lt;Attribute name=&quot;bkpushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景鼠标按下状态图片&quot;/&gt;        &lt;Attribute name=&quot;bkdisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景禁用状态图片&quot;/&gt;        &lt;Attribute name=&quot;hor&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;水平或垂直,如(true)&quot;/&gt;        &lt;Attribute name=&quot;linesize&quot; default=&quot;8&quot; type=&quot;INT&quot; comment=&quot;滚动一行的大小，如(8)&quot;/&gt;        &lt;Attribute name=&quot;range&quot; default=&quot;100&quot; type=&quot;INT&quot; comment=&quot;滚动范围，如(100)&quot;/&gt;        &lt;Attribute name=&quot;value&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;滚动位置，如(0)&quot;/&gt;        &lt;Attribute name=&quot;showbutton1&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否显示左或上按钮,如(true)&quot;/&gt;        &lt;Attribute name=&quot;showbutton2&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否显示右或下按钮,如(true)&quot;/&gt;    &lt;/ScrollBar&gt;    &lt;List parent=&quot;VerticalLayout&quot; notifies=&quot;setfocus killfocus timer menu itemselect windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;分隔符高度,正负表示分隔符在顶部还是底部,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepimm&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;拖动分隔符是否立即改变大小,如(false)&quot;/&gt;        &lt;Attribute name=&quot;header&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否显示表头,如(true)&quot;/&gt;        &lt;Attribute name=&quot;headerbkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;表头背景图片&quot;/&gt;        &lt;Attribute name=&quot;scrollselect&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否随滚动改变选中项,如(false)&quot;/&gt;        &lt;Attribute name=&quot;itemfont&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;item的字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;itemalign&quot; default=&quot;center&quot; type=&quot;STRING&quot; comment=&quot;item对齐方式,取值left、right、center，如(center)&quot;/&gt;        &lt;Attribute name=&quot;itemendellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item句末显示不全是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;itemtextpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;item文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;itemtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemaltbk&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用隔行交替背景&quot;/&gt;        &lt;Attribute name=&quot;itemselectedtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedbkcolor&quot; default=&quot;0xFFC1E3FF&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item被选中时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemhottextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotbkcolor&quot; default=&quot;0xFFE9F5FF&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item鼠标悬浮时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledtextcolor&quot; default=&quot;0xFFCCCCCC&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledbkcolor&quot; default=&quot;0xFFFFFFFF&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item禁用时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemlinecolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item行分割线颜色&quot;/&gt;        &lt;Attribute name=&quot;itemshowhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;multiexpanding&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否支持多个item同时打开,如(false)&quot;/&gt;    &lt;/List&gt;    &lt;ListHeader parent=&quot;HorizontalLayout&quot; notifies=&quot;setfocus killfocus timer windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;分隔符宽,正负表示分隔符在左边还是右边,如(-4)&quot;/&gt;        &lt;Attribute name=&quot;sepimm&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;拖动分隔符是否立即改变大小,如(false)&quot;/&gt;    &lt;/ListHeader&gt;    &lt;ListHeaderItem parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer headerclick windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;16&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;dragable&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可拖动改变大小,如(true)&quot;/&gt;        &lt;Attribute name=&quot;sepwidth&quot; default=&quot;4&quot; type=&quot;INT&quot; comment=&quot;分隔符宽,如(4)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、cente，如(center)&quot;/&gt;        &lt;Attribute name=&quot;endellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;句末显示不全是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，0表示使用默认字体颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;textpadding&quot; default=&quot;2,0,2,0&quot; type=&quot;RECT&quot; comment=&quot;文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;showhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;normalimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;普通状态图片&quot;/&gt;        &lt;Attribute name=&quot;hotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮的状态图片&quot;/&gt;        &lt;Attribute name=&quot;pushedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标按下的状态图片&quot;/&gt;        &lt;Attribute name=&quot;focusedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;获得焦点时的状态图片&quot;/&gt;        &lt;Attribute name=&quot;sepimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;拖动条图片&quot;/&gt;    &lt;/ListHeaderItem&gt;    &lt;ListLabelElement parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer itemactivate itemclick windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;selected&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否选中,如(true)&quot;/&gt;    &lt;/ListLabelElement&gt;    &lt;ListTextElement parent=&quot;ListLabelElement&quot; notifies=&quot;setfocus killfocus timer itemactivate itemclick link windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;selected&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否选中,如(true)&quot;/&gt;    &lt;/ListTextElement&gt;    &lt;ListContainerElement parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer itemactivate itemclick itemexpanded itemcollapsed windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;selected&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否选中,如(true)&quot;/&gt;    &lt;/ListContainerElement&gt;    &lt;RichEdit parent=&quot;Container&quot; notifies=&quot;setfocus killfocus timer menu return windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bordervisible&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否显示边框&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;autovscroll&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否随输入竖向滚动,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;autohscroll&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否随输入横向滚动,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;wanttab&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否接受tab按键消息,如(true)&quot;/&gt;        &lt;Attribute name=&quot;wantreturn&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否接受return按键消息,如(true)&quot;/&gt;        &lt;Attribute name=&quot;wantctrlreturn&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否接受ctrl+return按键消息,如(true)&quot;/&gt;        &lt;Attribute name=&quot;transparent&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否背景透明,如(true)&quot;/&gt;        &lt;Attribute name=&quot;rich&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否使用富格式,如(true)&quot;/&gt;        &lt;Attribute name=&quot;multiline&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否使用多行,如(true)&quot;/&gt;        &lt;Attribute name=&quot;readonly&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否只读,如(false)&quot;/&gt;        &lt;Attribute name=&quot;password&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否显示密码符,如(true)&quot;/&gt;        &lt;Attribute name=&quot;align&quot; default=&quot;left&quot; type=&quot;STRING&quot; comment=&quot;文字对齐方式,取值left、right、cente，如(center)&quot;/&gt;        &lt;Attribute name=&quot;font&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;字体颜色，如(0xFFFF0000)&quot;/&gt;    &lt;/RichEdit&gt;    &lt;TreeView parent=&quot;List&quot; notifies=&quot;selectchanged setfocus killfocus timer menu itemselect windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;分隔符高度,正负表示分隔符在顶部还是底部,如(4)&quot;/&gt;        &lt;Attribute name=&quot;sepimm&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;拖动分隔符是否立即改变大小,如(false)&quot;/&gt;        &lt;Attribute name=&quot;header&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否显示表头,如(true)&quot;/&gt;        &lt;Attribute name=&quot;headerbkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;表头背景图片&quot;/&gt;        &lt;Attribute name=&quot;scrollselect&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否随滚动改变选中项,如(false)&quot;/&gt;        &lt;Attribute name=&quot;itemfont&quot; default=&quot;-1&quot; type=&quot;INT&quot; comment=&quot;item的字体id,如(0)&quot;/&gt;        &lt;Attribute name=&quot;itemalign&quot; default=&quot;center&quot; type=&quot;STRING&quot; comment=&quot;item对齐方式,取值left、right、center，如(center)&quot;/&gt;        &lt;Attribute name=&quot;itemendellipsis&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item句末显示不全是否使用...代替,如(true)&quot;/&gt;        &lt;Attribute name=&quot;itemtextpadding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;item文字显示的边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;itemtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itembkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemaltbk&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用隔行交替背景&quot;/&gt;        &lt;Attribute name=&quot;itemselectedtextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedbkcolor&quot; default=&quot;0xFFC1E3FF&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemselectedimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item被选中时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemhottextcolor&quot; default=&quot;0xFF000000&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotbkcolor&quot; default=&quot;0xFFE9F5FF&quot; type=&quot;DWORD&quot; comment=&quot;item鼠标悬浮时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhotimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item鼠标悬浮时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledtextcolor&quot; default=&quot;0xFFCCCCCC&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的字体颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledbkcolor&quot; default=&quot;0xFFFFFFFF&quot; type=&quot;DWORD&quot; comment=&quot;item禁用时的背景颜色&quot;/&gt;        &lt;Attribute name=&quot;itemdisabledimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item禁用时的背景图片&quot;/&gt;        &lt;Attribute name=&quot;itemlinecolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item行分割线颜色&quot;/&gt;        &lt;Attribute name=&quot;itemshowhtml&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;item是否使用类html富文本绘制,如(false)&quot;/&gt;        &lt;Attribute name=&quot;multiexpanding&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否支持多个item同时打开,如(false)&quot;/&gt;        &lt;!--TreeView 私有属性--&gt;        &lt;Attribute name=&quot;multipleitem&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否允许item多选&quot;/&gt;        &lt;Attribute name=&quot;itemcheckimgsize&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;Item的复选框图片大小,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;itemiconimgsize&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;Item的图标大小,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;visiblefolderbtn&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否显示展开与收缩按钮对象&quot;/&gt;        &lt;Attribute name=&quot;visiblecheckbtn&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否显示复选框对象&quot;/&gt;        &lt;Attribute name=&quot;itemminwidth&quot; default=&quot;0&quot; type=&quot;UINT&quot; comment=&quot;设置Item的最小宽度，当hscrollbar为真且itemminwidth大于TreeView宽度时才会显示横向滚动条&quot;/&gt;        &lt;Attribute name=&quot;itemtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item文本颜色&quot;/&gt;        &lt;Attribute name=&quot;itemhottextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标进入item时文本颜色&quot;/&gt;        &lt;Attribute name=&quot;selitemtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时文本颜色&quot;/&gt;        &lt;Attribute name=&quot;selitemhottextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时且鼠标进入时的文本颜色&quot;/&gt;    &lt;/TreeView&gt;    &lt;TreeNode parent=&quot;ListContainerElement&quot; notifies=&quot;setfocus killfocus timer itemactivate itemclick itemexpanded itemcollapsed windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;name&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;控件名字，同一窗口内必须唯一，如(testbtn)&quot;/&gt;        &lt;Attribute name=&quot;pos&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;位置，如果为float控件则指定位置和大小，否则只指定大小,如(0,0,100,100)&quot;/&gt;        &lt;Attribute name=&quot;padding&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;外边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor2&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色2,和bkcolor配合使用,如(0xFFFFFF00)&quot;/&gt;        &lt;Attribute name=&quot;bkcolor3&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;背景渐变色3,和bkcolor、bkcolor2配合使用,如(0xFFFF00FF)&quot;/&gt;        &lt;Attribute name=&quot;bordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;边框颜色,如(0xFF000000)&quot;/&gt;        &lt;Attribute name=&quot;focusbordercolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;获得焦点时边框的颜色,如(0xFFFF0000)&quot;/&gt;        &lt;Attribute name=&quot;colorhsl&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;本控件的颜色是否随窗口的hsl变化而变化,如(false)&quot;/&gt;        &lt;Attribute name=&quot;bordersize&quot; default=&quot;1&quot; type=&quot;INT&quot; comment=&quot;边框大小，如(1)&quot;/&gt;        &lt;Attribute name=&quot;borderround&quot; default=&quot;0,0&quot; type=&quot;SIZE&quot; comment=&quot;边框圆角半径,如(2,2)&quot;/&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;背景图片,如(bk.bmp或file=&apos;aaa.jpg&apos; res=&apos;&apos; restype=&apos;0&apos; dest=&apos;0,0,0,0&apos; source=&apos;0,0,0,0&apos; corner=&apos;0,0,0,0&apos; mask=&apos;#FF0000&apos; fade=&apos;255&apos; hole=&apos;false&apos; xtiled=&apos;false&apos; ytiled=&apos;false&apos;)&quot;/&gt;        &lt;Attribute name=&quot;width&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;height&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件预设的高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;minwidth&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;minheight&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;控件的最小高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;maxwidth&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大宽度，如(100)&quot;/&gt;        &lt;Attribute name=&quot;maxheight&quot; default=&quot;9999&quot; type=&quot;INT&quot; comment=&quot;控件的最大高度，如(30)&quot;/&gt;        &lt;Attribute name=&quot;text&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;显示文本,如(测试文本)&quot;/&gt;        &lt;Attribute name=&quot;tooltip&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;鼠标悬浮提示,如(请在这里输入你的密码)&quot;/&gt;        &lt;Attribute name=&quot;userdata&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;自定义标识&quot;/&gt;        &lt;Attribute name=&quot;enabled&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mouse&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件是否可以响应鼠标操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;mousechild&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;本控件的子控件是否可以响应用户操作,如(true)&quot;/&gt;        &lt;Attribute name=&quot;visible&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否可见,如(true)&quot;/&gt;        &lt;Attribute name=&quot;float&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用绝对定位,如(true)&quot;/&gt;        &lt;Attribute name=&quot;shortcut&quot; default=&quot;&quot; type=&quot;CHAR&quot; comment=&quot;对应的快捷键,如(P)&quot;/&gt;        &lt;Attribute name=&quot;menu&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否需要右键菜单,如(true)&quot;/&gt;        &lt;Attribute name=&quot;inset&quot; default=&quot;0,0,0,0&quot; type=&quot;RECT&quot; comment=&quot;容器的内边距,如(2,2,2,2)&quot;/&gt;        &lt;Attribute name=&quot;vscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用竖向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;hscrollbar&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否使用横向滚动条,如(true)&quot;/&gt;        &lt;Attribute name=&quot;childpadding&quot; default=&quot;0&quot; type=&quot;INT&quot; comment=&quot;子控件之间的额外距离,如(4)&quot;/&gt;        &lt;Attribute name=&quot;selected&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否选中,如(true)&quot;/&gt;        &lt;!--TreeNode 私有属性--&gt;        &lt;Attribute name=&quot;horizattr&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item虚线、复选框、展开与收缩、文本按钮等对象容器属性设置，格式参考Default元素的属性设置&quot;/&gt;        &lt;Attribute name=&quot;dotlineattr&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item虚线对象属性设置，格式参考Default元素的属性设置&quot;/&gt;        &lt;Attribute name=&quot;folderattr&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item展开与收缩按钮对象属性设置，格式参考Default元素的属性设置&quot;/&gt;        &lt;Attribute name=&quot;checkboxattr&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item复选框对象属性设置，格式参考Default元素的属性设置&quot;/&gt;        &lt;Attribute name=&quot;itemattr&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;item按钮对象属性设置，格式参考Default元素的属性设置&quot;/&gt;        &lt;Attribute name=&quot;textcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item文本颜色&quot;/&gt;        &lt;Attribute name=&quot;texthotcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;鼠标进入item时文本颜色&quot;/&gt;        &lt;Attribute name=&quot;selitemtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时文本颜色&quot;/&gt;        &lt;Attribute name=&quot;selhotitemtextcolor&quot; default=&quot;0x00000000&quot; type=&quot;DWORD&quot; comment=&quot;item被选中时且鼠标进入时的文本颜色&quot;/&gt;    &lt;/TreeNode&gt;    &lt;GifAnim parent=&quot;Control&quot; notifies=&quot;setfocus killfocus timer menu windowinit(root)&quot;&gt;        &lt;Attribute name=&quot;bkimage&quot; default=&quot;&quot; type=&quot;STRING&quot; comment=&quot;Gif动画图片路径(不支持source等属性设置)&quot;/&gt;        &lt;Attribute name=&quot;autoplay&quot; default=&quot;true&quot; type=&quot;BOOL&quot; comment=&quot;是否自动播放GIF动画&quot;/&gt;        &lt;Attribute name=&quot;autosize&quot; default=&quot;false&quot; type=&quot;BOOL&quot; comment=&quot;是否根据图片自动设置控件大小(开启后width和height属性失效)&quot;/&gt;    &lt;/GifAnim&gt;&lt;/Controls&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;duilib&quot;&gt;&lt;a href=&quot;#duilib&quot; class=&quot;headerlink&quot; title=&quot;duilib&quot;&gt;&lt;/a&gt;duilib&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/duilib/duilib&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="ATL" scheme="https://caojingyou.github.io/tags/ATL/"/>
    
      <category term="duilib" scheme="https://caojingyou.github.io/tags/duilib/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://caojingyou.github.io/2018/04/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2018/04/03/正则表达式/</id>
    <published>2018-04-03T01:53:00.000Z</published>
    <updated>2018-04-13T07:16:03.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-regex"><a href="#c-regex" class="headerlink" title="c regex"></a>c regex</h1><ol><li>编译正则表达式 <code>regcomp()</code></li><li>匹配正则表达式 <code>regexec()</code></li><li>释放正则表达式 <code>regfree()</code></li><li>错误处理 <code>regerror()</code></li></ol><pre><code>#include &lt;stdio.h&gt;#include &lt;regex.h&gt;  //标准c不支持，Linux常带有此文件int main(){    regex_t reg;    //定义一个正则实例    const char* pattern = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$&quot;; //定义模式串    regcomp(&amp;reg, pattern, REG_EXTENDED);    //编译正则模式串    char* buf = &quot;david19842003@gmail.com&quot;;   //定义待匹配串    const size_t nmatch = 1;    //定义匹配结果最大允许数    regmatch_t pmatch[1];   //定义匹配结果在待匹配串中的下标范围    int status = regexec(&amp;reg, buf, nmatch, pmatch, 0); //匹配他    if (status == REG_NOMATCH){ //如果没匹配上        printf(&quot;No Match\n&quot;);    }    else if (status == 0){  //如果匹配上了        printf(&quot;Match\n&quot;);        for (int i = pmatch[0].rm_so; i &lt; pmatch[0].rm_eo; i++){    //遍历输出匹配范围的字符串            printf(&quot;%c&quot;, buf[i]);        }        printf(&quot;\n&quot;);    }    regfree(&amp;reg);  //释放正则表达式    return 0;}</code></pre><p>1.<code>int regcomp (regex_t *compiled, const char *pattern, int cflags)</code></p><ul><li><code>regex_t</code> 是一个结构体数据类型，用来存放编译后的正则表达式<ul><li><code>regex_t</code> 的成员<code>re_nsub</code> 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式</li></ul></li><li><code>pattern</code> 是指向我们写好的正则表达式的指针</li><li><code>cflags</code> 有如下4个值或者是它们或运算(|)后的值：<ul><li>REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。</li><li>REG_ICASE 匹配字母时忽略大小写。</li><li>REG_NOSUB 不用存储匹配后的结果。</li><li>REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配</li></ul></li></ul><p>2.<code>int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)</code></p><ul><li>如果在编译正则表达式的时候没有指定cflags的参数为REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回0<ul><li><code>regmatch_t</code> 是一个结构体数据类型，在regex.h中定义：<code>typedef struct{regoff_t rm_so;regoff_t rm_eo;} regmatch_t;</code></li><li>成员<code>rm_so</code> 存放匹配文本串在目标串中的开始位置，<code>rm_eo</code>存放结束位置</li><li>通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置</li></ul></li><li><code>compiled</code> 是已经用<code>regcomp</code>函数编译好的正则表达式</li><li><code>string</code> 是目标文本串</li><li><code>nmatch</code> 是<code>regmatch_t</code>结构体数组的长度</li><li><code>matchptr regmatch_t</code>类型的结构体数组，存放匹配文本串的位置信息</li><li><code>eflags</code> 有两个值<ul><li><code>REG_NOTBOL</code> 按我的理解是如果指定了这个值，那么’^’就不会从我们的目标串开始匹配。总之我到现在还不是很明白这个参数的意义</li><li><code>REG_NOTEOL</code> 和上边那个作用差不多，不过这个指定结束<code>end of line</code></li></ul></li></ul><p>3.<code>void regfree (regex_t *compiled)</code></p><ul><li>清空compiled指向的regex_t结构体的内容</li><li>如果是重新编译的话，一定要先清空regex_t结构体c</li></ul><p>4.<code>size_t regerror (int errcode, regex_t *compiled, char *buffer, size_t length)</code></p><ul><li><code>当执行regcomp</code> 或者<code>regexec</code> 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串</li><li><code>errcode</code> <code>是由regcomp</code> 和 <code>regexec</code> 函数返回的错误代号</li><li><code>compiled</code> 是已经用<code>regcomp</code>函数编译好的正则表达式，这个值可以为<code>NULL</code></li><li><code>buffer</code> 指向用来存放错误信息的字符串的内存空间</li><li><code>length</code> 指明<code>buffer</code>的长度，如果这个错误信息的长度大于这个值，则<code>regerror</code> 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。</li></ul><pre><code>`size_t length = regerror (errcode, compiled, NULL, 0);`</code></pre><p>转载：<br><a href="http://www.yingzinanfei.com/2017/02/06/c-regex-yongfa/" target="_blank" rel="noopener">c regex 用法</a></p><h1 id="C-regex"><a href="#C-regex" class="headerlink" title="C++ regex"></a>C++ regex</h1><p><a href="https://msdn.microsoft.com/en-us/library/bb982382.aspx" target="_blank" rel="noopener">regex头文件</a></p><p><a href="https://msdn.microsoft.com/en-us/library/bb982727.aspx" target="_blank" rel="noopener">Regular Expressions (C++)</a></p><p><a href="https://msdn.microsoft.com/zh-cn/ch/library/bb982727.aspx" target="_blank" rel="noopener">正则表达式 (C++)</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regular-expressions-cpp" target="_blank" rel="noopener">正则表达式 (C++)</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regex" target="_blank" rel="noopener">微软regex</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/regex-typedefs" target="_blank" rel="noopener">regex typedefs</a></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><code>basic_regex</code>    包装正则表达式。</li><li><code>match_results</code>    包含一系列子匹配项。</li><li><code>regex_constants</code>    包含各种类型的常量。</li><li><code>regex_error</code>    报告错误的正则表达式。</li><li><code>regex_iterator</code>    循环访问匹配结果。</li><li><code>regex_traits</code>    描述用于匹配的元素的特征。</li><li><code>regex_traits&lt;char&gt;</code>    描述用于匹配的 <code>char</code> 的特征。</li><li><code>regex_traits&lt;wchar_t&gt;</code>    描述用于匹配的 <code>wchar_t</code> 的特征。</li><li><code>regex_token_iterator</code>    循环访问子匹配项。</li><li><code>sub_match</code>    介绍子匹配项。</li></ul><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><ul><li><code>cmatch</code>    <code>char match_results</code> 的类型定义。</li><li><code>cregex_iterator</code>    <code>char regex_iterator</code> 的类型定义。</li><li><code>cregex_token_iterator</code>    <code>char regex_token_iterator</code> 的类型定义。</li><li><code>csub_match</code>    <code>char sub_match</code> 的类型定义。</li><li><code>regex</code>    <code>char basic_regex</code> 的类型定义。</li><li><code>smatch</code>    <code>string match_results</code> 的类型定义。</li><li><code>sregex_iterator</code>    <code>string regex_iterator</code> 的类型定义。</li><li><code>sregex_token_iterator</code>    <code>string regex_token_iterator</code> 的类型定义。</li><li><code>ssub_match</code>    <code>string sub_match</code> 的类型定义。</li><li><code>wcmatch</code>    <code>wchar_t match_results</code> 的类型定义。</li><li><code>wcregex_iterator</code>    <code>wchar_t regex_iterator</code> 的类型定义。</li><li><code>wcregex_token_iterator</code>    <code>wchar_t regex_token_iterator</code> 的类型定义。</li><li><code>wcsub_match</code>    <code>wchar_t sub_match</code> 的类型定义。</li><li><code>wregex</code>    <code>wchar_t basic_regex</code> 的类型定义。</li><li><code>wsmatch</code>    <code>wstring match_results</code> 的类型定义。</li><li><code>wsregex_iterator</code>    <code>wstring regex_iterator</code> 的类型定义。</li><li><code>wsregex_token_iterator</code>    <code>wstring regex_token_iterator</code> 的类型定义。</li><li><code>wssub_match</code>    <code>wstring sub_match</code> 的类型定义。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><code>regex_match</code>    与正则表达式完全匹配。</li><li><code>regex_replace</code>    替换匹配正则表达式。</li><li><code>regex_search</code>    搜索正则表达式匹配项。</li><li><code>swap</code>    交换 <code>basic_regex</code> 或 <code>match_results</code> 对象。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><code>operator==</code>    比较各种对象，相等。</li><li><code>operator!=</code>    比较各种对象，不相等。</li><li><code>operator&lt;</code>    比较各种对象，小于。</li><li><code>operator&lt;=</code>    比较各种对象，小于或等于。</li><li><code>operator&gt;</code>    比较各种对象，大于。</li><li><code>operator&gt;=</code>    比较各种对象，大于或等于。</li><li><code>operator&lt;&lt;</code>    将 sub_match 插入流中。</li></ul><h2 id="regex-match"><a href="#regex-match" class="headerlink" title="regex_match"></a><code>regex_match</code></h2><pre><code>#include &quot;stdafx.h&quot;  #include &lt;regex&gt;   #include &lt;iostream&gt;   using namespace std;  int _tmain(int argc, _TCHAR* argv[])  {      // (1) with char*      // Note how const char* requires cmatch and regex      const char *first = &quot;abc&quot;;      const char *last = first + strlen(first);      cmatch narrowMatch;      regex rx(&quot;a(b)c&quot;);      bool found = regex_match(first, last, narrowMatch, rx);      // (1) with std::wstring      // Note how wstring requires wsmatch and wregex.      // Note use of const iterators cbegin() and cend().      wstring target(L&quot;Hello&quot;);      wsmatch wideMatch;      wregex wrx(L&quot;He(l+)o&quot;);      if (regex_match(target.cbegin(), target.cend(), wideMatch, wrx))          wcout &lt;&lt; L&quot;The matching text is:&quot; &lt;&lt; wideMatch.str() &lt;&lt; endl;       // (2) with std::string      string target2(&quot;Drizzle&quot;);      regex rx2(R&quot;(D\w+e)&quot;); // no double backslashes with raw string literal      found = regex_match(target2.cbegin(), target2.cend(), rx2);      // (3) with wchar_t*      const wchar_t* target3 = L&quot;2014-04-02&quot;;      wcmatch wideMatch2;      // LR&quot;(...)&quot; is a  raw wide-string literal. Open and close parens      // are delimiters, not string elements.      wregex wrx2(LR&quot;(\d{4}(-|/)\d{2}(-|/)\d{2})&quot;);       if (regex_match(target3, wideMatch2, wrx2))      {          wcout &lt;&lt; L&quot;Matching text: &quot; &lt;&lt; wideMatch2.str() &lt;&lt; endl;      }       return 0;  }</code></pre><h2 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace"></a><code>regex_replace</code></h2><pre><code>// std__regex__regex_replace.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       char buf[20];       const char *first = &quot;axayaz&quot;;       const char *last = first + strlen(first);       std::regex rx(&quot;a&quot;);       std::string fmt(&quot;A&quot;);       std::regex_constants::match_flag_type fonly =           std::regex_constants::format_first_only;    *std::regex_replace(&amp;buf[0], first, last, rx, fmt) = &apos;\0&apos;;       std::cout &lt;&lt; &quot;replacement == &quot; &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;    *std::regex_replace(&amp;buf[0], first, last, rx, fmt, fonly) = &apos;\0&apos;;       std::cout &lt;&lt; &quot;replacement == &quot; &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;       std::string str(&quot;adaeaf&quot;);       std::cout &lt;&lt; &quot;replacement == &quot;           &lt;&lt; std::regex_replace(str, rx, fmt) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;replacement == &quot;           &lt;&lt; std::regex_replace(str, rx, fmt, fonly) &lt;&lt; std::endl;       return (0);       }</code></pre><p>结果：</p><pre><code>replacement == AxAyAz  replacement == Axayaz  replacement == AdAeAf  replacement == Adaeaf </code></pre><h2 id="regex-search"><a href="#regex-search" class="headerlink" title="regex_search"></a><code>regex_search</code></h2><pre><code>// std__regex__regex_search.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       const char *first = &quot;abcd&quot;;       const char *last = first + strlen(first);       std::cmatch mr;       std::regex rx(&quot;abc&quot;);       std::regex_constants::match_flag_type fl =           std::regex_constants::match_default;       std::cout &lt;&lt; &quot;search(f, f+1, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(first, first + 1, rx, fl) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(f, l, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(first, last, mr, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(\&quot;a\&quot;, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(&quot;a&quot;, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(\&quot;xabcd\&quot;, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(&quot;xabcd&quot;, mr, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;search(string, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(std::string(&quot;a&quot;), rx) &lt;&lt; std::endl;       std::string str(&quot;abcabc&quot;);       std::match_results&lt;std::string::const_iterator&gt; mr2;       std::cout &lt;&lt; &quot;search(string, \&quot;abc\&quot;) == &quot; &lt;&lt; std::boolalpha           &lt;&lt; regex_search(str, mr2, rx) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;  matched: \&quot;&quot; &lt;&lt; mr2.str() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;       return (0);   }</code></pre><h2 id="match-results"><a href="#match-results" class="headerlink" title="match_results"></a><code>match_results</code></h2><pre><code>// std__regex__match_results_begin.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex rx(&quot;c(a*)|(b)&quot;);       std::cmatch mr;       std::regex_search(&quot;xcaaay&quot;, mr, rx);       std::cout &lt;&lt; &quot;prefix: matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; mr.prefix().matched           &lt;&lt; &quot;, value == &quot; &lt;&lt; mr.prefix() &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;whole match: &quot; &lt;&lt; mr.length() &lt;&lt; &quot; chars, value == &quot;           &lt;&lt; mr.str() &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;suffix: matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; mr.suffix().matched           &lt;&lt; &quot;, value == &quot; &lt;&lt; mr.suffix() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;       std::string fmt(&quot;\&quot;c(a*)|(b)\&quot; matched \&quot;$0\&quot;\n&quot;           &quot;\&quot;(a*)\&quot; matched \&quot;$1\&quot;\n&quot;           &quot;\&quot;(b)\&quot; matched \&quot;$2\&quot;\n&quot;);       std::cout &lt;&lt; mr.format(fmt) &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // index through submatches       for (size_t n = 0; n &lt; mr.size(); ++n)           {           std::cout &lt;&lt; &quot;submatch[&quot; &lt;&lt; n &lt;&lt; &quot;]: matched == &quot; &lt;&lt; std::boolalpha               &lt;&lt; mr[n].matched &lt;&lt;               &quot; at position &quot; &lt;&lt; mr.position(n) &lt;&lt; std::endl;           std::cout &lt;&lt; &quot;  &quot; &lt;&lt; mr.length(n)               &lt;&lt; &quot; chars, value == &quot; &lt;&lt; mr[n] &lt;&lt; std::endl;           }       std::cout &lt;&lt; std::endl;   // iterate through submatches       for (std::cmatch::iterator it = mr.begin(); it != mr.end(); ++it)           {           std::cout &lt;&lt; &quot;next submatch: matched == &quot; &lt;&lt; std::boolalpha               &lt;&lt; it-&gt;matched &lt;&lt; std::endl;           std::cout &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;length()               &lt;&lt; &quot; chars, value == &quot; &lt;&lt; *it &lt;&lt; std::endl;           }       std::cout &lt;&lt; std::endl;   // other members       std::cmatch mr1(mr);       mr = mr1;       mr.swap(mr1);       char buf[10];    *mr.format(&amp;buf[0], &quot;&lt;$0&gt;&quot;) = &apos;\0&apos;;       std::cout &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;empty == &quot; &lt;&lt; std::boolalpha &lt;&lt; mr.empty() &lt;&lt; std::endl;       std::cmatch::allocator_type al = mr.get_allocator();       std::cmatch::string_type str = std::string(&quot;x&quot;);       std::cmatch::size_type maxsiz = mr.max_size();       std::cmatch::char_type ch = &apos;x&apos;;       std::cmatch::difference_type dif = mr.begin() - mr.end();       std::cmatch::const_iterator cit = mr.begin();       std::cmatch::value_type val = *cit;       std::cmatch::const_reference cref = val;       std::cmatch::reference ref = val;       maxsiz = maxsiz;  // to quiet &quot;unused&quot; warnings       if (ref == cref)           ch = ch;       dif = dif;       return (0);       }</code></pre><h2 id="sub-match"><a href="#sub-match" class="headerlink" title="sub_match"></a><code>sub_match</code></h2><pre><code>// std__regex__sub_match_compare.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex rx(&quot;c(a*)|(b)&quot;);       std::cmatch mr;       std::regex_search(&quot;xcaaay&quot;, mr, rx);       std::csub_match sub = mr[1];       std::cout &lt;&lt; &quot;matched == &quot; &lt;&lt; std::boolalpha           &lt;&lt; sub.matched &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;length == &quot; &lt;&lt; sub.length() &lt;&lt; std::endl;       std::csub_match::difference_type dif = std::distance(sub.first, sub.second);       std::cout &lt;&lt; &quot;difference == &quot; &lt;&lt; dif &lt;&lt; std::endl;       std::csub_match::iterator first = sub.first;       std::csub_match::iterator last = sub.second;       std::cout &lt;&lt; &quot;range == &quot; &lt;&lt; std::string(first, last)           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;string == &quot; &lt;&lt; sub &lt;&lt; std::endl;       std::csub_match::value_type *ptr = &quot;aab&quot;;       std::cout &lt;&lt; &quot;compare(\&quot;aab\&quot;) == &quot;           &lt;&lt; sub.compare(ptr) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;compare(string) == &quot;           &lt;&lt; sub.compare(std::string(&quot;AAA&quot;)) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;compare(sub) == &quot;           &lt;&lt; sub.compare(sub) &lt;&lt; std::endl;       return (0);       }</code></pre><h2 id="regex-error"><a href="#regex-error" class="headerlink" title="regex_error"></a><code>regex_error</code></h2><pre><code>// std__regex__regex_error_code.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   int main()       {       std::regex_error paren(std::regex_constants::error_paren);       try           {           std::regex rx(&quot;(a&quot;);           }       catch (const std::regex_error&amp; rerr)           {           std::cout &lt;&lt; &quot;regex error: &quot;               &lt;&lt; (rerr.code() == paren.code()                    &quot;unbalanced parentheses&quot; : &quot;&quot;)               &lt;&lt; std::endl;           }       catch (...)           {           std::cout &lt;&lt; &quot;unknown exception&quot; &lt;&lt; std::endl;           }       return (0);       }</code></pre><h2 id="regex-iterator"><a href="#regex-iterator" class="headerlink" title="regex_iterator"></a><code>regex_iterator</code></h2><pre><code>// std__regex__regex_iterator_difference_type.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_iterator&lt;const char *&gt; Myiter;   int main()       {       const char *pat = &quot;axayaz&quot;;       Myiter::regex_type rx(&quot;a&quot;);       Myiter next(pat, pat + strlen(pat), rx);       Myiter end;       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;   // other members       Myiter it1(pat, pat + strlen(pat), rx);       Myiter it2(it1);       next = it1;       Myiter::iterator_category cat = std::forward_iterator_tag();       Myiter::difference_type dif = -3;       Myiter::value_type mr = *it1;       Myiter::reference ref = mr;       Myiter::pointer ptr = &amp;ref;       dif = dif; // to quiet &quot;unused&quot; warnings       ptr = ptr;       return (0);       }</code></pre><h2 id="regex-token-iterator"><a href="#regex-token-iterator" class="headerlink" title="regex_token_iterator"></a><code>regex_token_iterator</code></h2><pre><code>#include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_token_iterator&lt;const char *&gt; Myiter;   int main()       {       const char *pat = &quot;aaxaayaaz&quot;;       Myiter::regex_type rx(&quot;(a)a&quot;);       Myiter next(pat, pat + strlen(pat), rx);       Myiter end;   // show whole match       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefix before match       next = Myiter(pat, pat + strlen(pat), rx, -1);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show (a) submatch only       next = Myiter(pat, pat + strlen(pat), rx, 1);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefixes and submatches       std::vector&lt;int&gt; vec;       vec.push_back(-1);       vec.push_back(1);       next = Myiter(pat, pat + strlen(pat), rx, vec);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // show prefixes and whole matches       int arr[] = {-1, 0};       next = Myiter(pat, pat + strlen(pat), rx, arr);       for (; next != end; ++next)           std::cout &lt;&lt; &quot;match == &quot; &lt;&lt; next-&gt;str() &lt;&lt; std::endl;       std::cout &lt;&lt; std::endl;   // other members       Myiter it1(pat, pat + strlen(pat), rx);       Myiter it2(it1);       next = it1;       Myiter::iterator_category cat = std::forward_iterator_tag();       Myiter::difference_type dif = -3;       Myiter::value_type mr = *it1;       Myiter::reference ref = mr;       Myiter::pointer ptr = &amp;ref;       dif = dif; // to quiet &quot;unused&quot; warnings       ptr = ptr;       return (0);       }</code></pre><h2 id="regex-traits"><a href="#regex-traits" class="headerlink" title="regex_traits"></a><code>regex_traits</code></h2><pre><code>// std__regex__regex_traits_char_class_type.cpp   // compile with: /EHsc   #include &lt;regex&gt;   #include &lt;iostream&gt;   typedef std::regex_traits&lt;char&gt; Mytr;   int main()       {       Mytr tr;       Mytr::char_type ch = tr.translate(&apos;a&apos;);       std::cout &lt;&lt; &quot;translate(&apos;a&apos;) == &apos;a&apos; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (ch == &apos;a&apos;) &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;nocase &apos;a&apos; == &apos;A&apos; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (tr.translate_nocase(&apos;a&apos;) == tr.translate_nocase(&apos;A&apos;))           &lt;&lt; std::endl;       const char *lbegin = &quot;abc&quot;;       const char *lend = lbegin + strlen(lbegin);       Mytr::size_type size = tr.length(lbegin);       std::cout &lt;&lt; &quot;length(\&quot;abc\&quot;) == &quot; &lt;&lt; size &lt;&lt;std::endl;       Mytr::string_type str = tr.transform(lbegin, lend);       std::cout &lt;&lt; &quot;transform(\&quot;abc\&quot;) &lt; \&quot;abc\&quot; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (str &lt; &quot;abc&quot;) &lt;&lt; std::endl;       const char *ubegin = &quot;ABC&quot;;       const char *uend = ubegin + strlen(ubegin);       std::cout &lt;&lt; &quot;primary \&quot;ABC\&quot; &lt; \&quot;abc\&quot; == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (tr.transform_primary(ubegin, uend) &lt;               tr.transform_primary(lbegin, lend))           &lt;&lt; std::endl;       const char *dig = &quot;digit&quot;;       Mytr::char_class_type cl = tr.lookup_classname(dig, dig + 5);       std::cout &lt;&lt; &quot;class digit == d == &quot; &lt;&lt; std::boolalpha           &lt;&lt; (cl == tr.lookup_classname(dig, dig + 1))           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;&apos;3&apos; is digit == &quot; &lt;&lt;std::boolalpha           &lt;&lt; tr.isctype(&apos;3&apos;, tr.lookup_classname(dig, dig + 5))           &lt;&lt; std::endl;       std::cout &lt;&lt; &quot;hex C == &quot; &lt;&lt; tr.value(&apos;C&apos;, 16) &lt;&lt; std::endl;   // other members       str = tr.lookup_collatename(dig, dig + 5);       Mytr::locale_type loc = tr.getloc();       tr.imbue(loc);       return (0);       }</code></pre><h2 id="C-正则表达式库"><a href="#C-正则表达式库" class="headerlink" title="C++正则表达式库"></a>C++正则表达式库</h2><p><a href="http://zh.cppreference.com/w/cpp/regex" target="_blank" rel="noopener">C++正则表达式库</a></p><pre><code>#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;string&gt;#include &lt;regex&gt;int main(){    std::string s = &quot;Some people, when confronted with a problem, think &quot;        &quot;\&quot;I know, I&apos;ll use regular expressions.\&quot; &quot;        &quot;Now they have two problems.&quot;;    std::regex self_regex(&quot;REGULAR EXPRESSIONS&quot;,            std::regex_constants::ECMAScript | std::regex_constants::icase);    if (std::regex_search(s, self_regex)) {        std::cout &lt;&lt; &quot;Text contains the phrase &apos;regular expressions&apos;\n&quot;;    }    std::regex word_regex(&quot;(\\S+)&quot;);    auto words_begin =         std::sregex_iterator(s.begin(), s.end(), word_regex);    auto words_end = std::sregex_iterator();    std::cout &lt;&lt; &quot;Found &quot;              &lt;&lt; std::distance(words_begin, words_end)              &lt;&lt; &quot; words\n&quot;;    const int N = 6;    std::cout &lt;&lt; &quot;Words longer than &quot; &lt;&lt; N &lt;&lt; &quot; characters:\n&quot;;    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {        std::smatch match = *i;        std::string match_str = match.str();        if (match_str.size() &gt; N) {            std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match_str &lt;&lt; &apos;\n&apos;;        }    }    std::regex long_word_regex(&quot;(\\w{7,})&quot;);    std::string new_s = std::regex_replace(s, long_word_regex, &quot;[$&amp;]&quot;);    std::cout &lt;&lt; new_s &lt;&lt; &apos;\n&apos;;}</code></pre><h2 id="ECMA与POSIX区别"><a href="#ECMA与POSIX区别" class="headerlink" title="ECMA与POSIX区别"></a>ECMA与POSIX区别</h2><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;int main(){    std::string str = &quot;zzxayyzz&quot;;    std::regex re1(&quot;.*(a|xayy)&quot;); // ECMA    std::regex re2(&quot;.*(a|xayy)&quot;, std::regex::extended); // POSIX    std::cout &lt;&lt; &quot;Searching for .*(a|xayy) in zzxayyzz:\n&quot;;    std::smatch m;    std::regex_search(str, m, re1);    std::cout &lt;&lt; &quot; ECMA (depth first search) match: &quot; &lt;&lt; m[0] &lt;&lt; &apos;\n&apos;;    std::regex_search(str, m, re2);    std::cout &lt;&lt; &quot; POSIX (leftmost longest)  match: &quot; &lt;&lt; m[0] &lt;&lt; &apos;\n&apos;;}</code></pre><h1 id="boost-regex"><a href="#boost-regex" class="headerlink" title="boost regex"></a>boost regex</h1><p>1 boost::regex_match</p><p>正则表达式匹配</p><p>2 boost::regex_replace</p><p>正则表达式替换</p><p>3 boost::regex_search</p><p>正则表达式检索</p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;void main(){    std::string str = &quot;chinaen 8Glish&quot;;    boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);    //+ 用来表示重复一或多次    //d-digit 任何0-9之间的数字    //s-space 任何空格字符    //u-upper A-Z之间的大写字母。如果设置了地域的话，可能包含其他字符    //w-word 任何单词字符-字母数字下划线    std::cout &lt;&lt; boost::regex_match(str, expr) &lt;&lt; std::endl;//匹配1，不匹配0    boost::smatch what;    if (boost::regex_search(str, what, expr))//正则表达式检索    {        std::cout &lt;&lt; what[0] &lt;&lt; std::endl;        std::cout &lt;&lt; what[1] &lt;&lt; std::endl;        std::cout &lt;&lt; what[2] &lt;&lt; std::endl;        std::cout &lt;&lt; what[3] &lt;&lt; std::endl;    }    else    {        std::cout &lt;&lt; &quot;检索失败&quot; &lt;&lt; std::endl;    }}</code></pre><p>boost::regex_replace</p><p>正则表达式替换</p><p>//s-space 任何空格字符</p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;void main(){    std::string str = &quot;chinaen 8Glish&quot;;    boost::regex expr(&quot;\\s&quot;);//s-space 任何空格字符    std::string tihuan = &quot;____&quot;;    std::cout &lt;&lt; boost::regex_replace(str, expr, tihuan) &lt;&lt; std::endl;//把expr替换}</code></pre><p>以上内容转载：<a href="https://www.cnblogs.com/denggelin/p/5769624.html" target="_blank" rel="noopener">https://www.cnblogs.com/denggelin/p/5769624.html</a></p><p><a href="https://yq.aliyun.com/articles/75580" target="_blank" rel="noopener">Boost学习之正则表达式–regex</a></p><pre><code>#include &lt;iostream&gt;#include &lt;boost/regex.hpp&gt;using namespace std;int main(int argc, char* argv[]){        //( 1 )   ((  3  )  2 )((  5 )4)(    6    )       //(\w+)://((\w+\.)*\w+)((/\w*)*)(/\w+\.\w+)?    //^协议://网址(x.x...x)/路径(n个\字串)/网页文件(xxx.xxx)    const char *szReg = &quot;(\\w+)://((\\w+\\.)*\\w+)((/\\w*)*)(/\\w+\\.\\w+)?&quot;;    const char *szStr = &quot;http://www.cppprog.com/2009/0112/48.html&quot;;    {    //字符串匹配        boost::regex reg( szReg );        bool r=boost::regex_match( szStr , reg);        assert(r);    }    {    //提取子串        boost::cmatch mat;        boost::regex reg( szReg );        bool r=boost::regex_match( szStr, mat, reg);        if(r) //如果匹配成功        {            //显示所有子串            for(boost::cmatch::iterator itr=mat.begin(); itr!=mat.end(); ++itr)            {                //       指向子串对应首位置        指向子串对应尾位置          子串内容                cout &lt;&lt; itr-&gt;first-szStr &lt;&lt; &apos; &apos; &lt;&lt; itr-&gt;second-szStr &lt;&lt; &apos; &apos; &lt;&lt; *itr &lt;&lt; endl;            }        }        //也可直接取指定位置信息        if(mat[4].matched) cout &lt;&lt; &quot;Path is&quot; &lt;&lt; mat[4] &lt;&lt; endl;    }    { //查找        boost::cmatch mat;        boost::regex reg( &quot;\\d+&quot; );    //查找字符串里的数字        if(boost::regex_search(szStr, mat, reg))        {            cout &lt;&lt; &quot;searched:&quot; &lt;&lt; mat[0] &lt;&lt; endl;        }    }    { //替换        boost::regex reg( szReg );        string s = boost::regex_replace( string(szStr), reg, &quot;ftp://$2$5&quot;);        cout &lt;&lt; &quot;ftp site:&quot;&lt;&lt; s &lt;&lt; endl;    }    { //替换2，把&lt;&gt;&amp;转换成网页字符        string s1 = &quot;(&lt;)|(&gt;)|(&amp;)&quot;;        string s2 = &quot;(?1&lt;)(?2&gt;)(?3&amp;)&quot;;        boost::regex reg( s1 );        string s = boost::regex_replace( string(&quot;cout &lt;&lt; a&amp;b &lt;&lt; endl;&quot;), reg, s2, boost::match_default | boost::format_all);        cout &lt;&lt; &quot;HTML:&quot;&lt;&lt; s &lt;&lt; endl;    }    { //使用迭代器找出所有数字        boost::regex reg( &quot;\\d+&quot; );    //查找字符串里的数字        boost::cregex_iterator itrBegin = make_regex_iterator(szStr,reg); //(szStr, szStr+strlen(szStr), reg);        boost::cregex_iterator itrEnd;        for(boost::cregex_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            //       指向子串对应首位置        指向子串对应尾位置          子串内容            cout &lt;&lt; (*itr)[0].first-szStr &lt;&lt; &apos; &apos; &lt;&lt; (*itr)[0].second-szStr &lt;&lt; &apos; &apos; &lt;&lt; *itr &lt;&lt; endl;        }    }    { //使用迭代器拆分字符串        boost::regex reg(&quot;/&quot;);  //按/符拆分字符串        boost::cregex_token_iterator itrBegin = make_regex_token_iterator(szStr,reg,-1); //使用-1参数时拆分，使用其它数字时表示取第几个子串，可使用数组取多个串        boost::cregex_token_iterator itrEnd;        for(boost::cregex_token_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            cout &lt;&lt; *itr &lt;&lt; endl;        }    }    { //使用迭代器拆分字符串2        boost::regex reg(&quot;(.)/(.)&quot;);  //取/的前一字符和后一字符（这个字符串形象貌似有点邪恶-_-）        int subs[] = {1,2};        // 第一子串和第二子串        boost::cregex_token_iterator itrBegin = make_regex_token_iterator(szStr,reg,subs); //使用-1参数时拆分，使用其它数字时表示取第几个子串，可使用数组取多个串        boost::cregex_token_iterator itrEnd;        for(boost::cregex_token_iterator itr=itrBegin; itr!=itrEnd; ++itr)        {            cout &lt;&lt; *itr &lt;&lt; endl;        }    }    cin.get();    return 0;}</code></pre><p><a href="https://blog.csdn.net/leonardwang/article/details/6035171?spm=a2c4e.11153940.blogcont75580.15.3a02b5f4uSDlxO" target="_blank" rel="noopener">正则表达式 boost Regex</a></p><h1 id="NET-正则表达式"><a href="#NET-正则表达式" class="headerlink" title=".NET 正则表达式"></a>.NET 正则表达式</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expressions</a></p><p><a href="http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx" target="_blank" rel="noopener">http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference" target="_blank" rel="noopener">正则表达式语言 - 快速参考</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx" target="_blank" rel="noopener">Regex 类</a></p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="http://www.zjmainstay.cn/regexp-lookaround" target="_blank" rel="noopener">深入理解正则表达式环视的概念与用法</a></p><p><a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">表达式全集</a></p><p><a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></p><p><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="noopener">揭开正则表达式的神秘面纱</a></p><p><a href="http://blog.jobbole.com/96708/" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a></p><p><a href="http://blog.jobbole.com/75188/" target="_blank" rel="noopener">Python正则表达式指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-regex&quot;&gt;&lt;a href=&quot;#c-regex&quot; class=&quot;headerlink&quot; title=&quot;c regex&quot;&gt;&lt;/a&gt;c regex&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;编译正则表达式 &lt;code&gt;regcomp()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配正则
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="正则表达式" scheme="https://caojingyou.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="regex" scheme="https://caojingyou.github.io/tags/regex/"/>
    
      <category term="Boost" scheme="https://caojingyou.github.io/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>zlib</title>
    <link href="https://caojingyou.github.io/2018/04/01/zlib/"/>
    <id>https://caojingyou.github.io/2018/04/01/zlib/</id>
    <published>2018-04-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:18:53.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="http://www.zlib.net/" title="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a></p><p><a href="https://github.com/madler/zlib" title="https://github.com/madler/zlib" target="_blank" rel="noopener">https://github.com/madler/zlib</a></p><p><a href="http://www.zlib.net/fossils/" title="http://www.zlib.net/fossils/" target="_blank" rel="noopener">http://www.zlib.net/fossils/</a></p><p><a href="https://github.com/madler/zlib/archive/v1.2.11.zip" title="https://github.com/madler/zlib/archive/v1.2.11.zip" target="_blank" rel="noopener">zlib1.2.11.zip</a></p><h2 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h2><p>可从此处直接下载：</p><p><a href="http://www.winimage.com/zLibDll" title="http://www.winimage.com/zLibDll" target="_blank" rel="noopener">http://www.winimage.com/zLibDll</a></p><p>解压后，进入到zlib-1.2.11/contrib/masmx86目录，执行bld_ml32.bat。（同理，64位的电脑进入masmx64目录，执行bld_ml64.bat）。这一步运行bld_ml32批处理文件，里面调用ml命令编译inffas32.asm和match686.asm，生成inffas32.obj和match686.obj（生成在本目录下）。这两个文件在zlibvc中用到。</p><p>实际已提供了在vc下编译的工程，目录为：zlib-1.2.11\contrib\vstudio.此项目的生成事件中已经执行了bld_ml32.bat</p><p>  其中的zlibstat是编译为静态库，zlibvc是编译为动态库。</p><p>如果报错：</p><p>fatal error LNK1281: 无法生成 SAFESEH 映像。</p><p>修改配置-连接器-高级-映像具有安全异常处理程序，改成“否(/SAFESEH:NO)”</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="使用zlib静态库：zlibstat-lib"><a href="#使用zlib静态库：zlibstat-lib" class="headerlink" title="使用zlib静态库：zlibstat.lib"></a>使用zlib静态库：zlibstat.lib</h3><ol><li><p>包含头文件</p><p> 属性–C/C++–常规–附加包含目录（添加包含.h文件的目录）</p></li><li><p>定义宏</p><p> 属性–C/C++–预处理器–预处理器定义：添加 ZLIB_WINAPI ASMV ASMINF</p></li><li><p>项目包含.lib文件所在的目录：</p><p> 属性–链接器–常规–附加库目录</p></li><li><p>项目包含.lib文件</p><p> 属性–链接器–输入–附加依赖项（libstat.lib）</p></li><li><p>项目代码中 #include “zlib.h”</p></li></ol><p>编译生成.exe即可使用。</p><h3 id="使用动态库-zlibwapi-lib"><a href="#使用动态库-zlibwapi-lib" class="headerlink" title="使用动态库 zlibwapi.lib"></a>使用动态库 zlibwapi.lib</h3><ol><li><p>包含头文件</p><p> 属性–C/C++–常规–附加包含目录（添加包含.h的目录）</p></li><li><p>定义宏</p><p> 属性–C/C++–预处理器–预处理器定义：添加 ZLIB_WINAPI</p></li><li><p>项目包含.lib文件所在的目录：</p><p> 属性–链接器–常规–附加库目录</p></li><li><p>项目包含.lib文件</p><p> 属性–链接器–输入–附加依赖项（zlibwapi.lib）</p></li><li><p>项目代码中 #include “zlib.h”</p></li></ol><p>编译生成.exe文件需要.dll文件支持（动态加载）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zlib&quot;&gt;&lt;a href=&quot;#zlib&quot; class=&quot;headerlink&quot; title=&quot;zlib&quot;&gt;&lt;/a&gt;zlib&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=&quot;下载：&quot;&gt;&lt;/a&gt;下载
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="zlib" scheme="https://caojingyou.github.io/tags/zlib/"/>
    
      <category term="解压缩" scheme="https://caojingyou.github.io/tags/%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>tesseract-ocr</title>
    <link href="https://caojingyou.github.io/2018/03/26/tesseract-ocr/"/>
    <id>https://caojingyou.github.io/2018/03/26/tesseract-ocr/</id>
    <published>2018-03-26T09:01:00.000Z</published>
    <updated>2018-03-26T09:52:57.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中文OCR"><a href="#Python-中文OCR" class="headerlink" title="Python 中文OCR"></a>Python 中文OCR</h1><p><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></p><p><a href="https://digi.bib.uni-mannheim.de/tesseract/doc/" target="_blank" rel="noopener">https://digi.bib.uni-mannheim.de/tesseract/doc/</a></p><p><a href="https://blog.csdn.net/wwj_748/article/details/78109680?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Python 中文OCR</a></p><p>Tesseract的OCR引擎目前已作为开源项目发布在Google Project，其项目主页在这里查看<a href="https://github.com/tesseract-ocr" target="_blank" rel="noopener">https://github.com/tesseract-ocr</a>，<br>它支持中文OCR，并提供了一个命令行工具。python中对应的包是pytesseract. 通过这个工具我们可以识别图片上的文字。</p><h1 id="tesseract安装"><a href="#tesseract安装" class="headerlink" title="tesseract安装"></a>tesseract安装</h1><p><a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki</a></p><p><a href="https://github.com/UB-Mannheim/tesseract/wiki" target="_blank" rel="noopener">https://github.com/UB-Mannheim/tesseract/wiki</a></p><p><a href="https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html</a></p><p>需要把安装路径设置到环境变量中</p><h1 id="运行-Tesseract"><a href="#运行-Tesseract" class="headerlink" title="运行 Tesseract"></a>运行 Tesseract</h1><p>Tesseract 是 命令行 程序 ， 那么 第一 终端 或者 打开 一个 命令 提示 。 在 命令 使用 过程 是 这样 的 ：</p><pre><code>tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</code></pre><p>结果 保存 到  out.txt </p><pre><code>tesseract myscan.png out</code></pre><p> 用于 多个 语言</p><pre><code>tesseract myscan.png out -l eng+deu</code></pre><p><a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc" target="_blank" rel="noopener">其他各种选项</a></p><p>1.jpg是当前目录中的1.jpg图片</p><p>1.txt是指定结果输出到文本文件</p><p>-l是指定使用的包</p><p>chi_sim是中文识别包，equ是数学公式包，eng是英文包</p><pre><code>tesseract 1.jpg 1.txt -l chi_sim+equ+eng</code></pre><h1 id="其他-语言"><a href="#其他-语言" class="headerlink" title="其他 语言"></a>其他 语言</h1><p><a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">语言 tessdata 储存库 </a></p><h1 id="训练语言"><a href="#训练语言" class="headerlink" title="训练语言"></a>训练语言</h1><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract</a></p><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00</a></p><p><a href="https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/" title="jTessBoxEditor" target="_blank" rel="noopener">jTessBoxEditor</a></p><p><a href="https://blog.csdn.net/cn_wk/article/details/52280567" target="_blank" rel="noopener">https://blog.csdn.net/cn_wk/article/details/52280567</a></p><p><a href="http://www.bkjia.com/Pythonjc/1131343.html" target="_blank" rel="noopener">http://www.bkjia.com/Pythonjc/1131343.html</a></p><p><a href="https://github.com/tesseract-ocr/tesseract/wiki/AddOns" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/AddOns</a></p><p><a href="http://zdenop.github.io/qt-box-editor/" target="_blank" rel="noopener">http://zdenop.github.io/qt-box-editor/</a></p><p><a href="https://www.cnblogs.com/cnlian/p/5765871.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnlian/p/5765871.html</a></p><p>大体流程为：安装jTessBoxEditor -&gt; 获取样本文件 -&gt; Merge样本文件 –&gt; 生成BOX文件 -&gt; 定义字符配置文件 -&gt; 字符矫正 -&gt; 执行批处理文件 -&gt; 将生成的traineddata放入tessdata中</p><p><a href="https://jingyan.baidu.com/article/cdddd41c90544f53cb00e1c3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/cdddd41c90544f53cb00e1c3.html</a></p><p><a href="https://blog.csdn.net/woaipangruimao/article/details/78741022" target="_blank" rel="noopener">https://blog.csdn.net/woaipangruimao/article/details/78741022</a></p><h1 id="python-pytesseract"><a href="#python-pytesseract" class="headerlink" title="python pytesseract"></a>python pytesseract</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014320027235877860c87af5544f25a8deeb55141d60c5000" target="_blank" rel="noopener">Pillow</a></p><p><a href="https://pillow.readthedocs.org/" target="_blank" rel="noopener">https://pillow.readthedocs.org/</a></p><p><a href="https://pypi.python.org/pypi/pytesseract" target="_blank" rel="noopener">https://pypi.python.org/pypi/pytesseract</a></p><pre><code>pip install pytesseractpip install pillow</code></pre><p>code:</p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-import pytesseractfrom PIL import Imagepytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos;# open imageimage = Image.open(&apos;test.png&apos;)code = pytesseract.image_to_string(image, lang=&apos;chi_sim&apos;)print(code)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-中文OCR&quot;&gt;&lt;a href=&quot;#Python-中文OCR&quot; class=&quot;headerlink&quot; title=&quot;Python 中文OCR&quot;&gt;&lt;/a&gt;Python 中文OCR&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/te
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
      <category term="tesseract" scheme="https://caojingyou.github.io/tags/tesseract/"/>
    
      <category term="ocr" scheme="https://caojingyou.github.io/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>C#调用C++</title>
    <link href="https://caojingyou.github.io/2018/03/21/CShap%E8%B0%83%E7%94%A8C++/"/>
    <id>https://caojingyou.github.io/2018/03/21/CShap调用C++/</id>
    <published>2018-03-21T01:53:00.000Z</published>
    <updated>2018-04-13T07:21:38.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="互操作"><a href="#互操作" class="headerlink" title="互操作"></a>互操作</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms177552(v=vs.90" target="_blank" rel="noopener">互操作</a>.aspx)<br>包含以下内容：</p><ul><li>CLR/本机互操作性</li><li>C++ Interop</li><li>COM 互操作</li><li>P/Invoke</li><li>C++ 支持库</li><li>在 MFC 中使用 Windows 窗体</li></ul><h1 id="P-Invoke"><a href="#P-Invoke" class="headerlink" title="P/Invoke"></a>P/Invoke</h1><p><a href="https://baike.baidu.com/item/P%2FInvoke/9872691?fr=aladdin" target="_blank" rel="noopener">P/Invoke</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/aa686045.aspx" title="https://msdn.microsoft.com/zh-cn/library/aa686045.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/aa686045.aspx</a></p><p><a href="https://www.zhihu.com/question/55901875" title="https://www.zhihu.com/question/55901875" target="_blank" rel="noopener">https://www.zhihu.com/question/55901875</a></p><h1 id="C-CLI"><a href="#C-CLI" class="headerlink" title="C++/CLI"></a>C++/CLI</h1><p><a href="https://baike.baidu.com/item/C++%2FCLI/8375456?fr=aladdin" target="_blank" rel="noopener">C++/CLI</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx</a>.aspx “<a href="https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms235281(v=vs.90).aspx</a>“)</p><p><a href="http://www.cnblogs.com/TianFang/p/4946049.html" title="http://www.cnblogs.com/TianFang/p/4946049.html" target="_blank" rel="noopener">http://www.cnblogs.com/TianFang/p/4946049.html</a></p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/2x8kf7zx(v=vs.120" target="_blank" rel="noopener">使用 C++ 互操作（隐式 PInvoke）</a>.aspx “使用 C++ 互操作（隐式 PInvoke）”)</p><p><a href="https://msdn.microsoft.com/zh-cn/library/eyzhw3s8(v=vs.120" target="_blank" rel="noopener">在 C++ 中使用显式 PInvoke（DllImport 特性）</a>.aspx)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;互操作&quot;&gt;&lt;a href=&quot;#互操作&quot; class=&quot;headerlink&quot; title=&quot;互操作&quot;&gt;&lt;/a&gt;互操作&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/ms177552(v=vs.90
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Photoshop插件开发</title>
    <link href="https://caojingyou.github.io/2018/03/20/Adobe%20Photoshop%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://caojingyou.github.io/2018/03/20/Adobe Photoshop插件开发/</id>
    <published>2018-03-20T01:53:00.000Z</published>
    <updated>2018-09-30T08:34:23.306Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.adobe.com/devnet/photoshop/sdk.html" title="https://www.adobe.com/devnet/photoshop/sdk.html" target="_blank" rel="noopener">Photoshop SDK</a></p><p>查看<code>SDK\document.html</code>文章</p><h1 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h1><p>Photoshopapi文件夹：包含了c/c++头文件、源文件、资源文件，定义了在插件开发中需要的结构、常量、函数。</p><p>Samplecode文件夹：保护了每一种类插件的示例源代码。</p><p>Documentation文件夹：包含了各种插件开发相关的文档，这里是开发的主要学习材料和api文档来源。</p><h1 id="为Photoshop制作64位Windows插件-SixtyFour-html"><a href="#为Photoshop制作64位Windows插件-SixtyFour-html" class="headerlink" title="为Photoshop制作64位Windows插件-SixtyFour.html"></a>为Photoshop制作64位Windows插件-SixtyFour.html</h1><h1 id="用于构建Photoshop和SDK示例的工具的详细信息-buildinfo-html"><a href="#用于构建Photoshop和SDK示例的工具的详细信息-buildinfo-html" class="headerlink" title="用于构建Photoshop和SDK示例的工具的详细信息-buildinfo.html"></a>用于构建Photoshop和SDK示例的工具的详细信息-buildinfo.html</h1><p>Photoshop 18.0 - CC 2017</p><p>Windows是使用64位工具链和以下版本在Windows 7 64位SP 1计算机上构建的：Microsoft Visual Studio 2015版本14.0.24720.0。更新3<br>OS X构建于OS X 10.10.5计算机上使用Xcode 7.2.1（7C1002），基本SDK 10.11，OS X部署目标10.10</p><h2 id="PS插件开发简介"><a href="#PS插件开发简介" class="headerlink" title="PS插件开发简介"></a><a href="https://blog.csdn.net/jize00/article/details/8638056" target="_blank" rel="noopener">PS插件开发简介</a></h2><p> 入门首先需要学习两个插件：getter 和 listener，它们在samplecode\automation目录下</p><p>getter插件：打开samplecode\automation\getter\win\getter.sln，编译生成插件，放到PS插件目录下试下（你也可以将Output里插件目录设置为PS的增效工具目录），运行PS-&gt;文件-&gt;自动-&gt;getter，然后你会发现桌面上多了个getter.log，该插件的主要目的就是把你当前在PS里打开的文件、图层信息及函数调用方法输出到log里去，所以当你不知道如何获取某个信息时，查找getter.log里对应的函数</p><p>listener插件：该插件的作用是监听PS里的大部分操作和事件的函数调用过程，并输出到桌面上的listerner.log里，比如你要复制剪切某一图层，而且不知道如何用函数实现它的时候，先使用listener插件，打开PS对图层进行一次复制剪切操作，然后打开listener.log，代码就在那</p><h3 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h3><p>每个插件里都有个AutoPluginMain，其实就是DLL入口，所谓的插件其实就是个DLL，找几个插件，在AutoPluginMain里加个断点，跟踪一下，看看这些插件都干了些什么</p><p>有些插件自带弹框界面，可以用资源管理器编辑，用DialogBoxParam创建你自定义的界面，参考listener里的DoUI函数，makenew里的DoAbout等</p><p>几乎所有的API函数都会返回一个SPErr，表示函数调用正确与否</p><p>所有的操作都需要有个PIActionDescriptor，可以创建（sPSActionDescriptor-&gt;make()）或获取（PIUGetInfo()）</p><p>sPSActionDescriptor是一个接口指针，可以从中获取PIActionDescriptor信息（下面简称desc）以及执行一些操作</p><p>sPSActionReference是一个接口指针，用来封装一些信息到desc中，（下面简称refer）</p><p>sPSActionControl是一个接口指针，用来Play各种事件</p><p>如果要获取信息，可以使用PIUGetInfo系列函数（在PIUGet.h中定义）</p><h2 id="Photoshop插件开发"><a href="#Photoshop插件开发" class="headerlink" title="Photoshop插件开发"></a><a href="https://blog.csdn.net/yiyi31130108/article/details/38924993" target="_blank" rel="noopener">Photoshop插件开发</a></h2><p>探索SDK</p><p>Plug-In SDK：开发者可以使用这个SDK来创建插件和扩展Adobe Photoshop CC的功能。</p><p>Connection SDK：使用这个SDK，开发者可以创建和使得APP能操控或与PhotoshopCC通信。</p><h1 id="InDesign"><a href="#InDesign" class="headerlink" title="InDesign"></a>InDesign</h1><p><a href="https://www.adobe.com/devnet/indesign/sdk.html" target="_blank" rel="noopener">https://www.adobe.com/devnet/indesign/sdk.html</a></p><p><a href="https://www.adobe.com/devnet/indesign/sdk/eula_cs6.html" target="_blank" rel="noopener">https://www.adobe.com/devnet/indesign/sdk/eula_cs6.html</a></p><p>界面：</p><p>ODFRC语言做界面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.adobe.com/devnet/photoshop/sdk.html&quot; title=&quot;https://www.adobe.com/devnet/photoshop/sdk.html&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Photoshop插件" scheme="https://caojingyou.github.io/tags/Photoshop%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins</title>
    <link href="https://caojingyou.github.io/2018/03/02/Jenkins/"/>
    <id>https://caojingyou.github.io/2018/03/02/Jenkins/</id>
    <published>2018-03-02T01:53:00.000Z</published>
    <updated>2018-04-13T07:19:36.684Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a></p><p><a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/solutions/c/</a></p><p><a href="https://www.cnblogs.com/huangenai/p/7416322.html" target="_blank" rel="noopener">记密码解决方法</a></p><h1 id="安装-MSBuild-plugin"><a href="#安装-MSBuild-plugin" class="headerlink" title="安装 MSBuild plugin"></a>安装 MSBuild plugin</h1><p>在 Jenkins 管理页面中，点击[插件管理]进入插件管理页面，切换到[可选插件]页签，在右上角搜索框中输入 MSBuild 找到 MSBuild Plugin，点击[直接安装]按钮开始安装</p><p>安装好之后，就会在[已安装]页签找到 MSBuild Plugin。<br>回到 Jenkins 管理页面中，点击[Global Tool Configuration]，进入全局工具设置页面。</p><p>找到[MSBuild]栏目，点击[新增MSBuild]按钮，[Name]随意填写，使用MSBuild 14.0。[Path to MSBuild]填写MSBuild.exe所在的实际路径。</p><p>.\build\src\AppName.sln</p><p>/t:rebuild /p:configuration=”Release”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Jenkins" scheme="https://caojingyou.github.io/tags/Jenkins/"/>
    
      <category term="自动构建" scheme="https://caojingyou.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>WPF读写config配置文件</title>
    <link href="https://caojingyou.github.io/2018/03/01/WPF%E8%AF%BB%E5%86%99config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2018/03/01/WPF读写config配置文件/</id>
    <published>2018-03-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:08:08.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h1><p>在引用里添加</p><pre><code>System.Configuration</code></pre><p>如果你想给程序配置一些参数，就在app.config文件<configuration>标签中添加<appsettings>.例如下面：</appsettings></configuration></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;  &lt;configuration&gt;    &lt;appSettings&gt;      &lt;add key=&quot;Path&quot; value=&quot;D:\&quot;/&gt;      &lt;add key=&quot;NAME&quot; value=&quot;123&quot;/&gt;    &lt;/appSettings&gt;  &lt;/configuration&gt;</code></pre><p>读操作：</p><pre><code>string strPath = ConfigurationManager.AppSettings[&quot;Path&quot;]; </code></pre><p>写操作：</p><pre><code>Configuration cfa = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); cfa.AppSettings.Settings[&quot;NAME&quot;].Value = &quot;WANGLICHAO&quot;; cfa.Save(); </code></pre><p>是配置立刻起作用：</p><pre><code>Save()</code></pre><p>后加</p><pre><code>ConfigurationManager.RefreshSection(&quot;appSettings&quot;);</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://www.cnblogs.com/fei12/p/3331100.html" target="_blank" rel="noopener">WPF读写config配置文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设置：&quot;&gt;&lt;a href=&quot;#设置：&quot; class=&quot;headerlink&quot; title=&quot;设置：&quot;&gt;&lt;/a&gt;设置：&lt;/h1&gt;&lt;p&gt;在引用里添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.Configuration
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你想给程序
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="WPF" scheme="https://caojingyou.github.io/tags/WPF/"/>
    
      <category term="配置文件" scheme="https://caojingyou.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>VA Snippet 与 代码片段管理器</title>
    <link href="https://caojingyou.github.io/2018/02/21/VA%20Snippet%20%E4%B8%8E%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>https://caojingyou.github.io/2018/02/21/VA Snippet 与 代码片段管理器/</id>
    <published>2018-02-21T08:03:00.000Z</published>
    <updated>2018-04-12T06:24:19.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VA-Snippet"><a href="#VA-Snippet" class="headerlink" title="VA Snippet"></a>VA Snippet</h1><p><a href="http://docs.wholetomato.com/default.asp?W171" target="_blank" rel="noopener">Introduction to VA Snippets</a></p><h2 id="备份VA-Snippet-tpl文件"><a href="#备份VA-Snippet-tpl文件" class="headerlink" title="备份VA Snippet.tpl文件"></a>备份VA Snippet.tpl文件</h2><p>Backup your current VA Snippets, for the programming languages of interest. You can find your VA Snippets in .tpl files in:</p><pre><code>%APPDATA%\VisualAssist\Autotext\</code></pre><h1 id="代码片段管理器"><a href="#代码片段管理器" class="headerlink" title="代码片段管理器"></a>代码片段管理器</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VA-Snippet&quot;&gt;&lt;a href=&quot;#VA-Snippet&quot; class=&quot;headerlink&quot; title=&quot;VA Snippet&quot;&gt;&lt;/a&gt;VA Snippet&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://docs.wholetomato.com/d
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VS" scheme="https://caojingyou.github.io/tags/VS/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="代码片段" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>C#用到的库</title>
    <link href="https://caojingyou.github.io/2018/02/15/CShap%E7%94%A8%E5%88%B0%E8%BF%87%E7%9A%84%E5%BA%93/"/>
    <id>https://caojingyou.github.io/2018/02/15/CShap用到过的库/</id>
    <published>2018-02-15T08:03:00.000Z</published>
    <updated>2018-09-05T03:05:39.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扁平化界面"><a href="#扁平化界面" class="headerlink" title="扁平化界面"></a>扁平化界面</h1><p>MahApps.Metro</p><p>MahApps.Metro.IconPacks</p><p>MahApps.Metro.Resources</p><h1 id="系统托盘图标"><a href="#系统托盘图标" class="headerlink" title="系统托盘图标"></a>系统托盘图标</h1><p>WPF NotifyIcon</p><h1 id="Json-NET"><a href="#Json-NET" class="headerlink" title="Json.NET"></a>Json.NET</h1><p>Json.NET可序列化和反序列化、可以转成xml</p><h1 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h1><p>Entity Framework</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Nlog</p><p>log4net</p><p>Serilog</p><h1 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h1><p>MailKit<br>与<br>MimeKit</p><h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p>EasyHttp</p><p>httplib好用</p><h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><p>Epplus</p><p>NPIO</p><h1 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h1><p>TaskScheduler</p><p>TaskSchedulerEditor</p><h1 id="待研究的库"><a href="#待研究的库" class="headerlink" title="待研究的库"></a>待研究的库</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>NUnit</p><h2 id="界面库"><a href="#界面库" class="headerlink" title="界面库"></a>界面库</h2><p>MaterialDesignInXamlToolkit</p><p>Fluent.Ribbon</p><h1 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h1><p>SharpZipLib</p><p>DotNetZip</p><p><a href="https://blog.miniasp.com/post/2009/01/11/Introduce-SharpZipLib-and-DotNetZip-Library-for-NET.aspx" target="_blank" rel="noopener">https://blog.miniasp.com/post/2009/01/11/Introduce-SharpZipLib-and-DotNetZip-Library-for-NET.aspx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扁平化界面&quot;&gt;&lt;a href=&quot;#扁平化界面&quot; class=&quot;headerlink&quot; title=&quot;扁平化界面&quot;&gt;&lt;/a&gt;扁平化界面&lt;/h1&gt;&lt;p&gt;MahApps.Metro&lt;/p&gt;
&lt;p&gt;MahApps.Metro.IconPacks&lt;/p&gt;
&lt;p&gt;MahApp
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
      <category term="扁平化" scheme="https://caojingyou.github.io/tags/%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    
      <category term="Json.NET" scheme="https://caojingyou.github.io/tags/Json-NET/"/>
    
      <category term="log4net" scheme="https://caojingyou.github.io/tags/log4net/"/>
    
      <category term="Nlog" scheme="https://caojingyou.github.io/tags/Nlog/"/>
    
      <category term="MailKit" scheme="https://caojingyou.github.io/tags/MailKit/"/>
    
      <category term="EasyHttp" scheme="https://caojingyou.github.io/tags/EasyHttp/"/>
    
      <category term="httplib" scheme="https://caojingyou.github.io/tags/httplib/"/>
    
      <category term="Epplus" scheme="https://caojingyou.github.io/tags/Epplus/"/>
    
      <category term="NPIO" scheme="https://caojingyou.github.io/tags/NPIO/"/>
    
      <category term="TaskScheduler" scheme="https://caojingyou.github.io/tags/TaskScheduler/"/>
    
      <category term="NUnit" scheme="https://caojingyou.github.io/tags/NUnit/"/>
    
      <category term="MaterialDesignInXamlToolkit" scheme="https://caojingyou.github.io/tags/MaterialDesignInXamlToolkit/"/>
    
      <category term="Fluent.Ribbon" scheme="https://caojingyou.github.io/tags/Fluent-Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>libcur</title>
    <link href="https://caojingyou.github.io/2018/02/12/libcur%E4%BD%BF%E7%94%A8/"/>
    <id>https://caojingyou.github.io/2018/02/12/libcur使用/</id>
    <published>2018-02-12T08:03:00.000Z</published>
    <updated>2018-08-27T05:45:38.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h1><p><code>curl-curl-7_54_0.zip</code></p><p><a href="https://curl.haxx.se/download.html" title="https://curl.haxx.se/download.html" target="_blank" rel="noopener">https://curl.haxx.se/download.html</a></p><h1 id="github"><a href="#github" class="headerlink" title="github:"></a>github:</h1><p><a href="https://github.com/curl/curl" title="https://github.com/curl/curl" target="_blank" rel="noopener">https://github.com/curl/curl</a></p><h1 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>运行：curl\projects\generate.bat，生成vs工具可以打开的文件。</p><p>具体读取文件：README</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>在目录curl\winbuild\BUILD.WINDOWS.txt文件中，详细介绍了使用nmake编译windows下curl及libcurl库的相关命令</p><p>curl-7.59.0可以使用nmake编译</p><p>cmd下进入到vs安装路径\VC\Bin下，执行vcvars32,此时会执行vcvas32.bat自动为vs设置环境变量</p><h2 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h2><p>编译curl主要有两种ssl模式，默认是基于windows的winssl编译，另一种是基于openssl加密库。</p><p>一、curl+winssl</p><p>命令：</p><pre><code>nmake /f Makefile.vc mode=static vc=14</code></pre><p>生成：</p><pre><code>libcurl-vc14-x86-release-static-ipv6-sspi-winssl</code></pre><p>这时默认使用SSPI、IDN、WINSSL等技术，编译后使用windows系统自带的CA数字证书文件、ssl加密库winssl(Schannel and Secure Transport)，这种编译方式有很多优点，一是因为使用windows自带的加密库，没有跨平台等考虑因素，性能自然是最优的；二是不用引入第三方库openssl，也不需要显示设置https CA数字证书文件或者打包根证书到软件中。但是缺点也是很明显的，因为windows有很多系统版本，不同版本的ssl有较大区别，早期windows上的ssl安全性能没那么高；最严重的一个问题是，windows xp及以下系统在国内用户量还是很大的，而windows xp不支持SNI技术，如果服务器使用了SNI技术，而且同一个域名配置了多个证书，有可能导致返回证书错误，导致https访问失败。</p><p>SNI：Server Name Indication，是为了应对虚拟服务器技术的兴起而产生的，就是允许同一台服务器布置多个域名，在发起https请求的时候，会将请求的域名加到https请求头中，服务端收到请求后，根据请求头中的域名返回对应的根证书。</p><p>WinSSL:</p><pre><code>void winssl_Https() {     CURLcode res;     CURL* curl = curl_easy_init();     　　if(NULL == curl)     {         return CURLE_FAILED_INIT;     }     //...    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);//winssl编译时使用windows自带的根证书    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);  　//...　　curl_easy_cleanup(curl);}</code></pre><p>二、curl+openssl</p><p>命令：</p><pre><code>nmake /f Makefile.vc mode=dll VC＝10 WITH_DEVEL=OpenSLL编译目录 ENABLE_SSPI=no ENABLE_WINSSL=no </code></pre><p>这种编译方式，首先得下载OpenSSL源码或者已经编译好的OpenSSL库，放到指定目录并设置到参数WITH_DEVEL参数中，具体的编译方式可参考<a href="http://www.cnblogs.com/openiris/p/3812443.html" target="_blank" rel="noopener">http://www.cnblogs.com/openiris/p/3812443.html</a> 。</p><p>基于OpenSSL编译的curl和libcurl，一大优点是使用的较新的SSL加密算法， 安全性较高，而且不需要考虑不同的操作系统SSL库不同导致的各种问题；缺点就是需要单独引入OpenSSL库，需要手动从Mozilla导出根证书，编译到OpenSSL或者打包到软件中，在curl中显示设置加载。 curl官网提供CA数字证书文件下载，地址是<a href="https://curl.haxx.se/ca/cacert.pem,更新地址是https://curl.haxx.se/docs/caextract.html" target="_blank" rel="noopener">https://curl.haxx.se/ca/cacert.pem,更新地址是https://curl.haxx.se/docs/caextract.html</a> 。</p><p> 远程更新CA数字证书命令（证书发生改变了才会下载）：</p><p>curl –remote-name –time-cond cacert.pem </p><p><a href="https://curl.haxx.se/ca/cacert.pem" target="_blank" rel="noopener">https://curl.haxx.se/ca/cacert.pem</a></p><p>OpenSSL:</p><pre><code>void openssl_https(const char * pCaPath) {     CURLcode res;     CURL* curl = curl_easy_init();    　　if(NULL == curl)     {         return CURLE_FAILED_INIT;     } 　　//...　　if(pCaPath){        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);//openssl编译时使用curl官网或者firefox导出的第三方根证书文件         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);        curl_easy_setopt(curl, CURLOPT_CAINFO, pCaPath);/*pCaPath为证书路径 */ 　　else{ 　　　　　　　　 curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);　　　　 curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);　　　　 curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;cacert.pem&quot;);//cacert.pem为curl官网下载的根证书文件　　}　　//...　　curl_easy_cleanup(curl);}</code></pre><h2 id="需要用到其他库："><a href="#需要用到其他库：" class="headerlink" title="需要用到其他库："></a>需要用到其他库：</h2><p><a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>, <a href="https://www.wolfssl.com/wolfSSL/Home.html" target="_blank" rel="noopener">wolfSSL</a> and <a href="https://www.libssh2.org/" target="_blank" rel="noopener">SSH2</a></p><h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><p>使用静态库时</p><p>预处理器定义添加：<code>CURL_STATICLIB</code>或<code>BUILDING_LIBCURL</code></p><p>附加依赖项：</p><pre><code>libcurl.libws2_32.libwinmm.libwldap32.lib</code></pre><p>使用动态库时</p><p>附加依赖项：</p><pre><code>libcurl.lib</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><pre><code>static size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream){    size_t written = fwrite(ptr, size, nmemb, (FILE *)stream);    return written;}int url2file(){    CURL *curl_handle;    static const char *pagefilename = &quot;page.html&quot;;    FILE *pagefile;    curl_global_init(CURL_GLOBAL_ALL);    /* init the curl session */    curl_handle = curl_easy_init();    /* set URL to get here */    curl_easy_setopt(curl_handle, CURLOPT_URL, &quot;http://www.baidu.com&quot;);    /* Switch on full protocol/debug output while testing */    /*打开调试开关* /    curl_easy_setopt(curl_handle, CURLOPT_VERBOSE, 1L);    /* disable progress meter, set to 0L to enable and disable debug output */    /*关闭进度表* /    curl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 1L);    /* send all data to this function  */    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, write_data);    /* open the file */    pagefile = fopen(pagefilename, &quot;wb&quot;);    if(pagefile)    {        /* write the page body to this file handle */        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, pagefile);        /* get it! */        curl_easy_perform(curl_handle);        /* close the header file */        fclose(pagefile);    }    /* cleanup curl stuff */    curl_easy_cleanup(curl_handle);    curl_global_cleanup();    return 0;}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://www.cnblogs.com/chenyangchun/p/6868102.html" target="_blank" rel="noopener">编译curl，libcurl</a></p><p><a href="http://www.cnblogs.com/openiris/p/3812443.html" target="_blank" rel="noopener">在window平台下，自己DIY编译OpenSSL,Libcurl ，来支持HTTPS传输协议</a></p><p><a href="http://blog.csdn.net/huyiyang2010/article/details/7664201" title="http://blog.csdn.net/huyiyang2010/article/details/7664201" target="_blank" rel="noopener">http://blog.csdn.net/huyiyang2010/article/details/7664201</a></p><p><a href="http://blog.csdn.net/fengshuiyue/article/details/39530093/" title="http://blog.csdn.net/fengshuiyue/article/details/39530093/" target="_blank" rel="noopener">http://blog.csdn.net/fengshuiyue/article/details/39530093/</a></p><p><a href="http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html" title="http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html" target="_blank" rel="noopener">http://www.cnblogs.com/suiyingjie/archive/2012/11/12/2766332.html</a></p><p><a href="http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq" title="http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq" target="_blank" rel="noopener">http://baike.baidu.com/link?url=IVlZbIwx9qZ5DUoUJMp69PSG6EvsWlzC9xrDrVEhN2SjjuDJ36HE50pQnMXV4z4f6Sw4mM_jkar70LcZa84NCq</a></p><p><a href="https://curl.haxx.se/libcurl/c/libcurl-tutorial.html" title="https://curl.haxx.se/libcurl/c/libcurl-tutorial.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/libcurl-tutorial.html</a></p><p><a href="https://curl.haxx.se/libcurl/c/example.html" title="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">https://curl.haxx.se/libcurl/c/example.html</a></p><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p><a href="http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html" title="http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html" target="_blank" rel="noopener">http://www.cnblogs.com/ytjjyy/archive/2012/05/19/2508803.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=&quot;下载：&quot;&gt;&lt;/a&gt;下载：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;curl-curl-7_54_0.zip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.hax
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="libcur" scheme="https://caojingyou.github.io/tags/libcur/"/>
    
      <category term="网络" scheme="https://caojingyou.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SVN版本号</title>
    <link href="https://caojingyou.github.io/2018/02/08/SVN%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://caojingyou.github.io/2018/02/08/SVN版本号/</id>
    <published>2018-02-08T07:24:00.000Z</published>
    <updated>2018-07-17T09:23:11.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVN获取版本号"><a href="#SVN获取版本号" class="headerlink" title="SVN获取版本号"></a>SVN获取版本号</h1><h2 id="version-template-h"><a href="#version-template-h" class="headerlink" title="version_template.h"></a>version_template.h</h2><pre><code>#ifndef _VERSION_H_#define _VERSION_H_#define VER_MAJOR 1#define VER_MINOR 0#define VER_REVISION $WCREV$#define SVN_REVISION&quot;$WCMIXED?$WCRANGE$:$WCREV$$&quot;#define SVN_RANGE   $WCRANGE$#define SVN_REV $WCREV$#define SVN_REVISION&quot;$WCMIXED?SVN_RANGE:SVN_REV$&quot;#endif //!_VERSION_H_// Test file for SubWCRevchar *Revision  = &quot;$WCREV$&quot;;char *Revision16= &quot;$WCREV&amp;0xFF$&quot;;char *Revisionp100  = &quot;$WCREV+100$&quot;;char *Revisionm100  = &quot;$WCREV-100$&quot;;char *Modified  = &quot;$WCMODS?Modified:Not modified$&quot;;char *Unversioned   = &quot;$WCUNVER?Unversioned items found:no unversioned items$&quot;;char *Date  = &quot;$WCDATE$&quot;;char *CustDate  = &quot;$WCDATE=%a, %d %B %Y$&quot;;char *DateUTC   = &quot;$WCDATEUTC$&quot;;char *CustDateUTC   = &quot;$WCDATEUTC=%a, %d %B %Y$&quot;;char *TimeNow   = &quot;$WCNOW$&quot;;char *TimeNowUTC= &quot;$WCNOWUTC$&quot;;char *RevRange  = &quot;$WCRANGE$&quot;;char *Mixed = &quot;$WCMIXED?Mixed revision WC:Not mixed$&quot;;char *ExtAllFixed   = &quot;$WCEXTALLFIXED?All externals fixed:Not all externals fixed$&quot;;char *IsTagged  = &quot;$WCISTAGGED?Tagged:Not tagged$&quot;;char *URL   = &quot;$WCURL$&quot;;char *isInSVN   = &quot;$WCINSVN?versioned:not versioned$&quot;;char *needslck  = &quot;$WCNEEDSLOCK?TRUE:FALSE$&quot;;char *islocked  = &quot;$WCISLOCKED?locked:not locked$&quot;;char *lockdateutc   = &quot;$WCLOCKDATEUTC$&quot;;char *lockdate  = &quot;$WCLOCKDATE$&quot;;char *lockcustutc   = &quot;$WCLOCKDATEUTC=%a, %d %B %Y$&quot;;char *lockcust  = &quot;$WCLOCKDATE=%a, %d %B %Y$&quot;;char *lockown   = &quot;$WCLOCKOWNER$&quot;;char *lockcmt   = &quot;$WCLOCKCOMMENT$&quot;;#if $WCMODS?1:0$#error Source is modified#endif// End of file</code></pre><h2 id="运行bat"><a href="#运行bat" class="headerlink" title="运行bat"></a>运行bat</h2><pre><code>setlocal::设置svn客户端安装目录set SVN_PATH=D:\Program Files\TortoiseSVN\bin ::设置工作目录，即工程目录set WORK_DIR=E:\code\C++\Demo::设置版本模版文件，对应第一步中新建的模板文件set VERSION_TEMPLATE=E:\code\C++\Demo\version_template.h::设置版本号生成文件，生成的文件就是我们需要使用的版本文件set VERSION_RELEASE=E:\code\C++\Demo\version.h::进入svn客户端安装目录cd %SVN_PATH%::执行更新版本号操作&quot;%SVN_PATH%\SubWCRev.exe&quot; &quot;%WORK_DIR%&quot; &quot;%VERSION_TEMPLATE%&quot; &quot;%VERSION_RELEASE%&quot;endlocal</code></pre><h2 id="生成version-h"><a href="#生成version-h" class="headerlink" title="生成version.h"></a>生成version.h</h2><pre><code>#ifndef _VERSION_H_#define _VERSION_H_#define VER_MAJOR 1#define VER_MINOR 0#define VER_REVISION 6185#define SVN_REVISION&quot;4620&quot;#define SVN_RANGE   4620:6185#define SVN_REV 6185#define SVN_REVISION&quot;SVN_RANGE&quot;#endif //!_VERSION_H_// Test file for SubWCRevchar *Revision  = &quot;6185&quot;;char *Revision16= &quot;41&quot;;char *Revisionp100  = &quot;6285&quot;;char *Revisionm100  = &quot;6085&quot;;char *Modified  = &quot;Modified&quot;;char *Unversioned   = &quot;Unversioned items found&quot;;char *Date  = &quot;2018/02/07 10:00:58&quot;;char *CustDate  = &quot;Wed, 07 February 2018&quot;;char *DateUTC   = &quot;2018/02/07 02:00:58&quot;;char *CustDateUTC   = &quot;Wed, 07 February 2018&quot;;char *TimeNow   = &quot;2018/02/08 14:56:08&quot;;char *TimeNowUTC= &quot;2018/02/08 06:56:08&quot;;char *RevRange  = &quot;4620:6185&quot;;char *Mixed = &quot;Mixed revision WC&quot;;char *ExtAllFixed   = &quot;All externals fixed&quot;;char *IsTagged  = &quot;Not tagged&quot;;char *URL   = &quot;http://xxx&quot;;char *isInSVN   = &quot;versioned&quot;;char *needslck  = &quot;FALSE&quot;;char *islocked  = &quot;not locked&quot;;char *lockdateutc   = &quot;1970/01/01 00:00:00&quot;;char *lockdate  = &quot;1970/01/01 08:00:00&quot;;char *lockcustutc   = &quot;Thu, 01 January 1970&quot;;char *lockcust  = &quot;Thu, 01 January 1970&quot;;char *lockown   = &quot;&quot;;char *lockcmt   = &quot;&quot;;#if 1#error Source is modified#endif// End of file</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>在VS2005的项目属性页-&gt;预生成事件-&gt;命令行中添加一句：</p><pre><code>$(SolutionDir)\subwcrev.exe $(SolutionDir) $(SolutionDir)\src\qmlv\version_template.h $(SolutionDir)\src\qmlv\version.h</code></pre><p>SubWCRev 调用语法:</p><pre><code>SubWCRev WorkingCopyPath [SrcVersionFile DstVersionFile]</code></pre><h1 id="svn版本日志"><a href="#svn版本日志" class="headerlink" title="svn版本日志"></a>svn版本日志</h1><p>添加svn.exe目录到环境变量中</p><p>Apache-Subversion-1.9.7：</p><pre><code>&quot;svn.exe&quot; log --incremental -r4620&quot;svn.exe&quot; log --incremental -r4522</code></pre><p>显示当前工作副本的最新5条日志消息<br>    每次提交中更改的目录和显示路径：</p><pre><code>svn log -l 5 -v</code></pre><p>更新readme.bat</p><pre><code>svn update %~dp0..\svn log -l 1 %~dp0..\ &gt; %~dp0readme.txt</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html" title="https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-subwcrev-keywords.html</a></p><p><a href="http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html" title="http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_75c9af020102vgh2.html</a></p><p><a href="https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html" title="https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ae97a646833b87bbfd461d0d.html</a></p><p><a href="http://blog.csdn.net/yangxiao2shi/article/details/50719286/" title="http://blog.csdn.net/yangxiao2shi/article/details/50719286/" target="_blank" rel="noopener">http://blog.csdn.net/yangxiao2shi/article/details/50719286/</a></p><p><a href="https://www.visualsvn.com/support/svnbook/ref/svn/" title="https://www.visualsvn.com/support/svnbook/ref/svn/" target="_blank" rel="noopener">https://www.visualsvn.com/support/svnbook/ref/svn/</a></p><p><a href="https://www.visualsvn.com/support/svnbook/ref/svn/c/log/" title="https://www.visualsvn.com/support/svnbook/ref/svn/c/log/" target="_blank" rel="noopener">https://www.visualsvn.com/support/svnbook/ref/svn/c/log/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SVN获取版本号&quot;&gt;&lt;a href=&quot;#SVN获取版本号&quot; class=&quot;headerlink&quot; title=&quot;SVN获取版本号&quot;&gt;&lt;/a&gt;SVN获取版本号&lt;/h1&gt;&lt;h2 id=&quot;version-template-h&quot;&gt;&lt;a href=&quot;#version-tem
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="svn" scheme="https://caojingyou.github.io/tags/svn/"/>
    
      <category term="版本号" scheme="https://caojingyou.github.io/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL</title>
    <link href="https://caojingyou.github.io/2018/02/02/OpenSSL/"/>
    <id>https://caojingyou.github.io/2018/02/02/OpenSSL/</id>
    <published>2018-02-02T08:03:00.000Z</published>
    <updated>2018-08-17T02:00:59.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h1><p><a href="https://www.openssl.org/" title="https://www.openssl.org/" target="_blank" rel="noopener">https://www.openssl.org/</a></p><p><a href="https://github.com/openssl/openssl" title="https://github.com/openssl/openssl" target="_blank" rel="noopener">https://github.com/openssl/openssl</a></p><h1 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h1><p>安装<code>ActiveState Perl</code> </p><p><a href="https://www.perl.org/" title="https://www.perl.org/" target="_blank" rel="noopener">https://www.perl.org/</a></p><p><a href="https://www.activestate.com/activeperl/downloads/thank-you?dl=http://downloads.activestate.com/ActivePerl/releases/5.24.1.2402/ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe" title="https://www.activestate.com/activeperl/downloads/thank-you?dl=http://downloads.activestate.com/ActivePerl/releases/5.24.1.2402/ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe" target="_blank" rel="noopener">ActivePerl-5.24.1.2402-MSWin32-x86-64int-401627.exe</a></p><p>Perl 在 Window 平台上有 ActiveStatePerl 和 Strawberry Perl 编译器。</p><p>ActiveState Perl和 Strawberry Perl最大的区别是 Strawberry Perl 里面有多包含一些 CPAN 里的模块， 所以Strawberry Perl 下载的安装文件有 80多M, 而ActiveState Perl 只有20M 左右。</p><p>使用libcur中的<code>build-openssl.bat</code>编译</p><p>需要注意%PE%路径与VS真是路径</p><p><a href="http://files.cnblogs.com/files/yhcao/build-openssl.rar" title="http://files.cnblogs.com/files/yhcao/build-openssl.rar" target="_blank" rel="noopener">build-openssl.rar</a></p><h2 id="需要文件："><a href="#需要文件：" class="headerlink" title="需要文件："></a>需要文件：</h2><pre><code>$ copy /b inc32\openssl\*       c:\openssl\include\openssl$ copy /b out32dll\ssleay32.lib c:\openssl\lib$ copy /b out32dll\libeay32.lib c:\openssl\lib$ copy /b out32dll\ssleay32.dll c:\openssl\bin$ copy /b out32dll\libeay32.dll c:\openssl\bin$ copy /b out32dll\openssl.exe  c:\openssl\bin</code></pre><p><a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p><h1 id="安装程序："><a href="#安装程序：" class="headerlink" title="安装程序："></a>安装程序：</h1><p>或到此处下载：</p><p><a href="http://slproweb.com/products/Win32OpenSSL.html" title="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenSSL&quot;&gt;&lt;a href=&quot;#OpenSSL&quot; class=&quot;headerlink&quot; title=&quot;OpenSSL&quot;&gt;&lt;/a&gt;OpenSSL&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.openssl.org/&quot; title=&quot;https://
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OpenSSL" scheme="https://caojingyou.github.io/tags/OpenSSL/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>VS工具</title>
    <link href="https://caojingyou.github.io/2018/02/01/VS%E5%B7%A5%E5%85%B7/"/>
    <id>https://caojingyou.github.io/2018/02/01/VS工具/</id>
    <published>2018-02-01T08:03:00.000Z</published>
    <updated>2018-09-05T03:26:16.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Conan"><a href="#Conan" class="headerlink" title="Conan"></a>Conan</h1><p>C/C++包管理开发工具</p><p><a href="https://conan.io/" title="https://conan.io/" target="_blank" rel="noopener">https://conan.io/</a></p><p><a href="https://docs.conan.io/en/latest/introduction.html" title="https://docs.conan.io/en/latest/introduction.html" target="_blank" rel="noopener">https://docs.conan.io/en/latest/introduction.html</a></p><h1 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a>vcpkg</h1><p>C++包管理开发工具</p><p><a href="https://github.com/Microsoft/vcpkg" title="https://github.com/Microsoft/vcpkg" target="_blank" rel="noopener">https://github.com/Microsoft/vcpkg</a></p><p><a href="https://blog.csdn.net/cjmqas/article/details/79282847" title="https://blog.csdn.net/cjmqas/article/details/79282847" target="_blank" rel="noopener">https://blog.csdn.net/cjmqas/article/details/79282847</a></p><p><a href="https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/" title="https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/</a></p><h1 id="nuget"><a href="#nuget" class="headerlink" title="nuget"></a>nuget</h1><p>.net包管理开发工具</p><p><a href="https://www.nuget.org/downloads" title="https://www.nuget.org/downloads" target="_blank" rel="noopener">https://www.nuget.org/downloads</a></p><h1 id="MSDN-Code-Gallery"><a href="#MSDN-Code-Gallery" class="headerlink" title="MSDN Code Gallery"></a>MSDN Code Gallery</h1><p><a href="https://code.msdn.microsoft.com/" title="https://code.msdn.microsoft.com/" target="_blank" rel="noopener">https://code.msdn.microsoft.com/</a></p><h1 id="Visual-Studio-Gallery"><a href="#Visual-Studio-Gallery" class="headerlink" title="Visual Studio Gallery"></a>Visual Studio Gallery</h1><p><a href="https://visualstudiogallery.msdn.microsoft.com/" title="https://visualstudiogallery.msdn.microsoft.com/" target="_blank" rel="noopener">https://visualstudiogallery.msdn.microsoft.com/</a></p><h1 id="cppcheck"><a href="#cppcheck" class="headerlink" title="cppcheck"></a>cppcheck</h1><p><a href="http://cppcheck.sourceforge.net/" title="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">http://cppcheck.sourceforge.net/</a></p><p><a href="https://github.com/danmar/cppcheck" title="https://github.com/danmar/cppcheck" target="_blank" rel="noopener">https://github.com/danmar/cppcheck</a></p><p><a href="http://cppcheck.sourceforge.net/manual.html" title="http://cppcheck.sourceforge.net/manual.html" target="_blank" rel="noopener">http://cppcheck.sourceforge.net/manual.html</a></p><h1 id="Resharper"><a href="#Resharper" class="headerlink" title="Resharper"></a>Resharper</h1><p>深度代码分析，智能代码协助，实时错误代码高亮显示，解决方案范围内代码分析，快速代码更正，一步完成代码格式化和清理，业界领先的自动代码重构，高级的集成单元测试方案，和强大的解决方案内导航和搜索</p><p><a href="https://www.jetbrains.com/resharper/" title="https://www.jetbrains.com/resharper/" target="_blank" rel="noopener">https://www.jetbrains.com/resharper/</a></p><p><a href="https://masuit.com/21" target="_blank" rel="noopener">https://masuit.com/21</a></p><p><a href="https://www.cnblogs.com/smiler/p/3302713.html" target="_blank" rel="noopener">https://www.cnblogs.com/smiler/p/3302713.html</a></p><pre><code>官方下载地址[下载地址](http://www.jetbrains.com/resharper/download/)注册码：用户名: User注册码：D9d09DSYJel9IyuDU4btAQwZcbLugUad</code></pre><h1 id="CodeMaid"><a href="#CodeMaid" class="headerlink" title="CodeMaid"></a>CodeMaid</h1><p>整理代码</p><p><a href="https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid" title="https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=SteveCadwallader.CodeMaid</a></p><h1 id="ClaudiaIDE"><a href="#ClaudiaIDE" class="headerlink" title="ClaudiaIDE"></a>ClaudiaIDE</h1><p>vs背景</p><p><a href="https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE" title="https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=kbuchi.ClaudiaIDE</a></p><h1 id="VSColorOutput"><a href="#VSColorOutput" class="headerlink" title="VSColorOutput"></a>VSColorOutput</h1><p>vs彩色输出信息</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput" title="https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MikeWard-AnnArbor.VSColorOutput</a></p><h1 id="VS10x-Comments-Extender"><a href="#VS10x-Comments-Extender" class="headerlink" title="VS10x Comments Extender"></a>VS10x Comments Extender</h1><p>更改代码注释样式</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCommentsExtender</a></p><h1 id="VS10x-CodeMAP"><a href="#VS10x-CodeMAP" class="headerlink" title="VS10x CodeMAP"></a>VS10x CodeMAP</h1><p>可视化代码</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xCodeMAP</a></p><h1 id="VS10x-Editor-View-Enhancer"><a href="#VS10x-Editor-View-Enhancer" class="headerlink" title="VS10x Editor View Enhancer"></a>VS10x Editor View Enhancer</h1><p>增强 代码 编辑器 突出 显示 类 和 成员 名称</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer" title="https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MichaelKissBG8.VS10xEditorViewEnhancer</a></p><h1 id="Atomineer-Pro-Documentation"><a href="#Atomineer-Pro-Documentation" class="headerlink" title="Atomineer Pro Documentation"></a>Atomineer Pro Documentation</h1><p>生成Doxygen注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation" title="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentation</a></p><h1 id="Atomineer-Pro-Documentation-Trial"><a href="#Atomineer-Pro-Documentation-Trial" class="headerlink" title="Atomineer Pro Documentation Trial"></a>Atomineer Pro Documentation Trial</h1><p>生成Doxygen注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial" title="https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=JasonWilliams.AtomineerProDocumentationTrial</a></p><h1 id="DoxygenComments"><a href="#DoxygenComments" class="headerlink" title="DoxygenComments"></a>DoxygenComments</h1><p>Doxygen注释高亮</p><p><a href="https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments" title="https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=OleksandrManenko.DoxygenComments</a></p><h1 id="XML-Comments"><a href="#XML-Comments" class="headerlink" title="XML Comments"></a>XML Comments</h1><p>xml注释</p><p><a href="https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments" title="https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=UwePhilipps.XMLComments</a></p><h1 id="Go-To-Definition"><a href="#Go-To-Definition" class="headerlink" title="Go To Definition"></a>Go To Definition</h1><p>转到定义</p><p><a href="https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition" title="https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=NoahRichards.GoToDefinition</a></p><h1 id="AnkhSVN"><a href="#AnkhSVN" class="headerlink" title="AnkhSVN"></a>AnkhSVN</h1><p>svn</p><p><a href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider" title="https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=vs-publisher-303797.AnkhSVN-SubversionSupportSCCProvider</a></p><h1 id="Code-Compare"><a href="#Code-Compare" class="headerlink" title="Code Compare"></a>Code Compare</h1><p>代码对比</p><p><a href="https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare" title="https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=DevartSoftware.CodeCompare</a></p><h1 id="Indent-Guides"><a href="#Indent-Guides" class="headerlink" title="Indent Guides"></a>Indent Guides</h1><p>花括号虚线</p><p><a href="https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides" title="https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=SteveDowerMSFT.IndentGuides</a></p><h1 id="Hide-Main-Menu"><a href="#Hide-Main-Menu" class="headerlink" title="Hide Main Menu"></a>Hide Main Menu</h1><p>隐藏主菜单</p><p><a href="https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu" title="https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=MatthewJohnsonMSFT.HideMainMenu</a></p><h1 id="重复代码检查工具simian"><a href="#重复代码检查工具simian" class="headerlink" title="重复代码检查工具simian"></a>重复代码检查工具simian</h1><p><a href="http://www.harukizaemon.com/simian/" target="_blank" rel="noopener">http://www.harukizaemon.com/simian/</a></p><h1 id="代码度量工具——SourceMonitor"><a href="#代码度量工具——SourceMonitor" class="headerlink" title="代码度量工具——SourceMonitor"></a>代码度量工具——SourceMonitor</h1><p><a href="http://www.campwoodsw.com/sourcemonitor.html" target="_blank" rel="noopener">source moniter</a></p><p><a href="https://blog.csdn.net/feng_ma_niu/article/details/40594799" target="_blank" rel="noopener">软件质量之道：SourceMonitor</a></p><h1 id="Productivity-Power-Tools"><a href="#Productivity-Power-Tools" class="headerlink" title="Productivity Power Tools"></a><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.ProductivityPowerTools" target="_blank" rel="noopener">Productivity Power Tools</a></h1><h1 id="fxcop和stylecop"><a href="#fxcop和stylecop" class="headerlink" title="fxcop和stylecop"></a>fxcop和stylecop</h1><p>C#检查代码是否符合微软命名标准，让您的代码更加符合微软官方的设计规范。</p><h1 id="Unit-Test-Generator"><a href="#Unit-Test-Generator" class="headerlink" title="Unit Test Generator"></a><a href="https://github.com/nunit/docs/wiki/Visual-Studio-Test-Generator" target="_blank" rel="noopener">Unit Test Generator</a></h1><p>可以帮助快速生成C#单元测试项目和测试方法定义，提高单元测试编写效率。</p><h1 id="OzCode"><a href="#OzCode" class="headerlink" title="OzCode"></a><a href="https://oz-code.com/" target="_blank" rel="noopener">OzCode</a></h1><p>这个C#扩展可以大幅提升代码调试的体验，具备强大的结果搜索、跟踪、比较等功能，它将可视化调试的概念上升到了一个新的高度，将循环、表达式、比较阵列都直观的展示出来。</p><h1 id="C-文档管理和生成工具"><a href="#C-文档管理和生成工具" class="headerlink" title="C#文档管理和生成工具"></a><code>C#</code>文档管理和生成工具</h1><ul><li>Sandcastle Help File Builder与NDOC：可制作出MSDN风格的帮忙文档，生成帮助文件和用户手册。</li><li>AsPhere：配置文件编辑器，可以对配置文件进行编辑和调整。它使用方便，拥有很多有用的特性。</li><li>DocFX：微软开源的API文档生成工具，可将三斜杠注释生成HTML格式的API帮助文件。</li></ul><h1 id="Nant"><a href="#Nant" class="headerlink" title="Nant"></a>Nant</h1><p>开源免费项目，可以方便快捷对自己的.NET项目或解决方案进行自动构建。</p><h1 id="网络协议、请求监控和调试"><a href="#网络协议、请求监控和调试" class="headerlink" title="网络协议、请求监控和调试"></a>网络协议、请求监控和调试</h1><p>Fiddler：监控、查看、断点、调试和模拟HTTP请求。</p><p>HttpWatch：强大的网页数据分析工具。</p><p>Microsoft Network Monitor：微软发布的一款网络协议数据分析工具。</p><h1 id="net反编译和反向工程"><a href="#net反编译和反向工程" class="headerlink" title=".net反编译和反向工程"></a>.net反编译和反向工程</h1><p>ILdasm.exe：基于.NET平台查看程序集信息（元数据，程序集清单和MSIL）。</p><p>Reflector：强大的反编译工具，将MSIL转换为C#和VB高级语言</p><p>Dotfuscator：基于.NET混淆器和压缩器，防止应用程序被反编译，压缩程序集。</p><p>SmartAssembly：混淆.NET程序集，保护软件，减小分发包的大小，提高性能</p><p>ILSpy：开源免费的的.NET反编译工具，简洁强大易用。</p><p>JustDecompile：Telerik公司推出一个免费开源的.NET反编译工具，支持插件，与VisualStudio集成，JustDecompile与Reflector相比的话，个人更喜欢JustDecompile，因为他免费，而且对于一些C#动态类型的反编译效果比较好。</p><p>DotPeek：最先进的.NET反编译器之一，它生成的代码质量很高，它还尝试到源代码服务器上抓取代码，能精确查找符号的使用，同时支持插件，目前不能与Visual Studio集成。</p><h1 id="性能分析和调试工具"><a href="#性能分析和调试工具" class="headerlink" title="性能分析和调试工具"></a>性能分析和调试工具</h1><p>perfmon.exe：windows内置性能监视器支持多种计数器。</p><p>Debugging Tools for Windows：微软强大的用户态和内核态调试工具。</p><p>windows performance toolkit：微软官方发布的性能分析工具（可分析启动过程）。</p><p>Process Explorer：强大的进程管理器分析比任务管理更加详细的信息。</p><p>CLR Profiler：用图表的方式分析CLR运行时堆栈信息。</p><p>.NET Memory Profiler：基于.NET的内存分析工具。</p><p>PerfMonitor：更细节地分析CPU统计、GC统计和JIT编译统计。</p><p>visual studio内置性能分析工具：强大的IDE集成和友好的界面。</p><p>PerfView：重在分析堆的使用情况可支持保存和加载堆镜像。</p><p>ab.exe：Apache出品的Web负载测试与压力测试工具，经常用此工具测试抗压能力。</p><h1 id="Microsoft-SQL-Server-Data-Tools"><a href="#Microsoft-SQL-Server-Data-Tools" class="headerlink" title="Microsoft SQL Server Data Tools"></a>Microsoft SQL Server Data Tools</h1><p>为数据库开发人员提供了一个集成的环境，让他们可以在 Visual Studio 内为任何 SQL Server 平台（无论是内部还是外部）执行所有数据库设计工作。数据库开发人员可以在 VS 中使用 SQL Server 对象资源管理器轻松创建或编辑数据库对象和数据，或执行查询。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Conan&quot;&gt;&lt;a href=&quot;#Conan&quot; class=&quot;headerlink&quot; title=&quot;Conan&quot;&gt;&lt;/a&gt;Conan&lt;/h1&gt;&lt;p&gt;C/C++包管理开发工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://conan.io/&quot; title=&quot;htt
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Doxygen" scheme="https://caojingyou.github.io/tags/Doxygen/"/>
    
      <category term="VS工具" scheme="https://caojingyou.github.io/tags/VS%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Conan" scheme="https://caojingyou.github.io/tags/Conan/"/>
    
      <category term="vcpkg" scheme="https://caojingyou.github.io/tags/vcpkg/"/>
    
      <category term="nuget" scheme="https://caojingyou.github.io/tags/nuget/"/>
    
      <category term="cppcheck" scheme="https://caojingyou.github.io/tags/cppcheck/"/>
    
      <category term="Resharper" scheme="https://caojingyou.github.io/tags/Resharper/"/>
    
      <category term="CodeMaid" scheme="https://caojingyou.github.io/tags/CodeMaid/"/>
    
  </entry>
  
  <entry>
    <title>bypy</title>
    <link href="https://caojingyou.github.io/2018/01/25/bypy/"/>
    <id>https://caojingyou.github.io/2018/01/25/bypy/</id>
    <published>2018-01-25T08:03:00.000Z</published>
    <updated>2018-04-12T06:49:09.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bypy"><a href="#bypy" class="headerlink" title="bypy"></a>bypy</h1><p><a href="https://github.com/houtianze/bypy" title="https://github.com/houtianze/bypy" target="_blank" rel="noopener">https://github.com/houtianze/bypy</a></p><p>TL;DR: <code>pip install bypy</code>. <code>Run bypy</code></p><p>安装配置完毕后可用命令行直接上传文件</p><pre><code>@echo offbypy -v upload E:\图片\Aatrox_Splash_0.jpg test/2.jpgpause</code></pre><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><ol><li>第一次运行要授权，打开命令行中的提示网站，复制授权码到命令行中</li></ol><ol><li><p>可能会由于百度权限问题，使用百度云备份需要差不多一个月跟新一次授权，否则报错</p><p> OpenShift server failed, authorizing/refreshing with the Heroku server …</p></li></ol><p>或者不小心删除了</p><p><code>Hash Cache File &#39;/home/pipi/.bypy/bypy.hashcache.json&#39; not found, no caching</code><br><code>Note: Skip saving Hash Cache since it has not been updated.</code></p><p>这个应该不是错误，而是没有再次更新授权的提示吧。</p><p>更新(重新)授权办法如下：</p><p>运行</p><p><code>bypy.py -c</code></p><p>删除令牌文件，然后重新授权一次。如果还不行，去百度应用授权里删除bypy再重新授权。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bypy&quot;&gt;&lt;a href=&quot;#bypy&quot; class=&quot;headerlink&quot; title=&quot;bypy&quot;&gt;&lt;/a&gt;bypy&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/houtianze/bypy&quot; title=&quot;https://git
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
      <category term="bypy" scheme="https://caojingyou.github.io/tags/bypy/"/>
    
      <category term="百度云盘" scheme="https://caojingyou.github.io/tags/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CppUnit</title>
    <link href="https://caojingyou.github.io/2018/01/18/cppunit/"/>
    <id>https://caojingyou.github.io/2018/01/18/cppunit/</id>
    <published>2018-01-18T08:03:00.000Z</published>
    <updated>2018-04-12T06:28:32.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CppUnit"><a href="#CppUnit" class="headerlink" title="CppUnit"></a>CppUnit</h1><p><a href="https://sourceforge.net/projects/cppunit/?source=directory" target="_blank" rel="noopener">CppUnit - C++ port of JUnit</a></p><p><a href="https://www.freedesktop.org/wiki/Software/cppunit/" target="_blank" rel="noopener">cppunit-freedesktop.org</a></p><p><a href="http://cppunit.sourceforge.net/doc/lastest/index.html" target="_blank" rel="noopener">CppUnit Documentation</a></p><p><a href="https://baike.baidu.com/item/CppUnit/2218302?fr=aladdin" target="_blank" rel="noopener">CppUnit百度百科</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cppunit/" target="_blank" rel="noopener">便利的开发工具 CppUnit 快速使用指南</a></p><p><a href="https://wenku.baidu.com/view/b7fcad4bcf84b9d528ea7ae1.html" target="_blank" rel="noopener">CppUnit源码解读</a></p><p><a href="http://morningspace.51.net/resource/cppunit/cppunit_anno.html" target="_blank" rel="noopener">晨光（Morning）CppUnit源码解读</a></p><p><a href="http://blog.csdn.net/eplanet/article/details/1844456" target="_blank" rel="noopener">C++——测试工具CppUnit的安装和配置</a></p><p><a href="http://blog.csdn.net/x_iya/article/details/8433716" target="_blank" rel="noopener">CppUnit在VS2010上的正确使用</a></p><p><a href="https://wenku.baidu.com/view/0997c8a30b1c59eef9c7b47f.html" target="_blank" rel="noopener">[vs2010 配置与实例] CppUnit快速入门</a></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="http://dev-www.libreoffice.org/src/cppunit-1.14.0.tar.gz" target="_blank" rel="noopener">cppunit-1.14.0.tar.gz</a></p><p><a href="https://sourceforge.net/projects/cppunit/files/cppunit/1.12.1/cppunit-1.12.1.tar.gz/download" target="_blank" rel="noopener">cppunit-1.12.1.tar.gz</a></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>在CppUnit的源代码中，包含了几个测试工程的例子。</p><ul><li>CppUnitTestMain：一个实际的测试包（test suite）用来测试CppUnit。使用了TextTestRunner（文本方式的单元测试环境），利用CompilterOutputter进行post-build testing（即在编译结束之后紧跟着进行测试）。在配置中设定连接了cppunit的静态库和动态库。</li></ul><ul><li>CppUnitTestApp：包含了与CppUnitTestMain相同的测试包，但使用了MFC TestRunner（GUI方式的单元测试环境）</li></ul><ul><li>Hierarchy：一个演示如何子类化测试的例子（你也许更愿意使用HelperMacros.h以及宏CPPUNIT_TEST_SUB_SUITE，这种方式更为简洁清晰。本示例已经很久没有更新了）。</li></ul><ul><li>HostApp ：一个用MFC TestRunner演示各种失败测试的例子。也演示了MFC Unicode TestRunner。</li></ul><ul><li>TestPlugIn：一个演示如何为TestPlugInRunner编写TestPlugIn的例子（实验性的）。</li></ul><h1 id="判断宏"><a href="#判断宏" class="headerlink" title="判断宏"></a>判断宏</h1><p><code>CPPUNIT_ASSERT</code>是一个宏，判断后面的参数是否正确，CPPUNIT还有很多宏，如</p><pre><code>CPPUNIT_ASSERT(condition)                      // 确信condition为真CPPUNIT_ASSERT_MESSAGE(message, condition)     // 当condition为假时失败, 并打印messageCPPUNIT_FAIL(message)                          // 当前测试失败, 并打印messageCPPUNIT_ASSERT_EQUAL(expected, actual)         // 确信两者相等CPPUNIT_ASSERT_EQUAL_MESSAGE(message, expected, actual) // 失败的同时打印messageCPPUNIT_ASSERT_DOUBLES_EQUAL(expected, actual, delta)   // 当expected和actual之间差大于delta时失败</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CppUnit&quot;&gt;&lt;a href=&quot;#CppUnit&quot; class=&quot;headerlink&quot; title=&quot;CppUnit&quot;&gt;&lt;/a&gt;CppUnit&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/cppunit/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
      <category term="CppUnit" scheme="https://caojingyou.github.io/tags/CppUnit/"/>
    
      <category term="单元测试" scheme="https://caojingyou.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo yilia主题</title>
    <link href="https://caojingyou.github.io/2018/01/10/Hexo%20yilia%E4%B8%BB%E9%A2%98/"/>
    <id>https://caojingyou.github.io/2018/01/10/Hexo yilia主题/</id>
    <published>2018-01-10T08:03:00.000Z</published>
    <updated>2018-04-12T06:19:37.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h1><ul><li><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></li><li><a href="http://litten.me/" title="http://litten.me/" target="_blank" rel="noopener">http://litten.me/</a></li><li><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></li><li><a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" title="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5</a></li></ul><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>关于SEO与RSS，需要在博客根目录（注意不是yilia根目录）安装这三个node_modules:</p><pre><code>npm install hexo-generator-feed --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save</code></pre><p>分别对应：rss、百度爬虫sitemap、通用搜索引擎sitemap</p><h1 id="不显示标签："><a href="#不显示标签：" class="headerlink" title="不显示标签："></a>不显示标签：</h1><p>缺失模块。<br>1、在博客根目录（注意不是yilia根目录）执行以下命令：</p><p>npm i hexo-generator-json-content –save</p><p>2、在根目录_config.yml里添加配置：</p><pre><code>jsonContent:  meta: false  pages: false  posts:    title: true    date: true    path: true    text: true    raw: false    content: false    slug: false    updated: false    comments: false    link: false    permalink: false    excerpt: false    categories: false    tags: true</code></pre><h1 id="【Hexo】Hexo-Github构建个人博客-（五）：错误集"><a href="#【Hexo】Hexo-Github构建个人博客-（五）：错误集" class="headerlink" title="【Hexo】Hexo+Github构建个人博客 （五）：错误集"></a>【Hexo】Hexo+Github构建个人博客 （五）：错误集</h1><ul><li><a href="http://www.cnblogs.com/arvin0/p/6664239.html" title="http://www.cnblogs.com/arvin0/p/6664239.html" target="_blank" rel="noopener">http://www.cnblogs.com/arvin0/p/6664239.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网址：&quot;&gt;&lt;a href=&quot;#网址：&quot; class=&quot;headerlink&quot; title=&quot;网址：&quot;&gt;&lt;/a&gt;网址：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Hexo" scheme="https://caojingyou.github.io/tags/Hexo/"/>
    
      <category term="yilia主题" scheme="https://caojingyou.github.io/tags/yilia%E4%B8%BB%E9%A2%98/"/>
    
      <category term="博客" scheme="https://caojingyou.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>SQLite NET</title>
    <link href="https://caojingyou.github.io/2018/01/09/SQLite%20NET/"/>
    <id>https://caojingyou.github.io/2018/01/09/SQLite NET/</id>
    <published>2018-01-09T08:03:00.000Z</published>
    <updated>2018-04-12T06:24:45.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-程序中使用-SQLite-数据库"><a href="#C-程序中使用-SQLite-数据库" class="headerlink" title="C# 程序中使用 SQLite 数据库"></a>C# 程序中使用 SQLite 数据库</h1><pre><code>using System;using System.Data;using System.Data.SQLite;//C# 使用 SQLite 数据测试程序public class Program{    public static void Main(string[] args)    {        using (SQLiteConnection con = new SQLiteConnection(&quot;Data Source=c:\\test.db3;Pooling=true;FailIfMissing=false&quot;))        {            //打开数据库文件 c:\\test.db3，不存在则创建            con.Open();            using (SQLiteCommand cmd = new SQLiteCommand())            {                cmd.Connection = con;                //检查是否存在表 test，不存在则创建                Boolean testTableExists = false;                cmd.CommandText = &quot;SELECT * FROM sqlite_master WHERE type=&apos;table&apos; and name=&apos;test&apos;&quot;;                using(SQLiteDataReader dr = cmd.ExecuteReader())                {                    if (dr.Read())                    {                        testTableExists = true;                    }                }                if (!testTableExists)                {                    cmd.CommandText = &quot;CREATE TABLE [test] (id int, name nvarchar(20))&quot;;                    cmd.ExecuteNonQuery();                }                //清空 test 表                cmd.CommandText = &quot;DELETE FROM [test]&quot;;                cmd.ExecuteNonQuery();                //插入测试数据                for (int i = 1; i &lt;= 5; i++)                {                    cmd.CommandText = string.Format(&quot;INSERT INTO [test] VALUES ({0}, &apos;中文测试&apos;)&quot;, i);                    cmd.ExecuteNonQuery();                }                //读取数据                cmd.CommandText = &quot;SELECT * FROM [test]&quot;;                using (SQLiteDataReader dr = cmd.ExecuteReader(CommandBehavior.CloseConnection))                {                    while (dr.Read())                    {                        Console.WriteLine(&quot;第{0} 条：{1}&quot;, dr.GetValue(0), dr.GetString(1));                    }                }            }        }        Console.WriteLine(&quot;Press any key to continue...&quot;);        Console.ReadKey();    }}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://unmi.cc/csharp-use-sqlite-db/" title="http://unmi.cc/csharp-use-sqlite-db/" target="_blank" rel="noopener">http://unmi.cc/csharp-use-sqlite-db/</a></li><li><a href="http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/" title="http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/" target="_blank" rel="noopener">http://blog.163.com/baiyunping333@126/blog/static/2439447220093162323933/</a></li><li><a href="http://www.sqlite.org/lang_keywords.html" title="http://www.sqlite.org/lang_keywords.html" target="_blank" rel="noopener">http://www.sqlite.org/lang_keywords.html</a></li><li><a href="http://www.sqlite.org/lang_corefunc.html" title="http://www.sqlite.org/lang_corefunc.html" target="_blank" rel="noopener">http://www.sqlite.org/lang_corefunc.html</a></li><li><a href="http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes" title="http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2008/01/sqlite-in-three-minutes</a></li><li><a href="http://www.sqlite.org/cvstrac/wiki?p=ManagementTools" title="http://www.sqlite.org/cvstrac/wiki?p=ManagementTools" target="_blank" rel="noopener">http://www.sqlite.org/cvstrac/wiki?p=ManagementTools</a></li><li><a href="http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html" title="http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html" target="_blank" rel="noopener">http://www.cnblogs.com/spymaster/archive/2008/09/10/1288419.html</a></li><li><a href="http://www.jb51.net/article/26381.htm" title="http://www.jb51.net/article/26381.htm" target="_blank" rel="noopener">http://www.jb51.net/article/26381.htm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-程序中使用-SQLite-数据库&quot;&gt;&lt;a href=&quot;#C-程序中使用-SQLite-数据库&quot; class=&quot;headerlink&quot; title=&quot;C# 程序中使用 SQLite 数据库&quot;&gt;&lt;/a&gt;C# 程序中使用 SQLite 数据库&lt;/h1&gt;&lt;pre&gt;&lt;c
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="SQLite NET" scheme="https://caojingyou.github.io/tags/SQLite-NET/"/>
    
  </entry>
  
  <entry>
    <title>wolfSSL</title>
    <link href="https://caojingyou.github.io/2018/01/08/wolfSSL/"/>
    <id>https://caojingyou.github.io/2018/01/08/wolfSSL/</id>
    <published>2018-01-08T08:03:00.000Z</published>
    <updated>2018-04-12T06:23:51.676Z</updated>
    
    <content type="html"><![CDATA[<p>下载：</p><p><a href="https://github.com/wolfSSL/wolfssl" title="https://github.com/wolfSSL/wolfssl" target="_blank" rel="noopener">https://github.com/wolfSSL/wolfssl</a></p><p><a href="https://www.wolfssl.com/wolfSSL/Home.html" title="https://www.wolfssl.com/wolfSSL/Home.html" target="_blank" rel="noopener">https://www.wolfssl.com/wolfSSL/Home.html</a></p><p><a href="http://www.updatestar.com/directdownload/wolfssl/2264982" title="http://www.updatestar.com/directdownload/wolfssl/2264982" target="_blank" rel="noopener">http://www.updatestar.com/directdownload/wolfssl/2264982</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wolfSSL/wolfssl&quot; title=&quot;https://github.com/wolfSSL/wolfssl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="wolfSSL" scheme="https://caojingyou.github.io/tags/wolfSSL/"/>
    
  </entry>
  
  <entry>
    <title>个人喜欢的电脑软件</title>
    <link href="https://caojingyou.github.io/2018/01/01/%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2018/01/01/个人喜欢的电脑软件/</id>
    <published>2018-01-01T08:03:00.000Z</published>
    <updated>2018-02-06T09:04:41.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美化桌面"><a href="#美化桌面" class="headerlink" title="美化桌面"></a>美化桌面</h1><p>wallpaperengine</p><p>火萤视频桌面</p><p>雨滴桌面</p><p>Win10BGChanger1.2.1</p><p>StartIsBack</p><p>LiveDesktop</p><p>牛牛桌面</p><p>Fences</p><p>Q+</p><p>360安全桌面</p><h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>Listary</p><p>Rolan</p><p>Launchy</p><p>Wox</p><p>音速启动</p><p>CLaunch</p><p>ALTRun</p><p>Executor</p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><p>FreeFileSync</p><p>FastCopy</p><h1 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h1><p>Snipaste</p><p>ShareX-portable</p><p>Greenshot</p><h1 id="图片整理"><a href="#图片整理" class="headerlink" title="图片整理"></a>图片整理</h1><p>picasa</p><h1 id="RSS阅读"><a href="#RSS阅读" class="headerlink" title="RSS阅读"></a>RSS阅读</h1><p>feeddemon</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美化桌面&quot;&gt;&lt;a href=&quot;#美化桌面&quot; class=&quot;headerlink&quot; title=&quot;美化桌面&quot;&gt;&lt;/a&gt;美化桌面&lt;/h1&gt;&lt;p&gt;wallpaperengine&lt;/p&gt;
&lt;p&gt;火萤视频桌面&lt;/p&gt;
&lt;p&gt;雨滴桌面&lt;/p&gt;
&lt;p&gt;Win10BGChange
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="电脑软件" scheme="https://caojingyou.github.io/tags/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="个人喜欢" scheme="https://caojingyou.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%96%9C%E6%AC%A2/"/>
    
      <category term="美化桌面" scheme="https://caojingyou.github.io/tags/%E7%BE%8E%E5%8C%96%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>MSBuild</title>
    <link href="https://caojingyou.github.io/2017/12/21/MSBuild%20(Visual%20C++)/"/>
    <id>https://caojingyou.github.io/2017/12/21/MSBuild (Visual C++)/</id>
    <published>2017-12-21T08:03:00.000Z</published>
    <updated>2018-07-13T08:02:53.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-文档"><a href="#Visual-Studio-文档" class="headerlink" title="Visual Studio 文档"></a>Visual Studio 文档</h1><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/</a></p><h1 id="MSBuild-Visual-C"><a href="#MSBuild-Visual-C" class="headerlink" title="MSBuild (Visual C++)"></a>MSBuild (Visual C++)</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/dd293626.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd293626.aspx</a></p><p>可以使用 MSBuild 工具从命令提示符处生成 Visual C++ 应用程序。 该生成过程由您可以创建和编辑的项目文件 (.vcxproj) 中的信息来控制。 该项目文件基于生成阶段、条件和事件指定生成选项</p><h1 id="MSBuild-Visual-C-概述"><a href="#MSBuild-Visual-C-概述" class="headerlink" title="MSBuild (Visual C++) 概述"></a>MSBuild (Visual C++) 概述</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ee662426.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ee662426.aspx</a></p><p>用户目标和属性</p><p>若要在命令行上最有效地使用 MSBuild，最好先了解哪些属性和目标是有用且相关。 大多数属性和目标可以帮助实施 Visual c + + 生成系统，并因此不与用户相关。 本部分介绍一些值得面向用户的属性和目标。</p><p>PlatformToolset 属性</p><p>PlatformToolset 属性确定在生成中使用的 Visual c + + 工具集。 属性的值与字符串组合成包含生成用于特定平台的项目所需的属性和目标文件的目录路径串联。</p><p>设置 PlatformToolset 属性设置为 v110 使用 Visual Studio 2012 中的 Visual C++ 工具和库来构建您的应用程序。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v110</p><p>设置 PlatformToolset 属性设置为 v100 使用 Visual C++ 2010 工具和库来构建您的应用程序。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v100</p><p>设置 PlatformToolset 属性设置为 v90 使用 Visual c + + 2008年工具和库来生成你的应用程序。 此属性才有效在计算机上必须已安装的 Visual c + + 2008年工具集。</p><p>msbuild myProject.vcxproj /p:PlatformToolset=v90</p><p>PreferredToolArchitecture 属性</p><p>PreferredToolArchitecture 属性确定是否在生成中使用 32 位或 64 位编译器和工具。 此属性不影响输出的平台体系结构或配置。 默认情况下，MSBuild 使用 x86 版本的编译器和工具，如果此属性未设置，或为设置为任何值以外 x64。</p><p>设置 PreferredToolArchitecture 属性设置为 x64 以使用 64 位编译器和工具来生成应用程序。</p><p>msbuild myProject.vcxproj /p:PreferredToolArchitecture=x64</p><p>UseEnv 属性</p><p>默认情况下，当前项目的特定于平台的设置重写路径、 INCLUDE、 LIB、 LIBPATH、 配置和平台环境变量。 设置 UseEnv 属性设置为 true 若要确保环境变量不重写。</p><p>msbuild myProject.vcxproj /p:UseEnv=true</p><p>目标</p><p>有数百个 Visual c + + 支持文件中的目标。 但是，大多数都是用户可忽略的面向系统的目标。 大多数系统目标前缀是下划线 (_)，或具有”PrepareFor”，”计算”，以”Before”，”After”，”之前”或”Post”开头的名称。</p><p>下表列出了几个值得面向用户的目标。</p><h1 id="MSBuild-命令行参考"><a href="#MSBuild-命令行参考" class="headerlink" title="MSBuild 命令行参考"></a>MSBuild 命令行参考</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms164311.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms164311.aspx</a></p><p><code>MSBuild.exe [Switches] [ProjectFile]</code> </p><pre><code>语法:                             MSBuild.exe [选项] [项目文件]描述:                    在项目文件中生成指定的目标。如果                     未指定项目文件，MSBuild 将搜索                     当前工作目录来查找文件扩展名                     以“proj”结尾的文件并使用该文件。开关:  /target:&lt;targets&gt;  在此项目中生成这些目标。使用                     分号或逗号分隔多个目标，或者分别指定                     每个目标。(缩写: /t)                     示例:                       /target:Resources;Compile  /property:&lt;n&gt;=&lt;v&gt;  设置或重写这些项目级属性。&lt;n&gt; 是                     属性名，&lt;v&gt; 为属性值。请使用                     分号或逗号分隔多个属性，或者                     分别指定每个属性。(缩写: /p)                     示例:                       /property:WarningLevel=2;OutDir=bin\Debug\  /maxcpucount[:n]   指定用于生成的最大                     并发进程数。如果未使用开关，则使用的默认值                     为 1。如果使用开关时不带值，                     MSBuild 将最多使用计算机上的                     处理器数。(缩写: /m[:n])  /toolsversion:&lt;version&gt;                     要在生成过程中使用的 MSBuild 工具集                     (任务、目标等) 的版本。此版本将重写                     个别项目指定的版本。(缩写:                     /tv)                     示例:                       /toolsversion:3.5  /verbosity:&lt;level&gt; 在事件日志中显示此级别的信息量。                     可用的详细级别有: q[uiet]、 m[inimal]、                     n[ormal]、d[etailed] 和 diag[nostic]。(缩写: /v)                     示例:                       /verbosity:quiet  /consoleloggerparameters:&lt;parameters&gt;                     控制台记录器的参数。(缩写: /clp)                     可用的参数有:                        PerformanceSummary -- 显示在任务、目标和项目上                            花费的时间。                        Summary -- 结束时显示错误和警告的摘要。                        NoSummary -- 结束时不显示错误和警告                            的摘要。                        ErrorsOnly -- 仅显示错误。                        WarningsOnly -- 仅显示警告。                        NoItemAndPropertyList -- 在开始生成每个项目时不显示                            项和属性的列表。                        ShowCommandLine -- 显示 TaskCommandLineEvent 消息                        ShowTimestamp -- 将时间戳作为所有消息的前缀                            显示。                        ShowEventId -- 显示已开始事件、已完成事件和消息                            的事件 ID。                        ForceNoAlign -- 不将文本与控制台缓冲区的大小                            匹配。                        DisableConsoleColor -- 将默认控制台颜色                            用于所有记录消息。                        DisableMPLogging -- 在非多处理器                            模式下运行时，禁用输出的多处理器                            日志记录样式。                        EnableMPLogging -- 即使在非多处理器                            模式下运行，也启用多处理器                            日志记录样式。默认情况下启用此日志记录样式。                        Verbosity -- 重写此记录器的  /verbosity                            设置。                     示例:                        /consoleloggerparameters:PerformanceSummary;NoSummary;                                                 Verbosity=minimal  /noconsolelogger   禁用默认控制台记录器，并且不将事件                     记录到控制台。(缩写:  /noconlog)  /fileLogger[n]     将生成输出记录到文件中。默认情况下，                     该文件在当前目录中，名称为                     “msbuild[n].log”。所有节点中的事件合并到                     单个日志中。fileLogger 的文件和                     其他参数的位置可以通过添加                     “/fileLoggerParameters[n]”开关来指定。                     “n”(如果存在)可以为 1-9 的数字，允许最多附加                     10 个文件记录器。(缩写:  /fl[n])  /fileloggerparameters[n]:&lt;parameters&gt;                     为文件记录器提供任何额外的参数。                     存在此开关意味着                     存在对应的 /filelogger[n] 开关。                    “n”(如果存在)可以为 1-9 的数字。                     任何分布式文件记录器也可以使用                     /fileloggerparameters，具体可参阅 /distributedFileLogger 的说明。                     (缩写: /flp[n])                     为控制台记录器列出的相同参数                     可用。某些其他可用参数有:                        LogFile -- 生成日志将写入其中的                            日志文件的路径。                        Append -- 确定是将生成日志附加到日志文件，                            还是覆盖日志文件。如果设置此                            开关，则会将生成日志附加到日志文件；                            如果不设置此开关，则会覆盖                            现有日志文件的内容。                            默认值为不附加到日志文件。                        Encoding -- 指定文件的编码，                            例如，UTF-8、Unicode 或 ASCII                     默认的详细级别为 Detailed。                     示例:                       /fileLoggerParameters:LogFile=MyLog.log;Append;                                           Verbosity=diagnostic;Encoding=UTF-8                       /flp:Summary;Verbosity=minimal;LogFile=msbuild.sum                       /flp1:warningsonly;logfile=msbuild.wrn                       /flp2:errorsonly;logfile=msbuild.err  /distributedlogger:&lt;central logger&gt;*&lt;forwarding logger&gt;                     使用此记录器来记录 MSBuild 中的事件，向每个节点                     附加不同的记录器实例。若要指定                     多个记录器，请分别指定每个记录器。                     (缩写 /dl)                     &lt;logger&gt; 语法为:                       [&lt;logger class&gt;,]&lt;logger assembly&gt;[;&lt;logger parameters&gt;]                     &lt;logger class&gt; 语法为:                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;                     &lt;logger assembly&gt; 语法为:                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}                     &lt;logger parameters&gt; 是可选的，并且按键入的                     形式原样传递给记录器。(缩写: /l)                     示例:                       /dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral                       /dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll  /distributedFileLogger                     将生成输出记录到多个日志文件，每个 MSBuild 节点                     一个日志文件。这些文件的初始位置为                     当前目录。默认情况下，这些文件名为                     “MSBuild&lt;nodeid&gt;.log”。可通过添加                     “/fileLoggerParameters”开关来指定                     这些文件的位置和 fileLogger 的其他参数。                     如果日志文件名是通过 fileLoggerParameters                     开关设置的，分布式记录器将使用 fileName 作为                     模板并将节点 ID 附加到此 fileName                     以便为每个节点创建一个日志文件。  /logger:&lt;logger&gt;   使用此记录器来记录 MSBuild 中的事件。若要指定                     多个记录器，请分别指定每个记录器。                     &lt;logger&gt; 语法为:                       [&lt;logger class&gt;,]&lt;logger assembly&gt;[;&lt;logger parameters&gt;]                    &lt;logger class&gt; 语法为:                        [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;                   &lt;logger assembly&gt; 语法为:                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}                     &lt;logger parameters&gt; 是可选的，并按键入的                    形式原样传递给记录器。(缩写: /l)                     示例:                       /logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral                       /logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML  /validate          依据默认架构验证项目。(缩写:                     /val)  /validate:&lt;schema&gt; 依据指定的架构验证项目。 (缩写:                     /val)                     示例:                       /validate:MyExtendedBuildSchema.xsd  /ignoreprojectextensions:&lt;扩展名&gt;                     确定要生成的项目文件时要忽略的                     扩展名的列表。使用分号或逗号来分隔                     多个扩展名。                     (缩写: /ignore)                     示例:                       /ignoreprojectextensions:.sln  /nodeReuse:&lt;parameters&gt;                     允许或禁止重复使用 MSBuild 节点。                     参数包括:                     True -- 生成完成后节点将保留，                             并且将由后面的生成重复使用(默认)                     False -- 生成完成后节点将不会保留                     (缩写: /nr)                     示例:                       /nr:true  /preprocess[:file]                     通过嵌入将在生成过程中导入的                     所有文件并标记其边界，                     创建一个聚合的项目文件。这对于                     了解导入什么文件、从何处导入以及                     这些文件在生成中的构成                     非常有用。默认情况下，输出将写入                     控制台窗口。如果提供输出文件的路径，                     则将改用该路径。                     (缩写: /pp)                      示例:                       /pp:out.txt  /detailedsummary                     在生成的结尾显示有关                     所生成的配置以及如何向节点安排                     这些配置的详细信息。                     (缩写:  /ds)  @&lt;file&gt;            从文本文件插入命令行设置。若要指定                     多个响应文件，请分别指定每个响应                     文件。                     自动从以下位置使用任何                     名为“msbuild.rsp”的响应文件:                     (1) msbuild.exe 的目录                     (2) 生成的第一个项目或解决方案的目录  /noautoresponse    不自动包括任何 MSBuild.rsp 文件。(缩写:                     /noautorsp)  /nologo            不显示启动版权标志和版权消息。  /version           仅显示版本信息。(缩写:  /ver)  /help              显示此用法消息。(缩写: /? 或 /h)示例:        MSBuild MyApp.sln /t:Rebuild /p:Configuration=Release        MSBuild MyApp.csproj /t:Clean                             /p:Configuration=Debug;TargetFrameworkVersion=v3.5</code></pre><p>示例</p><pre><code>MSBuild.exe MyProject.proj /t:rebuild </code></pre><h1 id="演练：使用-MSBuild-创建-Visual-C-项目"><a href="#演练：使用-MSBuild-创建-Visual-C-项目" class="headerlink" title="演练：使用 MSBuild 创建 Visual C++ 项目"></a>演练：使用 MSBuild 创建 Visual C++ 项目</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/dd293607.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd293607.aspx</a></p><pre><code>msbuild myproject.vcxproj /p:configuration=debugmsbuild myproject.vcxproj /t:clean</code></pre><h2 id="将-MSBuild-与生成目标结合使用"><a href="#将-MSBuild-与生成目标结合使用" class="headerlink" title="将 MSBuild 与生成目标结合使用"></a>将 MSBuild 与生成目标结合使用</h2><p>生成目标是指定的一组预定义命令或用户定义的命令，这组命令可在生成期间执行。 使用目标命令行选项 (/t) 可以指定生成目标。 对于 myproject 示例项目，预定义的 clean 目标将删除调试文件夹中的所有文件并创建新日志文件。<br>在命令提示符处，键入以下命令以清理 myproject。<br>    msbuild myproject.vcxproj /t:clean</p><h2 id="将-MSBuild-与生成属性结合使用"><a href="#将-MSBuild-与生成属性结合使用" class="headerlink" title="将 MSBuild 与生成属性结合使用"></a>将 MSBuild 与生成属性结合使用</h2><p>通过使用属性命令行选项 (/p)，您可以在项目生成文件中重写属性。 在 myproject 示例项目中，发布版本配置或调试版本配置是由 Configuration 属性指定的。 用来运行生成的应用程序的操作系统是由 Platform 属性指定的。<br>在命令提示符处，键入以下命令，以创建打算在 32 位 Windows 上运行的 myproject 应用程序的调试版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=debug /p:platform=win32</code></pre><p>假设 myproject 示例项目也为 64 位 Windows 定义了配置，并为名为 myplatform 的自定义操作系统定义了另一个配置。<br>在命令提示符处，键入以下命令，以创建在 64 位 Windows 上运行的发布版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=release /p:platform=x64</code></pre><p>在命令提示符处，键入以下命令以为 myplatform 创建发布版本。</p><pre><code>msbuild myproject.vcxproj /p:configuration=release /p:platform=myplatform</code></pre><h1 id="个人写的例子："><a href="#个人写的例子：" class="headerlink" title="个人写的例子："></a>个人写的例子：</h1><p>vs2005:</p><pre><code>call &quot;D:\Program Files (x86)\Microsoft Visual Studio 8\VC\vcvarsall.bat&quot; x86</code></pre><p>vs2010:</p><pre><code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\vcvarsall.bat&quot; x86</code></pre><p>vs2012:</p><pre><code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\vcvarsall.bat&quot; x86</code></pre><p>重新编译：</p><pre><code>MSBuild %~dp0..\Project\VC10\pro.sln /t:rebuild /p:configuration=&quot;Release&quot;</code></pre><h1 id="在命令行上生成"><a href="#在命令行上生成" class="headerlink" title="在命令行上生成"></a>在命令行上生成</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/f35ctcxw.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/f35ctcxw.aspx</a></p><h1 id="为命令行生成设置路径和环境变量"><a href="#为命令行生成设置路径和环境变量" class="headerlink" title="为命令行生成设置路径和环境变量"></a>为命令行生成设置路径和环境变量</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/f2ccy3wt.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/f2ccy3wt.aspx</a></p><h1 id="生成应用程序"><a href="#生成应用程序" class="headerlink" title="生成应用程序"></a>生成应用程序</h1><p><a href="https://msdn.microsoft.com/zh-cn/library/ms181709.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms181709.aspx</a></p><p><a href="https://msdn.microsoft.com/zh-cn/library/ms244359.aspx" target="_blank" rel="noopener">Team Foundation Build 参考</a></p><h1 id="vcvars-bat-设置命令行编译环境"><a href="#vcvars-bat-设置命令行编译环境" class="headerlink" title="vcvars.bat 设置命令行编译环境"></a>vcvars.bat 设置命令行编译环境</h1><pre><code>@echo offif defined VSINSTALLDIR (    echo already installedgoto eof)set &quot;_ARG_=%1&quot;rem helpif &quot;%_ARG_%&quot; EQU &quot;&quot; (    echo syntax: %0 [2005 ^| 2008 ^| 2010 ^| 2012 ^| 2013 ^| 2015] [64]    goto eof)if &quot;%_ARG_%&quot; EQU &quot;2005&quot; set &quot;ProgramFiles(x86)=%VS80COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2008&quot; set &quot;ProgramFiles(x86)=%VS90COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2010&quot; set &quot;ProgramFiles(x86)=%VS100COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2012&quot; set &quot;ProgramFiles(x86)=%VS110COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2013&quot; set &quot;ProgramFiles(x86)=%VS120COMNTOOLS%..\..\&quot;if &quot;%_ARG_%&quot; EQU &quot;2015&quot; set &quot;ProgramFiles(x86)=%VS140COMNTOOLS%..\..\&quot;echo &quot;%ProgramFiles(x86)%&quot;if NOT DEFINED ProgramFiles(x86) set ProgramFiles(x86)=C:\Program Files (x86)if NOT DEFINED VS80COMNTOOLS set VS80COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 8\Common7\Tools\if NOT DEFINED VS90COMNTOOLS set VS90COMNTOOLS=c:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\Tools\rem VS100COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\Tools\rem VS110COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 11.0\Common7\Tools\rem VS120COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\rem VS140COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Tools\rem VS80COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 8\Common7\Tools\rem VS90COMNTOOLS=D:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\Tools\rem VSSDK140Install=D:\Program Files (x86)\Microsoft Visual Studio 14.0\VSSDK\set &quot;_OPT_=%2&quot;if NOT DEFINED _OPT_ set _OPT_=64if &quot;%_OPT_%&quot; EQU &quot;x64&quot; set &quot;_OPT_=64&quot;if &quot;%_ARG_%&quot; EQU &quot;2005&quot; (  if &quot;%_OPT_%&quot; EQU &quot;64&quot; (pushd &quot;%ProgramFiles(x86)%\VC\bin\amd64\&quot;call vcvarsamd64.batset PROCESSOR_ARCHITECTURE=AMD64  ) else (pushd &quot;%ProgramFiles(x86)%\VC\bin&quot;call vcvars32.batset PROCESSOR_ARCHITECTURE=x86  )  popd  goto eof)rem set the variable _VC_set _VC_=if &quot;%_ARG_%&quot; EQU &quot;2008&quot; set &quot;_VC_=9.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2010&quot; set &quot;_VC_=10.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2012&quot; set &quot;_VC_=11.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2013&quot; set &quot;_VC_=12.0&quot;if &quot;%_ARG_%&quot; EQU &quot;2015&quot; set &quot;_VC_=14.0&quot;if DEFINED _VC_ (  echo &quot;%ProgramFiles(x86)%\VC\&quot;  pushd &quot;%ProgramFiles(x86)%\VC\&quot;  if &quot;%_OPT_%&quot; EQU &quot;64&quot; (vcvarsall.bat x86_amd64set PROCESSOR_ARCHITECTURE=AMD64  ) else (vcvarsall.bat x86set PROCESSOR_ARCHITECTURE=x86  )  if errorlevel 1 (      echo.*** error - failed ***  ) else (      echo Success Environment for Visual Studio %_VC_% = %*  )  popd) else (  echo unknown version of Visual Studio %*  set _ARG_=  call:help)remrem That&apos;s all Folks!:eof</code></pre><h1 id="MSBuild编译"><a href="#MSBuild编译" class="headerlink" title="MSBuild编译"></a>MSBuild编译</h1><pre><code>call &quot;%~dp0\vcvars.bat&quot; 2005|2008|2010|2012|2013|2015 x86|x64MSBuild %~dp0..\Project\pro.sln /t:rebuild /p:configuration=&quot;Release&quot;MSBuild &quot;%~dp0..\Project\pro.sln&quot; /t:clean</code></pre><h1 id="devenv"><a href="#devenv" class="headerlink" title="devenv"></a>devenv</h1><pre><code>@echo offcd /d %~dp0set BUILD_TARGET=%CD%\MyProject.slnecho.if &quot;&quot;==&quot;%VS80COMNTOOLS%&quot; (   echo environment variable &apos;VS80COMNTOOLS%&apos; has not been set   goto Exit_Fail)set DEVENV=%VS80COMNTOOLS%\..\IDE\devenv.comif not exist &quot;%DEVENV%&quot; (   echo file &quot;%DEVENV%&quot; can not be found   goto Exit_Fail)@echo on&quot;%DEVENV%&quot; &quot;%BUILD_TARGET%&quot; /Build Release:Exit_Failpause</code></pre><p><code>Build</code>可换成<code>Rebuild</code></p><p><a href="https://www.cnblogs.com/songxingzhu/p/5242159.html" target="_blank" rel="noopener">使用devenv/MSBuild在命令行编译sln或csproj</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Visual-Studio-文档&quot;&gt;&lt;a href=&quot;#Visual-Studio-文档&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio 文档&quot;&gt;&lt;/a&gt;Visual Studio 文档&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MSBuild" scheme="https://caojingyou.github.io/tags/MSBuild/"/>
    
      <category term="VS" scheme="https://caojingyou.github.io/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>Log4Net</title>
    <link href="https://caojingyou.github.io/2017/12/15/Log4Net/"/>
    <id>https://caojingyou.github.io/2017/12/15/Log4Net/</id>
    <published>2017-12-15T08:03:00.000Z</published>
    <updated>2018-05-17T03:25:51.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Log4Net"><a href="#Log4Net" class="headerlink" title="Log4Net"></a>Log4Net</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>[assembly: log4net.Config.XmlConfigurator(Watch = true)]namespace APP02{    class Program    {        static void Main(string[] args)        {            ILog log = log4net.LogManager.GetLogger(&quot;Test&quot;);            log.Error(&quot;错误&quot;, new Exception(&quot;发生了一个异常&quot;));//错误            log.Fatal(&quot;严重错误&quot;, new Exception(&quot;发生了一个致命错误&quot;));//严重错误            log.Info(&quot;信息&quot;); //记录一般信息            log.Debug(&quot;调试信息&quot;);//记录调试信息            log.Warn(&quot;警告&quot;);//记录警告信息            Console.WriteLine(&quot;日志记录完毕。&quot;);            Console.Read();        }    }}</code></pre><p>或：</p><pre><code>ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);            //记录错误日志            log.Info(&quot;error&quot;);</code></pre><h2 id="App-config文件配置："><a href="#App-config文件配置：" class="headerlink" title="App.config文件配置："></a>App.config文件配置：</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt;  &lt;configSections&gt;    &lt;section name=&quot;log4net&quot; type=&quot;System.Configuration.IgnoreSectionHandler&quot;/&gt;  &lt;/configSections&gt;  &lt;log4net&gt;    &lt;appender name=&quot;控制台输出&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d [%t] %-5p %c [%x] - %m%n&quot;  /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;logger name=&quot;Test&quot;&gt;      &lt;level value=&quot;ALL&quot;/&gt;      &lt;appender-ref ref=&quot;控制台输出&quot; /&gt;    &lt;/logger&gt;  &lt;/log4net&gt;&lt;/configuration&gt;</code></pre><p>或：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;configuration&gt;  &lt;configSections&gt;    &lt;section name=&quot;log4net&quot; type=&quot;System.Configuration.IgnoreSectionHandler&quot;/&gt;  &lt;/configSections&gt;  &lt;appSettings&gt;  &lt;/appSettings&gt;  &lt;log4net&gt;    &lt;!--定义输出到文件中--&gt;    &lt;appender name=&quot;LogFileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt;      &lt;!--定义文件存放位置--&gt;      &lt;file value=&quot;D:/log4netfile.txt&quot; /&gt;      &lt;appendToFile value=&quot;true&quot; /&gt;      &lt;rollingStyle value=&quot;Date&quot; /&gt;      &lt;datePattern value=&quot;yyyyMMdd-HH:mm:ss&quot; /&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;!--每条日志末尾的文字说明--&gt;        &lt;footer value=&quot;by 周公&quot; /&gt;        &lt;!--输出格式--&gt;        &lt;!--样例：2008-03-26 13:42:32,111 [10] INFO  Log4NetDemo.MainClass [(null)] - info--&gt;        &lt;conversionPattern value=&quot;记录时间：%date 线程ID:[%thread] 日志级别：%-5level 出错类：%logger property:[%property{NDC}] - 错误描述：%message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到控制台命令行中--&gt;    &lt;appender name=&quot;ConsoleAppender&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到windows事件中--&gt;    &lt;appender name=&quot;EventLogAppender&quot; type=&quot;log4net.Appender.EventLogAppender&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger [%property{NDC}] - %message%newline&quot; /&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;!--定义输出到数据库中，这里举例输出到Access数据库中，数据库为C盘的log4net.mdb--&gt;    &lt;appender name=&quot;AdoNetAppender_Access&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&gt;      &lt;connectionString value=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:log4net.mdb&quot; /&gt;      &lt;commandText value=&quot;INSERT INTO LogDetails ([LogDate],[Thread],[Level],[Logger],[Message]) VALUES (@logDate, @thread, @logLevel, @logger,@message)&quot; /&gt;      &lt;!--定义各个参数--&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logDate&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%date&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@thread&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%thread&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logLevel&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%level&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@logger&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%logger&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;      &lt;parameter&gt;        &lt;parameterName value=&quot;@message&quot; /&gt;        &lt;dbType value=&quot;String&quot; /&gt;        &lt;size value=&quot;240&quot; /&gt;        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;          &lt;conversionPattern value=&quot;%message&quot; /&gt;        &lt;/layout&gt;      &lt;/parameter&gt;    &lt;/appender&gt;    &lt;!--定义日志的输出媒介，下面定义日志以四种方式输出。也可以下面的按照一种类型或其他类型输出。--&gt;    &lt;root&gt;      &lt;!--文件形式记录日志--&gt;      &lt;appender-ref ref=&quot;LogFileAppender&quot; /&gt;      &lt;!--控制台控制显示日志--&gt;      &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;      &lt;!--Windows事件日志--&gt;      &lt;appender-ref ref=&quot;EventLogAppender&quot; /&gt;      &lt;!-- 如果不启用相应的日志记录，可以通过这种方式注释掉      &lt;appender-ref ref=&quot;AdoNetAppender_Access&quot; /&gt;      --&gt;    &lt;/root&gt;  &lt;/log4net&gt;&lt;/configuration&gt;</code></pre><h2 id="appender配置使用示例"><a href="#appender配置使用示例" class="headerlink" title="appender配置使用示例"></a>appender配置使用示例</h2><pre><code>&lt;appender name=&quot;文件输出&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;      &lt;file value=&quot;F:\log\Log.txt&quot; /&gt;      &lt;appendToFile value=&quot;true&quot; /&gt;      &lt;rollingStyle value=&quot;Size&quot; /&gt;      &lt;maxSizeRollBackups value=&quot;10&quot; /&gt;      &lt;maximumFileSize value=&quot;5MB&quot; /&gt;      &lt;staticLogFileName value=&quot;true&quot; /&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %m %exception %n&quot;  /&gt;      &lt;/layout&gt;&lt;/appender&gt;</code></pre><h2 id="Log4Net结构"><a href="#Log4Net结构" class="headerlink" title="Log4Net结构"></a>Log4Net结构</h2><p>(1)Log4Net核心组件</p><pre><code>Log4net主要分为5个核心组件: Logger, Appender, Filter, Layout, Object Render。</code></pre><p>(2)Logger介绍</p><pre><code>Logger是负责日志的记录者，假设我们需要记录一些正常的运行时日志和出现异常时的错误日志，那么我们可以通过在配置文件当中添加两个Logger实现。Logger主要用于记录日志的分类和控制日志的级别。它可以以多种格式输出日志信息，同时它也可以控制日志的输出级别。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。</code></pre><p>(3)Appender介绍</p><pre><code>Appender提供记录的介质，我们可能要将日志输出到控制台，文本文件，windows 日志事件查看器中，包括数据库，邮件等等位置。我们可以通过Appender配置实现，而且Log4Net当中已经默认提供了一些常用的Appender，我们可以简单地修改一些配置文件就实现同时向数据库和同时向文件中写入的功能。</code></pre><p>(4)Filter介绍</p><pre><code>Filter就是过滤器，使用过滤器可以过滤掉Appender输出的部分内容，只输出感兴趣的日志。</code></pre><p>(5)Layout介绍</p><pre><code>Layout用于控制Appender的输出格式，可以使线性的也可以使XML。一个Appender只能有一个Layout配置。</code></pre><p>(6)Object Render介绍</p><pre><code>Object Render将告诉logger如何把一个对象转化为一个字符串记录到日志里。ILog中定义的记录日志的方法接收的参数是Object，而不是String。例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它。这时logger就会知道如何把Orange记录到日志中了。</code></pre><h2 id="配置文件结构图"><a href="#配置文件结构图" class="headerlink" title="配置文件结构图"></a>配置文件结构图</h2><p><img src="https://images0.cnblogs.com/blog/601464/201503/060905536956904.png" alt=""></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://logging.apache.org/log4net/release/config-examples.html" title="http://logging.apache.org/log4net/release/config-examples.html" target="_blank" rel="noopener">http://logging.apache.org/log4net/release/config-examples.html</a></p><ul><li><a href="http://www.cnblogs.com/LiZhiW/p/4317198.html" target="_blank" rel="noopener">Log4Net使用详解</a></li><li><a href="http://blog.csdn.net/zhoufoxcn/article/details/2220533" title="http://blog.csdn.net/zhoufoxcn/article/details/2220533" target="_blank" rel="noopener">http://blog.csdn.net/zhoufoxcn/article/details/2220533</a></li><li><a href="http://blog.csdn.net/zhoufoxcn/article/details/6029021" title="http://blog.csdn.net/zhoufoxcn/article/details/6029021" target="_blank" rel="noopener">http://blog.csdn.net/zhoufoxcn/article/details/6029021</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Log4Net&quot;&gt;&lt;a href=&quot;#Log4Net&quot; class=&quot;headerlink&quot; title=&quot;Log4Net&quot;&gt;&lt;/a&gt;Log4Net&lt;/h1&gt;&lt;h2 id=&quot;代码：&quot;&gt;&lt;a href=&quot;#代码：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Log4Net" scheme="https://caojingyou.github.io/tags/Log4Net/"/>
    
  </entry>
  
  <entry>
    <title>程序只能启动一次</title>
    <link href="https://caojingyou.github.io/2017/12/01/%E7%A8%8B%E5%BA%8F%E5%8F%AA%E8%83%BD%E5%90%AF%E5%8A%A8%E4%B8%80%E6%AC%A1/"/>
    <id>https://caojingyou.github.io/2017/12/01/程序只能启动一次/</id>
    <published>2017-12-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序只能启动一次"><a href="#程序只能启动一次" class="headerlink" title="程序只能启动一次"></a>程序只能启动一次</h1><pre><code>BOOL CIMServerApp::InitInstance(){    HANDLE hMutex=::CreateMutex(NULL,TRUE,&quot;NAME&quot;);//NAME随便写个    if (hMutex!=NULL)    {        if (GetLastError()==ERROR_ALREADY_EXISTS)        {            AfxMessageBox(&quot;已经有一个程序运行.&quot;);            return FALSE;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序只能启动一次&quot;&gt;&lt;a href=&quot;#程序只能启动一次&quot; class=&quot;headerlink&quot; title=&quot;程序只能启动一次&quot;&gt;&lt;/a&gt;程序只能启动一次&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;BOOL CIMServerApp::InitInstance()
{
  
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>libssh2</title>
    <link href="https://caojingyou.github.io/2017/11/24/libssh2/"/>
    <id>https://caojingyou.github.io/2017/11/24/libssh2/</id>
    <published>2017-11-24T08:03:00.000Z</published>
    <updated>2018-06-05T03:18:29.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="libssh2"><a href="#libssh2" class="headerlink" title="libssh2"></a>libssh2</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="https://www.libssh2.org/" title="https://www.libssh2.org/" target="_blank" rel="noopener">https://www.libssh2.org/</a></p><p><a href="https://github.com/libssh2/libssh2" title="https://github.com/libssh2/libssh2" target="_blank" rel="noopener">https://github.com/libssh2/libssh2</a></p><h2 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h2><p>需要<a href="https://www.openssl.org/" target="_blank" rel="noopener">openssl</a>以及<a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a></p><p>修改libssh下的win32目录下config.mk,修改openssl与zlib路径</p><p>在source根目录下nmake /f NMakefile</p><p>或vs2010打开win32\libssh2.dsp，在项目属性中配置openssl与zlib路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;libssh2&quot;&gt;&lt;a href=&quot;#libssh2&quot; class=&quot;headerlink&quot; title=&quot;libssh2&quot;&gt;&lt;/a&gt;libssh2&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="加密" scheme="https://caojingyou.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="libssh2" scheme="https://caojingyou.github.io/tags/libssh2/"/>
    
  </entry>
  
  <entry>
    <title>C++与浏览器交互</title>
    <link href="https://caojingyou.github.io/2017/11/15/C++%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E4%BA%92/"/>
    <id>https://caojingyou.github.io/2017/11/15/C++与浏览器交互/</id>
    <published>2017-11-15T08:03:00.000Z</published>
    <updated>2018-04-12T06:29:23.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebBrowser"><a href="#WebBrowser" class="headerlink" title="WebBrowser"></a>WebBrowser</h1><ul><li><a href="http://blog.csdn.net/charlessimonyi/article/details/18447471" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/18447471</a></li><li><a href="http://blog.csdn.net/charlessimonyi/article/details/18450783" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/18450783</a></li><li><a href="http://blog.csdn.net/charlessimonyi/article/details/50984903" target="_blank" rel="noopener">http://blog.csdn.net/charlessimonyi/article/details/50984903</a></li><li><a href="https://www.codeproject.com/articles/2352/javascript-call-from-c" target="_blank" rel="noopener">https://www.codeproject.com/articles/2352/javascript-call-from-c</a></li></ul><h1 id="CEF"><a href="#CEF" class="headerlink" title="CEF"></a>CEF</h1><ul><li><a href="https://www.codeproject.com/Articles/1105945/Embedding-a-Chromium-browser-in-an-MFC-application" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1105945/Embedding-a-Chromium-browser-in-an-MFC-application</a></li><li><a href="http://blog.csdn.net/daoxwj/article/details/8783629/" target="_blank" rel="noopener">http://blog.csdn.net/daoxwj/article/details/8783629/</a></li><li><a href="http://blog.csdn.net/daoxwj/article/details/8786911" target="_blank" rel="noopener">http://blog.csdn.net/daoxwj/article/details/8786911</a></li><li><a href="http://mariusbancila.ro/blog/2016/05/05/building-the-64-bit-version-of-chromium-embedded-framework-on-windows/" target="_blank" rel="noopener">http://mariusbancila.ro/blog/2016/05/05/building-the-64-bit-version-of-chromium-embedded-framework-on-windows/</a></li><li><a href="https://www.codeproject.com/Tips/785840/A-Simple-Windows-Example-Using-the-Chromium-Embedd" target="_blank" rel="noopener">https://www.codeproject.com/Tips/785840/A-Simple-Windows-Example-Using-the-Chromium-Embedd</a></li><li><a href="https://bitbucket.org/chromiumembedded/cef" target="_blank" rel="noopener">https://bitbucket.org/chromiumembedded/cef</a></li><li><a href="http://blog.csdn.net/mfcing/article/details/43953433" target="_blank" rel="noopener">http://blog.csdn.net/mfcing/article/details/43953433</a></li><li><a href="http://blog.csdn.net/mfcing/article/details/52066579" target="_blank" rel="noopener">http://blog.csdn.net/mfcing/article/details/52066579</a></li></ul><ol><li>CefClient：回调管理类，包含5个接口用于创建其它的回调类的对象</li><li>CefLifeSpanHandler: 回调类，用于控制popup对话框的创建和关闭等操作</li><li>CefLoadHandler: 回调类，可以用来监听frame的加载开始，完成，错误等信息</li><li>CefRequestHandler: 回调类，用于监听资源加载，重定向等信息</li><li>CefDisplayHandler: 回调类，用于监听页面加载状态，地址变化，标题等得信息</li><li>CefGeolocationHandler: 回调类，用于CEF3向嵌入者申请geolocation的权限</li><li>CefApp: 与进程，命令行参数，代理，资源管理相关的回调类，用于让CEF3的调用者们定制自己的逻辑</li><li>CefBrowser: renderer进程中执行浏览相关的类，例如前进，后退等</li><li>CefBrowserHost: browser进程中的执行浏览相关的类，其会把请求发送给CefBrowser</li><li>CefFrame: 表示的是页面中的一个Frame，可以加载特定url，在该运行环境下执行JavaScript代码等得。</li><li>V8：CEF3提供支持V8extension的接口，但是这有两个限制，第一，v8 extension仅在Renderer进程使用；第二，仅在沙箱模型关闭时使用</li></ol><p>需要安装cmake</p><ul><li><a href="https://cmake.org/" target="_blank" rel="noopener">https://cmake.org/</a></li><li><a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a></li><li></li></ul><h1 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h1><ul><li><a href="https://github.com/v8/v8/wiki" target="_blank" rel="noopener">https://github.com/v8/v8/wiki</a></li></ul><h1 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h1><p>SWIG 是一个非常优秀的开源工具，支持您将 C/C++ 代码与任何主流脚本语言相集成。此外，它向更广泛的受众公开了基本代码，改善了可测试性，让您的 Ruby 代码库某部分能快速写出高性能的 C/C++ 模块。</p><ul><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-swig/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/aix/library/au-swig/</a></li><li><a href="https://github.com/swig/swig" target="_blank" rel="noopener">https://github.com/swig/swig</a></li><li><a href="http://www.swig.org/download.html?cm_mc_uid=85410804137714897351221&amp;cm_mc_sid_50200000=1489735122" target="_blank" rel="noopener">http://www.swig.org/download.html?cm_mc_uid=85410804137714897351221&amp;cm_mc_sid_50200000=1489735122</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebBrowser&quot;&gt;&lt;a href=&quot;#WebBrowser&quot; class=&quot;headerlink&quot; title=&quot;WebBrowser&quot;&gt;&lt;/a&gt;WebBrowser&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ch
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="浏览器" scheme="https://caojingyou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CEF" scheme="https://caojingyou.github.io/tags/CEF/"/>
    
  </entry>
  
  <entry>
    <title>gitbook</title>
    <link href="https://caojingyou.github.io/2017/11/05/gitbook/"/>
    <id>https://caojingyou.github.io/2017/11/05/gitbook/</id>
    <published>2017-11-05T08:03:00.000Z</published>
    <updated>2018-04-12T06:27:40.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h1><p><a href="https://github.com/GitbookIO/gitbook" title="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">https://github.com/GitbookIO/gitbook</a></p><p><a href="https://toolchain.gitbook.com/ebook.html" title="https://toolchain.gitbook.com/ebook.html" target="_blank" rel="noopener">https://toolchain.gitbook.com/ebook.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gitbook&quot;&gt;&lt;a href=&quot;#gitbook&quot; class=&quot;headerlink&quot; title=&quot;gitbook&quot;&gt;&lt;/a&gt;gitbook&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/GitbookIO/gitbook&quot; tit
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="gitbook" scheme="https://caojingyou.github.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>wxWidgets</title>
    <link href="https://caojingyou.github.io/2017/11/01/wxWidgets/"/>
    <id>https://caojingyou.github.io/2017/11/01/wxWidgets/</id>
    <published>2017-11-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wxWidgets"><a href="#wxWidgets" class="headerlink" title="wxWidgets"></a>wxWidgets</h1><h2 id="Code-Blocks环境"><a href="#Code-Blocks环境" class="headerlink" title="Code::Blocks环境"></a>Code::Blocks环境</h2><h3 id="Code-Blocks下载："><a href="#Code-Blocks下载：" class="headerlink" title="Code::Blocks下载："></a>Code::Blocks下载：</h3><p>Code::Blocks使用：</p><p><a href="https://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe/download" target="_blank" rel="noopener">codeblocks-16.01mingw-setup.exe</a></p><p>它的gcc版本为4.9.2，也可在设置中对其进行更改</p><h3 id="wxMSW-3-1-0-gcc492下载："><a href="#wxMSW-3-1-0-gcc492下载：" class="headerlink" title="## wxMSW-3.1.0_gcc492下载： ##"></a>## wxMSW-3.1.0_gcc492下载： ##</h3><ul><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_gcc492TDM_Dev.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_gcc492TDM\_Dev.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0\\_gcc492TDM\\_ReleaseDLL.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_gcc492TDM\_ReleaseDLL.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxWidgets-3.1.0-headers.7z" target="_blank" rel="noopener">wxWidgets-3.1.0-headers.7z</a></li></ul><h3 id="Code-Blocks配置："><a href="#Code-Blocks配置：" class="headerlink" title="Code::Blocks配置："></a>Code::Blocks配置：</h3><p>解压wxMSW-3.1.0_gcc492TDM_Dev.7z与wxWidgets-3.1.0-headers.7z到同一目录：X:\wxMSW-3.1.0_gcc492TDM</p><p>在环境变量里添加一个wxWidgets根目录环境变量，新增的用户变量命名为wxwin，值为X:\wxMSW-3.1.0_gcc492TDM</p><p>打开Code::Blocks，选择菜单Settings-&gt;Global Variables…，在设置default下新建立一个wx变量，在Build-in fields:下，base中填入“${wxwin}”（wxwin是刚才设置好的一个变量），include中填入“${wxwin}\include”，lib中填入“${wxwin}\lib”</p><h3 id="新建项目："><a href="#新建项目：" class="headerlink" title="新建项目："></a>新建项目：</h3><h4 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h4><h4 id="建立项目的过程"><a href="#建立项目的过程" class="headerlink" title="建立项目的过程"></a>建立项目的过程</h4><p>通过菜单“File”-&gt;“New”-&gt;“Project…”，选择“Empty project”建一个项目。</p><p>点击菜单File-&gt;New-&gt;File…为项目新建一个源程序文件,main.cpp:</p><pre><code>#include &lt;wx/wx.h&gt;class Simple : public wxFrame{    public:    Simple(const wxString &amp; title);};Simple::Simple(const wxString &amp; title): wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(250, 150)){    Centre();}class MyApp : public wxApp{    public:    virtual bool OnInit();};IMPLEMENT_APP(MyApp)bool MyApp::OnInit(){    Simple * simple = new Simple(wxT(&quot;Simple&quot;));    simple-&gt;Show(true);    return true;}</code></pre><p>选菜单Project-&gt;Build options…，在选项卡Search directories中，设置Compiler。通过“Add”增加目录X:\wxMSW-3.1.0_gcc492TDM\include和X:\wxMSW-3.1.0_gcc492TDM\lib\gcc_dll\mswud，最好include在上mswud在下。(debug版用mswud，release版用mswu)</p><p>选菜单Project-&gt;Build options…，在选项卡Linker settings中，需要加入要连接的“目标文件”。如图所示，通过Add按钮加入X:\wxMSW-3.1.0_gcc492TDM\lib\gcc_dll文件夹中的所有.a文件</p><p>此时编译即可通过。</p><h4 id="利用Code-Blocks的向导建立"><a href="#利用Code-Blocks的向导建立" class="headerlink" title="利用Code::Blocks的向导建立"></a>利用Code::Blocks的向导建立</h4><p>使用向导建一个“wxWidgets project”项目。</p><ul><li><p>GUI设计工具和程序类型，用wxSmith和Dialog based。如果设置了“Code::Blocks配置”，wxWidgets’location直接填入“$(#wx)”就可以了,否则设置为X:\wxMSW-3.1.0_gcc492TDM目录。</p></li><li><p>wxWidgets Library Settings选择Enable unicode</p></li><li><p>选择Configure Advanced Options</p></li><li><p>选择Use _WXDEBUG_ and Debug wxWidgets lib</p></li><li><p>选择GUI Mode Application</p></li></ul><p>生成的程序源码：</p><p><a href="http://files.cnblogs.com/files/yhcao/wxTest3.1.0.rar" target="_blank" rel="noopener">wxTest3.1.0.rar</a></p><h3 id="程序运行："><a href="#程序运行：" class="headerlink" title="程序运行："></a>程序运行：</h3><p>程序运行时需要一些dll,到wxMSW-3.1.0_gcc492TDM_ReleaseDLL.7z中寻找，放到程序目录即可启动。</p><h2 id="VS2010环境"><a href="#VS2010环境" class="headerlink" title="VS2010环境"></a>VS2010环境</h2><h3 id="wxMSW-3-1-0-vc100下载："><a href="#wxMSW-3-1-0-vc100下载：" class="headerlink" title="wxMSW-3.1.0_vc100下载："></a>wxMSW-3.1.0_vc100下载：</h3><ul><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_vc100_Dev.7z" target="_blank" rel="noopener">wxMSW-3.1.0_vc100\_Dev.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxMSW-3.1.0_vc100_ReleaseDLL.7z" target="_blank" rel="noopener">wxMSW-3.1.0\_vc100\_ReleaseDLL.7z</a></li><li><a href="https://github.com/wxWidgets/wxWidgets/releases/download/v3.1.0/wxWidgets-3.1.0-headers.7z" target="_blank" rel="noopener">wxWidgets-3.1.0-headers.7z</a></li></ul><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>把wxMSW-3.1.0_vc100_Dev.7z与wxWidgets-3.1.0-headers.7z解压到 X:\wxMSW-3.1.0_vc100_Dev</p><p>新建win32项目 windows应用程序 空项目</p><p>附加包含目录</p><ul><li>X:\wxMSW-3.1.0_vc100_Dev\include</li><li>X:\wxMSW-3.1.0_vc100_Dev\lib\vc_lib\mswud(debug)</li><li>X:\wxMSW-3.1.0_vc100_Dev\lib\vc_lib\mswu(release)</li></ul><p>添加附加依赖项：</p><pre><code>wxbase31ud_net.libwxmsw31ud_html.libwxbase31ud_xml.libwxmsw31ud_adv.libwxmsw31ud_aui.libwxmsw31ud_gl.libwxmsw31ud_media.libwxmsw31ud_propgrid.libwxmsw31ud_qa.libwxmsw31ud_ribbon.libwxmsw31ud_richtext.libwxmsw31ud_stc.libwxmsw31ud_xrc.libwxscintillad.libwxmsw31ud_core.libwxbase31ud.libwxtiffd.libwxjpegd.libwxpngd.libwxzlibd.libwxexpatd.libwinmm.libcomctl32.librpcrt4.libwsock32.libodbc32.lib</code></pre><p>头文件：</p><pre><code>#include &lt;wx/wx.h&gt;class wxMyApp:public wxApp{public:    virtual bool OnInit();};class wxMyFrame:public wxFrame{public:    wxMyFrame(const wxString&amp; title);};</code></pre><p>源文件：</p><pre><code>#include &quot;头文件.h&quot;bool wxMyApp::OnInit(){    wxMyFrame *pMyFrame=new wxMyFrame(_(&quot;myframe&quot;));    pMyFrame-&gt;Show(TRUE);    return TRUE;}wxMyFrame::wxMyFrame(const wxString&amp; title):wxFrame(NULL,NULL,title){}DECLARE_APP(wxMyApp);IMPLEMENT_APP(wxMyApp);</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://docs.wxwidgets.org/3.1/" target="_blank" rel="noopener">wxwidgets文档</a></li><li><a href="http://zetcode.com/gui/wxwidgets/" target="_blank" rel="noopener">wxWidgets教程</a></li><li><a href="http://wiki.codeblocks.org/index.php/User_documentation" target="_blank" rel="noopener">wxWidgets wiki</a></li><li><a href="http://wiki.codeblocks.org/index.php/WxSmith_tutorials" target="_blank" rel="noopener">WxSmith tutorials</a></li><li>C<a href="http://www.wxwidgets.org/docs/book/" target="_blank" rel="noopener">ross-Platform GUI Programming with wxWidgets</a></li><li><a href="http://blog.csdn.net/sxhelijian/article/details/26164181" target="_blank" rel="noopener">wxWidgets应用程序初体验</a></li><li><a href="http://blog.csdn.net/sxhelijian/article/details/26165237" target="_blank" rel="noopener">用wxSmith进行可视化设计 </a></li><li><a href="http://shiningray.cn/windows-shang-pei-zhi-codeblocks-wxwidgets.html" target="_blank" rel="noopener">Windows上配置Code::Blocks + wxWidgets</a></li><li><a href="http://blog.csdn.net/hitwhzhongqiu/article/details/44682359" target="_blank" rel="noopener">VS2010下新建wxWidgets空白工程</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wxWidgets&quot;&gt;&lt;a href=&quot;#wxWidgets&quot; class=&quot;headerlink&quot; title=&quot;wxWidgets&quot;&gt;&lt;/a&gt;wxWidgets&lt;/h1&gt;&lt;h2 id=&quot;Code-Blocks环境&quot;&gt;&lt;a href=&quot;#Code-Blocks环
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="wxWidgets" scheme="https://caojingyou.github.io/tags/wxWidgets/"/>
    
      <category term="Code::Blocks" scheme="https://caojingyou.github.io/tags/Code-Blocks/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen</title>
    <link href="https://caojingyou.github.io/2017/10/15/Doxygen/"/>
    <id>https://caojingyou.github.io/2017/10/15/Doxygen/</id>
    <published>2017-10-15T08:03:00.000Z</published>
    <updated>2018-07-19T02:51:06.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h1><h2 id="doxygen"><a href="#doxygen" class="headerlink" title="doxygen"></a>doxygen</h2><p>doxygen-1.8.13-setup.exe</p><h2 id="graphviz"><a href="#graphviz" class="headerlink" title="graphviz"></a>graphviz</h2><p>graphviz-2.38.msi</p><p>Graphviz软件是开源的图形可视化。可视化是图表的结构信息作为表示方式的抽象网络的示图和曲线图。有重要的应用在网络、生物信息学、软件工程、数据库、网页设计、机器学习、视觉界面中的其它技术领域。</p><h2 id="htmlhelp"><a href="#htmlhelp" class="headerlink" title="htmlhelp"></a>htmlhelp</h2><p>htmlhelp1.3.exe</p><h1 id="Doxygen配置方法"><a href="#Doxygen配置方法" class="headerlink" title="Doxygen配置方法"></a>Doxygen配置方法</h1><p>打开doxywizard.exe</p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen1.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen2.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen3.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen4.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen5.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen6.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen7.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen8.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen9.gif" alt=""></p><p><img src="http://files.cnblogs.com/files/yhcao/Doxygen10.gif" alt=""></p><p>项目文件：</p><p><a href="http://files.cnblogs.com/files/yhcao/Doxyfile.rar" target="_blank" rel="noopener">Doxyfile.rar</a></p><h1 id="doxygen-的注释规范"><a href="#doxygen-的注释规范" class="headerlink" title="doxygen 的注释规范"></a>doxygen 的注释规范</h1><h2 id="标记的块的详细描述"><a href="#标记的块的详细描述" class="headerlink" title="标记的块的详细描述"></a>标记的块的详细描述</h2><h3 id="JavaDoc-style-C-style"><a href="#JavaDoc-style-C-style" class="headerlink" title="JavaDoc style,C-style"></a>JavaDoc style,C-style</h3><pre><code>/** * ... text ... */</code></pre><h3 id="Qt-style"><a href="#Qt-style" class="headerlink" title="Qt style"></a>Qt style</h3><pre><code>/*! * ... text ... */</code></pre><p>中间*可以省略</p><pre><code>/*! ... text ...*/</code></pre><h3 id="至少两个C-注释行，每一行都有一个附加斜线或感叹号"><a href="#至少两个C-注释行，每一行都有一个附加斜线或感叹号" class="headerlink" title="至少两个C++注释行，每一行都有一个附加斜线或感叹号"></a>至少两个C++注释行，每一行都有一个附加斜线或感叹号</h3><pre><code>////// ... text ...///</code></pre><p>或</p><pre><code>//!//!... text ...//!</code></pre><p>注意这种情况下需要一个单独的空行来结束注释。</p><h3 id="多行块注释"><a href="#多行块注释" class="headerlink" title="多行块注释"></a>多行块注释</h3><pre><code>/********************************************//** *  ... text ***********************************************/</code></pre><p>(note the 2 slashes to end the normal comment block and start a special comment block).</p><pre><code>//////////////////////////////////////////////////// ... text .../////////////////////////////////////////////////</code></pre><h2 id="简要描述"><a href="#简要描述" class="headerlink" title="简要描述"></a>简要描述</h2><h3 id="使用-brief"><a href="#使用-brief" class="headerlink" title="使用\brief"></a>使用<code>\brief</code></h3><pre><code>/*! \brief Brief description. *         Brief description continued. * *  Detailed description starts here. */</code></pre><h3 id="JAVADOC-AUTOBRIEF设置为YES-Javadoc风格"><a href="#JAVADOC-AUTOBRIEF设置为YES-Javadoc风格" class="headerlink" title="JAVADOC_AUTOBRIEF设置为YES,Javadoc风格"></a>JAVADOC_AUTOBRIEF设置为YES,Javadoc风格</h3><pre><code>/** Brief description which ends at this dot. Details follow *  here. */</code></pre><p>C++ comments:</p><pre><code>/// Brief description which ends at this dot. Details follow/// here.</code></pre><h3 id="用特殊的C-风格的注释"><a href="#用特殊的C-风格的注释" class="headerlink" title="用特殊的C++风格的注释"></a>用特殊的C++风格的注释</h3><pre><code>/// Brief description./** Detailed description. */</code></pre><p>或<br>    //! Brief description.</p><pre><code>//! Detailed description //! starts here.</code></pre><h3 id="多个详细的描述"><a href="#多个详细的描述" class="headerlink" title="多个详细的描述"></a>多个详细的描述</h3><pre><code>//! Brief description, which is//! really a detailed description since it spans multiple lines./*! Another detailed description! */</code></pre><h3 id="If-you-want-to-document-the-members-of-a-file-struct-union-class-or-enum-it-is-sometimes-desired-to-place-the-documentation-block-after-the-member-instead-of-before-For-this-purpose-you-have-to-put-an-additional-lt-marker-in-the-comment-block-Note-that-this-also-works-for-the-parameters-of-a-function"><a href="#If-you-want-to-document-the-members-of-a-file-struct-union-class-or-enum-it-is-sometimes-desired-to-place-the-documentation-block-after-the-member-instead-of-before-For-this-purpose-you-have-to-put-an-additional-lt-marker-in-the-comment-block-Note-that-this-also-works-for-the-parameters-of-a-function" class="headerlink" title="If you want to document the members of a file, struct, union, class, or enum, it is sometimes desired to place the documentation block after the member instead of before. For this purpose you have to put an additional &lt; marker in the comment block. Note that this also works for the parameters of a function"></a>If you want to document the members of a file, struct, union, class, or enum, it is sometimes desired to place the documentation block after the member instead of before. For this purpose you have to put an additional &lt; marker in the comment block. Note that this also works for the parameters of a function</h3><p>Qt style</p><pre><code>int var; /**&lt; Detailed description after the member */</code></pre><p>或</p><pre><code>int var; /*!&lt; Detailed description after the member */</code></pre><p>或</p><pre><code>int var; //!&lt; Detailed description after the member         //!&lt; </code></pre><p>或</p><pre><code>int var; ///&lt; Detailed description after the member         ///&lt; </code></pre><h3 id="Most-often-one-only-wants-to-put-a-brief-description-after-a-member"><a href="#Most-often-one-only-wants-to-put-a-brief-description-after-a-member" class="headerlink" title="Most often one only wants to put a brief description after a member"></a>Most often one only wants to put a brief description after a member</h3><pre><code>int var; //!&lt; Brief description after the member</code></pre><p>或</p><pre><code>int var; ///&lt; Brief description after the member</code></pre><h3 id="For-functions-one-can-use-the-param-command-to-document-the-parameters-and-then-use-in-out-in-out-to-document-the-direction-For-inline-documentation-this-is-also-possible-by-starting-with-the-direction-attribute-e-g"><a href="#For-functions-one-can-use-the-param-command-to-document-the-parameters-and-then-use-in-out-in-out-to-document-the-direction-For-inline-documentation-this-is-also-possible-by-starting-with-the-direction-attribute-e-g" class="headerlink" title="For functions one can use the @param command to document the parameters and then use [in], [out], [in,out] to document the direction. For inline documentation this is also possible by starting with the direction attribute, e.g."></a>For functions one can use the @param command to document the parameters and then use [in], [out], [in,out] to document the direction. For inline documentation this is also possible by starting with the direction attribute, e.g.</h3><pre><code>void foo(int v /**&lt; [in] docs for input parameter v. */);</code></pre><h3 id="Here-is-an-example-of-the-use-of-these-comment-blocks"><a href="#Here-is-an-example-of-the-use-of-these-comment-blocks" class="headerlink" title="Here is an example of the use of these comment blocks:"></a>Here is an example of the use of these comment blocks:</h3><pre><code>*! A test class */class Afterdoc_Test{  public:    /** An enum type.      *  The documentation block cannot be put after the enum!      */    enum EnumType    {      int EVal1,     /**&lt; enum value 1 */      int EVal2      /**&lt; enum value 2 */    };    void member();   //!&lt; a member function.  protected:    int value;       /*!&lt; an integer value */};</code></pre><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><h3 id="Qt-style-1"><a href="#Qt-style-1" class="headerlink" title="Qt style"></a>Qt style</h3><pre><code>//!  A test class. /*!  A more elaborate class description.*/class QTstyle_Test{  public:    //! An enum.    /*! More detailed enum description. */    enum TEnum {                  TVal1, /*!&lt; Enum value TVal1. */                   TVal2, /*!&lt; Enum value TVal2. */                   TVal3  /*!&lt; Enum value TVal3. */                 }          //! Enum pointer.         /*! Details. */         *enumPtr,          //! Enum variable.         /*! Details. */         enumVar;      //! A constructor.    /*!      A more elaborate description of the constructor.    */    QTstyle_Test();    //! A destructor.    /*!      A more elaborate description of the destructor.    */   ~QTstyle_Test();    //! A normal member taking two arguments and returning an integer value.    /*!      \param a an integer argument.      \param s a constant character pointer.      \return The test results      \sa QTstyle_Test(), ~QTstyle_Test(), testMeToo() and publicVar()    */    int testMe(int a,const char *s);    //! A pure virtual member.    /*!      \sa testMe()      \param c1 the first argument.      \param c2 the second argument.    */    virtual void testMeToo(char c1,char c2) = 0;    //! A public variable.    /*!      Details.    */    int publicVar;    //! A function variable.    /*!      Details.    */    int (*handler)(int a,int b);};</code></pre><h3 id="JavaDoc-style"><a href="#JavaDoc-style" class="headerlink" title="JavaDoc style"></a>JavaDoc style</h3><pre><code>/** *  A test class. A more elaborate class description. */class Javadoc_Test{  public:    /**      * An enum.     * More detailed enum description.     */    enum TEnum {           TVal1, /**&lt; enum value TVal1. */            TVal2, /**&lt; enum value TVal2. */            TVal3  /**&lt; enum value TVal3. */           }        *enumPtr, /**&lt; enum pointer. Details. */       enumVar;  /**&lt; enum variable. Details. */      /**       * A constructor.       * A more elaborate description of the constructor.       */      Javadoc_Test();      /**       * A destructor.       * A more elaborate description of the destructor.       */     ~Javadoc_Test();      /**       * a normal member taking two arguments and returning an integer value.       * @param a an integer argument.       * @param s a constant character pointer.       * @see Javadoc_Test()       * @see ~Javadoc_Test()       * @see testMeToo()       * @see publicVar()       * @return The test results       */       int testMe(int a,const char *s);      /**       * A pure virtual member.       * @see testMe()       * @param c1 the first argument.       * @param c2 the second argument.       */       virtual void testMeToo(char c1,char c2) = 0;      /**        * a public variable.       * Details.       */       int publicVar;      /**       * a function variable.       * Details.       */       int (*handler)(int a,int b);};</code></pre><h2 id="使用指令时需要在前面加上“-”或者“-”（JavaDoc风格）符号"><a href="#使用指令时需要在前面加上“-”或者“-”（JavaDoc风格）符号" class="headerlink" title="使用指令时需要在前面加上“\”或者“@”（JavaDoc风格）符号"></a>使用指令时需要在前面加上“\”或者“@”（JavaDoc风格）符号</h2><p><a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html" target="_blank" rel="noopener">特殊命令</a></p><ul><li>\class is used to indicate that the comment block contains documentation for the class</li><li>\struct to document a C-struct.</li><li>\union to document a union.</li><li>\enum to document an enumeration type.</li><li>\fn to document a function.</li><li>\var to document a variable or typedef or enum value.</li><li>\def to document a #define.</li><li>\typedef to document a type definition.</li><li>\file to document a file.</li><li>\namespace to document a namespace.</li><li>\package to document a Java package.</li><li>\interface to document an IDL interface.</li></ul><h2 id="Here-is-an-example-of-a-C-header-named-structcmd-h-that-is-documented-using-structural-commands"><a href="#Here-is-an-example-of-a-C-header-named-structcmd-h-that-is-documented-using-structural-commands" class="headerlink" title="Here is an example of a C header named structcmd.h that is documented using structural commands:"></a>Here is an example of a C header named structcmd.h that is documented using structural commands:</h2><pre><code>/*! \file structcmd.h    \brief A Documented file.    Details.*//*! \def MAX(a,b)    \brief A macro that returns the maximum of \a a and \a b.    Details.*//*! \var typedef unsigned int UINT32    \brief A type definition for a .    Details.*//*! \var int errno    \brief Contains the last error code.    \warning Not thread safe!*//*! \fn int open(const char *pathname,int flags)    \brief Opens a file descriptor.    \param pathname The name of the descriptor.    \param flags Opening flags.*//*! \fn int close(int fd)    \brief Closes the file descriptor \a fd.    \param fd The descriptor to close.*//*! \fn size_t write(int fd,const char *buf, size_t count)    \brief Writes \a count bytes from \a buf to the filedescriptor \a fd.    \param fd The descriptor to write to.    \param buf The data buffer to write.    \param count The number of bytes to write.*//*! \fn int read(int fd,char *buf,size_t count)    \brief Read bytes from a file descriptor.    \param fd The descriptor to read from.    \param buf The buffer to read into.    \param count The number of bytes to read.*/#define MAX(a,b) (((a)&gt;(b))?(a):(b))typedef unsigned int UINT32;int errno;int open(const char *,int);int close(int);size_t write(int,const char *, size_t);int read(int,char *,size_t);</code></pre><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><pre><code>/*** @file       filename* @brief      This is a brief description.* @details This is the detail description.* @author     author* @date       date* @version A001* @par Copyright (c):*      XXX公司* @par History:        *   version: author, date, desc\n*/</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><pre><code>/** 下面是一个含有两个参数的函数的注释说明（简述）  *  *     这里写该函数的详述信息  *     @param a 被测试的变量（param描述参数）  *     @param s 指向描述测试信息的字符串  *     @return    测试结果 （return描述返回值）  *     @see    Test()    （本函数参考其它的相关的函数，这里作一个链接）  *     @note    (note描述需要注意的问题)  */int testMe(int a,const char *s);</code></pre><h2 id="数据结构注释"><a href="#数据结构注释" class="headerlink" title="数据结构注释"></a>数据结构注释</h2><pre><code>/** * The brief description. * The detail description. */typedef struct{    int var1;///&lt;Description of the member variable}XXXX;或者typedef struct box {    成员变量注释（enum的各个值也如此注释）：    double length; ///&lt; The length of the box    double width; ///&lt; The width of the box    double height; ///&lt; The height of the box};</code></pre><h2 id="宏定义注释"><a href="#宏定义注释" class="headerlink" title="宏定义注释"></a>宏定义注释</h2><pre><code>/** Description of the macro */#define XXXX_XXX_XX      ox7fffffff或者#define XXXX_XXX_XX      0 ///&lt; Description of the macro.</code></pre><h2 id="全局和静态变量注释"><a href="#全局和静态变量注释" class="headerlink" title="全局和静态变量注释"></a>全局和静态变量注释</h2><pre><code>/**  Description of global variable  */int g_xxx = 0;static int s_xxx = 0; ///&lt;  Description of static variable</code></pre><h1 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h1><p><a href="http://www.doxygen.nl/helpers.html" title="http://www.doxygen.nl/helpers.html" target="_blank" rel="noopener">http://www.doxygen.nl/helpers.html</a></p><p><a href="https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET" title="https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET" target="_blank" rel="noopener">https://www.codeproject.com/Articles/2704/Useful-enhancements-for-Visual-Studio-NET</a></p><p><a href="https://www.atomineerutils.com/products.php" title="https://www.atomineerutils.com/products.php" target="_blank" rel="noopener">https://www.atomineerutils.com/products.php</a></p><p><a href="http://doxycomment.sourceforge.net/" title="http://doxycomment.sourceforge.net/" target="_blank" rel="noopener">http://doxycomment.sourceforge.net/</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.stack.nl/~dimitri/doxygen/download.html" title="http://www.stack.nl/~dimitri/doxygen/download.html" target="_blank" rel="noopener">http://www.stack.nl/~dimitri/doxygen/download.html</a></li><li><a href="http://www.stack.nl/~dimitri/doxygen/helpers.html" title="http://www.stack.nl/~dimitri/doxygen/helpers.html" target="_blank" rel="noopener">http://www.stack.nl/~dimitri/doxygen/helpers.html</a></li><li><a href="http://www.graphviz.org/" title="http://www.graphviz.org/" target="_blank" rel="noopener">http://www.graphviz.org/</a></li><li><a href="http://www.graphviz.org/Download..php" title="http://www.graphviz.org/Download..php" target="_blank" rel="noopener">http://www.graphviz.org/Download..php</a></li><li><a href="http://www.cnblogs.com/chenyang920/p/5732643.html" title="http://www.cnblogs.com/chenyang920/p/5732643.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenyang920/p/5732643.html</a></li><li><a href="http://blog.csdn.net/fly542/article/details/7164633" title="http://blog.csdn.net/fly542/article/details/7164633" target="_blank" rel="noopener">http://blog.csdn.net/fly542/article/details/7164633</a></li><li><a href="http://blog.csdn.net/bigpudding24/article/details/45247357" title="http://blog.csdn.net/bigpudding24/article/details/45247357" target="_blank" rel="noopener">http://blog.csdn.net/bigpudding24/article/details/45247357</a></li><li><a href="http://blog.csdn.net/hujian2008/article/details/16343489" title="http://blog.csdn.net/hujian2008/article/details/16343489" target="_blank" rel="noopener">http://blog.csdn.net/hujian2008/article/details/16343489</a></li><li><a href="http://blog.csdn.net/wenrenhua08/article/details/39591239" title="http://blog.csdn.net/wenrenhua08/article/details/39591239" target="_blank" rel="noopener">http://blog.csdn.net/wenrenhua08/article/details/39591239</a></li><li><a href="http://blog.csdn.net/augusdi/article/details/6749845" title="http://blog.csdn.net/augusdi/article/details/6749845" target="_blank" rel="noopener">http://blog.csdn.net/augusdi/article/details/6749845</a></li><li><a href="https://blog.csdn.net/bigpudding24/article/details/45306351" target="_blank" rel="noopener">https://blog.csdn.net/bigpudding24/article/details/45306351</a></li><li><a href="https://blog.csdn.net/bigpudding24/article/details/45247357" target="_blank" rel="noopener">https://blog.csdn.net/bigpudding24/article/details/45247357</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装工具&quot;&gt;&lt;a href=&quot;#安装工具&quot; class=&quot;headerlink&quot; title=&quot;安装工具&quot;&gt;&lt;/a&gt;安装工具&lt;/h1&gt;&lt;h2 id=&quot;doxygen&quot;&gt;&lt;a href=&quot;#doxygen&quot; class=&quot;headerlink&quot; title=&quot;dox
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Doxygen" scheme="https://caojingyou.github.io/tags/Doxygen/"/>
    
  </entry>
  
  <entry>
    <title>VC程序获取管理员权限</title>
    <link href="https://caojingyou.github.io/2017/10/01/VC%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"/>
    <id>https://caojingyou.github.io/2017/10/01/VC程序获取管理员权限/</id>
    <published>2017-10-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h1><p>编译程序的时候设置一下<br>在项目属性–连接器–清单文件–UAC执行级别改为requireAdministrator</p><h1 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h1><pre><code>void GainAdminPrivileges(CString strApp, UINT idd){    CString         strCmd;    strCmd.Format (_T(&quot;/adminoption %d&quot;), idd);    SHELLEXECUTEINFO execinfo;    memset(&amp;execinfo, 0, sizeof(execinfo));    execinfo.lpFile         = strApp;    execinfo.cbSize         = sizeof(execinfo);    execinfo.lpVerb         = _T(&quot;runas&quot;);    execinfo.fMask          = SEE_MASK_NO_CONSOLE;    execinfo.nShow          = SW_SHOWDEFAULT;    execinfo.lpParameters   = strCmd;    ShellExecuteEx(&amp;execinfo);}  </code></pre><p>strApp是应用程序的路径idd我传的是1，但好像传几都没问题</p><pre><code>BOOL ElevateCurrentProcess(CString sCmdLine){    TCHAR szPath[MAX_PATH] = {0};    if (::GetModuleFileName(NULL, szPath, MAX_PATH))    {        // Launch itself as administrator.        SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO) };        sei.lpVerb = _T(&quot;runas&quot;);        sei.lpFile = szPath;        sei.lpParameters = (LPCTSTR)sCmdLine;        //     sei.hwnd = hWnd;        sei.nShow = SW_SHOWNORMAL;        if (!ShellExecuteEx(&amp;sei))        {            DWORD dwStatus = GetLastError();            if (dwStatus == ERROR_CANCELLED)            {                // The user refused to allow privileges elevation.                return FALSE;            }            else if (dwStatus == ERROR_FILE_NOT_FOUND)            {                // The file defined by lpFile was not found and                // an error message popped up.                return FALSE;            }            return FALSE;        }        return TRUE;    }    return FALSE;}</code></pre><h1 id="如何获取正确的文件路径"><a href="#如何获取正确的文件路径" class="headerlink" title="如何获取正确的文件路径"></a>如何获取正确的文件路径</h1><p>当我们那些在Windows 7之前设计的应用程序遇到UAC Virtualization问题的时候，我们需要从新设计我们的代码，将文件写入到合适的位置。在改善既有代码，使之可以与Windows 7兼容的时候，我们应该确保以下几点：</p><p>　　——在运行的时候，应用程序只会将数据保存到每个用户预先定义的位置或者是%alluserprofile% 中定义的普通用户拥有访问权限的位置。</p><p>　　——确定你要写入数据的“已知文件夹”(Knownfolders)。通常，所有用户共用的公共数据文件应该写入到一个全局的公共的位置，这样所有用户都可以访问到。而其它数据则应该写入每个用户自己的文件夹。</p><p>　　1 公共数据文件包括日志文件，配置文件(通常是INI或者XML文件)，应用程序状态文件，比如保存的游戏进程等等。</p><p>　　2 而属于每个用户的文档，则应该保持在文档目录下，或者是用户自己指定的目录。</p><p>　　——当你确定合适的文件保存位置后，不要在代码中明文写出(Hard-code)你选择的路径。为了更好地保持兼容性，我们应该采用下面这些API来获得操作系统“已知文件夹(Knownfolders)”的正确路径。</p><p>　　1 C/C++非托管代码: 使用SHGetKnownFolderPath函数，通过指定“已知文件夹”的KNOWNFOLDERID作为参数来获得正确的文件夹路径。</p><pre><code>　　FOLDERID_ProgramData –所有用户都可以访问的应用程序数据适合放置在这个目录下。　　FOLDERID_LocalAppData – 每个用户单独访问的应用程序数据适合放置在这个目录下。　　FOLDERID_RoamingAppData – 每个用户单独访问的应用程序数据适合放置在这个目录下。 与上面一个目录不同的是，放置在这个目录下的文件会随着用户迁移，当一个用户在同一个域中的其他计算机登录的时候，这些文件会被复制到当前登录的机器上，就像用户随身携带的公文包一样。</code></pre><p>下面这段代码演示了在非托管代码中如何调用shell函数，SHGetKnownFolderPath函数获得正确的文件保存路径(SHGetFolderLocation, SHGetFolderPath, SHGetSpecialFolderLocation, SHGetSpecialFolderPath)：</p><pre><code>#include &quot;shlobj.h&quot;#include &quot;shlwapi.h&quot;//…#define AppFolderName _T(&quot;YourApp&quot;)#define DataFileName _T(&quot;SomeFile.txt&quot;)// 构造一个数据文件路径// dataFilePath指向一个长度为MAX_PATH，类型为TCHAR的字符串数值// hwndDlg是消息对话框的父窗口句柄// 当有错误发生的时候用于显示错误提示// includeFileName用于表示是否在路径后面扩展文件名BOOL MakeDataFilePath(TCHAR *dataFilePath,                       HWND hwndDlg, BOOL includeFileName){    // 初始化工作    memset(dataFilePath, 0, MAX_PATH * sizeof(TCHAR));    PWSTR pszPath = NULL;    // SHGetKnownFolderPath函数可以返回一个已知文件见的路径，    // 例如我的文档(My Documents)，桌面(Desktop)，       // 应用程序文件夹(Program Files)等等。     // 对于数据文件来说，FOLDERID_ProgramFiles并不是一个合适的位置    // 使用FOLDERID_ProgramFiles保存所有用户共享的数据文件    // 使用FOLDERID_LocalAppData保存属于每个用户自己的文件(non-roaming).    // 使用FOLDERID_RoamingAppData保存属于每个用户自己的文件(roaming).// 对于“随身文件”(Roaming files)，// 当一个用户在一个域中的其他计算机登陆的时候，    // 这些文件会被复制到当前登录的机器上，就像用户随身携带的公文包一样        // 获取文件夹路径    if (FAILED(SHGetKnownFolderPath(FOLDERID_ProgramData,               0, NULL, &amp;pszPath)))    // 错误的做法： if (FAILED(SHGetKnownFolderPath(FOLDERID_ProgramFiles,       // 0, NULL, &amp;pszPath)))    {        // 提示错误        MessageBox(hwndDlg, _T(&quot;SHGetKnownFolderPath无法获取文件路径&quot;),            _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);        return FALSE;    }    // 复制路径到目标变量    _tcscpy_s(dataFilePath, MAX_PATH, pszPath);    ::CoTaskMemFree(pszPath);    //错误的做法: _tcscpy_s(dataFilePath, MAX_PATH, _T(&quot;C:\\&quot;));    // 在路径后面扩展应用程序所在文件夹    if (!::PathAppend(dataFilePath, AppFolderName))    {        // 提示错误        MessageBox(hwndDlg, _T(&quot;PathAppend无法扩展路径&quot;),            _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);        return FALSE;    }    // 是否添加文件名    if (includeFileName)    {        // 在路径后扩展文件名        if (!::PathAppend(dataFilePath, DataFileName))        {            // 提示错误            MessageBox(hwndDlg, _T(&quot;PathAppend无法扩展文件名&quot;),                _T(&quot;Error&quot;), MB_OK | MB_ICONERROR);            return FALSE;        }    }    return TRUE;}</code></pre><p>2 托管代码: 使用System.Environment.GetFolderPath函数，通过指定我们想要获取的“已知文件夹”为参数，从而获取相应的文件夹的正确路径。</p><pre><code>　　Environment.SpecialFolder.CommonApplicationData – 所有用户都可以访问的应用程序数据适合放置在这个目录下。　　Environment.SpecialFolder.LocalApplicationData – 每个用户单独访问的应用程序数据适合放置在这个目录下。　　Environment.SpecialFolder.ApplicationData – 每个用户单独访问的应用程序数据适合放置在这个目录下。这是“随身文件夹”。</code></pre><p>下面这段代码展示了如何在托管代码中获取正确的文件路径：</p><pre><code>internal class FileIO    {        private const string AppFolderName = &quot;YourApp&quot;;        private const string DataFileName = &quot;SomeFile.txt&quot;;        private static string _dataFilePath;        /// &lt;summary&gt;        /// 构建路径        /// &lt;/summary&gt;        static FileIO()        {            // Environment.GetFolderPath返回一个“已知文件夹”的路径            // Path.Combine可以合并两个路径成一个合法的路径            // …            _dataFilePath = Path.Combine(Environment.GetFolderPath(                  Environment.SpecialFolder.ProgramFiles), AppFolderName);            //错误的做法：            //_dataFilePath = Path.Combine(Environment.GetFolderPath(             Environment.SpecialFolder.CommonApplicationData), AppFolderName);            // 扩展文件名            _dataFilePath = Path.Combine(_dataFilePath, DataFileName);        }         public static void Save(string text)        {            // 检查要保存的字符串是否为空            if (String.IsNullOrEmpty(text))            {                MessageBox.Show(&quot;字符串为空，无法保持.&quot;, &quot;空字符串&quot;,                     MessageBoxButtons.OK, MessageBoxIcon.Error);                return;            }            try            {                // 获取文件保存的路径                string dirPath = Path.GetDirectoryName(_dataFilePath);                // 检查文件夹是否存在                if (!Directory.Exists(dirPath))                    Directory.CreateDirectory(dirPath); // 创建文件夹            }            catch (Exception ex)            {                MessageBox.Show(ex.Message, &quot;文件夹创建失败&quot;,                    MessageBoxButtons.OK, MessageBoxIcon.Error);                return;            }            try            {                // 保存字符串到文件                StreamWriter sw = new StreamWriter(_dataFilePath);                try                {                    sw.Write(text);                }                finally                {                    // 关闭文件                    sw.Close();                }            }            catch (Exception ex)            {                MessageBox.Show(ex.Message, &quot;文件写入失败&quot;,                    MessageBoxButtons.OK, MessageBoxIcon.Error);            }        }        // …   }}</code></pre><p>如果上面的方法都不适合你，你还可以使用环境变量，使用getenv()或GetEnvironmentVariable()获取相应的文件夹路径：</p><pre><code>　　%ALLUSERSPROFILE% – 所有用户都可以访问的应用程序数据适合放置在这个目录下。　　%LOCALAPPDATA% – 每个用户单独访问的应用程序数据适合放置在这个目录下。 - (Windows Vista 或者Windows 7)　　%APPDATA% – 每个用户单独访问的应用程序数据适合放置在这个目录下。这是“随身文件夹”。- (Windows Vista 或者Windows 7)</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://blog.csdn.net/zhangyulin54321/article/details/8802023" target="_blank" rel="noopener">vc++MCF/C++/C中怎样让应用程序获得或以管理员权限运行 ，ShellExecuteEX编程 — 获取管理员权限</a> </li><li><a href="http://blog.csdn.net/suixiangzhe/article/details/50503047" target="_blank" rel="noopener">VS2010与Win7共舞：UAC与数据重定向 </a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb762494(v=vs.85" target="_blank" rel="noopener">CSIDL</a>.aspx)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：&quot;&gt;&lt;a href=&quot;#一：&quot; class=&quot;headerlink&quot; title=&quot;一：&quot;&gt;&lt;/a&gt;一：&lt;/h1&gt;&lt;p&gt;编译程序的时候设置一下&lt;br&gt;在项目属性–连接器–清单文件–UAC执行级别改为requireAdministrator&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VC" scheme="https://caojingyou.github.io/tags/VC/"/>
    
      <category term="管理员权限" scheme="https://caojingyou.github.io/tags/%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Crypto++</title>
    <link href="https://caojingyou.github.io/2017/09/15/Crypto++/"/>
    <id>https://caojingyou.github.io/2017/09/15/Crypto++/</id>
    <published>2017-09-15T08:03:00.000Z</published>
    <updated>2018-04-19T07:48:45.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Crypto-学习"><a href="#Crypto-学习" class="headerlink" title="Crypto++学习"></a>Crypto++学习</h1><pre><code>// MyTest.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iomanip&gt;//setw与setfill头文件#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1#include &quot;cryptlib.h&quot;#include &quot;md5.h&quot;#include &quot;filters.h&quot;#include &quot;hex.h&quot;#include &quot;base64.h&quot;#include &quot;files.h&quot;#include &quot;sha.h&quot;#include &quot;crc.h&quot;#include &quot;ripemd.h&quot;USING_NAMESPACE(CryptoPP)USING_NAMESPACE(std)int _tmain(int argc, _TCHAR *argv[]){    /************************************************************************/    /* 散列算法                                                                     */    /************************************************************************/    /************************************************************************/    /* MD5                                                                     */    /************************************************************************/    printf(&quot;MD5开始\n&quot;);    byte message[] = &quot;HelloWorld!&quot;;    int mesLen = strlen((char *)message - 1);    byte mres[16];//MD5 128 bits=16bytes    Weak::MD5 md5;    md5.Update(message, mesLen);    md5.Final(mres);    /************************************************************************/    /* md5转换到string                                                                     */    /************************************************************************/    string digest3;    StringSource ss3(mres, sizeof(mres), true,        new HexEncoder(new StringSink(digest3))        );    cout &lt;&lt; digest3 &lt;&lt; endl;    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* md5转换到byte数组                                                                     */    /************************************************************************/    for(int i = 0; i &lt; 16; i++)        printf(&quot;%02x&quot;, mres[i]);    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* 使用SecByteBlock                                                                     */    /************************************************************************/    char *inputCh = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    const byte *input = (byte *)inputCh;    SecByteBlock digest(md5.DigestSize());    //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句    md5.Update(input, strlen(inputCh));    md5.Final(digest);    for(int i = 0; i &lt; md5.DigestSize(); i++)        printf(&quot;%02x&quot;, digest[i]);    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    for (unsigned j = 0; j &lt; md5.DigestSize(); j++)        cout &lt;&lt; setw(2) &lt;&lt; setfill(&apos;0&apos;) &lt;&lt; hex &lt;&lt; (int)digest[j];    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    string src = &quot;123&quot;;    string digest1;    /************************************************************************/    /* 另一种方法转换md5                                                                     */    /************************************************************************/    Weak::MD5 md51;    StringSource(src, true,        new HashFilter(md51,        new HexEncoder(new StringSink(digest1))        )        );    cout &lt;&lt; digest1 &lt;&lt; endl;    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    /************************************************************************/    /* MD5对文件产生签名                                                                     */    /************************************************************************/    {        std::locale loc1 = std::locale::global(std::locale(&quot;.936&quot;)); //解决中文文件名问题        Weak::MD5 md5;        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            md5, new HexEncoder(new StringSink(digest4))            )            );        std::locale::global(std::locale(loc1));        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;    }    printf(&quot;\n&quot;);    system(&quot;pause&quot;);    printf(&quot;MD5结束\n&quot;);    /************************************************************************/    /* 二进制数组编码                                                                     */    /************************************************************************/    /************************************************************************/    /* 将一个byte数组按16进制编码后输出                                                                     */    /************************************************************************/    string encoded;    byte m[] = &quot;HelloWorld!&quot;;    StringSource ss(m, sizeof(m), true,        new HexEncoder(new StringSink(encoded))        );    cout &lt;&lt; encoded &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* 将一个string按16进制编码后输出                                                                     */    /************************************************************************/    string encoded1;    string ms = &quot;HelloWorld!&quot;;    StringSource ss1(ms, true,        new HexEncoder(new StringSink(encoded1))        );    cout &lt;&lt; encoded1 &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* 将一个byte数组按base64编码后输出                                                                     */    /************************************************************************/    string encoded2;    StringSource s(m, sizeof(m), true,        new Base64Encoder(new StringSink(encoded2))        );    cout &lt;&lt; encoded2 &lt;&lt; endl;    system(&quot;pause&quot;);    /************************************************************************/    /* SHA-1对字符串签名                                                                     */    /************************************************************************/    {        SHA1 sha1;        string digest5;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha1,            new HexEncoder(new StringSink(digest5))            )            );        cout &lt;&lt; &quot;SHA-1:    &quot; &lt;&lt; digest5 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha1, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA256 sha256;        string digest246;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha256,            new HexEncoder(new StringSink(digest246))            )            );        cout &lt;&lt; &quot;SHA-256:    &quot; &lt;&lt; digest246 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha256, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA384 sha384;        string digest384;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha384,            new HexEncoder(new StringSink(digest384))            )            );        cout &lt;&lt; &quot;SHA-384:    &quot; &lt;&lt; digest384 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha384, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    {        SHA512 sha512;        string digest512;        string src = &quot;HelloWorld!&quot;;        StringSource(src, true,            new HashFilter(sha512,            new HexEncoder(new StringSink(digest512))            )            );        cout &lt;&lt; &quot;SHA-512:    &quot; &lt;&lt; digest512 &lt;&lt; endl;        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            sha512, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* CRC32跟MD5类似                                                                     */    /************************************************************************/    {        CRC32 crc;        string src = &quot;HelloWorld!&quot;;        string digestcrc;        char *inputCh = &quot;HelloWorld!&quot;;        const byte *input = (byte *)inputCh;        SecByteBlock digest(crc.DigestSize());        //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句        crc.Update(input, strlen(inputCh));        crc.Final(digest);        cout &lt;&lt; &quot;CRC-32:    &quot;;        for(int i = 0; i &lt; crc.DigestSize(); i++)            printf(&quot;%02x&quot;, digest[i]);        printf(&quot;\n&quot;);        StringSource(src, true,            new HashFilter(crc,            new HexEncoder(new StringSink(digestcrc))            )            );        cout &lt;&lt; &quot;CRC-32:    &quot; &lt;&lt; digestcrc &lt;&lt; endl;        printf(&quot;\n&quot;);        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            crc, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* RIPEMD160                                                                   */    /************************************************************************/    {        RIPEMD160 md160;        string src = &quot;HelloWorld!&quot;;        string digestcrc;        char *inputCh = &quot;HelloWorld!&quot;;        const byte *input = (byte *)inputCh;        SecByteBlock digest(md160.DigestSize());        //md5.CalculateDigest(digest ,input, strlen(inputCh));  //此一句等于下面两句        md160.Update(input, strlen(inputCh));        md160.Final(digest);        cout &lt;&lt; &quot;RIPEMD-160:    &quot;;        for(int i = 0; i &lt; md160.DigestSize(); i++)            printf(&quot;%02x&quot;, digest[i]);        printf(&quot;\n&quot;);        StringSource(src, true,            new HashFilter(md160,            new HexEncoder(new StringSink(digestcrc))            )            );        cout &lt;&lt; &quot;RIPEMD-160:    &quot; &lt;&lt; digestcrc &lt;&lt; endl;        printf(&quot;\n&quot;);        system(&quot;pause&quot;);        string filePath = &quot;e:\\test.txt&quot;;        string digest4;        FileSource f(filePath.c_str(), true,            new HashFilter(            md160, new HexEncoder(new StringSink(digest4))            )            );        cout &lt;&lt; &quot;file:    &quot; &lt;&lt; digest4 &lt;&lt; endl;        system(&quot;pause&quot;);    }    /************************************************************************/    /* 对称加密算法 DES AES                                                                     */    /************************************************************************/    /************************************************************************/    /* DES    ValidateDES();                                                                     */    /************************************************************************/    /************************************************************************/    /* AES ValidateRijndael();                                                                     */    /************************************************************************/    /************************************************************************/    /* 非对称加密算法                                                                     */    /************************************************************************/    /************************************************************************/    /* RSA GenerateRSAKey、RSAEncryptString、RSADecryptString、RSASignFile、RSAVerifyFile                                                                     */    /************************************************************************/    system(&quot;pause&quot;);    //http://www.cppblog.com/ArthasLee/archive/2010/12/01/135186.html    return 0;}</code></pre><p>ChannelSwitch</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cryptopp/channels.h&gt; #include &lt;cryptopp/filters.h&gt; #include &lt;cryptopp/sha.h&gt; #include &lt;cryptopp/hex.h&gt;int main(int argc, char *argv[]) {std::string message = &quot;Now is the time for all good men to come to the aide of their country&quot;;// Allow user to override default message from command line arg.if(argc == 2 &amp;&amp; argv[1] != NULL)     message = std::string(argv[1]);// Set hash variablesstd::string s1, s2, s3, s4;CryptoPP::SHA1 sha1; CryptoPP::SHA224 sha224; CryptoPP::SHA256 sha256; CryptoPP::SHA512 sha512;// Run hash functionsCryptoPP::HashFilter f1(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s1)));CryptoPP::HashFilter f2(sha224, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s2)));CryptoPP::HashFilter f3(sha256, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s3)));CryptoPP::HashFilter f4(sha512, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s4)));// Set route to defaultCryptoPP::ChannelSwitch cs;cs.AddDefaultRoute(f1);cs.AddDefaultRoute(f2);cs.AddDefaultRoute(f3);cs.AddDefaultRoute(f4);CryptoPP::StringSource ss(message, true /*pumpAll*/, new CryptoPP::Redirector(cs));std::cout &lt;&lt; &quot;Message: &quot; &lt;&lt; message &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-1: &quot; &lt;&lt; s1 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-224: &quot; &lt;&lt; s2 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-256: &quot; &lt;&lt; s3 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;SHA-512: &quot; &lt;&lt; s4 &lt;&lt; std::endl;}</code></pre><p>文档：</p><ul><li><a href="https://www.cryptopp.com/docs/ref/index.html" title="https://www.cryptopp.com/docs/ref/index.html" target="_blank" rel="noopener">https://www.cryptopp.com/docs/ref/index.html</a></li><li><a href="https://www.cryptopp.com/wiki/Main_Page" title="https://www.cryptopp.com/wiki/Main_Page" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Main_Page</a></li><li><a href="https://www.cryptopp.com/wiki/Special:AllPages" title="https://www.cryptopp.com/wiki/Special:AllPages" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Special:AllPages</a></li><li><a href="https://www.cryptopp.com/wiki/Category:Class" title="https://www.cryptopp.com/wiki/Category:Class" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Category:Class</a><br>-<a href="https://www.cryptopp.com/wiki/Category:Sample" title="https://www.cryptopp.com/wiki/Category:Sample" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Category:Sample</a></li><li><a href="https://www.cryptopp.com/wiki/ChannelSwitch" title="https://www.cryptopp.com/wiki/ChannelSwitch" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/ChannelSwitch</a></li><li><a href="https://www.cryptopp.com/wiki/Recommended_Books" title="https://www.cryptopp.com/wiki/Recommended_Books" target="_blank" rel="noopener">https://www.cryptopp.com/wiki/Recommended_Books</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Crypto-学习&quot;&gt;&lt;a href=&quot;#Crypto-学习&quot; class=&quot;headerlink&quot; title=&quot;Crypto++学习&quot;&gt;&lt;/a&gt;Crypto++学习&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// MyTest.cpp : 定义控制台应用程序的入口点。
/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="Crypto++" scheme="https://caojingyou.github.io/tags/Crypto/"/>
    
      <category term="密码" scheme="https://caojingyou.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本编程30分钟入门</title>
    <link href="https://caojingyou.github.io/2017/09/01/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://caojingyou.github.io/2017/09/01/Shell脚本编程30分钟入门/</id>
    <published>2017-09-01T08:03:00.000Z</published>
    <updated>2018-06-15T06:40:36.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本编程30分钟入门"><a href="#Shell脚本编程30分钟入门" class="headerlink" title="Shell脚本编程30分钟入门"></a>Shell脚本编程30分钟入门</h1><p>转载地址：<br><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">Shell脚本编程30分钟入门</a></p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>看个例子吧：</p><pre><code>#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><ul><li>第1行：指定脚本解释器，这里是用/bin/sh做解释器的</li><li>第2行：切换到当前用户的home目录</li><li>第3行：创建一个目录shell_tut</li><li>第4行：切换到shell_tut目录</li><li>第5行：循环条件，一共循环10次</li><li>第6行：创建一个test_1…10.txt文件</li><li>第7行：循环体结束</li></ul><p>cd, mkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。</p><h3 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h3><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>shell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux默认安装就带了shell解释器。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p><h4 id="Windows上的模拟器"><a href="#Windows上的模拟器" class="headerlink" title="Windows上的模拟器"></a>Windows上的模拟器</h4><p>windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p><ul><li><a href="http://www.cygwin.com" target="_blank" rel="noopener">cygwin</a></li><li><a href="http://www.mingw.org" target="_blank" rel="noopener">mingw</a></li></ul><h3 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h3><h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p><p>本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。</p><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p><pre><code>[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code>iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h4 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h4><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><p>如下是一个PHP Shell Script示例（假设文件名叫test.php）：</p><pre><code>#!/usr/bin/php&lt;?phpfor ($i=0; $i &lt; 10; $i++)        echo $i . &quot;\n&quot;;</code></pre><p>执行：</p><pre><code>/usr/bin/php test.php</code></pre><p>或者：</p><pre><code>chmod +x test.php./test.php</code></pre><h2 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h2><h3 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h3><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h3 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h3><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><ul><li>它的函数只能返回字串，无法返回数组</li><li>它不支持面向对象，你无法实现一些优雅的设计模式</li><li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li></ul><h3 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h3><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p><p>输入一些代码，第一行一般是这样：</p><pre><code>#!/bin/bash#!/usr/bin/php</code></pre><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行Shell脚本有两种方法：</p><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><pre><code>chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code>your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`</code></pre><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name}</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at ${skill}Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h3 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h3><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以“#”开头的行就是注释，会被解释器忽略。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>sh里没有多行注释，只能每一行加一个#号。就像这样：</p><pre><code>#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><pre><code>str=&apos;this is a string&apos;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><pre><code>your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><pre><code>your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h4 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h4><pre><code>string=&quot;abcd&quot;echo ${#string} #输出：4</code></pre><h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><pre><code>string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出：liba</code></pre><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><pre><code>string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#输出：8，这个语句的意思是：找出单词is在这名话中的位置</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>参见本文档末尾的参考资料中<a href="http://tldp.org/LDP/abs/html/string-manipulation.html" target="_blank" rel="noopener">Advanced Bash-Scripting Guid Chapter 10.1</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如：</p><pre><code>&lt;?phpif (isset($_GET[&quot;q&quot;])) {    search(q);}else {    //do nothing}</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><p>还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和cd, ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：</p><pre><code>ll /usr/bin/[-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[</code></pre><p>正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code>if conditionthen    command1     command2    ...    commandN fi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code>if `ps -ef | grep ssh`;  then echo hello; fi</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的</p><h4 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h4><pre><code>if conditionthen    command1     command2    ...    commandNelse    commandfi</code></pre><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><pre><code>if condition1then    command1elif condition2    command2else    commandNfi</code></pre><h3 id="for-while"><a href="#for-while" class="headerlink" title="for while"></a>for while</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>在开篇的示例里演示过了：</p><pre><code>for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone</code></pre><p>写成一行：</p><pre><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></pre><h4 id="C风格的for"><a href="#C风格的for" class="headerlink" title="C风格的for"></a>C风格的for</h4><pre><code>for (( EXP1; EXP2; EXP3 ))do    command1    command2    command3done</code></pre><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><pre><code>while conditiondo    commanddone</code></pre><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><pre><code>while :do    commanddone</code></pre><p>或者</p><pre><code>while truedo    commanddone</code></pre><p>或者</p><pre><code>for (( ; ; ))</code></pre><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><pre><code>until conditiondo    commanddone</code></pre><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code>case &quot;${opt}&quot; in    &quot;Install-Puppet-Server&quot; )        install_master $1        exit    ;;    &quot;Install-Puppet-Client&quot; )        install_client $1        exit    ;;    &quot;Config-Puppet-Server&quot; )        config_puppet_master        exit    ;;    &quot;Config-Puppet-Client&quot; )        config_puppet_client        exit    ;;    &quot;Exit&quot; )        exit    ;;    * ) echo &quot;Bad option, please choose again&quot;esac</code></pre><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>可以使用source和.关键字，如：</p><pre><code>source ./function.sh. ./function.sh</code></pre><p>在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。</p><p>包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:</p><pre><code>. ./function.sh</code></pre><p>不可以写作：</p><pre><code>. function.sh</code></pre><p>如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</p><pre><code>real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path</code></pre><h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h2><h3 id="执行脚本时传入"><a href="#执行脚本时传入" class="headerlink" title="执行脚本时传入"></a>执行脚本时传入</h3><h3 id="脚本运行中输入"><a href="#脚本运行中输入" class="headerlink" title="脚本运行中输入"></a>脚本运行中输入</h3><h3 id="select菜单"><a href="#select菜单" class="headerlink" title="select菜单"></a>select菜单</h3><h2 id="stdin和stdout"><a href="#stdin和stdout" class="headerlink" title="stdin和stdout"></a>stdin和stdout</h2><h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><p>sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看进程列表</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h4 id="排除grep自身"><a href="#排除grep自身" class="headerlink" title="排除grep自身"></a>排除grep自身</h4><h4 id="查找与target相邻的结果"><a href="#查找与target相邻的结果" class="headerlink" title="查找与target相邻的结果"></a>查找与target相邻的结果</h4><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">Advanced Bash-Scripting Guide</a>，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</li><li><a href="http://www.tutorialspoint.com/unix/unix-shell.htm" target="_blank" rel="noopener">Unix Shell Programming</a></li><li><a href="http://bash.cyberciti.biz/guide/Main_Page" target="_blank" rel="noopener">Linux Shell Scripting Tutorial - A Beginner’s handbook</a></li><li><a href="http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">Shell编程基础</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shell脚本编程30分钟入门&quot;&gt;&lt;a href=&quot;#Shell脚本编程30分钟入门&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本编程30分钟入门&quot;&gt;&lt;/a&gt;Shell脚本编程30分钟入门&lt;/h1&gt;&lt;p&gt;转载地址：&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Shell" scheme="https://caojingyou.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://caojingyou.github.io/2017/08/21/Python/"/>
    <id>https://caojingyou.github.io/2017/08/21/Python/</id>
    <published>2017-08-21T08:03:00.000Z</published>
    <updated>2018-08-28T09:17:36.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.python.org/" title="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p><h2 id="第三方包安装方法"><a href="#第三方包安装方法" class="headerlink" title="第三方包安装方法"></a>第三方包安装方法</h2><h3 id="第一种方法（不使用pip或者easy-install-："><a href="#第一种方法（不使用pip或者easy-install-：" class="headerlink" title="第一种方法（不使用pip或者easy_install)："></a>第一种方法（不使用pip或者easy_install)：</h3><p>Step1:在网上找到的需要的包，下载下来。<code>eg. rsa-3.1.4.tar.gz</code></p><p>Step2:解压缩该文件。</p><p>Step3:命令行工具cd切换到所要安装的包的目录，找到<code>setup.py</code>文件，然后输入<code>python setup.py install</code></p><h3 id="第二种方法（使用pip或者easy-install）："><a href="#第二种方法（使用pip或者easy-install）：" class="headerlink" title="第二种方法（使用pip或者easy_install）："></a>第二种方法（使用pip或者easy_install）：</h3><p>直接打开cmd，敲<code>pip install rsa</code>。</p><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><h3 id="安装python插件"><a href="#安装python插件" class="headerlink" title="安装python插件"></a>安装python插件</h3><p>打开VScode，Ctrl+p<br>输入 “ext install python”</p><h2 id="WebStorm-2018-2-PyCharm-激活方法"><a href="#WebStorm-2018-2-PyCharm-激活方法" class="headerlink" title="WebStorm 2018.2 PyCharm 激活方法"></a><a href="http://www.unitycn.cn/?p=725" target="_blank" rel="noopener">WebStorm 2018.2 PyCharm 激活方法</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/&quot; title=&quot;https://www.python.org/&quot; targ
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Python" scheme="https://caojingyou.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>获取所有本机IP</title>
    <link href="https://caojingyou.github.io/2017/08/15/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E6%9C%AC%E6%9C%BAIP/"/>
    <id>https://caojingyou.github.io/2017/08/15/获取所有本机IP/</id>
    <published>2017-08-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.082Z</updated>
    
    <content type="html"><![CDATA[<pre><code>#include &lt;WinSock2.h&gt;#include &lt;Iphlpapi.h&gt;#pragma comment(lib,&quot;iphlpapi.lib&quot;)// 获得本机的IP地址void CIOCPModel::GetLocalIP(CStringArray &amp;arrIp){    //PIP_ADAPTER_INFO结构体指针存储本机网卡信息    PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();    //得到结构体大小,用于GetAdaptersInfo参数    unsigned long stSize = sizeof(IP_ADAPTER_INFO);    //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量    int nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);    if (ERROR_BUFFER_OVERFLOW == nRel)    {        //如果函数返回的是ERROR_BUFFER_OVERFLOW        //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小        //这也是说明为什么stSize既是一个输入量也是一个输出量        //释放原来的内存空间        delete pIpAdapterInfo;        //重新申请内存空间用来存储所有网卡信息        pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];        //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量        nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize);    }    if (ERROR_SUCCESS == nRel)    {        //输出网卡信息        while (pIpAdapterInfo)        {            IP_ADDR_STRING *pIpAddrString = &amp;(pIpAdapterInfo-&gt;IpAddressList);            do            {                CString strTemp = pIpAddrString-&gt;IpAddress.String;                arrIp.Add(strTemp);                pIpAddrString = pIpAddrString-&gt;Next;            }            while (pIpAddrString);            pIpAdapterInfo = pIpAdapterInfo-&gt;Next;        }    }    //释放内存空间    if (pIpAdapterInfo)    {        delete pIpAdapterInfo;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;#include &amp;lt;WinSock2.h&amp;gt;
#include &amp;lt;Iphlpapi.h&amp;gt;
#pragma comment(lib,&amp;quot;iphlpapi.lib&amp;quot;)

// 获得本机的IP地址
void CIOCPMod
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="IP" scheme="https://caojingyou.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>MFC背景透明</title>
    <link href="https://caojingyou.github.io/2017/08/01/MFC%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E/"/>
    <id>https://caojingyou.github.io/2017/08/01/MFC背景透明/</id>
    <published>2017-08-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h1><pre><code>typedef BOOL (WINAPI *lpfnSetLayeredWindowAttributes)(HWND hWnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);lpfnSetLayeredWindowAttributes SetLayeredWindowAttributes;   //设置成边缘透明COLORREF maskColor = RGB(240, 240, 240);HMODULE hUser32 = GetModuleHandle(_T(&quot;user32.dll&quot;)); //加载动态链接库SetLayeredWindowAttributes = (lpfnSetLayeredWindowAttributes)GetProcAddress(hUser32, &quot;SetLayeredWindowAttributes&quot;);            //取得SetLayeredWindowAttributes函数指针            //为窗口加入WS_EX_LAYERED扩展属性SetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE, GetWindowLong(GetSafeHwnd(), GWL_EXSTYLE)^WS_EX_LAYERED);             //调用SetLayeredWinowAttributes函数/*SetLayeredWindowAttributes(this-&gt;GetSafeHwnd(), maskColor, 192, LWA_COLORKEY);  */SetLayeredWindowAttributes(this-&gt;GetSafeHwnd(), maskColor, 255, LWA_ALPHA | LWA_COLORKEY);FreeLibrary(hUser32);   //释放动态链//LWA_ALPHA时：crKey参数无效，bAlpha参数有效；//LWA_COLORKEY：窗体中的所有颜色为crKey的地方将变为透明，bAlpha参数无效。//LWA_ALPHA | LWA_COLORKEY：crKey的地方将变为全透明，而其它地方根据bAlpha参数确定透明度。</code></pre><h1 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h1><pre><code>COLORREF m_bgcolor = RGB(0, 0, 0);BOOL m_bTransparent = ToggleTransparent(m_bgcolor, 100, LWA_ALPHA);BOOL ToggleTransparent(COLORREF crKey, BYTE bAlpha, DWORD dwFlags){    BOOL bResult;    LONG dwExStyle;    dwExStyle = GetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE);    if (dwExStyle &amp; WS_EX_LAYERED)    {        dwExStyle &amp;= ~(WS_EX_LAYERED);        bResult = FALSE;    }    else    {        dwExStyle |= (WS_EX_LAYERED);        bResult = TRUE;    }    SetWindowLong(this-&gt;GetSafeHwnd(), GWL_EXSTYLE, dwExStyle);    SetLayeredWindowAttributes( crKey, bAlpha, dwFlags);    return bResult;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：&quot;&gt;&lt;a href=&quot;#一：&quot; class=&quot;headerlink&quot; title=&quot;一：&quot;&gt;&lt;/a&gt;一：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;typedef BOOL (WINAPI *lpfnSetLayeredWindowAttributes)(HWND hWn
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="MFC" scheme="https://caojingyou.github.io/tags/MFC/"/>
    
      <category term="背景透明" scheme="https://caojingyou.github.io/tags/%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>boost</title>
    <link href="https://caojingyou.github.io/2017/07/15/boost/"/>
    <id>https://caojingyou.github.io/2017/07/15/boost/</id>
    <published>2017-07-15T08:03:00.000Z</published>
    <updated>2018-05-02T01:19:52.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Visual-Studio-IDE构建"><a href="#使用Visual-Studio-IDE构建" class="headerlink" title="使用Visual Studio IDE构建"></a>使用Visual Studio IDE构建</h1><ul><li><p>From Visual Studio’s File menu, select New &gt; Project…</p></li><li><p>In the left-hand pane of the resulting New Project dialog, select Visual C++ &gt; Win32.</p></li><li><p>In the right-hand pane, select Win32 Console Application (VS8.0) or Win32 Console Project (VS7.1).</p></li><li><p>In the name field, enter “example”</p></li><li><p>Right-click example in the Solution Explorer pane and select Properties from the resulting pop-up menu</p></li><li><p>In Configuration Properties &gt; C/C++ &gt; General &gt; Additional Include Directories, enter the path to the Boost root directory, for example</p><p>  C:\Program Files\boost\boost_1_63_0</p></li><li><p>In Configuration Properties &gt; C/C++ &gt; Precompiled Headers, change Use Precompiled Header (/Yu) to Not Using Precompiled Headers.</p></li><li><p>Replace the contents of the example.cpp generated by the IDE with the example code above.</p><pre><code>#include &lt;boost/lambda/lambda.hpp&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main(){    using namespace boost::lambda;    typedef std::istream_iterator&lt;int&gt; in;    std::for_each(        in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; &quot; &quot; );}</code></pre></li><li><p>From the Build menu, select Build Solution.</p></li></ul><h1 id="头文件与库"><a href="#头文件与库" class="headerlink" title="头文件与库"></a>头文件与库</h1><p>Nothing to Build?</p><p>Most Boost libraries are header-only: they consist entirely of header files containing templates and inline functions, and require no separately-compiled library binaries or special treatment when linking.</p><p>The only Boost libraries that must be built separately are:</p><pre><code>Boost.ChronoBoost.ContextBoost.FilesystemBoost.GraphParallelBoost.IOStreamsBoost.LocaleBoost.Log (see build documentation)Boost.MPIBoost.ProgramOptionsBoost.Python (see the Boost.Python build documentation before building and installing it)Boost.RegexBoost.SerializationBoost.SignalsBoost.SystemBoost.ThreadBoost.TimerBoost.Wave</code></pre><p>A few libraries have optional separately-compiled binaries:</p><pre><code>Boost.DateTime has a binary component that is only needed if you&apos;re using its to_string/from_string or serialization features, or if you&apos;re targeting Visual C++ 6.x or Borland.Boost.Graph also has a binary component that is only needed if you intend to parse GraphViz files.Boost.Math has binary components for the TR1 and C99 cmath functions.Boost.Random has a binary component which is only needed if you&apos;re using random_device.Boost.Test can be used in “header-only” or “separately compiled” mode, although separate compilation is recommended for serious use.Boost.Exception provides non-intrusive implementation of exception_ptr for 32-bit _MSC_VER==1310 and _MSC_VER==1400 which requires a separately-compiled binary. This is enabled by #define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR.</code></pre><h1 id="从源代码构建"><a href="#从源代码构建" class="headerlink" title="从源代码构建"></a>从源代码构建</h1><p>使用Visual Studio命令提示</p><p>If you wish to build from source with Visual C++, you can use a simple build procedure described in this section. Open the command prompt and change your current directory to the Boost root directory. Then, type the following commands:</p><pre><code>bootstrap.\b2</code></pre><p>The first command prepares the Boost.Build system for use. The second command invokes Boost.Build to build the separately-compiled Boost libraries. Please consult the <a href="http://www.boost.org/build/doc/html/bbv2/overview/invocation.html" target="_blank" rel="noopener">Boost.Build documentation</a> for a list of allowed options.</p><h2 id="构建动态库、静态库"><a href="#构建动态库、静态库" class="headerlink" title="构建动态库、静态库"></a>构建动态库、静态库</h2><p>编译，可以简单的使用b2 install，也可以指定存放目录，或者寻找网上其它帮助文章。</p><p>查看帮助可以输入：.\b2 –help</p><p>比如要开启多线程编译：b2 install threading=multi</p><p>设置生成的是debug或者release</p><p>备注：如果是使用VS2013，请指定输出库类型，否则会缺一个lib文件：</p><p>“无法打开文件 libboost_thread_vc120_mt_sgd-1_55.lib”。</p><p>在2013时，我是使用下面的语句进行编译：</p><pre><code>// 如果要获取动态库：bjam install stage --toolset=msvc-12.0 --stagedir=&quot;C:\Boost\boost_vc_120&quot; link=shared runtime-link=shared threading=multi debug release  // 如果是要获取静态库：bjam install stage --toolset=msvc-12.0 --stagedir=&quot;C:\Boost\boost_vc_120&quot; link=static runtime-link=static threading=multi debug release  </code></pre><p>其中，注意修改–toolset=msvc-12.0，将12.0修改成对应的vs版本号，12.0是VS2013的版本号。</p><p>目标地址也要修改成你所需的。</p><p>注意，不要漏了install，它会帮你把头文件集合到一个文件夹中。</p><p>编译过程有一个复制过程，编译需要的时间比较长，本次编译过程中，会在C盘根目录下生成一个boost文件夹，然后包含include和lib文件夹，这就是我们将要使用的头文件和库文件。</p><h2 id="出现“boost-此时不应有-Microsoft。”的问题："><a href="#出现“boost-此时不应有-Microsoft。”的问题：" class="headerlink" title="出现“boost 此时不应有 \Microsoft。”的问题："></a>出现“boost 此时不应有 \Microsoft。”的问题：</h2><p><a href="http://blog.csdn.net/poem_qianmo/article/details/26048697" target="_blank" rel="noopener">解决VS命令提示符 “Setting environment for using Microsoft Visual Studio. 此时不应有”系列错误</a></p><h1 id="使用预编译的二进制文件boost库"><a href="#使用预编译的二进制文件boost库" class="headerlink" title="使用预编译的二进制文件boost库"></a>使用预编译的二进制文件boost库</h1><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/boost_1_63_0-msvc-14.0-32.exe/download" target="_blank" rel="noopener">boost_1_63_0-msvc-14.0-32.exe</a></p><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/boost_1_63_0-msvc-10.0-64.exe/download" target="_blank" rel="noopener">boost_1_63_0-msvc-14.0-64.exe</a></p><p><a href="https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/" target="_blank" rel="noopener">https://sourceforge.net/projects/boost/files/boost-binaries/1.63.0/</a></p><h1 id="boost-jam"><a href="#boost-jam" class="headerlink" title="boost-jam"></a>boost-jam</h1><p>可使用<a href="https://sourceforge.net/projects/boost/files/boost-jam/3.1.18/" target="_blank" rel="noopener">boost-jam</a>编译boost</p><p>为了编译 bjam 本身，要执行一个名为 build 的简单脚本，它也为不同的操作系统提供了源代码。 对于 Windows，它是批处理文件 build.bat。 对于 Linux，文件名为 build.sh。</p><p>要用 Visual Studio 2008 的C++编译器同时生成 Boost C++ 库的调试版和发布版，并将它们安装在目录 D:\Boost 中，应执行的命令是 bjam –toolset=msvc-9.0 –build-type=complete –prefix=D:\Boost install. 要在 Linux 中使用缺省目录创建它们，则要执行的命令是 bjam –toolset=gcc –build-type=complete install.</p><h1 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h1><p>Boost C++  库    C++ 标准    简要说明</p><p><code>Boost.Any</code>        Boost.Any 提供了一个名为 boost::any 的数据类型，可以存放任意的类型。 例如，一个类型为 boost::any 的变量可以先存放一个 int 类型的值，然后替换为一个 std::string 类型的字符串。</p><p><code>Boost.Array</code>    TR1    Boost.Array 可以把 C++ 数组视同 C++ 标准的容器。</p><p><code>Boost.Asio</code>    TR2    Boost.Asio 可用于开发异步处理数据的应用，如网络应用。</p><p><code>Boost.Bimap</code>        Boost.Bimap 提供了一个名为 boost::bimap 的类，它类似于 std::map. 主要的差别在于 boost::bimap 可以同时从键和值进行搜索。</p><p><code>Boost.Bind</code>    TR1    Boost.Bind 是一种适配器，可以将函数作为模板参数，即使该函数的签名与模板参数不兼容。</p><p><code>Boost.Conversion</code>        Boost.Conversion 提供了三个转型操作符，分别执行向下转型、交叉转型，以及不同数字类型间的值转换。</p><p><code>Boost.DateTime</code>        Boost.DateTime 可用于以灵活的格式处理、读入和写出日期及时间值。</p><p><code>Boost.Exception</code>        Boost.Exception 可以在抛出的异常中加入额外的数据，以便在 catch 处理中提供更多的信息。 这有助于更容易地调试，以及对异常情况更好地作出反应。</p><p><code>Boost.Filesystem</code>    TR2    Boost.Filesystem 提供了一个类来处理路径信息，还包含了几个访问文件和目录的函数。</p><p><code>Boost.Format</code>        Boost.Format 以一个类型安全且可扩展的 boost::format 类替代了 std::printf() 函数。</p><p><code>Boost.Function</code>    TR1    Boost.Function 简化了函数指针的定义。</p><p><code>Boost.Interprocess</code>        Boost.Interprocess 允许多个应用通过共享内存以快速、高效的方式进行通信。</p><p><code>Boost.Lambda</code>        Boost.Lambda 可以定义匿名的函数。 代码被内联地声明和执行，避免了单独的函数调用。</p><p><code>Boost.Multiindex</code>        Boost.Multiindex 定义了一些新的容器，它们可以同时支持多个接口，如 std::vector 和 std::map 的接口。</p><p><code>Boost.NumericConversion</code>        Boost.NumericConversion 提供了一个转型操作符，可以安全地在不同的数字类型间进行值转换，不会生成上溢出或下溢出的条件。</p><p><code>Boost.PointerContainer</code>        Boost.PointerContainer 提供了专门为动态分配对象进行优化的容器。</p><p><code>Boost.Ref</code>    TR1    Boost.Ref 的适配器可以将不可复制对象的引用传给需要复制的函数。</p><p><code>Boost.Regex</code>    TR1    Boost.Regex 提供了通过正则表达式进行文本搜索的函数。</p><p><code>Boost.Serialization</code>        通过 Boost.Serialization，对象可以被序列化，如保存在文件中，并在以后重新导入。</p><p><code>Boost.Signals</code>        Boost.Signal 是一个事件处理的框架，基于所谓的 signal/slot 概念。 函数与信号相关联并在信号被触发时自动被调用。</p><p><code>Boost.SmartPoiners</code>    TR1    Boost.SmartPoiners 提供了多个智能指针，简化了动态分配对象的管理。</p><p><code>Boost.Spirit</code>        Boost.Spirit 可以用类似于 EBNF (扩展巴科斯范式)的语法生成词法分析器。</p><p><code>Boost.StringAlgorithms</code>        Boost.StringAlgorithms 提供了多个独立的函数，以方便处理字符串。</p><p><code>Boost.System</code>    TR2    Boost.System 提供了一个处理系统相关或应用相关错误代码的框架。</p><p><code>Boost.Thread</code>    C++0x    Boost.Thread 可用于开发多线程应用。</p><p><code>Boost.Tokenizer</code>        Boost.Tokenizer 可以对一个字符串的各个组件进行迭代。</p><p><code>Boost.Tuple</code>    TR1    Boost.Tuple 提供了泛化版的 std::pair，可以将任意数量的数据组在一起。</p><p><code>Boost.Unordered</code>    TR1    Boost.Unordered 扩展了 C++ 标准的容器，增加了boost::unordered_set 和 boost::unordered_map.</p><p><code>Boost.Variant</code>        Boost.Variant 可以定义多个数据类型，类似于 union, 将多个数据类型组在一起。 Boost.Variant 比 union 优胜的地方在于它可以使用类。</p><h1 id="highscore代码"><a href="#highscore代码" class="headerlink" title="highscore代码"></a>highscore代码</h1><pre><code>#include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2010, 1, 30);   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day_of_week() &lt;&lt; std::endl;   std::cout &lt;&lt; d.end_of_month() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d = boost::gregorian::day_clock::universal_day();   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl;   d = boost::gregorian::date_from_iso_string(&quot;20100131&quot;);   std::cout &lt;&lt; d.year() &lt;&lt; std::endl;   std::cout &lt;&lt; d.month() &lt;&lt; std::endl;   std::cout &lt;&lt; d.day() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2008, 1, 31);   boost::gregorian::date d2(2008, 8, 31);   boost::gregorian::date_duration dd = d2 - d1;   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date_duration dd(4);   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl;   boost::gregorian::weeks ws(4);   std::cout &lt;&lt; ws.days() &lt;&lt; std::endl;   boost::gregorian::months ms(4);   std::cout &lt;&lt; ms.number_of_months() &lt;&lt; std::endl;   boost::gregorian::years ys(4);   std::cout &lt;&lt; ys.number_of_years() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 31);   boost::gregorian::months ms(1);   boost::gregorian::date d2 = d + ms;   std::cout &lt;&lt; d2 &lt;&lt; std::endl;   boost::gregorian::date d3 = d2 - ms;   std::cout &lt;&lt; d3 &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 30);   boost::gregorian::months ms(1);   boost::gregorian::date d2 = d + ms;   std::cout &lt;&lt; d2 &lt;&lt; std::endl;   boost::gregorian::date d3 = d2 - ms;   std::cout &lt;&lt; d3 &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2009, 1, 30);   boost::gregorian::date d2(2009, 10, 31);   boost::gregorian::date_period dp(d1, d2);   boost::gregorian::date_duration dd = dp.length();   std::cout &lt;&lt; dd.days() &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d1(2009, 1, 30);   boost::gregorian::date d2(2009, 10, 31);   boost::gregorian::date_period dp(d1, d2);   std::cout &lt;&lt; dp.contains(d1) &lt;&lt; std::endl;   std::cout &lt;&lt; dp.contains(d2) &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::gregorian::date d(2009, 1, 5);   boost::gregorian::day_iterator it(d);   std::cout &lt;&lt; *++it &lt;&lt; std::endl;   std::cout &lt;&lt; boost::date_time::next_weekday(*it, boost::gregorian::greg_weekday(boost::date_time::Friday)) &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::gregorian::date d = pt.date();   std::cout &lt;&lt; d &lt;&lt; std::endl;   boost::posix_time::time_duration td = pt.time_of_day();   std::cout &lt;&lt; td &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt = boost::posix_time::second_clock::universal_time();   std::cout &lt;&lt; pt.date() &lt;&lt; std::endl;   std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl;   pt = boost::posix_time::from_iso_string(&quot;20090105T120000&quot;);   std::cout &lt;&lt; pt.date() &lt;&lt; std::endl;   std::cout &lt;&lt; pt.time_of_day() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::time_duration td(16, 30, 0);   std::cout &lt;&lt; td.hours() &lt;&lt; std::endl;   std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl;   std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl;   std::cout &lt;&lt; td.total_seconds() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0));   boost::posix_time::time_duration td = pt2 - pt1;   std::cout &lt;&lt; td.hours() &lt;&lt; std::endl;   std::cout &lt;&lt; td.minutes() &lt;&lt; std::endl;   std::cout &lt;&lt; td.seconds() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::time_duration td(6, 30, 0);   boost::posix_time::ptime pt2 = pt1 + td;   std::cout &lt;&lt; pt2.time_of_day() &lt;&lt; std::endl; } #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(18, 30, 0));   boost::posix_time::time_period tp(pt1, pt2);   std::cout &lt;&lt; tp.contains(pt1) &lt;&lt; std::endl;   std::cout &lt;&lt; tp.contains(pt2) &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 05), boost::posix_time::time_duration(12, 0, 0));   boost::posix_time::time_iterator it(pt, boost::posix_time::time_duration(6, 30, 0));   std::cout &lt;&lt; *++it &lt;&lt; std::endl;   std::cout &lt;&lt; *++it &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;));   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt(pt, tz);   std::cout &lt;&lt; dt.utc_time() &lt;&lt; std::endl;   std::cout &lt;&lt; dt &lt;&lt; std::endl;   std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl;   std::cout &lt;&lt; dt.zone_name() &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+1&quot;));   boost::posix_time::ptime pt(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt(pt, tz);   std::cout &lt;&lt; dt.local_time() &lt;&lt; std::endl;   boost::local_time::time_zone_ptr tz2(new boost::local_time::posix_time_zone(&quot;EET+2&quot;));   std::cout &lt;&lt; dt.local_time_in(tz2).local_time() &lt;&lt; std::endl; } #include &lt;boost/date_time/local_time/local_time.hpp&gt; #include &lt;iostream&gt; int main() {   boost::local_time::time_zone_ptr tz(new boost::local_time::posix_time_zone(&quot;CET+0&quot;));   boost::posix_time::ptime pt1(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(12, 0, 0));   boost::local_time::local_date_time dt1(pt1, tz);   boost::posix_time::ptime pt2(boost::gregorian::date(2009, 1, 5), boost::posix_time::time_duration(18, 0, 0));   boost::local_time::local_date_time dt2(pt2, tz);   boost::local_time::local_time_period tp(dt1, dt2);   std::cout &lt;&lt; tp.contains(dt1) &lt;&lt; std::endl;   std::cout &lt;&lt; tp.contains(dt2) &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; #include &lt;locale&gt; int main() {   boost::gregorian::date d(2009, 1, 7);   boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d %B %Y&quot;);   std::cout.imbue(std::locale(std::cout.getloc(), df));   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/date_time/gregorian/gregorian.hpp&gt; #include &lt;iostream&gt; #include &lt;locale&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string months[12] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; };   std::string weekdays[7] = { &quot;Sonntag&quot;, &quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot; };   boost::gregorian::date d(2009, 1, 7);   boost::gregorian::date_facet *df = new boost::gregorian::date_facet(&quot;%A, %d. %B %Y&quot;);   df-&gt;long_month_names(std::vector&lt;std::string&gt;(months, months + 12));   df-&gt;long_weekday_names(std::vector&lt;std::string&gt;(weekdays, weekdays + 7));   std::cout.imbue(std::locale(std::cout.getloc(), df));   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;iostream&gt; int main() {   boost::archive::text_oarchive oa(std::cout);   int i = 1;   oa &lt;&lt; i; } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; void save() {   std::ofstream file(&quot;archiv.txt&quot;);   boost::archive::text_oarchive oa(file);   int i = 1;   oa &lt;&lt; i; } void load() {   std::ifstream file(&quot;archiv.txt&quot;);   boost::archive::text_iarchive ia(file);   int i = 0;   ia &gt;&gt; i;   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   int i = 1;   oa &lt;&lt; i; } void load() {   boost::archive::text_iarchive ia(ss);   int i = 0;   ia &gt;&gt; i;   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_; } void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age, const std::string &amp;name)     : age_(age), name_(name)   {   }   int age() const   {     return age_;   }   std::string name() const   {     return name_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_;   std::string name_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_;   ar &amp; p.name_; } void save() {   boost::archive::text_oarchive oa(ss);   person p(31, &quot;Boris&quot;);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl;   std::cout &lt;&lt; p.name() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age, const std::string &amp;name)     : age_(age), name_(name)   {   }   int age() const   {     return age_;   }   std::string name() const   {     return name_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   friend void serialize(Archive &amp;ar, person &amp;p, const unsigned int version);   int age_;   std::string name_; }; template &lt;typename Archive&gt; void serialize(Archive &amp;ar, person &amp;p, const unsigned int version) {   ar &amp; p.age_;   if (version &gt; 0)     ar &amp; p.name_; } BOOST_CLASS_VERSION(person, 1) void save() {   boost::archive::text_oarchive oa(ss);   person p(31, &quot;Boris&quot;);   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   ia &gt;&gt; p;   std::cout &lt;&lt; p.age() &lt;&lt; std::endl;   std::cout &lt;&lt; p.name() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person *p = new person(31);   oa &lt;&lt; p;   std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/scoped_ptr.hpp&gt; #include &lt;boost/scoped_ptr.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   boost::scoped_ptr&lt;person&gt; p(new person(31));   oa &lt;&lt; p; } void load() {   boost::archive::text_iarchive ia(ss);   boost::scoped_ptr&lt;person&gt; p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; void save() {   boost::archive::text_oarchive oa(ss);   person p(31);   person &amp;pp = p;   oa &lt;&lt; pp; } void load() {   boost::archive::text_iarchive ia(ss);   person p;   person &amp;pp = p;   ia &gt;&gt; pp;   std::cout &lt;&lt; pp.age() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; void save() {   boost::archive::text_oarchive oa(ss);   developer d(31, &quot;C++&quot;);   oa &lt;&lt; d; } void load() {   boost::archive::text_iarchive ia(ss);   developer d;   ia &gt;&gt; d;   std::cout &lt;&lt; d.age() &lt;&lt; std::endl;   std::cout &lt;&lt; d.language() &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;boost/serialization/export.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   virtual int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; BOOST_CLASS_EXPORT(developer) void save() {   boost::archive::text_oarchive oa(ss);   person *p = new developer(31, &quot;C++&quot;);   oa &lt;&lt; p;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/string.hpp&gt; #include &lt;boost/serialization/export.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; std::stringstream ss; class person { public:   person()   {   }   person(int age)     : age_(age)   {   }   virtual int age() const   {     return age_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; age_;   }   int age_; }; class developer   : public person { public:   developer()   {   }   developer(int age, const std::string &amp;language)     : person(age), language_(language)   {   }   std::string language() const   {     return language_;   } private:   friend class boost::serialization::access;   template &lt;typename Archive&gt;   void serialize(Archive &amp;ar, const unsigned int version)   {     ar &amp; boost::serialization::base_object&lt;person&gt;(*this);     ar &amp; language_;   }   std::string language_; }; void save() {   boost::archive::text_oarchive oa(ss);   oa.register_type&lt;developer&gt;();   person *p = new developer(31, &quot;C++&quot;);   oa &lt;&lt; p;   delete p; } void load() {   boost::archive::text_iarchive ia(ss);   ia.register_type&lt;developer&gt;();   person *p;   ia &gt;&gt; p;   std::cout &lt;&lt; p-&gt;age() &lt;&lt; std::endl;   delete p; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   boost::array&lt;int, 3&gt; a = { 0, 1, 2 };   oa &lt;&lt; a; } void load() {   boost::archive::text_iarchive ia(ss);   boost::array&lt;int, 3&gt; a;   ia &gt;&gt; a;   std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/archive/text_oarchive.hpp&gt; #include &lt;boost/archive/text_iarchive.hpp&gt; #include &lt;boost/serialization/array.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; std::stringstream ss; void save() {   boost::archive::text_oarchive oa(ss);   boost::array&lt;int, 3&gt; a = { 0, 1, 2 };   oa &lt;&lt; boost::serialization::make_array(a.data(), a.size()); } void load() {   boost::archive::text_iarchive ia(ss);   boost::array&lt;int, 3&gt; a;   ia &gt;&gt; boost::serialization::make_array(a.data(), a.size());   std::cout &lt;&lt; a[0] &lt;&lt; &quot;, &quot; &lt;&lt; a[1] &lt;&lt; &quot;, &quot; &lt;&lt; a[2] &lt;&lt; std::endl; } int main() {   save();   load(); } #include &lt;boost/spirit.hpp&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main() { } #include &lt;boost/spirit.hpp&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/spirit.hpp&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   struct print   {     void operator()(const char *begin, const char *end) const     {       std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl;     }   };   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | &quot;true&quot; | &quot;false&quot; | &quot;null&quot;;       number = real_p;       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/spirit.hpp&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; struct json_grammar   : public boost::spirit::grammar&lt;json_grammar&gt; {   struct print   {     void operator()(const char *begin, const char *end) const     {       std::cout &lt;&lt; std::string(begin, end) &lt;&lt; std::endl;     }     void operator()(const double d) const     {       std::cout &lt;&lt; d &lt;&lt; std::endl;     }   };   template &lt;typename Scanner&gt;   struct definition   {     boost::spirit::rule&lt;Scanner&gt; object, member, string, value, number, array;     definition(const json_grammar &amp;self)     {       using namespace boost::spirit;       object = &quot;{&quot; &gt;&gt; member &gt;&gt; *(&quot;,&quot; &gt;&gt; member) &gt;&gt; &quot;}&quot;;       member = string[print()] &gt;&gt; &quot;:&quot; &gt;&gt; value;       string = &quot;\&quot;&quot; &gt;&gt; *~ch_p(&quot;\&quot;&quot;) &gt;&gt; &quot;\&quot;&quot;;       value = string | number | object | array | str_p(&quot;true&quot;)[print()] | &quot;false&quot; | &quot;null&quot;;       number = real_p[print()];       array = &quot;[&quot; &gt;&gt; value &gt;&gt; *(&quot;,&quot; &gt;&gt; value) &gt;&gt; &quot;]&quot;;     }     const boost::spirit::rule&lt;Scanner&gt; &amp;start()     {       return object;     }   }; }; int main(int argc, char *argv[]) {   std::ifstream fs(argv[1]);   std::ostringstream ss;   ss &lt;&lt; fs.rdbuf();   std::string data = ss.str();   json_grammar g;   boost::spirit::parse_info&lt;&gt; pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p);   if (pi.hit)   {     if (pi.full)       std::cout &lt;&lt; &quot;parsing all data successfully&quot; &lt;&lt; std::endl;     else       std::cout &lt;&lt; &quot;parsing data partially&quot; &lt;&lt; std::endl;     std::cout &lt;&lt; pi.length &lt;&lt; &quot; characters parsed&quot; &lt;&lt; std::endl;   }   else     std::cout &lt;&lt; &quot;parsing failed; stopped at &apos;&quot; &lt;&lt; pi.stop &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl; } #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; int main() {   typedef boost::array&lt;std::string, 3&gt; array;   array a;   a[0] = &quot;Boris&quot;;   a.at(1) = &quot;Anton&quot;;   *a.rbegin() = &quot;Caesar&quot;;   std::sort(a.begin(), a.end());   for (array::const_iterator it = a.begin(); it != a.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl;   std::cout &lt;&lt; a.size() &lt;&lt; std::endl;   std::cout &lt;&lt; a.max_size() &lt;&lt; std::endl; } #include &lt;boost/array.hpp&gt; #include &lt;string&gt; int main() {   typedef boost::array&lt;std::string, 3&gt; array;   array a = { &quot;Boris&quot;, &quot;Anton&quot;, &quot;Caesar&quot; }; } #include &lt;boost/unordered_set.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::unordered_set&lt;std::string&gt; unordered_set;   unordered_set set;   set.insert(&quot;Boris&quot;);   set.insert(&quot;Anton&quot;);   set.insert(&quot;Caesar&quot;);   for (unordered_set::iterator it = set.begin(); it != set.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl;   std::cout &lt;&lt; set.size() &lt;&lt; std::endl;   std::cout &lt;&lt; set.max_size() &lt;&lt; std::endl;   std::cout &lt;&lt; (set.find(&quot;David&quot;) != set.end()) &lt;&lt; std::endl;   std::cout &lt;&lt; set.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/unordered_map.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::unordered_map&lt;std::string, int&gt; unordered_map;   unordered_map map;   map.insert(unordered_map::value_type(&quot;Boris&quot;, 31));   map.insert(unordered_map::value_type(&quot;Anton&quot;, 35));   map.insert(unordered_map::value_type(&quot;Caesar&quot;, 25));   for (unordered_map::iterator it = map.begin(); it != map.end(); ++it)     std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;   std::cout &lt;&lt; map.size() &lt;&lt; std::endl;   std::cout &lt;&lt; map.max_size() &lt;&lt; std::endl;   std::cout &lt;&lt; (map.find(&quot;David&quot;) != map.end()) &lt;&lt; std::endl;   std::cout &lt;&lt; map.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/unordered_set.hpp&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   }   bool operator==(const person &amp;p) const   {     return name == p.name &amp;&amp; age == p.age;   } }; std::size_t hash_value(person const &amp;p) {   std::size_t seed = 0;   boost::hash_combine(seed, p.name);   boost::hash_combine(seed, p.age);   return seed; } int main() {   typedef boost::unordered_set&lt;person&gt; unordered_set;   unordered_set set;   set.insert(person(&quot;Boris&quot;, 31));   set.insert(person(&quot;Anton&quot;, 35));   set.insert(person(&quot;Caesar&quot;, 25)); } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 35));   persons.insert(person(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.count(&quot;Boris&quot;) &lt;&lt; std::endl;   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(25) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; void set_age(person &amp;p) {   p.age = 32; } int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 35));   persons.insert(person(&quot;Caesar&quot;, 25));   person_multi::iterator it = persons.find(&quot;Boris&quot;);   persons.modify(it, set_age);   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(32) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::hashed_non_unique&lt;       boost::multi_index::member&lt;         person, std::string, &amp;person::name       &gt;     &gt;,     boost::multi_index::hashed_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 31));   persons.insert(person(&quot;Caesar&quot;, 25));   const person_multi::nth_index&lt;1&gt;::type &amp;age_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; age_index.count(31) &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/sequenced_index.hpp&gt; #include &lt;boost/multi_index/ordered_index.hpp&gt; #include &lt;boost/multi_index/random_access_index.hpp&gt; #include &lt;boost/multi_index/member.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct person {   std::string name;   int age;   person(const std::string &amp;n, int a)     : name(n), age(a)   {   } }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::sequenced&lt;&gt;,     boost::multi_index::ordered_non_unique&lt;       boost::multi_index::member&lt;         person, int, &amp;person::age       &gt;     &gt;,     boost::multi_index::random_access&lt;&gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.push_back(person(&quot;Boris&quot;, 31));   persons.push_back(person(&quot;Anton&quot;, 31));   persons.push_back(person(&quot;Caesar&quot;, 25));   const person_multi::nth_index&lt;1&gt;::type &amp;ordered_index = persons.get&lt;1&gt;();   person_multi::nth_index&lt;1&gt;::type::iterator lower = ordered_index.lower_bound(30);   person_multi::nth_index&lt;1&gt;::type::iterator upper = ordered_index.upper_bound(40);   for (; lower != upper; ++lower)     std::cout &lt;&lt; lower-&gt;name &lt;&lt; std::endl;   const person_multi::nth_index&lt;2&gt;::type &amp;random_access_index = persons.get&lt;2&gt;();   std::cout &lt;&lt; random_access_index[2].name &lt;&lt; std::endl; } #include &lt;boost/multi_index_container.hpp&gt; #include &lt;boost/multi_index/ordered_index.hpp&gt; #include &lt;boost/multi_index/hashed_index.hpp&gt; #include &lt;boost/multi_index/identity.hpp&gt; #include &lt;boost/multi_index/mem_fun.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; class person { public:   person(const std::string &amp;n, int a)     : name(n), age(a)   {   }   bool operator&lt;(const person &amp;p) const   {     return age &lt; p.age;   }   std::string get_name() const   {     return name;   } private:   std::string name;   int age; }; typedef boost::multi_index::multi_index_container&lt;   person,   boost::multi_index::indexed_by&lt;     boost::multi_index::ordered_unique&lt;       boost::multi_index::identity&lt;person&gt;     &gt;,     boost::multi_index::hashed_unique&lt;       boost::multi_index::const_mem_fun&lt;         person, std::string, &amp;person::get_name       &gt;     &gt;   &gt; &gt; person_multi; int main() {   person_multi persons;   persons.insert(person(&quot;Boris&quot;, 31));   persons.insert(person(&quot;Anton&quot;, 31));   persons.insert(person(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.begin()-&gt;get_name() &lt;&lt; std::endl;   const person_multi::nth_index&lt;1&gt;::type &amp;hashed_index = persons.get&lt;1&gt;();   std::cout &lt;&lt; hashed_index.count(&quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, int&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, int&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   for (bimap::iterator it = persons.begin(); it != persons.end(); ++it)     std::cout &lt;&lt; it-&gt;left &lt;&lt; &quot; is &quot; &lt;&lt; it-&gt;right &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::set_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;boost/bimap/multiset_of.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;boost::bimaps::set_of&lt;std::string&gt;, boost::bimaps::multiset_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   std::cout &lt;&lt; persons.left.count(&quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; persons.right.count(31) &lt;&lt; std::endl; } #include &lt;boost/bimap.hpp&gt; #include &lt;boost/bimap/unconstrained_set_of.hpp&gt; #include &lt;boost/bimap/support/lambda.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   typedef boost::bimap&lt;std::string, boost::bimaps::unconstrained_set_of&lt;int&gt;&gt; bimap;   bimap persons;   persons.insert(bimap::value_type(&quot;Boris&quot;, 31));   persons.insert(bimap::value_type(&quot;Anton&quot;, 31));   persons.insert(bimap::value_type(&quot;Caesar&quot;, 25));   bimap::left_map::iterator it = persons.left.find(&quot;Boris&quot;);   persons.left.modify_key(it, boost::bimaps::_key = &quot;Doris&quot;);   std::cout &lt;&lt; it-&gt;first &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string&gt; person;   person p(&quot;Boris&quot;, &quot;Schaeling&quot;);   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; boost::tuple&lt;std::string, int&gt; func() {   return boost::make_tuple(&quot;Error message&quot;, 2009); }int main() {   std::string errmsg;   int errcode;   boost::tie(errmsg, errcode) = func();   std::cout &lt;&lt; errmsg &lt;&lt; &quot;: &quot; &lt;&lt; errcode &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   std::string s = &quot;Boris&quot;;   std::cout &lt;&lt; boost::make_tuple(boost::ref(s), &quot;Schaeling&quot;, 43) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   std::cout &lt;&lt; p.get&lt;0&gt;() &lt;&lt; std::endl;   std::cout &lt;&lt; boost::get&lt;0&gt;(p) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   p.get&lt;1&gt;() = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_comparison.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string, std::string, int&gt; person;   person p1 = boost::make_tuple(&quot;Boris&quot;, &quot;Schaeling&quot;, 43);   person p2 = boost::make_tuple(&quot;Boris&quot;, &quot;Becker&quot;, 43);   std::cout &lt;&lt; (p1 != p2) &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person;   std::string firstname = &quot;Boris&quot;;   std::string surname = &quot;Schaeling&quot;;   int shoesize = 43;   person p = boost::tie(firstname, surname, shoesize);   surname = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/tuple/tuple.hpp&gt; #include &lt;boost/tuple/tuple_io.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tuple&lt;std::string&amp;, std::string&amp;, int&amp;&gt; person;   std::string firstname = &quot;Boris&quot;;   std::string surname = &quot;Schaeling&quot;;   int shoesize = 43;   person p = boost::make_tuple(boost::ref(firstname), boost::ref(surname), boost::ref(shoesize));   surname = &quot;Becker&quot;;   std::cout &lt;&lt; p &lt;&lt; std::endl; } #include &lt;boost/any.hpp&gt; int main() {   boost::any a = 1;   a = 3.14;   a = true; } #include &lt;boost/any.hpp&gt; #include &lt;string&gt; int main() {   boost::any a = 1;   a = 3.14;   a = true;   a = std::string(&quot;Hello, world!&quot;); } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   std::cout &lt;&lt; boost::any_cast&lt;int&gt;(a) &lt;&lt; std::endl;   a = 3.14;   std::cout &lt;&lt; boost::any_cast&lt;double&gt;(a) &lt;&lt; std::endl;   a = true;   std::cout &lt;&lt; boost::any_cast&lt;bool&gt;(a) &lt;&lt; std::endl; } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::any a = 1;     std::cout &lt;&lt; boost::any_cast&lt;float&gt;(a) &lt;&lt; std::endl;   }   catch (boost::bad_any_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/any.hpp&gt; #include &lt;typeinfo&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   if (!a.empty())   {     const std::type_info &amp;ti = a.type();     std::cout &lt;&lt; ti.name() &lt;&lt; std::endl;   } } #include &lt;boost/any.hpp&gt; #include &lt;iostream&gt; int main() {   boost::any a = 1;   int *i = boost::any_cast&lt;int&gt;(&amp;a);   std::cout &lt;&lt; *i &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; int main() {   boost::variant&lt;double, char&gt; v;   v = 3.14;   v = &apos;A&apos;; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   v = &apos;A&apos;;   v = &quot;Hello, world!&quot;; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl;   v = &apos;A&apos;;   std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl;   v = &quot;Hello, world!&quot;;   std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   std::cout &lt;&lt; v &lt;&lt; std::endl;   v = &apos;A&apos;;   std::cout &lt;&lt; v &lt;&lt; std::endl;   v = &quot;Hello, world!&quot;;   std::cout &lt;&lt; v &lt;&lt; std::endl; } #include &lt;boost/variant.hpp&gt; #include &lt;boost/any.hpp&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; std::vector&lt;boost::any&gt; vector; struct output :   public boost::static_visitor&lt;&gt; {   void operator()(double &amp;d) const   {     vector.push_back(d);   }   void operator()(char &amp;c) const   {     vector.push_back(c);   }   void operator()(std::string &amp;s) const   {     vector.push_back(s);   } }; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   boost::apply_visitor(output(), v);   v = &apos;A&apos;;   boost::apply_visitor(output(), v);   v = &quot;Hello, world!&quot;;   boost::apply_visitor(output(), v); } #include &lt;boost/variant.hpp&gt; #include &lt;boost/any.hpp&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; std::vector&lt;boost::any&gt; vector; struct output :   public boost::static_visitor&lt;&gt; {   template &lt;typename T&gt;   void operator()(T &amp;t) const   {     vector.push_back(t);   } }; int main() {   boost::variant&lt;double, char, std::string&gt; v;   v = 3.14;   boost::apply_visitor(output(), v);   v = &apos;A&apos;;   boost::apply_visitor(output(), v);   v = &quot;Hello, world!&quot;;   boost::apply_visitor(output(), v); } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; class application_category :   public boost::system::error_category { public:   const char *name() const { return &quot;application&quot;; }   std::string message(int ev) const { return &quot;error message&quot;; } }; application_category cat; int main() {   boost::system::error_code ec(14, cat);   std::cout &lt;&lt; ec.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; } #include &lt;boost/system/error_code.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() {   boost::system::error_code ec;   std::string hostname = boost::asio::ip::host_name(ec);   boost::system::error_condition ecnd = ec.default_error_condition();   std::cout &lt;&lt; ecnd.value() &lt;&lt; std::endl;   std::cout &lt;&lt; ecnd.category().name() &lt;&lt; std::endl; } #include &lt;boost/asio.hpp&gt; #include &lt;boost/system/system_error.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::asio::ip::host_name() &lt;&lt; std::endl;   }   catch (boost::system::system_error &amp;e)   {     boost::system::error_code ec = e.code();     std::cerr &lt;&lt; ec.value() &lt;&lt; std::endl;     std::cerr &lt;&lt; ec.category().name() &lt;&lt; std::endl;   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public boost::exception,   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     throw allocation_failed(size);   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; boost::diagnostic_information(e);   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     BOOST_THROW_EXCEPTION(allocation_failed(size));   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; boost::diagnostic_information(e);   } } #include &lt;boost/exception/all.hpp&gt; #include &lt;boost/lexical_cast.hpp&gt; #include &lt;boost/shared_array.hpp&gt; #include &lt;exception&gt; #include &lt;string&gt; #include &lt;iostream&gt; typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; class allocation_failed :   public std::exception { public:   allocation_failed(std::size_t size)     : what_(&quot;allocation of &quot; + boost::lexical_cast&lt;std::string&gt;(size) + &quot; bytes failed&quot;)   {   }   virtual const char *what() const throw()   {     return what_.c_str();   } private:   std::string what_; }; boost::shared_array&lt;char&gt; allocate(std::size_t size) {   if (size &gt; 1000)     BOOST_THROW_EXCEPTION(allocation_failed(size));   return boost::shared_array&lt;char&gt;(new char[size]); } void save_configuration_data() {   try   {     boost::shared_array&lt;char&gt; a = allocate(2000);     // saving configuration data ...   }   catch (boost::exception &amp;e)   {     e &lt;&lt; errmsg_info(&quot;saving configuration data failed&quot;);     throw;   } } int main() {   try   {     save_configuration_data();   }   catch (boost::exception &amp;e)   {     std::cerr &lt;&lt; *boost::get_error_info&lt;errmsg_info&gt;(e);   } } struct father {   virtual ~father() { }; }; struct mother {   virtual ~mother() { }; }; struct child :   public father,   public mother { }; void func(father *f) {   child *c = dynamic_cast&lt;child*&gt;(f); } int main() {   child *c = new child;   func(c);   father *f = new child;   mother *m = dynamic_cast&lt;mother*&gt;(f); } #include &lt;boost/cast.hpp&gt; struct father {   virtual ~father() { }; }; struct mother {   virtual ~mother() { }; }; struct child :   public father,   public mother { }; void func(father *f) {   child *c = boost::polymorphic_downcast&lt;child*&gt;(f); } int main() {   child *c = new child;   func(c);   father *f = new child;   mother *m = boost::polymorphic_cast&lt;mother*&gt;(f); } #include &lt;boost/lexical_cast.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   std::string s = boost::lexical_cast&lt;std::string&gt;(169);   std::cout &lt;&lt; s &lt;&lt; std::endl;   double d = boost::lexical_cast&lt;double&gt;(s);   std::cout &lt;&lt; d &lt;&lt; std::endl; } #include &lt;boost/lexical_cast.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   try   {     int i = boost::lexical_cast&lt;int&gt;(&quot;abc&quot;);     std::cout &lt;&lt; i &lt;&lt; std::endl;   }   catch (boost::bad_lexical_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;iostream&gt; int main() {   int i = 0x10000;   short s = i;   std::cout &lt;&lt; s &lt;&lt; std::endl; } #include &lt;boost/numeric/conversion/cast.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     int i = 0x10000;     short s = boost::numeric_cast&lt;short&gt;(i);     std::cout &lt;&lt; s &lt;&lt; std::endl;   }   catch (boost::numeric::bad_numeric_cast &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/numeric/conversion/cast.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     int i = -0x10000;     short s = boost::numeric_cast&lt;short&gt;(i);     std::cout &lt;&lt; s &lt;&lt; std::endl;   }   catch (boost::numeric::negative_overflow &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;windows.h&gt; class windows_handle {   public:     windows_handle(HANDLE h)       : handle_(h)     {     }     ~windows_handle()     {       CloseHandle(handle_);     }     HANDLE handle() const     {       return handle_;     }   private:     HANDLE handle_; }; int main() {   windows_handle h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()));   SetPriorityClass(h.handle(), HIGH_PRIORITY_CLASS); } #include &lt;boost/scoped_ptr.hpp&gt; int main() {   boost::scoped_ptr&lt;int&gt; i(new int);   *i = 1;   *i.get() = 2;   i.reset(new int); } #include &lt;boost/scoped_array.hpp&gt; int main() {   boost::scoped_array&lt;int&gt; i(new int[2]);   *i.get() = 1;   i[1] = 2;   i.reset(new int[3]); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;vector&gt; int main() {   std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v;   v.push_back(boost::shared_ptr&lt;int&gt;(new int(1)));   v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); } #include &lt;boost/shared_ptr.hpp&gt; int main() {   boost::shared_ptr&lt;int&gt; i1(new int(1));   boost::shared_ptr&lt;int&gt; i2(i1);   i1.reset(new int(2)); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;windows.h&gt; int main() {   boost::shared_ptr&lt;void&gt; h(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()), CloseHandle);   SetPriorityClass(h.get(), HIGH_PRIORITY_CLASS); } #include &lt;boost/shared_array.hpp&gt; #include &lt;iostream&gt; int main() {   boost::shared_array&lt;int&gt; i1(new int[2]);   boost::shared_array&lt;int&gt; i2(i1);   i1[0] = 1;   std::cout &lt;&lt; i2[0] &lt;&lt; std::endl; } #include &lt;windows.h&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; #include &lt;iostream&gt; DWORD WINAPI reset(LPVOID p) {   boost::shared_ptr&lt;int&gt; *sh = static_cast&lt;boost::shared_ptr&lt;int&gt;*&gt;(p);   sh-&gt;reset();   return 0; } DWORD WINAPI print(LPVOID p) {   boost::weak_ptr&lt;int&gt; *w = static_cast&lt;boost::weak_ptr&lt;int&gt;*&gt;(p);   boost::shared_ptr&lt;int&gt; sh = w-&gt;lock();   if (sh)     std::cout &lt;&lt; *sh &lt;&lt; std::endl;   return 0; } int main() {   boost::shared_ptr&lt;int&gt; sh(new int(99));   boost::weak_ptr&lt;int&gt; w(sh);   HANDLE threads[2];   threads[0] = CreateThread(0, 0, reset, &amp;sh, 0, 0);   threads[1] = CreateThread(0, 0, print, &amp;w, 0, 0);   WaitForMultipleObjects(2, threads, TRUE, INFINITE); } #include &lt;boost/intrusive_ptr.hpp&gt; #include &lt;atlbase.h&gt; #include &lt;iostream&gt; void intrusive_ptr_add_ref(IDispatch *p) {   p-&gt;AddRef(); } void intrusive_ptr_release(IDispatch *p) {   p-&gt;Release(); } void check_windows_folder() {   CLSID clsid;   CLSIDFromProgID(CComBSTR(&quot;Scripting.FileSystemObject&quot;), &amp;clsid);   void *p;   CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, __uuidof(IDispatch), &amp;p);   boost::intrusive_ptr&lt;IDispatch&gt; disp(static_cast&lt;IDispatch*&gt;(p));   CComDispatchDriver dd(disp.get());   CComVariant arg(&quot;C:\\Windows&quot;);   CComVariant ret(false);   dd.Invoke1(CComBSTR(&quot;FolderExists&quot;), &amp;arg, &amp;ret);   std::cout &lt;&lt; (ret.boolVal != 0) &lt;&lt; std::endl; } void main() {   CoInitialize(0);   check_windows_folder();   CoUninitialize(); } #include &lt;boost/shared_ptr.hpp&gt; #include &lt;vector&gt; int main() {   std::vector&lt;boost::shared_ptr&lt;int&gt; &gt; v;   v.push_back(boost::shared_ptr&lt;int&gt;(new int(1)));   v.push_back(boost::shared_ptr&lt;int&gt;(new int(2))); } #include &lt;boost/ptr_container/ptr_vector.hpp&gt; int main() {   boost::ptr_vector&lt;int&gt; v;   v.push_back(new int(1));   v.push_back(new int(2)); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void print(int i) {   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), print); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; class add   : public std::binary_function&lt;int, int, void&gt; { public:   void operator()(int i, int j) const   {     std::cout &lt;&lt; i + j &lt;&lt; std::endl;   } }; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), std::bind1st(add(), 10)); } #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void add(int i, int j) {   std::cout &lt;&lt; i + j &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1)); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), boost::bind(compare, _1, _2)); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), compare); } #include &lt;boost/bind.hpp&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare(int i, int j) {   return i &gt; j; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::sort(v.begin(), v.end(), boost::bind(compare, _2, _1)); } #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void add(int i, int j, std::ostream &amp;os) {   os &lt;&lt; i + j &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), boost::bind(add, 10, _1, boost::ref(std::cout))); } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; int main() {   boost::function&lt;int (const char*)&gt; f = std::atoi;   std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl;   f = std::strlen;   std::cout &lt;&lt; f(&quot;1609&quot;) &lt;&lt; std::endl; } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::function&lt;int (const char*)&gt; f;     f(&quot;&quot;);   }   catch (boost::bad_function_call &amp;ex)   {     std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; struct world {   void hello(std::ostream &amp;os)   {     os &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;   } }; int main() {   boost::function&lt;void (world*, std::ostream&amp;)&gt; f = &amp;world::hello;   world w;   f(&amp;w, boost::ref(std::cout)); } #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void print(int i) {   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), print); } #include &lt;boost/lambda/lambda.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(), std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;); } #include &lt;boost/lambda/lambda.hpp&gt; #include &lt;boost/lambda/if.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() {   std::vector&lt;int&gt; v;   v.push_back(1);   v.push_back(3);   v.push_back(2);   std::for_each(v.begin(), v.end(),     boost::lambda::if_then(boost::lambda::_1 &gt; 1,     std::cout &lt;&lt; boost::lambda::_1 &lt;&lt; &quot;\n&quot;)); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func);   s(); } #include &lt;boost/function.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::function&lt;void ()&gt; f;   f = func;   f(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(1, func2);   s.connect(0, func1);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   s.disconnect(func2);   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func1() {   std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::flush; } void func2() {   std::cout &lt;&lt; &quot;, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   if (!s.empty())     s();   s.disconnect_all_slots(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; int func1() {   return 1; } int func2() {   return 2; } int main() {   boost::signal&lt;int ()&gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s() &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; int func1() {   return 1; } int func2() {   return 2; } template &lt;typename T&gt; struct min_element {   typedef T result_type;   template &lt;typename InputIterator&gt;   T operator()(InputIterator first, InputIterator last) const   {     return *std::min_element(first, last);   } }; int main() {   boost::signal&lt;int (), min_element&lt;int&gt; &gt; s;   s.connect(func1);   s.connect(func2);   std::cout &lt;&lt; s() &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int func1() {   return 1; } int func2() {   return 2; } template &lt;typename T&gt; struct min_element {   typedef T result_type;   template &lt;typename InputIterator&gt;   T operator()(InputIterator first, InputIterator last) const   {     return T(first, last);   } }; int main() {   boost::signal&lt;int (), min_element&lt;std::vector&lt;int&gt; &gt; &gt; s;   s.connect(func1);   s.connect(func2);   std::vector&lt;int&gt; v = s();   std::cout &lt;&lt; *std::min_element(v.begin(), v.end()) &lt;&lt; std::endl; } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   boost::signals::connection c = s.connect(func);   s();   c.disconnect(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   boost::signals::connection c = s.connect(func);   c.block();   s();   c.unblock();   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;iostream&gt; void func() {   std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } int main() {   boost::signal&lt;void ()&gt; s;   {     boost::signals::scoped_connection c = s.connect(func);   }   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;memory&gt; class world {   public:     void hello() const     {       std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;     } }; int main() {   boost::signal&lt;void ()&gt; s;   {     std::auto_ptr&lt;world&gt; w(new world());     s.connect(boost::bind(&amp;world::hello, w.get()));   }   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   s(); } #include &lt;boost/signal.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; #include &lt;memory&gt; class world :   public boost::signals::trackable {   public:     void hello() const     {       std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;     } }; int main() {   boost::signal&lt;void ()&gt; s;   {     std::auto_ptr&lt;world&gt; w(new world());     s.connect(boost::bind(&amp;world::hello, w.get()));   }   std::cout &lt;&lt; s.num_slots() &lt;&lt; std::endl;   s(); } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German_Switzerland&quot;));   std::locale loc;   std::cout &lt;&lt; loc.name() &lt;&lt; std::endl; } #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; int main() {   std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl;   std::locale::global(std::locale(&quot;German&quot;));   std::cout &lt;&lt; std::strcoll(&quot;ä&quot;, &quot;z&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;clocale&gt; int main() {   std::setlocale(LC_ALL, &quot;German&quot;);   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::starts_with(s, &quot;Boris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::ends_with(s, &quot;Schäling&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::contains(s, &quot;is&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::lexicographical_compare(s, &quot;Boris&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::vector&lt;std::string&gt; v;   boost::algorithm::split(v, s, boost::algorithm::is_space());   std::cout &lt;&lt; v.size() &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;boost/algorithm/string/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_regex(s, boost::regex(&quot;\\w\\s\\w&quot;));   std::cout &lt;&lt; r &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::to_upper_copy(s, std::locale(&quot;German&quot;)) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::erase_first_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_nth_copy(s, &quot;i&quot;, 0) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_last_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_all_copy(s, &quot;i&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_head_copy(s, 5) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::erase_tail_copy(s, 8) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::iterator_range&lt;std::string::iterator&gt; r = boost::algorithm::find_first(s, &quot;Boris&quot;);   std::cout &lt;&lt; r &lt;&lt; std::endl;   r = boost::algorithm::find_first(s, &quot;xyz&quot;);   std::cout &lt;&lt; r &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; #include &lt;vector&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::vector&lt;std::string&gt; v;   v.push_back(&quot;Boris&quot;);   v.push_back(&quot;Schäling&quot;);   std::cout &lt;&lt; boost::algorithm::join(v, &quot; &quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   std::cout &lt;&lt; boost::algorithm::replace_first_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_nth_copy(s, &quot;B&quot;, 0, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_last_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_all_copy(s, &quot;B&quot;, &quot;D&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_head_copy(s, 5, &quot;Doris&quot;) &lt;&lt; std::endl;   std::cout &lt;&lt; boost::algorithm::replace_tail_copy(s, 8, &quot;Becker&quot;) &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;\t Boris Schäling \t&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy(s) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;--Boris Schäling--&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_any_of(&quot;-&quot;)) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/algorithm/string.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;123456789Boris Schäling123456789&quot;;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt; boost::algorithm::trim_left_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_right_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;   std::cout &lt;&lt; &quot;.&quot; &lt;&lt;boost::algorithm::trim_copy_if(s, boost::algorithm::is_digit()) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;\\w+\\s\\w+&quot;);   std::cout &lt;&lt; boost::regex_match(s, expr) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   boost::smatch what;   if (boost::regex_search(s, what, expr))   {     std::cout &lt;&lt; what[0] &lt;&lt; std::endl;     std::cout &lt;&lt; what[1] &lt;&lt; &quot; &quot; &lt;&lt; what[2] &lt;&lt; std::endl;   } } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot; Boris Schäling &quot;;   boost::regex expr(&quot;\\s&quot;);   std::string fmt(&quot;_&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   std::string fmt(&quot;\\2 \\1&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt) &lt;&lt; std::endl; } #include &lt;boost/regex.hpp&gt; #include &lt;locale&gt; #include &lt;iostream&gt; int main() {   std::locale::global(std::locale(&quot;German&quot;));   std::string s = &quot;Boris Schäling&quot;;   boost::regex expr(&quot;(\\w+)\\s(\\w+)&quot;);   std::string fmt(&quot;\\2 \\1&quot;);   std::cout &lt;&lt; boost::regex_replace(s, expr, fmt, boost::regex_constants::format_literal) &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   tokenizer tok(s);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;, boost::keep_empty_tokens);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;wchar_t&gt;, std::wstring::const_iterator, std::wstring&gt; tokenizer;   std::wstring s = L&quot;Boost C++ libraries&quot;;   boost::char_separator&lt;wchar_t&gt; sep(L&quot; &quot;);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::wcout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::escaped_list_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost,\&quot;C++ libraries\&quot;&quot;;   tokenizer tok(s);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::offset_separator&gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   int offsets[] = { 5, 5, 9 };   boost::offset_separator sep(offsets, offsets + 3);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%1%.%2%.%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%2%/%1%/%3%&quot;) % 16 % 9 % 2008 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%1% %2% %1%&quot;) % boost::io::group(std::showpos, 99) % 100 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::format(&quot;%|+| %2% %1%&quot;) % 99 % 100 &lt;&lt; std::endl;   }   catch (boost::io::format_error &amp;ex)   {     std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%|+| %|| %||&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%+d %d %d&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/format.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::format(&quot;%+s %s %s&quot;) % 99 % 100 % 99 &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     std::cout &lt;&lt; i &lt;&lt; std::endl;   } } int main() {   boost::thread t(thread);   t.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } void thread() {   try   {     for (int i = 0; i &lt; 5; ++i)     {       wait(1);       std::cout &lt;&lt; i &lt;&lt; std::endl;     }   }   catch (boost::thread_interrupted&amp;)   {   } } int main() {   boost::thread t(thread);   wait(3);   t.interrupt();   t.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; int main() {   std::cout &lt;&lt; boost::this_thread::get_id() &lt;&lt; std::endl;   std::cout &lt;&lt; boost::thread::hardware_concurrency() &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     mutex.lock();     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;     mutex.unlock();   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     boost::lock_guard&lt;boost::mutex&gt; lock(mutex);     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::timed_mutex mutex; void thread() {   for (int i = 0; i &lt; 5; ++i)   {     wait(1);     boost::unique_lock&lt;boost::timed_mutex&gt; lock(mutex, boost::try_to_lock);     if (!lock.owns_lock())       lock.timed_lock(boost::get_system_time() + boost::posix_time::seconds(1));     std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl;     boost::timed_mutex *m = lock.release();     m-&gt;unlock();   } } int main() {   boost::thread t1(thread);   boost::thread t2(thread);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void wait(int seconds) {   boost::this_thread::sleep(boost::posix_time::seconds(seconds)); } boost::shared_mutex mutex; std::vector&lt;int&gt; random_numbers; void fill() {   std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::shared_mutex&gt; lock(mutex);     random_numbers.push_back(std::rand());     lock.unlock();     wait(1);   } } void print() {   for (int i = 0; i &lt; 3; ++i)   {     wait(1);     boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);     std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;   } } int sum = 0; void count() {   for (int i = 0; i &lt; 3; ++i)   {     wait(1);     boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);     sum += random_numbers.back();   } } int main() {   boost::thread t1(fill);   boost::thread t2(print);   boost::thread t3(count);   t1.join();   t2.join();   t3.join();   std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; boost::mutex mutex; boost::condition_variable_any cond; std::vector&lt;int&gt; random_numbers; void fill() {   std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::mutex&gt; lock(mutex);     random_numbers.push_back(std::rand());     cond.notify_all();     cond.wait(mutex);   } } void print() {   std::size_t next_size = 1;   for (int i = 0; i &lt; 3; ++i)   {     boost::unique_lock&lt;boost::mutex&gt; lock(mutex);     while (random_numbers.size() != next_size)       cond.wait(mutex);     std::cout &lt;&lt; random_numbers.back() &lt;&lt; std::endl;     ++next_size;     cond.notify_all();   } } int main() {   boost::thread t1(fill);   boost::thread t2(print);   t1.join();   t2.join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void init_number_generator() {   static bool done = false;   if (!done)   {     done = true;     std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   } } boost::mutex mutex; void random_number_generator() {   init_number_generator();   int i = std::rand();   boost::lock_guard&lt;boost::mutex&gt; lock(mutex);   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   boost::thread t[3];   for (int i = 0; i &lt; 3; ++i)     t[i] = boost::thread(random_number_generator);   for (int i = 0; i &lt; 3; ++i)     t[i].join(); } #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; void init_number_generator() {   static boost::thread_specific_ptr&lt;bool&gt; tls;   if (!tls.get())     tls.reset(new bool(false));   if (!*tls)   {     *tls = true;     std::srand(static_cast&lt;unsigned int&gt;(std::time(0)));   } } boost::mutex mutex; void random_number_generator() {   init_number_generator();   int i = std::rand();   boost::lock_guard&lt;boost::mutex&gt; lock(mutex);   std::cout &lt;&lt; i &lt;&lt; std::endl; } int main() {   boost::thread t[3];   for (int i = 0; i &lt; 3; ++i)     t[i] = boost::thread(random_number_generator);   for (int i = 0; i &lt; 3; ++i)     t[i].join(); } #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; void handler(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } int main() {   boost::asio::io_service io_service;   boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));   timer.async_wait(handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;10 s.&quot; &lt;&lt; std::endl; } int main() {   boost::asio::io_service io_service;   boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(10));   timer2.async_wait(handler2);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } boost::asio::io_service io_service; void run() {   io_service.run(); } int main() {   boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5));   timer2.async_wait(handler2);   boost::thread thread1(run);   boost::thread thread2(run);   thread1.join();   thread2.join(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;iostream&gt; void handler1(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } void handler2(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } boost::asio::io_service io_service1; boost::asio::io_service io_service2; void run1() {   io_service1.run(); } void run2() {   io_service2.run(); } int main() {   boost::asio::deadline_timer timer1(io_service1, boost::posix_time::seconds(5));   timer1.async_wait(handler1);   boost::asio::deadline_timer timer2(io_service2, boost::posix_time::seconds(5));   timer2.async_wait(handler2);   boost::thread thread1(run1);   boost::thread thread2(run2);   thread1.join();   thread2.join(); } #include &lt;boost/asio.hpp&gt; #include &lt;boost/array.hpp&gt; #include &lt;iostream&gt; #include &lt;string&gt; boost::asio::io_service io_service; boost::asio::ip::tcp::resolver resolver(io_service); boost::asio::ip::tcp::socket sock(io_service); boost::array&lt;char, 4096&gt; buffer; void read_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) {   if (!ec)   {     std::cout &lt;&lt; std::string(buffer.data(), bytes_transferred) &lt;&lt; std::endl;     sock.async_read_some(boost::asio::buffer(buffer), read_handler);   } } void connect_handler(const boost::system::error_code &amp;ec) {   if (!ec)   {     boost::asio::write(sock, boost::asio::buffer(&quot;GET / HTTP 1.1\r\nHost: highscore.de\r\n\r\n&quot;));     sock.async_read_some(boost::asio::buffer(buffer), read_handler);   } } void resolve_handler(const boost::system::error_code &amp;ec, boost::asio::ip::tcp::resolver::iterator it) {   if (!ec)   {     sock.async_connect(*it, connect_handler);   } } int main() {   boost::asio::ip::tcp::resolver::query query(&quot;www.highscore.de&quot;, &quot;80&quot;);   resolver.async_resolve(query, resolve_handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;string&gt; boost::asio::io_service io_service; boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 80); boost::asio::ip::tcp::acceptor acceptor(io_service, endpoint); boost::asio::ip::tcp::socket sock(io_service); std::string data = &quot;HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, world!&quot;; void write_handler(const boost::system::error_code &amp;ec, std::size_t bytes_transferred) { } void accept_handler(const boost::system::error_code &amp;ec) {   if (!ec)   {     boost::asio::async_write(sock, boost::asio::buffer(data), write_handler);   } } int main() {   acceptor.listen();   acceptor.async_accept(sock, accept_handler);   io_service.run(); } #include &lt;boost/asio.hpp&gt; #include &lt;cstddef&gt; template &lt;typename Service&gt; class basic_timer   : public boost::asio::basic_io_object&lt;Service&gt; {   public:     explicit basic_timer(boost::asio::io_service &amp;io_service)       : boost::asio::basic_io_object&lt;Service&gt;(io_service)     {     }     void wait(std::size_t seconds)     {       return this-&gt;service.wait(this-&gt;implementation, seconds);     }     template &lt;typename Handler&gt;     void async_wait(std::size_t seconds, Handler handler)     {       this-&gt;service.async_wait(this-&gt;implementation, seconds, handler);     } }; #include &lt;boost/asio.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/scoped_ptr.hpp&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; #include &lt;boost/system/error_code.hpp&gt; template &lt;typename TimerImplementation = timer_impl&gt; class basic_timer_service   : public boost::asio::io_service::service {   public:     static boost::asio::io_service::id id;     explicit basic_timer_service(boost::asio::io_service &amp;io_service)       : boost::asio::io_service::service(io_service),       async_work_(new boost::asio::io_service::work(async_io_service_)),       async_thread_(boost::bind(&amp;boost::asio::io_service::run, &amp;async_io_service_))     {     }     ~basic_timer_service()     {       async_work_.reset();       async_io_service_.stop();       async_thread_.join();     }     typedef boost::shared_ptr&lt;TimerImplementation&gt; implementation_type;     void construct(implementation_type &amp;impl)     {       impl.reset(new TimerImplementation());     }     void destroy(implementation_type &amp;impl)     {       impl-&gt;destroy();       impl.reset();     }     void wait(implementation_type &amp;impl, std::size_t seconds)     {       boost::system::error_code ec;       impl-&gt;wait(seconds, ec);       boost::asio::detail::throw_error(ec);     }     template &lt;typename Handler&gt;     class wait_operation     {       public:         wait_operation(implementation_type &amp;impl, boost::asio::io_service &amp;io_service, std::size_t seconds, Handler handler)           : impl_(impl),           io_service_(io_service),           work_(io_service),           seconds_(seconds),           handler_(handler)         {         }         void operator()() const         {           implementation_type impl = impl_.lock();           if (impl)           {               boost::system::error_code ec;               impl-&gt;wait(seconds_, ec);               this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, ec));           }           else           {               this-&gt;io_service_.post(boost::asio::detail::bind_handler(handler_, boost::asio::error::operation_aborted));           }       }       private:         boost::weak_ptr&lt;TimerImplementation&gt; impl_;         boost::asio::io_service &amp;io_service_;         boost::asio::io_service::work work_;         std::size_t seconds_;         Handler handler_;     };     template &lt;typename Handler&gt;     void async_wait(implementation_type &amp;impl, std::size_t seconds, Handler handler)     {       this-&gt;async_io_service_.post(wait_operation&lt;Handler&gt;(impl, this-&gt;get_io_service(), seconds, handler));     }   private:     void shutdown_service()     {     }     boost::asio::io_service async_io_service_;     boost::scoped_ptr&lt;boost::asio::io_service::work&gt; async_work_;     boost::thread async_thread_; }; template &lt;typename TimerImplementation&gt; boost::asio::io_service::id basic_timer_service&lt;TimerImplementation&gt;::id; #include &lt;boost/system/error_code.hpp&gt; #include &lt;cstddef&gt; #include &lt;windows.h&gt; class timer_impl {   public:     timer_impl()       : handle_(CreateEvent(NULL, FALSE, FALSE, NULL))     {     }     ~timer_impl()     {       CloseHandle(handle_);     }     void destroy()     {       SetEvent(handle_);     }     void wait(std::size_t seconds, boost::system::error_code &amp;ec)     {       DWORD res = WaitForSingleObject(handle_, seconds * 1000);       if (res == WAIT_OBJECT_0)         ec = boost::asio::error::operation_aborted;       else         ec = boost::system::error_code();     } private:     HANDLE handle_; }; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; #include &quot;basic_timer.hpp&quot; #include &quot;timer_impl.hpp&quot; #include &quot;basic_timer_service.hpp&quot; void wait_handler(const boost::system::error_code &amp;ec) {   std::cout &lt;&lt; &quot;5 s.&quot; &lt;&lt; std::endl; } typedef basic_timer&lt;basic_timer_service&lt;&gt; &gt; timer; int main() {   boost::asio::io_service io_service;   timer t(io_service);   t.async_wait(5, wait_handler);   io_service.run(); } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   std::cout &lt;&lt; shdmem.get_name() &lt;&lt; std::endl;   boost::interprocess::offset_t size;   if (shdmem.get_size(size))     std::cout &lt;&lt; size &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region.get_address() &lt;&lt; std::endl;   std::cout &lt;&lt; std::dec &lt;&lt; region.get_size() &lt;&lt; std::endl;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   std::cout &lt;&lt; std::hex &lt;&lt; &quot;0x&quot; &lt;&lt; region2.get_address() &lt;&lt; std::endl;   std::cout &lt;&lt; std::dec &lt;&lt; region2.get_size() &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write);   shdmem.truncate(1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   int *i1 = static_cast&lt;int*&gt;(region.get_address());   *i1 = 99;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   int *i2 = static_cast&lt;int*&gt;(region2.get_address());   std::cout &lt;&lt; *i2 &lt;&lt; std::endl; } #include &lt;boost/interprocess/shared_memory_object.hpp&gt; #include &lt;iostream&gt; int main() {   bool removed = boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   std::cout &lt;&lt; removed &lt;&lt; std::endl; } #include &lt;boost/interprocess/windows_shared_memory.hpp&gt; #include &lt;boost/interprocess/mapped_region.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::windows_shared_memory shdmem(boost::interprocess::open_or_create, &quot;Highscore&quot;, boost::interprocess::read_write, 1024);   boost::interprocess::mapped_region region(shdmem, boost::interprocess::read_write);   int *i1 = static_cast&lt;int*&gt;(region.get_address());   *i1 = 99;   boost::interprocess::mapped_region region2(shdmem, boost::interprocess::read_only);   int *i2 = static_cast&lt;int*&gt;(region2.get_address());   std::cout &lt;&lt; *i2 &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   if (p.first)     std::cout &lt;&lt; *p.first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[10](99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   if (p.first)   {     std::cout &lt;&lt; *p.first &lt;&lt; std::endl;     std::cout &lt;&lt; p.second &lt;&lt; std::endl;   } } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);     boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);     int *i = managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)[4096](99);   }   catch (boost::interprocess::bad_alloc &amp;ex)   {     std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;   } } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(99);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   managed_shm.destroy&lt;int&gt;(&quot;Integer&quot;);   std::pair&lt;int*, std::size_t&gt; p = managed_shm.find&lt;int&gt;(&quot;Integer&quot;);   std::cout &lt;&lt; p.first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/allocators/allocator.hpp&gt; #include &lt;boost/interprocess/containers/string.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   typedef boost::interprocess::allocator&lt;char, boost::interprocess::managed_shared_memory::segment_manager&gt; CharAllocator;   typedef boost::interprocess::basic_string&lt;char, std::char_traits&lt;char&gt;, CharAllocator&gt; string;   string *s = managed_shm.find_or_construct&lt;string&gt;(&quot;String&quot;)(&quot;Hello!&quot;, managed_shm.get_segment_manager());   s-&gt;insert(5, &quot;, world&quot;);   std::cout &lt;&lt; *s &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;iostream&gt; void construct_objects(boost::interprocess::managed_shared_memory &amp;managed_shm) {   managed_shm.construct&lt;int&gt;(&quot;Integer&quot;)(99);   managed_shm.construct&lt;float&gt;(&quot;Float&quot;)(3.14); } int main() {   boost::interprocess::shared_memory_object::remove(&quot;Highscore&quot;);   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;Highscore&quot;, 1024);   managed_shm.atomic_func(boost::bind(construct_objects, boost::ref(managed_shm)));   std::cout &lt;&lt; *managed_shm.find&lt;int&gt;(&quot;Integer&quot;).first &lt;&lt; std::endl;   std::cout &lt;&lt; *managed_shm.find&lt;float&gt;(&quot;Float&quot;).first &lt;&lt; std::endl; } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/named_mutex.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)();   boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;);   named_mtx.lock();   ++(*i);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   named_mtx.unlock(); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)();   boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)();   mtx-&gt;lock();   ++(*i);   std::cout &lt;&lt; *i &lt;&lt; std::endl;   mtx-&gt;unlock(); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/named_mutex.hpp&gt; #include &lt;boost/interprocess/sync/named_condition.hpp&gt; #include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; #include &lt;iostream&gt; int main() {   boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);   int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0);   boost::interprocess::named_mutex named_mtx(boost::interprocess::open_or_create, &quot;mtx&quot;);   boost::interprocess::named_condition named_cnd(boost::interprocess::open_or_create, &quot;cnd&quot;);   boost::interprocess::scoped_lock&lt;boost::interprocess::named_mutex&gt; lock(named_mtx);   while (*i &lt; 10)   {     if (*i % 2 == 0)     {       ++(*i);       named_cnd.notify_all();       named_cnd.wait(lock);     }     else     {       std::cout &lt;&lt; *i &lt;&lt; std::endl;       ++(*i);       named_cnd.notify_all();       named_cnd.wait(lock);     }   }   named_cnd.notify_all();   boost::interprocess::shared_memory_object::remove(&quot;shm&quot;);   boost::interprocess::named_mutex::remove(&quot;mtx&quot;);   boost::interprocess::named_condition::remove(&quot;cnd&quot;); } #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt; #include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt; #include &lt;boost/interprocess/sync/scoped_lock.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     boost::interprocess::managed_shared_memory managed_shm(boost::interprocess::open_or_create, &quot;shm&quot;, 1024);     int *i = managed_shm.find_or_construct&lt;int&gt;(&quot;Integer&quot;)(0);     boost::interprocess::interprocess_mutex *mtx = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_mutex&gt;(&quot;mtx&quot;)();     boost::interprocess::interprocess_condition *cnd = managed_shm.find_or_construct&lt;boost::interprocess::interprocess_condition&gt;(&quot;cnd&quot;)();     boost::interprocess::scoped_lock&lt;boost::interprocess::interprocess_mutex&gt; lock(*mtx);     while (*i &lt; 10)     {       if (*i % 2 == 0)       {         ++(*i);         cnd-&gt;notify_all();         cnd-&gt;wait(lock);       }       else       {         std::cout &lt;&lt; *i &lt;&lt; std::endl;         ++(*i);         cnd-&gt;notify_all();         cnd-&gt;wait(lock);       }     }     cnd-&gt;notify_all();   }   catch (...)   {   }   boost::interprocess::shared_memory_object::remove(&quot;shm&quot;); } #include &lt;boost/filesystem.hpp&gt; int main() {   boost::filesystem::path p1(&quot;C:\\&quot;);   boost::filesystem::path p2(&quot;C:\\Windows&quot;);   boost::filesystem::path p3(&quot;C:\\Program Files&quot;); } #include &lt;boost/filesystem.hpp&gt; int main() {   boost::filesystem::path p1(&quot;...&quot;);   boost::filesystem::path p2(&quot;\\&quot;);   boost::filesystem::path p3(&quot;@:&quot;); } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   std::cout &lt;&lt; p.string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;/&quot;);   std::cout &lt;&lt; p.string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.file_string() &lt;&lt; std::endl;   std::cout &lt;&lt; p.directory_string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   std::cout &lt;&lt; p.root_name() &lt;&lt; std::endl;   std::cout &lt;&lt; p.root_directory() &lt;&lt; std::endl;   std::cout &lt;&lt; p.root_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.relative_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.parent_path() &lt;&lt; std::endl;   std::cout &lt;&lt; p.filename() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;photo.jpg&quot;);   std::cout &lt;&lt; p.stem() &lt;&lt; std::endl;   std::cout &lt;&lt; p.extension() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\System&quot;);   for (boost::filesystem::path::iterator it = p.begin(); it != p.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   p /= &quot;Windows\\System&quot;;   std::cout &lt;&lt; p.string() &lt;&lt; std::endl; } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   try   {     boost::filesystem::file_status s = boost::filesystem::status(p);     std::cout &lt;&lt; boost::filesystem::is_directory(s) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;);   try   {     std::cout &lt;&lt; boost::filesystem::file_size(p) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; #include &lt;ctime&gt; int main() {   boost::filesystem::path p(&quot;C:\\Windows\\win.ini&quot;);   try   {     std::time_t t = boost::filesystem::last_write_time(p);     std::cout &lt;&lt; std::ctime(&amp;t) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\&quot;);   try   {     boost::filesystem::space_info s = boost::filesystem::space(p);     std::cout &lt;&lt; s.capacity &lt;&lt; std::endl;     std::cout &lt;&lt; s.free &lt;&lt; std::endl;     std::cout &lt;&lt; s.available &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;C:\\Test&quot;);   try   {     if (boost::filesystem::create_directory(p))     {       boost::filesystem::rename(p, &quot;C:\\Test2&quot;);       boost::filesystem::remove(&quot;C:\\Test2&quot;);     }   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::complete(&quot;photo.jpg&quot;, &quot;D:\\&quot;) &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;windows.h&gt; #include &lt;boost/filesystem.hpp&gt; #include &lt;iostream&gt; int main() {   try   {     std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl;     SetCurrentDirectory(&quot;C:\\&quot;);     std::cout &lt;&lt; boost::filesystem::current_path() &lt;&lt; std::endl;   }   catch (boost::filesystem::filesystem_error &amp;e)   {     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;   } } #include &lt;boost/filesystem/fstream.hpp&gt; #include &lt;iostream&gt; int main() {   boost::filesystem::path p(&quot;test.txt&quot;);   boost::filesystem::ofstream ofs(p);   ofs &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; } </code></pre><h1 id="Boost程序库完全开发指南——深入C-“准”标准库（第3版）"><a href="#Boost程序库完全开发指南——深入C-“准”标准库（第3版）" class="headerlink" title="Boost程序库完全开发指南——深入C++“准”标准库（第3版）"></a>Boost程序库完全开发指南——深入C++“准”标准库（第3版）</h1><p><a href="https://github/chronolaw/boost_guide.git" title="https://github/chronolaw/boost_guide.git" target="_blank" rel="noopener">https://github/chronolaw/boost_guide.git</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.boost.org/" target="_blank" rel="noopener">http://www.boost.org/</a></li><li><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">http://zh.highscore.de/cpp/boost/</a></li><li><a href="http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostChina" target="_blank" rel="noopener">http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostChina</a></li><li><a href="http://www.boost.org/doc/libs/1_63_0/more/getting_started/windows.html" target="_blank" rel="noopener">http://www.boost.org/doc/libs/1_63_0/more/getting_started/windows.html</a></li><li><a href="https://sourceforge.net/projects/boost/?source=directory" target="_blank" rel="noopener">https://sourceforge.net/projects/boost/?source=directory</a></li><li><a href="http://jingyan.baidu.com/article/a3aad71aa1ebe7b1fb009681.html" target="_blank" rel="noopener">win7 vs2012/2013 编译boost 1.55</a></li><li><a href="http://www.cnblogs.com/lidabo/p/3782400.html" target="_blank" rel="noopener">Win7+vs2010下安装boost_1_46_1库</a></li><li><a href="http://www.cnblogs.com/lidabo/p/3782193.html" target="_blank" rel="noopener">vs2008编译boost</a></li><li><a href="https://blog.csdn.net/qingyulove/article/details/78863457" target="_blank" rel="noopener">C++ Boost在VS2017中的使用</a></li><li><a href="http://sourceforge.net/projects/boost/files/boost-docs/" target="_blank" rel="noopener">PDF version of this manual is also available.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Visual-Studio-IDE构建&quot;&gt;&lt;a href=&quot;#使用Visual-Studio-IDE构建&quot; class=&quot;headerlink&quot; title=&quot;使用Visual Studio IDE构建&quot;&gt;&lt;/a&gt;使用Visual Studio IDE构建&lt;/
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="boost" scheme="https://caojingyou.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>MahApps.Metro使用</title>
    <link href="https://caojingyou.github.io/2017/07/01/MahApps.Metro%E4%BD%BF%E7%94%A8/"/>
    <id>https://caojingyou.github.io/2017/07/01/MahApps.Metro使用/</id>
    <published>2017-07-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:18.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MahApps-Metro使用"><a href="#MahApps-Metro使用" class="headerlink" title="MahApps.Metro使用"></a>MahApps.Metro使用</h1><h2 id="下载MahApps-Metro"><a href="#下载MahApps-Metro" class="headerlink" title="下载MahApps.Metro"></a>下载MahApps.Metro</h2><pre><code>PM&gt; Install-Package MahApps.Metro</code></pre><h2 id="MainWindow-xaml中添加"><a href="#MainWindow-xaml中添加" class="headerlink" title="MainWindow.xaml中添加"></a>MainWindow.xaml中添加</h2><pre><code>xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;</code></pre><h2 id="然后将Window标签替换为如下标签"><a href="#然后将Window标签替换为如下标签" class="headerlink" title="然后将Window标签替换为如下标签"></a>然后将Window标签替换为如下标签</h2><pre><code>&lt;Controls:MetroWindow x:Class=&quot;WpfApplication.MainWindow&quot;                  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                  xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;                  Title=&quot;MainWindow&quot;                  Height=&quot;600&quot;                  Width=&quot;800&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><h2 id="MainWindow-xaml-cs添加"><a href="#MainWindow-xaml-cs添加" class="headerlink" title="MainWindow.xaml.cs添加"></a>MainWindow.xaml.cs添加</h2><pre><code>using MahApps.Metro.Controls;namespace WpfApplication{  public partial class MainWindow : MetroWindow  {    public MainWindow()    {      InitializeComponent();    }  }}</code></pre><h2 id="使用内置的样式App-xaml"><a href="#使用内置的样式App-xaml" class="headerlink" title="使用内置的样式App.xaml"></a>使用内置的样式App.xaml</h2><pre><code>&lt;Application x:Class=&quot;WpfApplication.App&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             StartupUri=&quot;MainWindow.xaml&quot;&gt;  &lt;Application.Resources&gt;    &lt;ResourceDictionary&gt;      &lt;ResourceDictionary.MergedDictionaries&gt;        &lt;!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! --&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Colors.xaml&quot; /&gt;        &lt;!-- Accent and AppTheme setting --&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Blue.xaml&quot; /&gt;        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;      &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;  &lt;/Application.Resources&gt;&lt;/Application&gt;</code></pre><h2 id="显示标题栏、图标、最大化最小化按钮的显示"><a href="#显示标题栏、图标、最大化最小化按钮的显示" class="headerlink" title="显示标题栏、图标、最大化最小化按钮的显示"></a>显示标题栏、图标、最大化最小化按钮的显示</h2><pre><code>&lt;Controls:MetroWindow x:Class=&quot;WpfApplication.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;600&quot;                      Width=&quot;800&quot;                      Icon=&quot;mahapps.metro.logo2.ico&quot;                      ShowIconOnTitleBar=&quot;True&quot;                      ShowTitleBar=&quot;True&quot;&gt;    &lt;/Controls:MetroWindow&gt;</code></pre><p>WindowButtonCommands are the minimize, maximize/restore, and close buttons. You can hide the buttons with <code>ShowMinButton=&quot;True|False&quot;</code>, <code>ShowMaxRestoreButton=&quot;True|False&quot;</code> and <code>ShowCloseButton=&quot;True|False&quot;</code>.</p><p>The visibility of the minimize and maximize/restore buttons are also effected by the <code>ResizeMode</code>. If <code>ResizeMode=&quot;NoResize&quot;</code> the buttons are collapsed. If <code>ResizeMode=&quot;CanMinimize&quot;</code> the maximize/restore button is collapsed.</p><h2 id="记住窗口位置"><a href="#记住窗口位置" class="headerlink" title="记住窗口位置"></a>记住窗口位置</h2><p>aveWindowPosition=”True|False”(默认False选项）。将此属性设置为True将意味着在下一次发射，将被自动定位和尺寸对它的出口。这种设计为提高ux和速度发展为一个“管道”，UI是定期进行的。</p><h2 id="修改标题栏"><a href="#修改标题栏" class="headerlink" title="修改标题栏"></a>修改标题栏</h2><p>可以添加自己的控制 LeftWindowsCommands 或 RightWindowsCommands</p><pre><code>&lt;MetroWindow&gt; ... &lt;/MetroWindow&gt;</code></pre><p>MainWindow.xaml.cs内添加：</p><pre><code>&lt;Controls:MetroWindow.RightWindowCommands&gt;  &lt;Controls:WindowCommands&gt;    &lt;Button Content=&quot;settings&quot; /&gt;    &lt;Button&gt;      &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;        &lt;Rectangle Width=&quot;20&quot;                   Height=&quot;20&quot;                   Fill=&quot;{Binding RelativeSource={RelativeSource AncestorType=Button}, Path=Foreground}&quot;&gt;          &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot; Visual=&quot;{StaticResource appbar_cupcake}&quot; /&gt;          &lt;/Rectangle.OpacityMask&gt;        &lt;/Rectangle&gt;        &lt;TextBlock Margin=&quot;4 0 0 0&quot;                   VerticalAlignment=&quot;Center&quot;                   Text=&quot;deploy cupcakes&quot; /&gt;      &lt;/StackPanel&gt;    &lt;/Button&gt;  &lt;/Controls:WindowCommands&gt;&lt;/Controls:MetroWindow.RightWindowCommands&gt;</code></pre><p>显示图标需要加载MahApps.Metro.Resources资源</p><h1 id="MahApps-Metro-Resources使用"><a href="#MahApps-Metro-Resources使用" class="headerlink" title="MahApps.Metro.Resources使用"></a>MahApps.Metro.Resources使用</h1><h2 id="下载MahApps-Metro-Resources"><a href="#下载MahApps-Metro-Resources" class="headerlink" title="下载MahApps.Metro.Resources"></a>下载MahApps.Metro.Resources</h2><pre><code>PM&gt; Install-Package MahApps.Metro.Resources</code></pre><h2 id="MainWindow-xaml文件中添加"><a href="#MainWindow-xaml文件中添加" class="headerlink" title="MainWindow.xaml文件中添加"></a>MainWindow.xaml文件中添加</h2><pre><code>&lt;Window.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;/Resources/Icons.xaml&quot; /&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;/ResourceDictionary&gt;    &lt;/Window.Resources&gt;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>&lt;Rectangle&gt;        &lt;Rectangle.Fill&gt;            &lt;VisualBrush Visual=&quot;{StaticResource appbar_add}&quot; /&gt;        &lt;/Rectangle.Fill&gt;    &lt;/Rectangle&gt;</code></pre><p>或者</p><pre><code>&lt;Rectangle Fill=&quot;Black&quot;&gt;    &lt;Rectangle.OpacityMask&gt;        &lt;VisualBrush Visual=&quot;{StaticResource appbar_add}&quot; Stretch=&quot;Fill&quot; /&gt;    &lt;/Rectangle.OpacityMask&gt;&lt;/Rectangle&gt;</code></pre><h1 id="如何改变目前的主题-Styles"><a href="#如何改变目前的主题-Styles" class="headerlink" title="如何改变目前的主题 Styles"></a>如何改变目前的主题 Styles</h1><p>You can choose between these available accents:</p><pre><code>“Red”, “Green”, “Blue”, “Purple”, “Orange”, “Lime”, “Emerald”, “Teal”, “Cyan”, “Cobalt”, “Indigo”, “Violet”, “Pink”, “Magenta”, “Crimson”, “Amber”, “Yellow”, “Brown”, “Olive”, “Steel”, “Mauve”, “Taupe”, “Sienna”</code></pre><p>and these themes:</p><pre><code>“BaseLight”, “BaseDark”</code></pre><h2 id="通过App-xaml，直接修改其中对应的部分"><a href="#通过App-xaml，直接修改其中对应的部分" class="headerlink" title="通过App.xaml，直接修改其中对应的部分"></a>通过App.xaml，直接修改其中对应的部分</h2><pre><code>&lt;Application x:Class=&quot;MahAppsMetroThemesSample.App&quot;         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;         StartupUri=&quot;MainWindow.xaml&quot;&gt;    &lt;Application.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml&quot; /&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml&quot; /&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Colors.xaml&quot; /&gt;                &lt;!-- accent resource --&gt;                &lt;!-- change &quot;Cobalt&quot; to the accent color you want --&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Cobalt.xaml&quot; /&gt;                &lt;!-- theme resource --&gt;                &lt;!-- change &quot;BaseLight&quot; to the theme you want --&gt;                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;/ResourceDictionary&gt;    &lt;/Application.Resources&gt;&lt;/Application&gt;</code></pre><h2 id="通过ThemeManager"><a href="#通过ThemeManager" class="headerlink" title="通过ThemeManager"></a>通过ThemeManager</h2><pre><code>public partial class App : Application{    protected override void OnStartup(StartupEventArgs e)    {        // get the current app style (theme and accent) from the application        // you can then use the current theme and custom accent instead set a new theme        Tuple&lt;AppTheme, Accent&gt; appStyle = ThemeManager.DetectAppStyle(Application.Current);        // now set the Green accent and dark theme        ThemeManager.ChangeAppStyle(Application.Current,                                    ThemeManager.GetAccent(&quot;Green&quot;),                                    ThemeManager.GetAppTheme(&quot;BaseDark&quot;)); // or appStyle.Item1        base.OnStartup(e);    }}</code></pre><h2 id="在主窗口中修改"><a href="#在主窗口中修改" class="headerlink" title="在主窗口中修改"></a>在主窗口中修改</h2><h3 id="MainWindow-xaml文件"><a href="#MainWindow-xaml文件" class="headerlink" title="MainWindow.xaml文件"></a>MainWindow.xaml文件</h3><pre><code>&lt;Controls:MetroWindow.Resources&gt;    &lt;ResourceDictionary&gt;       &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;!-- this window should be blue --&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/Blue.xaml&quot; /&gt;            &lt;!-- and should use the light theme --&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Accents/BaseLight.xaml&quot; /&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;&lt;/Controls:MetroWindow.Resources&gt;</code></pre><h3 id="主类MetroWindow中"><a href="#主类MetroWindow中" class="headerlink" title="主类MetroWindow中"></a>主类MetroWindow中</h3><pre><code>public partial class AccentStyleWindow : MetroWindow{    public void ChangeAppStyle()    {        // set the Red accent and dark theme only to the current window        ThemeManager.ChangeAppStyle(this,                                    ThemeManager.GetAccent(&quot;Red&quot;),                                    ThemeManager.GetAppTheme(&quot;BaseDark&quot;));    }}</code></pre><p>还可以自定义主题</p><h2 id="Controls控件"><a href="#Controls控件" class="headerlink" title="Controls控件"></a>Controls控件</h2><h3 id="MetroWindow"><a href="#MetroWindow" class="headerlink" title="MetroWindow"></a>MetroWindow</h3><p>窗口有边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      BorderBrush=&quot;{DynamicResource AccentColorBrush}&quot;                      BorderThickness=&quot;1&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><p>发光的边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      GlowBrush=&quot;{DynamicResource AccentColorBrush}&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><p>有阴影的边框：</p><pre><code>&lt;Controls:MetroWindow x:Class=&quot;MahApps.Metro.Simple.Demo.MainWindow&quot;                      xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;                      xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;                      xmlns:Controls=&quot;http://metro.mahapps.com/winfx/xaml/controls&quot;                      Title=&quot;MainWindow&quot;                      Height=&quot;200&quot;                      Width=&quot;600&quot;                      BorderThickness=&quot;0&quot;                       GlowBrush=&quot;Black&quot;                      ResizeMode=&quot;CanResizeWithGrip&quot;                      WindowTransitionsEnabled=&quot;False&quot;                      WindowStartupLocation=&quot;CenterScreen&quot;&gt;&lt;/Controls:MetroWindow&gt;</code></pre><h3 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h3><h4 id="Default-look"><a href="#Default-look" class="headerlink" title="Default look"></a>Default look</h4><p><img src="http://mahapps.com/images/08_RegularButton.png" alt=""></p><h4 id="MetroCircleButton"><a href="#MetroCircleButton" class="headerlink" title="MetroCircleButton"></a>MetroCircleButton</h4><pre><code>&lt;Button Style=&quot;{DynamicResource MetroCircleButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/07_CircleButtons.png" alt=""></p><h4 id="SquareButton"><a href="#SquareButton" class="headerlink" title="SquareButton"></a>SquareButton</h4><pre><code>&lt;Button Style=&quot;{DynamicResource SquareButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/square-button.png" alt=""></p><h4 id="AccentedSquareButton"><a href="#AccentedSquareButton" class="headerlink" title="AccentedSquareButton"></a>AccentedSquareButton</h4><pre><code>&lt;Button Style=&quot;{StaticResource AccentedSquareButtonStyle}&quot; Content=&quot;Button&quot;/&gt;</code></pre><p><img src="http://mahapps.com/images/accent-square-button.png" alt=""></p><h4 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h4><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/FlatButton.xaml&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/flatbutton.png" alt=""></p><h3 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h3><p>您可以使用您熟悉的快捷菜单</p><pre><code>&lt;ContextMenu&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.New&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Delete&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Print&quot; /&gt;&lt;/ContextMenu&gt;</code></pre><p>如果你想使用快捷菜单的一部分被声明为资源和共享使用 <code>CompositeCollection</code></p><pre><code>&lt;CompositeCollection x:Key=&quot;ContextMenuBase&quot; x:Shared=&quot;False&quot;&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.New&quot; /&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Delete&quot; /&gt;  &lt;Separator /&gt;  &lt;StaticResource ResourceKey=&quot;ContextMenuItemRefresh&quot; /&gt;  &lt;Separator /&gt;&lt;/CompositeCollection&gt;&lt;ContextMenu&gt;  &lt;ContextMenu.ItemsSource&gt;&lt;CompositeCollection&gt;  &lt;CollectionContainer Collection=&quot;{StaticResource ContextMenuBase}&quot;&gt;&lt;/CollectionContainer&gt;  &lt;MenuItem Command=&quot;ApplicationCommands.Print&quot; /&gt;&lt;/CompositeCollection&gt;  &lt;/ContextMenu.ItemsSource&gt;&lt;/ContextMenu&gt;</code></pre><p>当你运行应用程序的绑定错误:</p><p>System.Windows.Data Error: 4 : Cannot find source for binding with reference ‘RelativeSource FindAncestor, AncestorType=’System.Windows.Controls.ItemsControl’, AncestorLevel=’1’’. BindingExpression:Path=VerticalContentAlignment; DataItem=null; target element is ‘MenuItem’ (Name=’’); target property is ‘VerticalContentAlignment’ (type ‘VerticalAlignment’)</p><p>这是一个已知的问题在WPF和解决方法是创建一个自定义 <code>MenuItem</code> 风格: </p><pre><code>&lt;Style TargetType=&quot;{x:Type MenuItem}&quot;   BasedOn=&quot;{StaticResource MetroMenuItem}&quot;&gt;  &lt;Setter Property=&quot;HorizontalContentAlignment&quot;  Value=&quot;Left&quot; /&gt;  &lt;Setter Property=&quot;VerticalContentAlignment&quot;  Value=&quot;Center&quot; /&gt;  &lt;/Style&gt;</code></pre><h2 id="Data-Grid"><a href="#Data-Grid" class="headerlink" title="Data Grid"></a>Data Grid</h2><p>In order for the style to be applied, you will have to include references to the <code>Styles/Controls</code> resource dictionary in your App.xaml and the namespace <code>xmlns:controls=&quot;clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro&quot;</code> in the window you are using.</p><p><img src="http://mahapps.com/images/default_datagrid_style.png" alt=""></p><h3 id="Alternative-Style"><a href="#Alternative-Style" class="headerlink" title="Alternative Style"></a>Alternative Style</h3><p>MahApps.Metro also provides an alternative style, <code>AzureDataGrid</code> that attempts to mimic the DataGrid found on Microsoft Azure. To use it instead of the default style, simple set the DataGrid’s <code>Style</code> property to <code>{StaticResource AzureDataGrid</code>. As usual, make sure that you have your references defined.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding People}&quot; Margin=&quot;10,20,10,0&quot;  AutoGenerateColumns=&quot;True&quot;  Style=&quot;{StaticResource AzureDataGrid}&quot;&gt;&lt;/DataGrid&gt; </code></pre><p><img src="http://mahapps.com/images/azure_datagrid_style.png" alt=""></p><h3 id="DataGrid-Numeric-Updown-Control"><a href="#DataGrid-Numeric-Updown-Control" class="headerlink" title="DataGrid Numeric Updown Control"></a>DataGrid Numeric Updown Control</h3><p>In addition to styling the DataGrid, MahApps.Metro also provides a control that allows users to add a <code>NumericUpDown</code> as one of their <code>DataGrid</code>’s columns. To add the custom column to your <code>DataGrid</code>, add <code>DataGridNumericUpDownColumn</code> under the MahApps namespace to your <code>DataGrid.Columns</code> properties. Be sure to set <code>AutoGenerateColumns</code> to <code>False</code> if you have not already done so.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding Path=Albums}&quot;  Grid.Row=&quot;0&quot;  AutoGenerateColumns=&quot;False&quot;&gt;&lt;DataGrid.Columns&gt;&lt;DataGridTextColumn Header=&quot;Genre&quot;Binding=&quot;{Binding Genre.Name}&quot; /&gt;&lt;controls:DataGridNumericUpDownColumn Header=&quot;Price&quot;  Binding=&quot;{Binding Price}&quot;  StringFormat=&quot;C&quot;  Minimum=&quot;0&quot; /&gt;&lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt;</code></pre><p><img src="http://mahapps.com/images/datagrid_numeric_up_down.png" alt=""></p><h3 id="DataGrid-Checkbox"><a href="#DataGrid-Checkbox" class="headerlink" title="DataGrid Checkbox"></a>DataGrid Checkbox</h3><p>Lastly, MahApps.Metro provides an <code>ElementStyle</code> for the <code>DataGridCheckBoxColumn</code>. In order to apply the style, you will have to set the <code>ElementStyle</code> property of the <code>DataGridCheckBoxColumn</code> to <code>{DynamicResource MetroDataGridCheckBox}</code> as shown in the code sample below.</p><pre><code>&lt;DataGrid ItemsSource=&quot;{Binding Path=Albums}&quot;  Grid.Row=&quot;0&quot;  AutoGenerateColumns=&quot;False&quot;&gt;&lt;DataGrid.Columns&gt;&lt;DataGridCheckBoxColumn ElementStyle=&quot;{DynamicResource MetroDataGridCheckBox}&quot;EditingElementStyle=&quot;{DynamicResource MetroDataGridCheckBox}&quot;Header=&quot;IsSelected&quot;Binding=&quot;{Binding RelativeSource={RelativeSource AncestorType=DataGridRow}, Path=IsSelected, Mode=OneWay}&quot;/&gt;&lt;/DataGrid.Columns&gt;&lt;/DataGrid&gt;</code></pre><p><img src="http://mahapps.com/images/datagrid_checkbox.png" alt=""></p><h2 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h2><h3 id="Message-dialog"><a href="#Message-dialog" class="headerlink" title="Message dialog"></a>Message dialog</h3><p>对话框还可以显示简单消息的<code>ShowMessageAsync</code>方法。扩展方法MetroWindow因此，呼叫从它的窗口类。</p><pre><code>await this.ShowMessageAsync(&quot;This is the title&quot;, &quot;Some message&quot;);</code></pre><p>有可选的额外参数的简单的按钮，例如 Ok Cancel 并设置主题颜色和动画选项。</p><h3 id="Progress-dialog"><a href="#Progress-dialog" class="headerlink" title="Progress dialog"></a>Progress dialog</h3><pre><code>var controller = await this.ShowProgressAsync(&quot;Please wait...&quot;, &quot;Progress message&quot;);</code></pre><p>This method returns a ProgressDialogController object that exposes the SetProgress method, use it to set the current progress.</p><p><img src="http://mahapps.com/images/progressdialog.png" alt=""></p><h2 id="FlipView"><a href="#FlipView" class="headerlink" title="FlipView"></a>FlipView</h2><p><img src="http://i.msdn.microsoft.com/dynimg/IC571410.png" alt=""></p><pre><code>&lt;Controls:FlipView Height=&quot;200&quot;    IsBannerEnabled=&quot;True&quot;    SelectionChanged=&quot;FlipView_SelectionChanged&quot;   Margin=&quot;0, 0, 10, 0&quot;&gt;&lt;Controls:FlipView.Items&gt;&lt;Grid Background=&quot;#2E8DEF&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_cupcake}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;Grid Background=&quot;#00A600&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_xbox}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;Grid Background=&quot;#BF1E4B&quot;&gt;&lt;Rectangle Margin=&quot;0, 0, 10, 0&quot; Width=&quot;50&quot; Height=&quot;50&quot;&gt;&lt;Rectangle.Fill&gt;&lt;VisualBrush Visual=&quot;{StaticResource appbar_chess_horse}&quot; /&gt;&lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt;&lt;/Grid&gt;&lt;/Controls:FlipView.Items&gt;&lt;/Controls:FlipView&gt;</code></pre><h3 id="The-Banner"><a href="#The-Banner" class="headerlink" title="The Banner"></a>The Banner</h3><pre><code>private void FlipView_SelectionChanged(object sender, SelectionChangedEventArgs e){var flipview = ((FlipView)sender);switch (flipview.SelectedIndex){case 0:flipview.BannerText = &quot;Cupcakes!&quot;;break;case 1:flipview.BannerText = &quot;Xbox!&quot;;break;case 2:flipview.BannerText = &quot;Chess!&quot;;break;}}</code></pre><h3 id="The-Control-Buttons"><a href="#The-Control-Buttons" class="headerlink" title="The Control Buttons"></a>The Control Buttons</h3><p>The control buttons (the next and previous buttons) allow the user to flip through the items using their mouse. The buttons can be disabled by calling <code>HideControlButtons</code> and renabled by calling <code>ShowControlButtons</code>.</p><p>The user can also flip through the items using the arrows on their keyboard.</p><h3 id="Automated-scrolling-batteries-not-included"><a href="#Automated-scrolling-batteries-not-included" class="headerlink" title="Automated scrolling (batteries not included)"></a>Automated scrolling (batteries not included)</h3><p>Disabling the control buttons is useful when you want to provide an automated scrolling experience. This can be implemented by using a timer and by incrementing SelectedIndex by 1 until the index is equal to Items.Length - 1. At that point, you would reset SelectedIndex to 0.</p><h2 id="Flyouts"><a href="#Flyouts" class="headerlink" title="Flyouts"></a>Flyouts</h2><p>Add the following code to your MetroWindow:</p><pre><code>&lt;Controls:MetroWindow.Flyouts&gt;&lt;Controls:FlyoutsControl&gt;&lt;/Controls:FlyoutsControl&gt;&lt;/Controls:MetroWindow.Flyouts&gt;</code></pre><p>This is the container for the flyouts. Inside this container add the following:</p><pre><code>&lt;Controls:Flyout Header=&quot;Flyout&quot; Position=&quot;Right&quot; Width=&quot;200&quot;&gt;&lt;!-- Your custom content here --&gt;&lt;/Controls:Flyout&gt;</code></pre><h3 id="Themed-flyouts"><a href="#Themed-flyouts" class="headerlink" title="Themed flyouts"></a>Themed flyouts</h3><p>As of version 0.12, flyouts can have various themes, assignable through the Theme property, those are:</p><pre><code>Adapt,Inverse,Dark,Light,Accent</code></pre><ul><li>Adapt adapts the flyout theme to the host window’s theme.</li><li>Inverse has the inverse theme of the host window’s theme.</li><li>Dark will always be the dark theme, this is also the default value.</li><li>Light will always be the light theme.</li><li>Accent adapts the flyout theme to the host window’s theme, it looks like this for the blue theme</li></ul><h3 id="WindowCommandsOverlayBehaviorn"><a href="#WindowCommandsOverlayBehaviorn" class="headerlink" title="WindowCommandsOverlayBehaviorn"></a>WindowCommandsOverlayBehaviorn</h3><p>MetroWindow has overlay properties for LeftWindowCommands, RightWindowCommands, WindowButtonCommands and the Icon to handle the topmost status, even if a flyout is shown.</p><pre><code>public WindowCommandsOverlayBehavior LeftWindowCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior RightWindowCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior WindowButtonCommandsOverlayBehaviorpublic WindowCommandsOverlayBehavior IconOverlayBehavior</code></pre><p>These are the values for WindowCommandsOverlayBehavior</p><pre><code>Never // Doesn&apos;t overlay flyouts nor a hidden TitleBar.Flyouts // Overlays opened Flyout controls.HiddenTitleBar // // Overlays a hidden TitleBar.Always</code></pre><p>WindowCommandsOverlayBehavior.Always</p><p><img src="http://mahapps.com/images/WindowCommandsOverlayBehavior_Always.png" alt=""></p><p>WindowCommandsOverlayBehavior.Never</p><p><img src="http://mahapps.com/images/WindowCommandsOverlayBehavior_Never.png" alt=""></p><h2 id="NumericUpDown"><a href="#NumericUpDown" class="headerlink" title="NumericUpDown"></a>NumericUpDown</h2><p>NumericUpDown控件将用来增大或减小数值。</p><p><img src="http://mahapps.com/images/numeric_up_down.png" alt=""></p><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p><img src="http://mahapps.com/images/progressbar.png" alt=""></p><h3 id="MetroProgressBar"><a href="#MetroProgressBar" class="headerlink" title="MetroProgressBar"></a>MetroProgressBar</h3><p>MetroProgressBar is an alternative and simpler style. Instead of creating a normal ProgressBar use:</p><pre><code>&lt;Controls:MetroProgressBar /&gt;</code></pre><p>Its indeterminate state looks like a ProgressRing but not circular.</p><h2 id="ProgressRing"><a href="#ProgressRing" class="headerlink" title="ProgressRing"></a>ProgressRing</h2><p>The Progress Ring control is styled after a similar control in Windows 8 to indicate activity rather than a percentage of progress completed.</p><pre><code>&lt;Controls:ProgressRing IsActive=&quot;True&quot; /&gt;</code></pre><p><code>IsActive</code> can easily be bound to a viewmodel property.</p><pre><code>&lt;Controls:ProgressRing IsActive=&quot;{Binding IsActive}&quot; /&gt;</code></pre><p>Override Foreground if you wish to change the colour.</p><pre><code>&lt;Controls:ProgressRing Foreground=&quot;{DynamicResource AccentColorBrush}&quot;/&gt;</code></pre><h2 id="RangeSlider"><a href="#RangeSlider" class="headerlink" title="RangeSlider"></a>RangeSlider</h2><p><img src="http://mahapps.com/images/range_slider.PNG" alt=""></p><p>Small Example</p><pre><code>&lt;Сontrols:RangeSlider Style=&quot;{StaticResource RangeSliderCameraCommonStyle}&quot; Minimum=&quot;{Binding Path=MinValue, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}&quot;Maximum=&quot;{Binding Path=MaxValue, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}&quot;LowerValue=&quot;{Binding Path=CurrentMinValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;UpperValue=&quot;{Binding Path=CurrentMaxValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}&quot;LowerValueChanged=&quot;OnLowerValueChanged&quot; UpperValueChanged=&quot;OnUpperValueChanged&quot;LowerThumbDragStarted=&quot;OnLowerDragStarted&quot;LowerThumbDragCompleted=&quot;OnLowerDragCompleted&quot;UpperThumbDragStarted=&quot;OnUpperDragStarted&quot; UpperThumbDragCompleted=&quot;OnUpperDragCompleted&quot; AutoToolTipPlacement=&quot;TopLeft&quot; AutoToolTipPrecision=&quot;2&quot; MoveWholeRange=&quot;True&quot;IsSnapToTickEnabled=&quot;True&quot; IsMoveToPointEnabled=&quot;True&quot; ExtendedMode=&quot;True&quot;&gt;&lt;/Сontrols:RangeSlider&gt;</code></pre><h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h2><p><img src="http://mahapps.com/images/slider_standard.png" alt=""></p><p>If you want to base your custom style on that style, you need to add <code>BasedOn=&quot;{StaticResource MetroSlider}&quot;</code></p><h2 id="FlatSlider-style"><a href="#FlatSlider-style" class="headerlink" title="FlatSlider style"></a>FlatSlider style</h2><p><img src="http://mahapps.com/images/slider_cube.png" alt=""></p><p>To use that style you need to load resource dictionary <code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/FlatSlider.xaml&quot; /&gt;</code> and explicitly set the style of the Slider to <code>Style=&quot;{DynamicResource FlatSlider}&quot;</code></p><p>This style could be dynamically changed to:</p><p><img src="http://mahapps.com/images/slider_tick.png" alt=""></p><h2 id="SplitButton-and-DropDownButton"><a href="#SplitButton-and-DropDownButton" class="headerlink" title="SplitButton and DropDownButton"></a>SplitButton and DropDownButton</h2><p><img src="http://mahapps.com/images/splitButton_1.png" alt=""></p><h3 id="SelectedItem-and-SelectedIndex"><a href="#SelectedItem-and-SelectedIndex" class="headerlink" title="SelectedItem and SelectedIndex"></a>SelectedItem and SelectedIndex</h3><p>This properties usage is just like in Listbox or ComboBox. When one of this properties changed, Content of the button will also changed.</p><h3 id="Binding-to-ObservableCollection-or-Dictionary"><a href="#Binding-to-ObservableCollection-or-Dictionary" class="headerlink" title="Binding to ObservableCollection or Dictionary"></a>Binding to ObservableCollection or Dictionary</h3><p>To correctly bind an <code>ObservableCollection</code> or a <code>Dictionary</code> to <code>SplitButton</code>, you need to use <code>ItemsSource</code> and <code>DisplayMemberPath</code> For ex, <code>ItemsSource=&quot;{Binding Albums}&quot; DisplayMemberPath=&quot;Title&quot;</code>In case you bind simple types like an enum or integer, you dont need to use DisplayMemberPath property, only ItemsSource`.</p><h3 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a>Orientation</h3><p>SplitButton supports orientation changing as you can see on the screenshot.</p><h3 id="Button-commands"><a href="#Button-commands" class="headerlink" title="Button commands"></a>Button commands</h3><p>You can use button commands for SplitButton</p><h3 id="Icon-property"><a href="#Icon-property" class="headerlink" title="Icon property"></a>Icon property</h3><p>You can add separate icon to SplitButton to display it independently from its content. It could be bitmap image or vector icon. <code>Icon=&quot;{DynamicResource appbar_alert}&quot;</code></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code>&lt;Controls:SplitButton Icon=&quot;{DynamicResource appbar_alert}&quot;HorizontalContentAlignment=&quot;Left&quot;HorizontalAlignment=&quot;Center&quot;VerticalContentAlignment=&quot;Center&quot;Width=&quot;120&quot;SelectedIndex=&quot;2&quot;ItemsSource=&quot;{Binding Albums}&quot;DisplayMemberPath=&quot;Title&quot;VerticalAlignment=&quot;Center&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/splitButton_2.png" alt=""></p><h3 id="DropDownButton"><a href="#DropDownButton" class="headerlink" title="DropDownButton"></a>DropDownButton</h3><p><img src="http://mahapps.com/images/dropDownButton_1.png" alt=""></p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><pre><code>Controls:DropDownButton VerticalContentAlignment=&quot;Center&quot;Width=&quot;120&quot;Content=&quot;Test&quot;DisplayMemberPath=&quot;Title&quot;Icon=&quot;{DynamicResource appbar_music}&quot;ItemsSource=&quot;{Binding Albums}&quot;&gt;&lt;/Controls:DropDownButton&gt;</code></pre><p><img src="http://mahapps.com/images/dropDownButton_2.png" alt=""></p><h2 id="TabControl"><a href="#TabControl" class="headerlink" title="TabControl"></a>TabControl</h2><p>There are three included tab styles - <code>AnimatedTabControl</code>, <code>SingleRowAnimatedTabControl</code> and the default <code>TabControl</code>. The default TabControl style is included in Controls.xaml, but the other two require specific referencing (make sure to do this after a reference to <code>Controls.xaml</code>)</p><h3 id="Default-look-1"><a href="#Default-look-1" class="headerlink" title="Default look"></a>Default look</h3><p><img src="http://mahapps.com/images/default_tab_control.png" alt=""></p><p>This shows the three states - selected/active tab, hover and inactive.</p><h3 id="AnimatedTabControl"><a href="#AnimatedTabControl" class="headerlink" title="AnimatedTabControl"></a>AnimatedTabControl</h3><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.AnimatedTabControl.xaml&quot; /&gt;</code></pre><p>Functioning just like the regular TabControl, except it animates every tab change by wrapping everything in a MetroContentControl.</p><p><img src="http://mahapps.com/images/animatedtabcontrol.gif" alt=""></p><h3 id="AnimatedSingleRowTabControl"><a href="#AnimatedSingleRowTabControl" class="headerlink" title="AnimatedSingleRowTabControl"></a>AnimatedSingleRowTabControl</h3><pre><code>&lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro;component/Styles/Controls.AnimatedSingleRowTabControl.xaml&quot; /&gt;</code></pre><p>AnimatedSingleRowTabControl functions exactly the same as the AnimatedTabControl except the tabs will only appear on a single line rather than wrapping. Instead of wrapping, arrows (left/right) are presented.</p><p><img src="http://mahapps.com/images/singlerow_tab_control.png" alt=""></p><h2 id="TextBox-MahApps-Metro"><a href="#TextBox-MahApps-Metro" class="headerlink" title="TextBox - MahApps.Metro"></a>TextBox - MahApps.Metro</h2><h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><pre><code>&lt;TextBox Controls:TextBoxHelper.Watermark=&quot;This is a textbox&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/10_textboxstates.png" alt=""></p><h3 id="Clear-button"><a href="#Clear-button" class="headerlink" title="Clear button"></a>Clear button</h3><p>Like the watermark, a simple attached property adds in the functionality</p><pre><code>&lt;TextBox Controls:TextBoxHelper.ClearTextButton=&quot;True&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/11_textboxclearstates.png" alt=""></p><h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><pre><code>&lt;controls:Tile Title=&quot;Hello!&quot; TiltFactor=&quot;2&quot;Width=&quot;100&quot; Height=&quot;100&quot; Count=&quot;1&quot;&gt;&lt;/controls:Tile&gt;</code></pre><p><img src="https://github-camo.global.ssl.fastly.net/4793fa88b9041fb4a1bba21aa2140ee7d0f32b3c/687474703a2f2f7777772e6e63756265642e6e65742f7a2f706963732f6d6168617070732f54696c65436f6e74656e74436f6c6f72732e706e67" alt=""></p><h2 id="ToggleButton"><a href="#ToggleButton" class="headerlink" title="ToggleButton"></a>ToggleButton</h2><p>The default style, available just by placing a ToggleButton control in XAML looks like the default MahApps.Metro button.</p><p><img src="http://mahapps.com/images/toggle-button-normal.png" alt=""></p><pre><code>&lt;Grid&gt;&lt;ToggleButton/&gt;&lt;/Grid&gt;</code></pre><p>Another style, MetroCircleToggleButtonStyle is available by setting the ToggleButton’s style to MetroCircleToggleButtonStyle. This style changes the button’s background to AccentColorBrush when it is checked. To modify this behaviour, you will have to edit a copy of the control template using Blend.</p><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;&lt;/ToggleButton&gt;</code></pre><p><img src="http://mahapps.com/images/toggle-button-circle.png" alt=""></p><h3 id="Using-Glyphs-Within-a-Circle-Toggle-Button"><a href="#Using-Glyphs-Within-a-Circle-Toggle-Button" class="headerlink" title="Using Glyphs Within a Circle Toggle Button"></a>Using Glyphs Within a Circle Toggle Button</h3><p>In order to use glyphs, you will have to add a reference to Icons.xaml.</p><pre><code>`&lt;UserControl.Resources&gt;    &lt;ResourceDictionary&gt;        &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;ResourceDictionary Source=&quot;pack://application:,,,/MahApps.Metro.Resources;component/Icons.xaml&quot; /&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;&lt;/UserControl.Resources&gt;`</code></pre><ol><li>Nest a Rectangle within the ToggleButton</li><li>Set it’s fill to the color you want the icon to have</li><li>Set Rectangle.OpacityMask to contain a VisualBrush with a Visual using the icon’s value as a reference.</li></ol><h3 id="For-example"><a href="#For-example" class="headerlink" title="For example:"></a>For example:</h3><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;    &lt;Rectangle Width=&quot;20&quot;               Height=&quot;20&quot;               Fill=&quot;{DynamicResource BlackBrush}&quot;&gt;        &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot;                         Visual=&quot;{DynamicResource appbar_city}&quot;/&gt;        &lt;/Rectangle.OpacityMask&gt;    &lt;/Rectangle&gt;&lt;/ToggleButton&gt;</code></pre><h3 id="Syncing-Checked-State-of-ToggleButton-with-Foreground"><a href="#Syncing-Checked-State-of-ToggleButton-with-Foreground" class="headerlink" title="Syncing Checked State of ToggleButton with Foreground"></a>Syncing Checked State of ToggleButton with Foreground</h3><p>By default, any icon you set will retain the same color you set it to even if the ToggleButton is checked. To alter this, you can bind your content’s color to the ToggleButton’s Foreground property which changes to white by default when it is checked.</p><p>An example of how to do the binding can be found below:</p><pre><code>&lt;ToggleButton Width=&quot;50&quot;              Height=&quot;50&quot;              Margin=&quot;0, 10, 0, 0&quot;              Style=&quot;{DynamicResource MetroCircleToggleButtonStyle}&quot;&gt;    &lt;Rectangle Width=&quot;20&quot;               Height=&quot;20&quot;               Fill=&quot;{Binding Path=Foreground, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type ToggleButton}}}&quot;&gt;        &lt;Rectangle.OpacityMask&gt;            &lt;VisualBrush Stretch=&quot;Fill&quot;                         Visual=&quot;{DynamicResource appbar_city}&quot;/&gt;        &lt;/Rectangle.OpacityMask&gt;    &lt;/Rectangle&gt;&lt;/ToggleButton&gt;</code></pre><h2 id="ToggleSwitch"><a href="#ToggleSwitch" class="headerlink" title="ToggleSwitch"></a>ToggleSwitch</h2><p>The function is very similar to that of a checkbox, but easier to differentiate and easier to use with touch interfaces. Basically though, it can be thought of as a pretty CheckBox:</p><pre><code>&lt;Controls:ToggleSwitch Header=&quot;WiFi rest state&quot; /&gt;</code></pre><p><img src="http://mahapps.com/images/09_toggleswitch.png" alt=""></p><p>You can bind to/set IsChecked to switch between the two states. You can change the on and off labels by setting</p><pre><code>&lt;Controls:ToggleSwitch OnLabel=&quot;Yes&quot; OffLabel=&quot;No&quot; /&gt;</code></pre><h2 id="TransitioningContentControl"><a href="#TransitioningContentControl" class="headerlink" title="TransitioningContentControl"></a>TransitioningContentControl</h2><p>Taken from Silverlight (specifically this port), TransitioningContentControl is great for switching content smoothly around. At it’s core, TransitioningContentControl is a ContentControl, so only one child element can be displayed at a time. When you change the content, an animation is played switching the two.</p><pre><code>&lt;Controls:TransitioningContentControl x:Name=&quot;transitioning&quot; Width=&quot;150&quot; Height=&quot;50&quot; Transition=&quot;DownTransition&quot; /&gt;</code></pre><p>Built in there are several transitions:</p><ul><li>Default</li><li>Down</li><li>Up</li><li>Right</li><li>Left</li><li>RightReplace</li><li>LeftReplace</li><li>Custom</li></ul><h2 id="StatusBar"><a href="#StatusBar" class="headerlink" title="StatusBar"></a>StatusBar</h2><pre><code>&lt;StatusBar Grid.Row=&quot;2&quot;&gt;            &lt;StatusBarItem&gt;MahApps.Metro DEMO Application&lt;/StatusBarItem&gt;            &lt;Separator Style=&quot;{StaticResource MetroStatusBarSeparator}&quot; /&gt;            &lt;StatusBarItem&gt;Selected Tab:&lt;/StatusBarItem&gt;            &lt;StatusBarItem Content=&quot;{Binding ElementName=MainTabControl, Path=SelectedItem.Header, Mode=OneWay}&quot; /&gt;        &lt;/StatusBar&gt;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/MahApps/MahApps.Metro.IconPacks" target="_blank" rel="noopener">MahApps.Metro.IconPacks</a></li><li><a href="http://mahapps.com/guides/icons-and-resources.html" target="_blank" rel="noopener">MahApps.Metro.Resources</a> </li><li>NHotkey</li><li>NHotkey.Wpf</li></ul><p>参考：</p><ul><li><a href="http://rehansaeed.com/wpf-metro-part1-modern-ui-for-wpf/" target="_blank" rel="noopener">http://rehansaeed.com/wpf-metro-part1-modern-ui-for-wpf/</a></li><li><a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener">https://github.com/MahApps/MahApps.Metro</a></li><li><a href="http://mahapps.com/guides/quick-start.html" target="_blank" rel="noopener">http://mahapps.com/guides/quick-start.html</a></li><li><a href="http://www.wxzzz.com/1202.html" target="_blank" rel="noopener">http://www.wxzzz.com/1202.html</a></li><li><a href="http://mahapps.com/guides/icons-and-resources.html" target="_blank" rel="noopener">http://mahapps.com/guides/icons-and-resources.html</a></li><li><a href="http://mahapps.com/guides/styles.html" target="_blank" rel="noopener">http://mahapps.com/guides/styles.html</a></li><li><a href="http://mahapps.com/controls/" target="_blank" rel="noopener">http://mahapps.com/controls/</a></li><li><a href="https://github.com/MahApps/MahApps.Metro.IconPacks" target="_blank" rel="noopener">https://github.com/MahApps/MahApps.Metro.IconPacks</a></li><li><a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></li><li><a href="https://materialdesignicons.com/" target="_blank" rel="noopener">https://materialdesignicons.com/</a></li><li><a href="http://www.wxzzz.com/tag/mahapps" title="http://www.wxzzz.com/tag/mahapps" target="_blank" rel="noopener">http://www.wxzzz.com/tag/mahapps</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MahApps-Metro使用&quot;&gt;&lt;a href=&quot;#MahApps-Metro使用&quot; class=&quot;headerlink&quot; title=&quot;MahApps.Metro使用&quot;&gt;&lt;/a&gt;MahApps.Metro使用&lt;/h1&gt;&lt;h2 id=&quot;下载MahApps-Met
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="MahApps.Metro" scheme="https://caojingyou.github.io/tags/MahApps-Metro/"/>
    
  </entry>
  
  <entry>
    <title>获得GetLastError()内容</title>
    <link href="https://caojingyou.github.io/2017/06/15/%E8%8E%B7%E5%BE%97GetLastError()%E5%86%85%E5%AE%B9/"/>
    <id>https://caojingyou.github.io/2017/06/15/获得GetLastError()内容/</id>
    <published>2017-06-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.045Z</updated>
    
    <content type="html"><![CDATA[<pre><code>GetStrError(CString&amp; strError, const DWORD&amp; dwErr){    LPVOID lpMsgBuf;    //DWORD dw = GetLastError();    FormatMessage (        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,        NULL,        dwErr,        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPTSTR) &amp;lpMsgBuf,        0, NULL );    strError = (char *)lpMsgBuf;    LocalFree(lpMsgBuf);}</code></pre><p>个人写的：</p><pre><code>GetStrError(CString &amp;strError, const DWORD &amp;dwErr){    LPVOID lpMsgBuf;    //DWORD dw = GetLastError();    FormatMessage (        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,        NULL,        dwErr,        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPTSTR) &amp;lpMsgBuf,        0, NULL );    strError = (char *)lpMsgBuf;    LocalFree(lpMsgBuf);}MyAfxMessageBox(CString strError){    CString str;    DWORD dwErr = GetLastError();    GetStrError(str, dwErr);    CString strTemp;    strTemp.Format(_T(&quot;程序运行错误!%s\r\n错误码:%lu\r\n错误内容:%s&quot;), strError, dwErr, str);    AfxMessageBox(strTemp);}try{    AfxMessageBox(strMsg, MB_ICONINFORMATION);}catch (CMemoryException *e){    MyAfxMessageBox(_T(&quot;CMemoryException&quot;));}catch (CFileException *e){    MyAfxMessageBox(_T(&quot;CFileException&quot;));}catch (CException *e){    MyAfxMessageBox(_T(&quot;CException&quot;));}catch(...){    MyAfxMessageBox(_T(&quot;其他&quot;));}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;GetStrError(CString&amp;amp; strError, const DWORD&amp;amp; dwErr)
{
    LPVOID lpMsgBuf;
    //DWORD dw = GetLastError();
    FormatMess
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="GetLastError" scheme="https://caojingyou.github.io/tags/GetLastError/"/>
    
  </entry>
  
  <entry>
    <title>C++字符串分割</title>
    <link href="https://caojingyou.github.io/2017/06/01/C++%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2/"/>
    <id>https://caojingyou.github.io/2017/06/01/C++字符分割/</id>
    <published>2017-06-01T08:03:00.000Z</published>
    <updated>2018-08-31T10:06:02.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AfxExtractSubString"><a href="#AfxExtractSubString" class="headerlink" title="AfxExtractSubString"></a>AfxExtractSubString</h1><p>表头: <afxwin.h></afxwin.h></p><p>BOOL AFXAPI AfxExtractSubString ( CString&amp; rString, LPCTSTR lpszFullString, int iSubString, TCHAR chSep = ‘\n’);</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>rString 对CString将得到一个单独的子字符串的对象。</p><p>lpszFullString 字符串包含字符串的全文提取自。</p><p>iSubString 提取的子字符串的从零开始的索引从lpszFullString。</p><p>chSep 使用的分隔符分隔子字符串，默认的是’\n’。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>TRUE ，如果函数成功提取了该子字符串中提供的索引;否则， FALSE。</p><h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><pre><code>// 使用AfxExtractSubString分割字符串void CSplitString::SplitString1(){    std::vector&lt;long&gt; arrPic;    CString strContent = _T(&quot;1,2,3,4,5&quot;);    CString strTemp;    int iPos = 0;    while (AfxExtractSubString(strTemp, strContent, iPos, &apos;,&apos;))    {        iPos++;        arrPic.push_back(_wtol(strTemp));    }}</code></pre><h1 id="STL-find-first-of"><a href="#STL-find-first-of" class="headerlink" title="STL find_first_of"></a>STL find_first_of</h1><pre><code>// 利用STL自己实现字符串分割void CSplitString::SplitString2(){    const std::string s(&quot;1,2,3,4,5;6;7;8;9&quot;);    std::vector&lt;std::string&gt; v;    const std::string c(&quot;,;&quot;);//多个分隔符    std::string::size_type pos1, pos2;    pos2 = s.find_first_of(c);    pos1 = 0;    while (std::string::npos != pos2)    {        v.push_back(s.substr(pos1, pos2 - pos1));        pos1 = pos2 + 1;        pos2 = s.find_first_of(c, pos1);    }    if (pos1 != s.length())        v.push_back(s.substr(pos1));}</code></pre><h1 id="tcstok-s"><a href="#tcstok-s" class="headerlink" title="_tcstok_s"></a>_tcstok_s</h1><pre><code>// 使用C的_tcstok分割字符串void CSplitString::SplitString3(){    CString str = _T(&quot;a,b*c,d&quot;);    TCHAR seps[] = _T(&quot;,*&quot;);//可按多个字符来分割    TCHAR *next_token1 = NULL;    TCHAR* token = _tcstok_s((LPTSTR)(LPCTSTR)str, seps,&amp;next_token1);    while (token != NULL)    {        TRACE(&quot;\r\nstr=%s  token=%s\r\n&quot;, str, token);        token = _tcstok_s(NULL, seps, &amp;next_token1);    }}</code></pre><p><a href="http://www.qiezichaodan.com/mfc_cstring_split/" target="_blank" rel="noopener">http://www.qiezichaodan.com/mfc_cstring_split/</a></p><p><a href="http://blog.csdn.net/xjw532881071/article/details/49154911" target="_blank" rel="noopener">http://blog.csdn.net/xjw532881071/article/details/49154911</a></p><p><a href="http://www.cnblogs.com/happykoukou/p/5427268.html" target="_blank" rel="noopener">http://www.cnblogs.com/happykoukou/p/5427268.html</a></p><h1 id="词汇分割器库-Boost-Tokenizer"><a href="#词汇分割器库-Boost-Tokenizer" class="headerlink" title="词汇分割器库 Boost.Tokenizer"></a>词汇分割器库 Boost.Tokenizer</h1><pre><code>#include &lt;boost/tokenizer.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() {   typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokenizer;   std::string s = &quot;Boost C++ libraries&quot;;   boost::char_separator&lt;char&gt; sep(&quot; &quot;, &quot;+&quot;, boost::keep_empty_tokens);   tokenizer tok(s, sep);   for (tokenizer::iterator it = tok.begin(); it != tok.end(); ++it)     std::cout &lt;&lt; *it &lt;&lt; std::endl; } </code></pre><h1 id="分词Boost-regex"><a href="#分词Boost-regex" class="headerlink" title="分词Boost.regex"></a>分词Boost.regex</h1><pre><code>void TestToken(){    using namespace std;    using namespace boost;    string str(&quot;tengxun@qq.com, aa@tt.com, bb@qq.com&quot;);    regex reg(&quot;\\w+&quot;);    sregex_token_iterator pos(str.begin(), str.end(), reg);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //如果最后一个参数args为-1，则把匹配到的字符串视为分隔符    regex split_reg(&quot;,&quot;);    pos = sregex_token_iterator(str.begin(), str.end(), split_reg, -1);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //如果最后一个参数args为正数，则返回匹配结果的第args个子串    regex split_sub_reg(&quot;(\\w*)@(\\w*).(\\w*)&quot;);    pos = sregex_token_iterator(str.begin(), str.end(), split_sub_reg, 1);    while (pos != sregex_token_iterator())    {        cout &lt;&lt; &quot;[&quot; &lt;&lt; *pos &lt;&lt; &quot;]&quot;;        ++pos;    }    cout &lt;&lt; endl;    //匹配并指定输出顺序    //从下面字符串中提取日期，并转换成 年月日 的顺序输出    std::string input(&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;);    regex re(&quot;(\\d{2})/(\\d{2})/(\\d{4})&quot;); // find a date    int const sub_matches[] = { 3, 1, 2 }; // year，month， day    sregex_token_iterator begin(input.begin(), input.end(), re, sub_matches), end;    // write all the words to std::cout    std::ostream_iterator&lt; std::string &gt; out_iter(std::cout, &quot;\n&quot;);    std::copy(begin, end, out_iter);}</code></pre><h1 id="C-11正则表达式"><a href="#C-11正则表达式" class="headerlink" title="C++ 11正则表达式"></a>C++ 11正则表达式</h1><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;regex&gt;// std::wstring版本std::vector&lt;std::wstring&gt; ws_split(const std::wstring&amp; in, const std::wstring&amp; delim) {    std::wregex re{ delim };    return std::vector&lt;std::wstring&gt; {        std::wsregex_token_iterator(in.begin(), in.end(), re, -1),        std::wsregex_token_iterator()    };}// c string版本std::vector&lt;std::string&gt; c_split(const char* in, const char* delim) {    std::regex re{ delim };    return std::vector&lt;std::string&gt; {        std::cregex_token_iterator(in, in + strlen(in),re, -1),        std::cregex_token_iterator()    };}// 支持wchar_t宽字符集的版本std::vector&lt;std::wstring&gt; wc_split(const wchar_t* in, const wchar_t* delim) {    std::wregex re{ delim };    return std::vector&lt;std::wstring&gt; {        std::wcregex_token_iterator(in, in + wcslen(in),re, -1),        std::wcregex_token_iterator()    };}// 上面的s_split和ws_split可以统一用模板来实现template&lt;typename E,    typename TR = std::char_traits&lt;E&gt;,    typename AL = std::allocator&lt;E&gt;,    typename _str_type = std::basic_string&lt;E, TR, AL&gt;&gt;std::vector&lt;_str_type&gt; bs_split(const std::basic_string&lt;E, TR, AL&gt;&amp; in, const std::basic_string&lt;E, TR, AL&gt;&amp; delim) {    std::basic_regex&lt;E&gt; re{ delim };    return std::vector&lt;_str_type&gt; {        std::regex_token_iterator&lt;typename _str_type::const_iterator&gt;(in.begin(), in.end(), re, -1),            std::regex_token_iterator&lt;typename _str_type::const_iterator&gt;()    };}</code></pre><p>参考：</p><ul><li><a href="http://www.cplusplus.com/faq/sequences/strings/split/" target="_blank" rel="noopener">http://www.cplusplus.com/faq/sequences/strings/split/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AfxExtractSubString&quot;&gt;&lt;a href=&quot;#AfxExtractSubString&quot; class=&quot;headerlink&quot; title=&quot;AfxExtractSubString&quot;&gt;&lt;/a&gt;AfxExtractSubString&lt;/h1&gt;&lt;p&gt;表头
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="字符串" scheme="https://caojingyou.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>GUID</title>
    <link href="https://caojingyou.github.io/2017/05/15/GUID/"/>
    <id>https://caojingyou.github.io/2017/05/15/GUID/</id>
    <published>2017-05-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><pre><code>CString CreateNewUid(){    CoInitialize(NULL);    AUTH_TRACE_STACK();    GUID guid;    HRESULT hr = CoCreateGuid(&amp;guid);    if (FAILED(hr))    {        AUTH_LOGMESSAGE1(_T(&quot;Create Guid Failed!&quot;));    }#ifdef _UNICODE    unsigned short* buf = NULL;#else    unsigned char* buf = NULL;#endif    UuidToString((UUID*)&amp;guid, &amp;buf);        CString strUID((LPCTSTR)buf);    RpcStringFree(&amp;buf);    CoUninitialize();    return strUID;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUID&quot;&gt;&lt;a href=&quot;#GUID&quot; class=&quot;headerlink&quot; title=&quot;GUID&quot;&gt;&lt;/a&gt;GUID&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;CString CreateNewUid()
{
    CoInitialize(NULL);

    
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="GUID" scheme="https://caojingyou.github.io/tags/GUID/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ</title>
    <link href="https://caojingyou.github.io/2017/05/02/ZeroMQ/"/>
    <id>https://caojingyou.github.io/2017/05/02/ZeroMQ/</id>
    <published>2017-05-02T10:09:00.000Z</published>
    <updated>2018-05-21T09:19:54.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://zeromq.org/" target="_blank" rel="noopener">http://zeromq.org/</a></p><p><a href="https://github.com/zeromq" title="https://github.com/zeromq" target="_blank" rel="noopener">https://github.com/zeromq</a></p><p><a href="http://zeromq.org/distro:microsoft-windows" title="http://zeromq.org/distro:microsoft-windows" target="_blank" rel="noopener">http://zeromq.org/distro:microsoft-windows</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://zeromq.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://zeromq.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zeromq&quot; title=&quot;http
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="即时通讯" scheme="https://caojingyou.github.io/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="ZeroMQ" scheme="https://caojingyou.github.io/tags/ZeroMQ/"/>
    
  </entry>
  
  <entry>
    <title>ImageMagick</title>
    <link href="https://caojingyou.github.io/2017/04/15/ImageMagick/"/>
    <id>https://caojingyou.github.io/2017/04/15/ImageMagick/</id>
    <published>2017-04-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unix-源码安装-Windows-源码安装"><a href="#Unix-源码安装-Windows-源码安装" class="headerlink" title="[ Unix 源码安装 | Windows 源码安装 ]"></a>[ Unix 源码安装 | Windows 源码安装 ]</h1><p>首先检查一下电脑里已经安装的ImageMagick版本，输入：</p><pre><code>convert -version</code></pre><p>除非你想要把对另外的图像格式的支持或升级一个较新的版本，否则你可能不需要ImageMagick的源码安装。 你也可以安装预先编译二进位版本。然而，如果你仍然想要从源码安装，请选择一个平台，Unix 或 Windows。<br>在源码安装之前，你可能要回顾ImageMagick的最近变化。</p><h2 id="Unix-源码安装"><a href="#Unix-源码安装" class="headerlink" title="Unix 源码安装"></a>Unix 源码安装</h2><p>ImageMagick 在多种操作系统 Unix 和包括 Linux，Solaris，FreeBSD，Mac 操作系统 X 和其它的类 Unix 一样的操作系统上建立。 它需要一个编译器，几乎所有现代的 Unix 系统都会有一个。 可以从 ftp.imagemagick.org 或它的镜像网站下载 ImageMagick.tar.gz 并用这个指令解压缩:</p><pre><code>gunzip -c ImageMagick.tar.gz | tar xvf -</code></pre><p>然后配置编译ImageMagick:</p><pre><code>cd ImageMagick-6.?.?</code></pre><p>./configure<br>make</p><p>如果配置编译的ImageMagick没有出现错误，要把它安装到系统里，你需要使用管理员权限，输入：</p><pre><code>make install</code></pre><p>最后，可以测试一下ImageMagick的工作效果：</p><pre><code>/usr/local/bin/convert logo: logo.gif</code></pre><p>恭喜你，你已经有ImageMagick的工作环境了，你可以使用ImageMagick加入新图片，生成缩略图，组合图片……<br>还可以使用其它程序接口 C, C++, Perl, 和其它程序。<br>上述的指导将会使很多的 ImageMagick 使用者满意，但是我们怀疑一些将会有另外的问题或问题考虑。<br>如果 ImageMagick 无法配置或编译，或如果你没有管理员权限或没有将ImageMagick安装到默认目录<br>请点这里了解更多……</p><h2 id="Windows-源码安装"><a href="#Windows-源码安装" class="headerlink" title="Windows 源码安装"></a>Windows 源码安装</h2><p>Windows系统下ImageMagick源码安装需要Microsoft Visual Studio IDE。<br>有的用户也成功的用Borland C++编译。如果你没有编译器，你可以安装二进位发布版本</p><p>从ftp.imagemagick.org或它的镜像网站下载 ImageMagick-windows.zip 文件，然后用 WinZip 解压缩。</p><p>然后运行你的Visual Studio IDE选择Open-&gt;Project从ImageMagick-6.?.?/VisualMagick/configure文件夹里选择configure.dsp文件 Build-&gt;Build编译并执行。</p><p>可以通过以下方法获取图片信息</p><h2 id="安装ImageMagick便携版本"><a href="#安装ImageMagick便携版本" class="headerlink" title="安装ImageMagick便携版本"></a>安装ImageMagick便携版本</h2><h1 id="调用命令行程序并获取返回信息"><a href="#调用命令行程序并获取返回信息" class="headerlink" title="调用命令行程序并获取返回信息"></a>调用命令行程序并获取返回信息</h1><pre><code>CString ExeCmd(CString pszCmd){    //创建匿名管道    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};    HANDLE hRead, hWrite;    if (!CreatePipe(&amp;hRead, &amp;hWrite, &amp;sa, 0))    {        return _T(&quot;&quot;);    }    //设置命令行进程启动信息(以隐藏方式启动命令并定位其输出到hWrite)    STARTUPINFO si = {sizeof(STARTUPINFO)};    GetStartupInfo(&amp;si);    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;    si.wShowWindow = SW_HIDE;    si.hStdError = hWrite;    si.hStdOutput = hWrite;    //启动命令行    PROCESS_INFORMATION pi;    if (!CreateProcess(NULL, (LPWSTR)(LPCWSTR)pszCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &amp;si, &amp;pi))    {        return _T(&quot;&quot;);    }    //立即关闭hWrite    CloseHandle(hWrite);    //读取命令行返回值    char buff[1024] = {0};    DWORD dwRead = 0;    while (ReadFile(hRead, buff, 1024, &amp;dwRead, NULL))    {    }    CString strRet(buff);    CloseHandle(hRead);    return strRet;}</code></pre><p>使用：</p><pre><code>ExeCmd(_T(&quot;ping baidu.com&quot;));ExeCmd(_T(&quot;identify -format &quot;%[colorspace]&quot; E:\\P70306-163226.jpg&quot;));</code></pre><h2 id="安装ImageMagickCOM-对象"><a href="#安装ImageMagickCOM-对象" class="headerlink" title="安装ImageMagickCOM+对象"></a>安装ImageMagickCOM+对象</h2><p>C++程序员应该看一下MagickCMD.cpp命令行实用工具的示例调用该对象的C++。对象变量列表的大小需要BSTR的模仿命令行argc，argv风格的COM组件的调用约定，这是更复杂的C++中然后在VB或VBS。</p><pre><code>#include &lt;iostream&gt;#include &lt;atlbase.h&gt;#include &lt;atlsafe.h&gt;#import &quot;ImageMagickObject.tlb&quot; no_namespaceusing namespace std;typedef enum{  cmdUnknown,  cmdCompare,  cmdComposite,  cmdConvert,  cmdIdentify,  cmdMogrify,  cmdMontage,  cmdStream} CommandType;static struct  Commands  {    char      *name;    CommandType      code;  } Commands[] =  {    { &quot;&quot;,          cmdUnknown   },    { &quot;compare&quot;,   cmdCompare   },    { &quot;composite&quot;, cmdComposite },    { &quot;convert&quot;,   cmdConvert   },    { &quot;identify&quot;,  cmdIdentify  },    { &quot;mogrify&quot;,   cmdMogrify   },    { &quot;montage&quot;,   cmdMontage   },    { &quot;stream&quot;,    cmdStream   }  };int main(int argc, char* argv[]){  int    index,    status = 0;  char    *name;  CommandType    code = cmdUnknown;  // We must have at least a command, input, and output  if (argc &lt; 4)    return 0;  index = 1;  while ((name = Commands[index].name))  {    if (stricmp(name,argv[1]) == 0)    {      code = Commands[index].code;      break;    }    index++;  }  if (code == cmdUnknown)    return 0;  CoInitialize(NULL);  try  {    CComVariant      result;    SAFEARRAY      **ppsa = (SAFEARRAY**) NULL;    IMagickImagePtr pImageProc(__uuidof(MagickImage));    if (pImageProc == NULL)      status = 1;    else    {      {        // Define the array bound structure        CComSafeArrayBound bound[1];        bound[0].SetCount(argc-2);        bound[0].SetLowerBound(0);        CComSafeArray&lt;VARIANT&gt; args(bound);        if( !args )          status = 2;        else        {          for(index = 2; index &lt; argc; ++index)          {            CComVariant vt(argv[index]);            HRESULT hr = vt.Detach(&amp;args[index-2]);          }          switch(code)          {            case cmdCompare:              result = pImageProc-&gt;Compare(args.GetSafeArrayPtr());              break;            case cmdComposite:              result = pImageProc-&gt;Composite(args.GetSafeArrayPtr());              break;            case cmdConvert:              result = pImageProc-&gt;Convert(args.GetSafeArrayPtr());              break;            case cmdIdentify:              result = pImageProc-&gt;Identify(args.GetSafeArrayPtr());              break;            case cmdMogrify:              result = pImageProc-&gt;Mogrify(args.GetSafeArrayPtr());              break;            case cmdMontage:              result = pImageProc-&gt;Montage(args.GetSafeArrayPtr());              break;            case cmdStream:              result = pImageProc-&gt;Stream(args.GetSafeArrayPtr());              break;          }          pImageProc.Release();        }      }    }  }  catch(_com_error ex)  {    HRESULT      res = ex.Error();      _bstr_t      desc = ex.Description();      printf(&quot;Error %s (0x%08x)\n&quot;,(char *)desc,res);    status = 4;  }  CoUninitialize();  return status;}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">http://www.imagemagick.org/script/index.php</a></li><li><a href="http://www.imagemagick.com.cn/" target="_blank" rel="noopener">http://www.imagemagick.com.cn/</a></li><li><a href="http://www.imagemagick.org/script/download.php" target="_blank" rel="noopener">http://www.imagemagick.org/script/download.php</a></li><li><a href="https://github.com/ImageMagick/ImageMagick/tree/master/Magick%2B%2B" target="_blank" rel="noopener">https://github.com/ImageMagick/ImageMagick/tree/master/Magick%2B%2B</a></li><li><a href="https://legacy.imagemagick.org/script/index.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/index.php</a></li><li><a href="https://www.imagemagick.org/Usage/" target="_blank" rel="noopener">https://www.imagemagick.org/Usage/</a></li><li><a href="https://www.imagemagick.org/Usage/color_basics/" target="_blank" rel="noopener">https://www.imagemagick.org/Usage/color_basics/</a></li><li><a href="ftp://ftp.imagemagick.org/pub/ImageMagick/windows/" target="_blank" rel="noopener">ftp://ftp.imagemagick.org/pub/ImageMagick/windows/</a></li><li><a href="https://legacy.imagemagick.org/script/install-source.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/install-source.php</a></li><li><a href="https://legacy.imagemagick.org/script/advanced-windows-installation.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/advanced-windows-installation.php</a></li><li><a href="https://legacy.imagemagick.org/script/download.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/download.php</a></li><li><a href="https://legacy.imagemagick.org/script/ImageMagickObject.php" target="_blank" rel="noopener">https://legacy.imagemagick.org/script/ImageMagickObject.php</a></li><li><a href="https://legacy.imagemagick.org/script/ImageMagickObject.php" target="_blank" rel="noopener">http://imagemagick.org/Magick++/</a></li><li><a href="https://www.imagemagick.org/discourse-server/" target="_blank" rel="noopener">https://www.imagemagick.org/discourse-server/</a></li><li><a href="http://dahua2.blog.163.com/blog/static/1748435142015317633489/" target="_blank" rel="noopener">http://dahua2.blog.163.com/blog/static/1748435142015317633489/</a></li><li><a href="http://www.tuicool.com/articles/NvYfi2" target="_blank" rel="noopener">http://www.tuicool.com/articles/NvYfi2</a></li><li><a href="http://www.tuicool.com/articles/6fyI7z" target="_blank" rel="noopener">http://www.tuicool.com/articles/6fyI7z</a></li><li><a href="http://www.tuicool.com/articles/NN3M7fv" target="_blank" rel="noopener">http://www.tuicool.com/articles/NN3M7fv</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unix-源码安装-Windows-源码安装&quot;&gt;&lt;a href=&quot;#Unix-源码安装-Windows-源码安装&quot; class=&quot;headerlink&quot; title=&quot;[ Unix 源码安装 | Windows 源码安装 ]&quot;&gt;&lt;/a&gt;[ Unix 源码安装 | 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="图像" scheme="https://caojingyou.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="ImageMagick" scheme="https://caojingyou.github.io/tags/ImageMagick/"/>
    
  </entry>
  
  <entry>
    <title>C++进程间通信</title>
    <link href="https://caojingyou.github.io/2017/04/01/C++%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2017/04/01/C++进程间通信/</id>
    <published>2017-04-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-进程间通信"><a href="#C-进程间通信" class="headerlink" title="C++进程间通信"></a>C++进程间通信</h1><p>进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽</p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><pre><code>//设置剪切板内容CString str;this-&gt;GetDlgItemText(IDC_EDIT1, str);OpenClipboard();//打开剪贴板查看,并防止其他应用程序修改剪贴板的内容.EmptyClipboard();//EmptyClipboard Function该函数清空剪切板并释放剪切板内数据的句柄。函数在之后会将剪切板的所有权指派给当前打开剪切板的窗口。HANDLE hclip = GlobalAlloc(GMEM_MOVEABLE, str.GetLength() + 1);char *pBuf = (char *)GlobalLock(hclip);//WideCharToMultiByte()//字形转换strcpy(pBuf, str.GetBuffer());//memcpy(pBuf, str.GetBuffer(), GetLength()+2);GlobalLock(hclip);SetClipboardData(CF_TEXT, hclip);//SetClipboardData是把指定数据按照指定格式放入剪切板中CloseClipboard();//关闭剪贴板,这使其他窗口或程序能访问剪贴板。//获得剪切板内容OpenClipboard();if (IsClipboardFormatAvailable(CF_TEXT))//是以NULL结尾的ASCII字符的文本格式,则该函数返回值为true,否则为false。{    HANDLE hclip;    hclip = GetClipboardData(CF_TEXT);//用来打开剪贴板并获取剪贴板内容。    char *pBuf =  (char *)GlobalLock(hclip);    GlobalUnlock(hclip);    CString STR;    SetDlgItemText(IDC_EDIT1, pBuf);}CloseClipboard();//参考：//http://bbs.kechuang.org/t/72605//http://www.cnblogs.com/BoyXiao/archive/2010/12/25/1916677.html</code></pre><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><pre><code>//父进程实现//创建匿名管道SECURITY_ATTRIBUTES sa;sa.bInheritHandle = TRUE;sa.lpSecurityDescriptor = NULL;sa.nLength = sizeof(SECURITY_ATTRIBUTES);if (!CreatePipe(&amp;m_hRead, &amp;m_hWrite, &amp;sa, 0)){    AfxMessageBox(_T(&quot;create pipe error&quot;));}//子进程的创建STARTUPINFO sui;PROCESS_INFORMATION pi;sui.cb = sizeof(STARTUPINFO);ZeroMemory(&amp;sui, sizeof(STARTUPINFO));sui.dwFlags = STARTF_USESTDHANDLES;sui.hStdInput = m_hRead;sui.hStdOutput = m_hWrite;sui.hStdError = GetStdHandle(STD_ERROR_HANDLE);if (!CreateProcess(_T(&quot;../debug/child.exe&quot;), NULL , NULL, NULL, TRUE, 0, NULL, NULL, &amp;sui, &amp;pi )){    AfxMessageBox(_T(&quot;创建子进程错误&quot;));}//关闭进程 线程计数器if (pi.hThread){    CloseHandle(pi.hThread);}if (pi.hProcess){    CloseHandle(pi.hProcess);}//发送数据char buf[] = &quot;this is pipe server&quot;;DWORD dwWrite = 0;if (!WriteFile(m_hWrite, buf, strlen(buf) + 1, &amp;dwWrite, NULL)){    AfxMessageBox(_T(&quot;write error parent&quot;));}//接收数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hRead, buf, sizeof(buf), &amp;dwRead, NULL );//子进程实现//获取继承自父进程的匿名管道读写句柄m_hRead = GetStdHandle(STD_INPUT_HANDLE);m_hWrite = GetStdHandle(STD_OUTPUT_HANDLE);//写入数据char buf[] = &quot;this is pipe child&quot;;DWORD dwWrite = 0;if (!WriteFile(m_hWrite, buf, strlen(buf) + 1, &amp;dwWrite, NULL)){    AfxMessageBox(_T(&quot;write error child&quot;));}//读取数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hRead, buf, sizeof(buf), &amp;dwRead, NULL );//参考http://www.cnblogs.com/BoyXiao/archive/2011/01/01/1923828.html</code></pre><h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><pre><code>//服务端//创建命名管m_hPipe = CreateNamedPipe(_T(&quot;\\\\.\\pipe\\mypipe&quot;), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, /*OVERLAPPED是为了满足异步实现非阻塞的工能，当连接上用事件通知*/                          0, 1, 1024, 1024, 0, NULL);if (m_hPipe == INVALID_HANDLE_VALUE){    return;}//创建事件HANDLE hEvent;hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);if (!hEvent){    MessageBox(_T(&quot;创建事件对象失败！&quot;));    CloseHandle(m_hPipe);    m_hPipe = NULL;    return;}OVERLAPPED ovlap;ZeroMemory(&amp;ovlap, sizeof(OVERLAPPED));ovlap.hEvent = hEvent;if (!ConnectNamedPipe(m_hPipe, &amp;ovlap)){    if (ERROR_IO_PENDING != GetLastError())    {        MessageBox(_T(&quot;等待客户连接失败！&quot;));        CloseHandle(m_hPipe);        CloseHandle(hEvent);        m_hPipe = NULL;        return;    }}//重叠操作if (WAIT_FAILED == WaitForSingleObject(hEvent, INFINITE)){    MessageBox(_T(&quot;等待对象失败！&quot;));    CloseHandle(m_hPipe);    CloseHandle(hEvent);    m_hPipe = NULL;    return;}CloseHandle(hEvent);//写数据char buf[] = &quot;this is named pipe server&quot;;DWORD dwWrite = 0;WriteFile(m_hPipe, buf, strlen(buf) + 1, &amp;dwWrite, NULL);//读数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hPipe, buf, 128, &amp;dwRead, NULL);//客户端//连接命名管道if (!WaitNamedPipe(_T(&quot;\\\\.\\pipe\\mypipe&quot;), NMPWAIT_WAIT_FOREVER)){    return;}m_hPipe = CreateFile(_T(&quot;\\\\.\\pipe\\mypipe&quot;), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//写入数据char buf[] = &quot;this is named pipe client&quot;;DWORD dwWrite = 0;WriteFile(m_hPipe, buf, strlen(buf) + 1, &amp;dwWrite, NULL);//读取数据char buf[128] = {0};DWORD dwRead = 0;ReadFile(m_hPipe, buf, 128, &amp;dwRead, NULL);//参考//http://www.cnblogs.com/BoyXiao/archive/2011/01/02/1924188.html</code></pre><h2 id="邮槽"><a href="#邮槽" class="headerlink" title="邮槽"></a>邮槽</h2><pre><code>//服务端HANDLE hMail = CreateMailslot(_T(&quot;\\\\.\\mailslot\\myslot&quot;), 424, MAILSLOT_WAIT_FOREVER, NULL);if (hMail == INVALID_HANDLE_VALUE){    int nRes = GetLastError();    CString str;    str.Format(_T(&quot;%s&quot;), nRes);    AfxMessageBox(str);    return;}char buf[424] = {0};DWORD dwSize = 0;ReadFile(hMail, buf, 424, &amp;dwSize, NULL);CString str;str = buf;MessageBox(str);//客户端HANDLE hMailslot;hMailslot = CreateFile(_T(&quot;\\\\.\\mailslot\\myslot&quot;), GENERIC_WRITE,                       FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);if (INVALID_HANDLE_VALUE == hMailslot){    MessageBox(_T(&quot;打开邮槽失败！&quot;));    return;}char buf[] = &quot;this is mail slot client&quot;;DWORD dwSize = 0;if (!WriteFile(hMailslot, buf, strlen(buf) + 1, &amp;dwSize, NULL)){    MessageBox(_T(&quot;写入邮槽失败！&quot;));}//http://blog.csdn.net/kylin_p/article/details/5146797//http://www.cnblogs.com/BoyXiao/archive/2010/12/31/1923462.html//http://www.cnblogs.com/jzincnblogs/p/5192654.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-进程间通信&quot;&gt;&lt;a href=&quot;#C-进程间通信&quot; class=&quot;headerlink&quot; title=&quot;C++进程间通信&quot;&gt;&lt;/a&gt;C++进程间通信&lt;/h1&gt;&lt;p&gt;进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽&lt;/p&gt;
&lt;h2 id=&quot;剪切板&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title> C++ 最小化到托盘</title>
    <link href="https://caojingyou.github.io/2017/03/01/C++%20%E6%9C%80%E5%B0%8F%E5%8C%96%E5%88%B0%E6%89%98%E7%9B%98/"/>
    <id>https://caojingyou.github.io/2017/03/01/C++ 最小化到托盘/</id>
    <published>2017-03-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-最小化到托盘"><a href="#C-最小化到托盘" class="headerlink" title="C++ 最小化到托盘"></a>C++ 最小化到托盘</h1><pre><code>#define  WM_SHOWTASK (WM_USER + 1)void CTestDlg::OnSysCommand(UINT nID, LPARAM lParam){    if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)    {        CAboutDlg dlgAbout;        dlgAbout.DoModal();    }    else    {        //增加关闭时最小化到托盘的函数        if (nID == SC_CLOSE) //SC_MINIMIZE        {            ToTray();            return;        }        CDialog::OnSysCommand(nID, lParam);    }}BEGIN_MESSAGE_MAP(CTestDlg, CDialog)    ON_MESSAGE(WM_SHOWTASK, OnShowTask)    //}}AFX_MSG_MAPEND_MESSAGE_MAP()//在托盘区添加图标 最小化到托盘函数void ToTray(void);void CTestDlg::ToTray(void){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条    Shell_NotifyIcon(NIM_ADD, &amp;nid);//在托盘区添加图标    ShowWindow(SW_HIDE);//隐藏主窗口}//恢复界面函数afx_msg LRESULT OnShowTask(WPARAM wParam, LPARAM lParam);//托盘事件LRESULT CTestDlg::OnShowTask(WPARAM wParam, LPARAM lParam){    if (wParam != IDR_MAINFRAME)    {        return 1;    }    switch(lParam)    {    case WM_RBUTTONUP://右键起来时弹出快捷菜单，这里只有一个关闭    {        LPPOINT lpoint = new tagPOINT;        ::GetCursorPos(lpoint);//得到鼠标位置        CMenu menu;        menu.CreatePopupMenu();//声明一个弹出式菜单        //增加菜单项“关闭”，点击则发送消息WM_DESTROY给主窗口（已        //隐藏），将程序结束。        menu.AppendMenu(MF_STRING, WM_DESTROY, _T(&quot;退出&quot;));        //确定弹出式菜单的位置        menu.TrackPopupMenu(TPM_LEFTALIGN, lpoint-&gt;x, lpoint-&gt;y, this);        //资源回收        HMENU hmenu = menu.Detach();        menu.DestroyMenu();        delete lpoint;    }    break;    case WM_LBUTTONDBLCLK://双击左键的处理    {        this-&gt;ShowWindow(SW_SHOW);//简单的显示主窗口        this-&gt;ShowWindow(SW_RESTORE);        DeleteTray();    }    break;    default:        break;    }    return 0;}//删除托盘中图标void DeleteTray();void CTestlDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;    nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}//退出程序需时需要DeleteTray();void CTestDlg::OnDestroy(){    CDialog::OnDestroy();    // TODO: 在此处添加消息处理程序代码    DeleteTray();}//修改风格使得他不在任务栏显示int CTestDlg::OnCreate(LPCREATESTRUCT lpCreateStruct){    if (CDialog::OnCreate(lpCreateStruct) == -1)        return -1;    // TODO:  在此添加您专用的创建代码    //修改风格使得他不在任务栏显示    ModifyStyleEx(WS_EX_APPWINDOW, WS_EX_TOOLWINDOW);    return 0;}</code></pre><p>DeleteTray改为：</p><pre><code>void CTestDlg::DeleteTray(){    NOTIFYICONDATA nid;    nid.cbSize = (DWORD)sizeof(NOTIFYICONDATA);    nid.hWnd = this-&gt;m_hWnd;    nid.uID = IDR_MAINFRAME;    nid.uFlags = NIF_ICON /*| NIF_MESSAGE | NIF_TIP*/;    //nid.uCallbackMessage = WM_SHOWTASK;//自定义的消息名称    //nid.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));    //wcscpy_s(nid.szTip, _T(&quot;***程序&quot;));//信息提示条为“按计划任务提醒”    Shell_NotifyIcon(NIM_DELETE, &amp;nid);//在托盘中删除图标}</code></pre><p>否则会出现程序退出后，托盘图标还在的情况，鼠标移动到图标上后，图标一闪然后消失的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-最小化到托盘&quot;&gt;&lt;a href=&quot;#C-最小化到托盘&quot; class=&quot;headerlink&quot; title=&quot;C++ 最小化到托盘&quot;&gt;&lt;/a&gt;C++ 最小化到托盘&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#define  WM_SHOWTASK (WM_USER + 1)
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中判断某一文件或目录是否存在</title>
    <link href="https://caojingyou.github.io/2017/02/15/C++%E4%B8%AD%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%80%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>https://caojingyou.github.io/2017/02/15/C++中判断某一文件或目录是否存在/</id>
    <published>2017-02-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="ifstream"><a href="#ifstream" class="headerlink" title="ifstream"></a>ifstream</h2><p>在C++中，可以利用ifstream文件输入流，当我们直接使用ifstream来创建文件输入流的时候，如果文件不存在则流创建失败。</p><pre><code>ifstream fin(&quot;hello.txt&quot;);if (!fin){   std::cout &lt;&lt; &quot;can not open this file&quot; &lt;&lt; endl;}</code></pre><h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><pre><code>fstream _file;_file.open(FILENAME,ios::in);if(!_file){ cout&lt;&lt;FILENAME&lt;&lt;&quot;没有被创建&quot;;}else{  cout&lt;&lt;FILENAME&lt;&lt;&quot;已经存在&quot;;}</code></pre><h2 id="taccess"><a href="#taccess" class="headerlink" title="_taccess"></a>_taccess</h2><p>Generic-Text Routine Mappings:</p><pre><code>| TCHAR.H Routine    | _UNICODE &amp; _MBCS Not Defined    | _UNICODE Defined    | _UNICODE Defined    || _taccess            | _access                        | _access            |_waccess            |</code></pre><p>返回值</p><pre><code>mode Value     Checks File For00     Existence only02     Write permission04     Read permission06     Read and write permission</code></pre><p>Example:</p><pre><code>#include  &lt;io.h&gt;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;int main( void ){    // Check for existence.    if( (_access( &quot;crt_ACCESS.C&quot;, 0 )) != -1 )    {        printf_s( &quot;File crt_ACCESS.C exists.\n&quot; );        // Check for write permission.        // Assume file is read-only.        if( (_access( &quot;crt_ACCESS.C&quot;, 2 )) == -1 )            printf_s( &quot;File crt_ACCESS.C does not have write permission.\n&quot; );    }}</code></pre><p><a href="https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22TCHAR%2f_TACCESS%22" target="_blank" rel="noopener">https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22TCHAR%2f_TACCESS%22);k(_TACCESS);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true</a>;k(_TACCESS);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true)</p><h2 id="FindFirstFile"><a href="#FindFirstFile" class="headerlink" title="FindFirstFile"></a>FindFirstFile</h2><pre><code>WIN32_FIND_DATA FindFileData;HANDLE hFind;printf (&quot;Target file is %s. &quot;, argv[1]);hFind = FindFirstFile(strPath.c_str(), &amp;FindFileData);if (hFind == INVALID_HANDLE_VALUE){    printf (&quot;Invalid File Handle. Get Last Error reports %d &quot;, GetLastError ());}else{    printf (&quot;The first file found is %s &quot;, FindFileData.cFileName);    FindClose(hFind);}</code></pre><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="FindFirstFile-1"><a href="#FindFirstFile-1" class="headerlink" title="FindFirstFile"></a>FindFirstFile</h2><pre><code>WIN32_FIND_DATA wfd;bool rValue = false;HANDLE hFind = FindFirstFile(strPath.c_str(), &amp;wfd);if ((hFind != INVALID_HANDLE_VALUE) &amp;&amp; (wfd.dwFileAttributes &amp;FILE_ATTRIBUTE_DIRECTORY)){    std::cout &lt;&lt; &quot;this file exists&quot; &lt;&lt; endl;}FindClose(hFind);</code></pre><h2 id="Tstat"><a href="#Tstat" class="headerlink" title="_Tstat"></a>_Tstat</h2><p>在windows中可以使用_stat() 函数。</p><p>声明：int _stat(const char<em> path, struct _stat</em> buffer);</p><p>这个函数使用起来非常方便，如下：</p><pre><code>struct _stat fileStat;if ((_stat(dir.c_str(), &amp;fileStat) == 0) &amp;&amp; (fileStat.st_mode &amp; _S_IFDIR)){    isExist = true;}</code></pre><p>_S_IFDIR 是一个标志位，如果是目录的话，该位就会被系统设置。</p><p>在linux底下也有相对应的函数stat();</p><p>使用方法基本相同：</p><pre><code>struct stat fileStat;if ((stat(dir.c_str(), &amp;fileStat) == 0) &amp;&amp; S_ISDIR(fileStat.st_mode)){    isExist = true;}</code></pre><p>唯一不同的地方我使用了一个macro， S_ISDIR来判断文件是否存在，原理实际都一样的。</p><p><a href="https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22WCHAR%2f_STAT%22" target="_blank" rel="noopener">https://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=ZH-CN&amp;k=k(%22WCHAR%2f_STAT%22);k(_STAT);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true</a>;k(_STAT);k(DevLang-%22C%2B%2B%22);k(TargetOS-WINDOWS)&amp;rd=true)</p><h2 id="boost的filesystem类库的exists函数"><a href="#boost的filesystem类库的exists函数" class="headerlink" title="boost的filesystem类库的exists函数"></a>boost的filesystem类库的exists函数</h2><pre><code>#include &lt;boost/filesystem/operations.hpp&gt;#include &lt;boost/filesystem/path.hpp&gt;#include &lt;boost/filesystem/convenience.hpp&gt;int GetFilePath(std::string &amp;strFilePath){    string strPath;    int nRes = 0;    //指定路径    strPath = &quot;D:/myTest/Test1/Test2&quot;;    namespace fs = boost::filesystem;    //路径的可移植    fs::path full_path( fs::initial_path() );    full_path = fs::system_complete( fs::path(strPath, fs::native ) );    //判断各级子目录是否存在，不存在则需要创建    if ( !fs::exists( full_path ) )    {        // 创建多层子目录        bool bRet = fs::create_directories(full_path);        if (false == bRet)        {            return -1;        }    }    strFilePath = full_path.native_directory_string();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h1&gt;&lt;h2 id=&quot;ifstream&quot;&gt;&lt;a href=&quot;#ifstream&quot; class=&quot;headerlink&quot; title=&quot;ifstream&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="文件" scheme="https://caojingyou.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C# 系统托盘图标</title>
    <link href="https://caojingyou.github.io/2017/02/01/CShap%20%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87/"/>
    <id>https://caojingyou.github.io/2017/02/01/CShap 系统托盘图标/</id>
    <published>2017-02-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-系统托盘图标"><a href="#C-系统托盘图标" class="headerlink" title="C# 系统托盘图标"></a>C# 系统托盘图标</h1><h2 id="WPF-NotifyIcon-资料"><a href="#WPF-NotifyIcon-资料" class="headerlink" title="WPF NotifyIcon 资料"></a>WPF NotifyIcon 资料</h2><h3 id="网址："><a href="#网址：" class="headerlink" title="网址："></a>网址：</h3><p><a href="http://www.codeproject.com/Articles/36468/WPF-NotifyIcon" target="_blank" rel="noopener">http://www.codeproject.com/Articles/36468/WPF-NotifyIcon</a></p><p><a href="http://www.hardcodet.net/" target="_blank" rel="noopener">http://www.hardcodet.net/</a></p><p><a href="https://bitbucket.org/hardcodet/notifyicon-wpf/src" target="_blank" rel="noopener">https://bitbucket.org/hardcodet/notifyicon-wpf/src</a></p><p><a href="https://www.nuget.org/packages/Hardcodet.NotifyIcon.Wpf/" target="_blank" rel="noopener">https://www.nuget.org/packages/Hardcodet.NotifyIcon.Wpf/</a></p><h3 id="NuGet"><a href="#NuGet" class="headerlink" title="NuGet:"></a>NuGet:</h3><pre><code>Install-Package Hardcodet.NotifyIcon.Wpf</code></pre><h3 id="NuGet下载的Package："><a href="#NuGet下载的Package：" class="headerlink" title="NuGet下载的Package："></a>NuGet下载的Package：</h3><p><a href="http://files.cnblogs.com/files/yhcao/Hardcodet.NotifyIcon.Wpf.1.0.8.rar" target="_blank" rel="noopener">Hardcodet.NotifyIcon.Wpf.1.0.8.rar</a></p><h2 id="WPF-NotifyIcon-使用"><a href="#WPF-NotifyIcon-使用" class="headerlink" title="WPF NotifyIcon 使用"></a>WPF NotifyIcon 使用</h2><p>在MainWindow.xaml<window>添加</window></p><pre><code>xmlns:tb=&quot;http://www.hardcodet.net/taskbar&quot;</code></pre><p>在MainWindow.xaml的 <grid\> 修改中添加</grid\></p><pre><code>&lt;tb:TaskbarIcon Name=&quot;MyNotifyIcon&quot;  IconSource=&quot;Founder.ico&quot;&lt;!--托盘显示图标--&gt;  ToolTipText=&quot;Founder 启动本地程序&quot;&gt;&lt;!--鼠标移动到托盘图标显示的文字--&gt;  &lt;tb:TaskbarIcon.ContextMenu&gt;&lt;!--添加菜单--&gt;    &lt;ContextMenu&gt;      &lt;MenuItem Header=&quot;显示&quot; ToolTip=&quot;显示主界面&quot; Click=&quot;MenuItem_Click_Show&quot; /&gt;      &lt;MenuItem Header=&quot;退出&quot; ToolTip=&quot;退出程序&quot; Click=&quot;MenuItem_Click_Close&quot; /&gt;    &lt;/ContextMenu&gt;  &lt;/tb:TaskbarIcon.ContextMenu&gt;&lt;/tb:TaskbarIcon&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-系统托盘图标&quot;&gt;&lt;a href=&quot;#C-系统托盘图标&quot; class=&quot;headerlink&quot; title=&quot;C# 系统托盘图标&quot;&gt;&lt;/a&gt;C# 系统托盘图标&lt;/h1&gt;&lt;h2 id=&quot;WPF-NotifyIcon-资料&quot;&gt;&lt;a href=&quot;#WPF-Notify
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="系统托盘" scheme="https://caojingyou.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>C#与C++相互发送消息</title>
    <link href="https://caojingyou.github.io/2017/02/01/CShap%E4%B8%8EC++%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2017/02/01/CShap与C++通信/</id>
    <published>2017-02-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-与C-相互发送消息"><a href="#C-与C-相互发送消息" class="headerlink" title="C#与C++相互发送消息"></a>C#与C++相互发送消息</h1><h2 id="C-端："><a href="#C-端：" class="headerlink" title="C#端："></a>C#端：</h2><pre><code>namespace CshapMessage{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        IntPtr hwnd;        const int WM_COPYDATA = 0x004A;        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        [DllImport(&quot;User32.dll&quot;)]        public static extern int SendMessage(int hwnd, int msg, int wParam, ref COPYDATASTRUCT IParam);        [DllImport(&quot;User32.dll&quot;)]        public static extern int FindWindow(string lpClassName, string lpWindowName);        public MainWindow()        {            InitializeComponent();            this.Title = &quot;CshapMessage&quot;;            this.Loaded += MainWindow_Loaded;            this.Closed += MainWindow_Closed;        }        private void MainWindow_Closed(object sender, EventArgs e)        {            try            {                HwndSource.FromHwnd(hwnd).RemoveHook(WndProc);            }            catch (Exception) { }        }        private void MainWindow_Loaded(object sender, RoutedEventArgs e)        {            hwnd = new WindowInteropHelper(this).Handle;            HwndSource.FromHwnd(hwnd).AddHook(new HwndSourceHook(WndProc));        }        /// &lt;summary&gt;        /// 向C++程序 CshapMessage发送消息        /// &lt;/summary&gt;        /// &lt;param name=&quot;nMessgeId&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;strSend&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        private bool CshapSendMessage(int nMessgeId, String strSend)        {            int WINDOW_HANDLE = FindWindow(null, &quot;VcMessage&quot;);//VcMessage为向C++程序发送的窗口名称            if (WINDOW_HANDLE != 0)            {                COPYDATASTRUCT cdata;                cdata.dwData = (IntPtr)100;//这里可以传入一些自定义的数据，但只能是4字节整数                 cdata.lpData = strSend;//消息字符串                cdata.cData = System.Text.Encoding.Default.GetBytes(strSend).Length+1;//注意，这里的长度是按字节来算的                SendMessage(WINDOW_HANDLE, WM_COPYDATA, 0, ref cdata);            }            else            {                return false;            }            return true;        }        private void button_Click(object sender, RoutedEventArgs e)        {            String strSend = &quot;C#发送的信息&quot;;            int nMessageId = 100;            if (CshapSendMessage(nMessageId,strSend))            {                MessageBox.Show(&quot;发送消息成功&quot;);            }            else            {                MessageBox.Show(&quot;消息发送失败，请打开VcMessage程序&quot;);            }        }        //接收消息。        private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)        {            if (msg == WM_COPYDATA)            {                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)Marshal.PtrToStructure(lParam, mytype);                switch (cdata.dwData.ToInt32())                {                    case 1:                        {                            string strRecv = cdata.lpData;                            break;                        }                    default:                        break;                }            }            return IntPtr.Zero;        }    }}</code></pre><h2 id="C-端：-1"><a href="#C-端：-1" class="headerlink" title="C++端："></a>C++端：</h2><pre><code>BOOL CVcMessageDlg::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct){    // TODO: 在此添加消息处理程序代码和/或调用默认值    //接收C#发送来的数据    switch (pCopyDataStruct-&gt;dwData)    {    case 100:    {        CStringA strRecv = (char*)pCopyDataStruct-&gt;lpData;        break;    }    default:    {        break;    }    }    return CDialogEx::OnCopyData(pWnd, pCopyDataStruct);}void CVcMessageDlg::OnBnClickedButton1(){    // TODO: 在此添加控件通知处理程序代码    CStringA strSend = &quot;VC发送的数据&quot;;    if (VCSendMessage(1,strSend))    {        AfxMessageBox(_T(&quot;消息发送成功&quot;));    }     else    {        AfxMessageBox(_T(&quot;消息发送失败&quot;));    }}//************************************// Method:    VCSendMessage// FullName:  CVcMessageDlg::VCSendMessage// Access:    public // Returns:   BOOL// Qualifier: 向C#程序 CshapMessage发送消息// Parameter: int nMessgeId// Parameter: CStringA strSend//************************************BOOL CVcMessageDlg::VCSendMessage(int nMessgeId,CStringA strSend){    HWND hSendWindow = this-&gt;m_hWnd;    if (hSendWindow == NULL)    {        return FALSE;    }    CWnd *phwnd = FindWindow(NULL, _T(&quot;CshapMessage&quot;));    HWND hRecvWindow = NULL;    if (phwnd == NULL)    {        return FALSE;    }    hRecvWindow = phwnd-&gt;GetSafeHwnd();    if (hRecvWindow == NULL)    {        return FALSE;    }    COPYDATASTRUCT CopyData;    CopyData.dwData = nMessgeId;    CopyData.cbData = strSend.GetLength()+1;    CopyData.lpData = (PVOID)strSend.GetBuffer(CopyData.cbData);    ::SendMessage(hRecvWindow, WM_COPYDATA, (WPARAM)hSendWindow, (LPARAM)&amp;CopyData);    return TRUE;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-与C-相互发送消息&quot;&gt;&lt;a href=&quot;#C-与C-相互发送消息&quot; class=&quot;headerlink&quot; title=&quot;C#与C++相互发送消息&quot;&gt;&lt;/a&gt;C#与C++相互发送消息&lt;/h1&gt;&lt;h2 id=&quot;C-端：&quot;&gt;&lt;a href=&quot;#C-端：&quot; class
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>钩子</title>
    <link href="https://caojingyou.github.io/2017/01/15/%E9%92%A9%E5%AD%90/"/>
    <id>https://caojingyou.github.io/2017/01/15/钩子/</id>
    <published>2017-01-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程内钩子"><a href="#进程内钩子" class="headerlink" title="进程内钩子"></a>进程内钩子</h1><pre><code>//进程内钩子//鼠标钩子过程函数HHOOK g_hHookDm = NULL;HWND g_DestWndH = NULL;LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam){    //此区间内的消息都是鼠标消息    if (WM_MOUSEMOVE &lt;= wParam &amp;&amp; wParam &lt;= WM_MOUSEWHEEL)    {        if (g_DestWndH != NULL)        {            ::SendMessage(g_DestWndH, wParam, wParam, lParam);            //鼠标钩子,lParam是MOUSEHOOKSTRUCT结构指针            PMOUSEHOOKSTRUCT lpMsg = (PMOUSEHOOKSTRUCT)lParam;            lpMsg-&gt;hwnd = NULL;            lpMsg-&gt;dwExtraInfo = 0L;            lpMsg-&gt;pt = CPoint(0, 0);            lpMsg-&gt;wHitTestCode = 0L;        }        return 1;//如果不想让此消息再往下传，返回非0    }    else    {        return ::CallNextHookEx(g_hHookDm, nCode, wParam, lParam);    }}//创建钩子过程if (g_hHookDm == NULL){    //如果dwThreadid指定的线程是由当前进程创建，并且钩子过程在当时进程中，那么hMod必须设置为NULL.    g_hHookDm = ::SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId());    if (g_hHookDm != NULL)    {        g_DestWndH = m_hWnd;//保存目的窗口句柄    }}//消毁进程内钩子if (g_hHookDm != NULL){    UnhookWindowsHookEx(g_hHookDm);    g_DestWndH = NULL;}全局钩子-MFC扩展DLL/新建一个CMouseHook的导出类#pragma once// CMouseHook 命令目标//.hclass AFX_EXT_CLASS CMouseHook : public CObject    //AFX_EXT_CLASS宏声明类为导出类{public:    CMouseHook();    virtual ~CMouseHook();public:    BOOL StartHook(HWND hWnd); //安装钩子函数    BOOL StopHook();//卸载钩子函数};//.cpp#include &lt;afxwin.h&gt;#include &lt;afxdllx.h&gt;#ifdef _DEBUG#define new DEBUG_NEW#endif#define  WM_TOTASK (WM_USER + 2)#pragma data_seg(&quot;SharedDataName&quot;)HHOOK g_mouseHook;HHOOK g_keyboardHook;HWND g_hwnd = NULL;HINSTANCE glhInstance = NULL; //DLL实例句柄#pragma data_seg()#pragma comment(linker,&quot;/section:.SharedDataName,rws&quot;)static AFX_EXTENSION_MODULE MyMouseHookDLL = { NULL, NULL };extern &quot;C&quot; int APIENTRYDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved){    // 如果使用 lpReserved，请将此移除    UNREFERENCED_PARAMETER(lpReserved);    if (dwReason == DLL_PROCESS_ATTACH)    {        TRACE0(&quot;MyMouseHook.DLL 正在初始化!\n&quot;);        // 扩展 DLL 一次性初始化        if (!AfxInitExtensionModule(MyMouseHookDLL, hInstance))            return 0;        // 将此 DLL 插入到资源链中        // 注意: 如果此扩展 DLL 由        //  MFC 规则 DLL (如 ActiveX 控件)隐式链接到，        //  而不是由 MFC 应用程序链接到，则需要        //  将此行从 DllMain 中移除并将其放置在一个        //  从此扩展 DLL 导出的单独的函数中。使用此扩展 DLL 的        //  规则 DLL 然后应显式        //  调用该函数以初始化此扩展 DLL。否则，        //  CDynLinkLibrary 对象不会附加到        //  规则 DLL 的资源链，并将导致严重的        //  问题。        new CDynLinkLibrary(MyMouseHookDLL);        glhInstance = hInstance; //插入保存DLL    }    else if (dwReason == DLL_PROCESS_DETACH)    {        TRACE0(&quot;MyMouseHook.DLL 正在终止!\n&quot;);        // 在调用析构函数之前终止该库        AfxTermExtensionModule(MyMouseHookDLL);    }    return 1;   // 确定}LRESULT CALLBACK MouseProc(    int nCode,      // hook code    WPARAM wParam,  // message identifier    LPARAM lParam   // mouse coordinates) //鼠标钩子过程{    LPMOUSEHOOKSTRUCT pMouseHook = (MOUSEHOOKSTRUCT FAR *)lParam;    if (nCode &gt;= 0)    {        if (WM_LBUTTONDOWN == wParam)        {            //鼠标钩子,lParam是MOUSEHOOKSTRUCT结构指针            PMOUSEHOOKSTRUCT lpMsg = (PMOUSEHOOKSTRUCT)lParam;            CPoint point = lpMsg-&gt;pt;            RECT rect;            ::GetWindowRect(g_hwnd, &amp;rect);    //得到整个窗口在屏幕上的矩形框位置            if ((point.x &lt; rect.left || point.x &gt; rect.right) || (point.y &lt; rect.top || point.y &gt; rect.bottom))            {                ::SendMessage(g_hwnd, WM_SYSCOMMAND, WM_TOTASK, 0);            }        }    }    return CallNextHookEx(g_mouseHook, nCode, wParam, lParam);}LRESULT CALLBACK KeyboardProc(    int code,       // hook code    WPARAM wParam,  // virtual-key code    LPARAM lParam   // keystroke-message information)//键盘钩子过程{    if(VK_F2 == wParam)    {        ::SendMessage(g_hwnd, WM_CLOSE, 0, 0);        ::UnhookWindowsHookEx(g_mouseHook);        ::UnhookWindowsHookEx(g_keyboardHook);    }    else        return 1;}//安装钩子并设定接收显示窗口句柄BOOL CMouseHook::StartHook(HWND hWnd){    BOOL bResult = FALSE;    g_hwnd = hWnd;    g_mouseHook =::SetWindowsHookEx(WH_MOUSE, MouseProc, glhInstance/*::GetModuleHandle(_T(&quot;MyMouseHook.dll&quot;))*/, 0);    g_keyboardHook =::SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, ::GetModuleHandle(_T(&quot;MyMouseHook.dll&quot;)), 0);    /*=================================================================================    HHOOK SetWindowsHookEx( int idHook,HOOKPROC lpfn, INSTANCE hMod,DWORD dwThreadId )    　　参数idHook表示钩子类型，它是和钩子函数类型一一对应的。    比如，WH_KEYBOARD表示安装的是键盘钩子，WH_MOUSE表示是鼠标钩子等等。    　　Lpfn是钩子函数的地址。    　　HMod是钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；    对于系统钩子，该参数为钩子函数所在的DLL句柄。    　　dwThreadId 指定钩子所监视的线程的线程号。对于全局钩子，该参数为NULL。    　　SetWindowsHookEx返回所安装的钩子句柄。    值得注意的是线程钩子和系统钩子的钩子函数的位置有很大的差别。    线程钩子一般在当前线程或者当前线程派生的线程内，    而系统钩子必须放在独立的动态链接库中，实现起来要麻烦一些。    ==================================================================================*/    if(g_mouseHook != NULL)        bResult = TRUE;    if(g_keyboardHook != NULL)        bResult = TRUE;    //设置显示目标窗口标题编辑框的句柄    return bResult;}//卸载钩子BOOL CMouseHook::StopHook(){    BOOL bResult = FALSE;    if(g_mouseHook)    {        bResult = UnhookWindowsHookEx(g_mouseHook);        if(bResult)        {            g_mouseHook = NULL;        }    }    if(g_keyboardHook)    {        bResult = UnhookWindowsHookEx(g_keyboardHook);        if(bResult)        {            g_keyboardHook = NULL;        }    }    return bResult;}</code></pre><h1 id="全局钩子-WIN32-DLL"><a href="#全局钩子-WIN32-DLL" class="headerlink" title="全局钩子-WIN32  DLL"></a>全局钩子-WIN32  DLL</h1><pre><code>#pragma data_seg(&quot;MySec&quot;)HHOOK g_mouseHook;HHOOK g_keyboardHook;HWND g_hwnd = NULL;#pragma data_seg()#pragma comment(linker,&quot;/section:MySec,RWS&quot;)   //设置链接器，使MySec节拥有属性为 RWS (READ WRITE SHARED )LRESULT CALLBACK MouseProc(    int nCode,      // hook code    WPARAM wParam,  // message identifier    LPARAM lParam   // mouse coordinates) //鼠标钩子过程{    return 1;}LRESULT CALLBACK KeyboardProc(    int code,       // hook code    WPARAM wParam,  // virtual-key code    LPARAM lParam   // keystroke-message information)//键盘钩子过程{    if(VK_F2 == wParam)    {        ::SendMessage(g_hwnd, WM_CLOSE, 0, 0);        ::UnhookWindowsHookEx(g_mouseHook);        ::UnhookWindowsHookEx(g_keyboardHook);    }    else        return 1;}void SetHook(HWND hwnd){    g_hwnd = hwnd;    g_mouseHook =::SetWindowsHookEx(WH_MOUSE, MouseProc, ::GetModuleHandle(_T(&quot;dll_hook.dll&quot;)), 0);    g_keyboardHook =::SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, ::GetModuleHandle(_T(&quot;dll_hook.dll&quot;)), 0);}//之后我们添加def文件//或者在def(模块定义文件中 )LIBRARY    &quot;Hook&quot;EXPORTSSetHook @2SECTIONSMySec   READ WRITE SHARED//编译下，编译通过之后可以看到 hook_dll.dll  和  hook_dll.lib文件。//接着我们写一个测试程序，新建MFC工程 选择对话框程序.拷贝hook_dll.dll  和  hook_dll.lib到工程目录下，在链接器命令行加上  hook_dll.lib.//在OnInitDialog()函数之前 定义DLL函数：_declspec(dllimport) void SetHook(HWND hwnd);//在OnInitDialog()内添加SetHook(this-&gt;m_hWnd);</code></pre><p> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程内钩子&quot;&gt;&lt;a href=&quot;#进程内钩子&quot; class=&quot;headerlink&quot; title=&quot;进程内钩子&quot;&gt;&lt;/a&gt;进程内钩子&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//进程内钩子

//鼠标钩子过程函数
HHOOK g_hHookDm = NULL;
HWND g
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="代码" scheme="https://caojingyou.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="钩子" scheme="https://caojingyou.github.io/tags/%E9%92%A9%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>C++获取外部exe程序的返回值，判断图片颜色模式</title>
    <link href="https://caojingyou.github.io/2017/01/13/C++%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8exe%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F/"/>
    <id>https://caojingyou.github.io/2017/01/13/C++获取外部exe程序的返回值，判断图片颜色模式/</id>
    <published>2017-01-13T09:23:00.000Z</published>
    <updated>2018-07-18T02:04:44.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-获取外部exe程序的返回值"><a href="#C-获取外部exe程序的返回值" class="headerlink" title="C++获取外部exe程序的返回值"></a>C++获取外部exe程序的返回值</h1><pre><code>#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;iostream&gt;using namespace std;int _tmain(int argc, _TCHAR *argv[]){    STARTUPINFOA si;    PROCESS_INFORMATION pi;    ZeroMemory(&amp;pi,   sizeof(pi));    ZeroMemory(&amp;si,   sizeof(si));    si.cb = sizeof(STARTUPINFOA);    TCHAR cmd[256] = _T(&quot;D:\\7za.exe a D:\\nv1.zip D:\\test\\*.*&quot;);    BOOL working = ::CreateProcess(NULL, cmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS , NULL, NULL, &amp;si, &amp;pi);    if (working == 0)    {        DWORD error = GetLastError();        cout &lt;&lt; &quot;CreateProcess Error : &quot; &lt;&lt; error &lt;&lt; endl;        getchar();        return 0;    }    WaitForSingleObject(pi.hProcess, INFINITE);    unsigned long Result;    GetExitCodeProcess(pi.hProcess, &amp;Result);    cout &lt;&lt; &quot;Exit Code : &quot; &lt;&lt; Result &lt;&lt; endl;    getchar();    return 0;}</code></pre><h1 id="调用命令行程序并获取返回信息"><a href="#调用命令行程序并获取返回信息" class="headerlink" title="调用命令行程序并获取返回信息"></a>调用命令行程序并获取返回信息</h1><pre><code>CString ExeCmd(CString pszCmd){    //创建匿名管道    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};    HANDLE hRead, hWrite;    if (!CreatePipe(&amp;hRead, &amp;hWrite, &amp;sa, 0))    {        return _T(&quot;&quot;);    }    //设置命令行进程启动信息(以隐藏方式启动命令并定位其输出到hWrite)    STARTUPINFO si = {sizeof(STARTUPINFO)};    GetStartupInfo(&amp;si);    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;    si.wShowWindow = SW_HIDE;    si.hStdError = hWrite;    si.hStdOutput = hWrite;    //启动命令行    PROCESS_INFORMATION pi;    if (!CreateProcess(NULL, (LPWSTR)(LPCWSTR)pszCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &amp;si, &amp;pi))    {        return _T(&quot;&quot;);    }    //立即关闭hWrite    CloseHandle(hWrite);    //读取命令行返回值    char buff[1024] = {0};    DWORD dwRead = 0;    while (ReadFile(hRead, buff, 1024, &amp;dwRead, NULL))    {    }    CString strRet(buff);    CloseHandle(hRead);    return strRet;}</code></pre><p>使用：</p><pre><code>ExeCmd(_T(&quot;ping baidu.com&quot;));ExeCmd(_T(&quot;identify -format &quot;%[colorspace]&quot; E:\\P70306-163226.jpg&quot;));</code></pre><h1 id="其他参考："><a href="#其他参考：" class="headerlink" title="其他参考："></a>其他参考：</h1><pre><code>BOOL    Start(LPCTSTR lpszTaskInfo){    if (!lpszTaskInfo)    {        return FALSE;    }    if (m_hRenderProcess)    {        if (Wait(0))        {            m_nProgress = 0;            SAFE_CLOSE_HANDLE(m_hRenderProcess);            m_dwRenderThreadId = 0;        }        else        {            return FALSE;        }    }    BOOL bRet = FALSE;    HANDLE hDebugInfo = NULL;    do    {        TCHAR szDebugLog[MAX_PATH];        _tcscpy(szDebugLog, m_szFastRenderExPath);        _tcscat(szDebugLog, _T(&quot;.debug&quot;));        SECURITY_ATTRIBUTES sa;        sa.nLength = sizeof(sa);        sa.lpSecurityDescriptor = NULL;        sa.bInheritHandle = TRUE;        hDebugInfo = CreateFile(szDebugLog, FILE_WRITE_DATA, FILE_SHARE_READ, &amp;sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);        STARTUPINFO si;        PROCESS_INFORMATION pi;        ZeroMemory( &amp;si, sizeof(si) );        si.cb = sizeof(si);        ZeroMemory( &amp;pi, sizeof(pi) );        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;        si.hStdInput = NULL;        si.hStdOutput = hDebugInfo;        si.hStdError = hDebugInfo;        si.wShowWindow = SW_HIDE;        TCHAR szCmdline[MAX_PATH * 2];        _sntprintf(szCmdline, ARRAYSIZE(szCmdline), _T(&quot; -i \&quot;%s\&quot;&quot;), lpszTaskInfo); // 第一个空格非常重要        // Start the child process.        if( !CreateProcess( m_szFastRenderExPath,   // Module name                            szCmdline,      // Command line                            NULL,           // Process handle not inheritable                            NULL,           // Thread handle not inheritable                            TRUE,          // Set handle inheritance to FALSE                            0,              // No creation flags                            NULL,           // Use parent&apos;s environment block                            NULL,           // Use parent&apos;s starting directory                            &amp;si,            // Pointer to STARTUPINFO structure                            &amp;pi )           // Pointer to PROCESS_INFORMATION structure          )        {            break;        }        // Close process and thread handles.        m_hRenderProcess = pi.hProcess;        CloseHandle( pi.hThread );        m_dwRenderThreadId = pi.dwThreadId;        // Start the message receive thread        if (!m_dwReceiveThreadId)        {            HANDLE hThread = (HANDLE) _beginthreadex(NULL,    0, ThreadFn, this, 0, &amp;m_dwReceiveThreadId);            if (hThread == NULL)            {                break;            }            CloseHandle(hThread);        }        if (!m_hMsgEvent)        {            m_hMsgEvent = CreateEvent(NULL, FALSE, FALSE, NULL);        }        else        {            ResetEvent(m_hMsgEvent);        }        bRet = TRUE;    }    while (FALSE);    SAFE_CLOSE_HANDLE(hDebugInfo);    if (!bRet)    {        if (m_hRenderProcess)        {            TerminateProcess(m_hRenderProcess, -1);            SAFE_CLOSE_HANDLE(m_hRenderProcess);        }        m_dwRenderThreadId = 0;        SAFE_CLOSE_HANDLE(m_hMsgEvent);    }    return bRet;}</code></pre><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://blog.csdn.net/lgh1700/article/details/7713500" title="http://blog.csdn.net/lgh1700/article/details/7713500" target="_blank" rel="noopener">C++获取外部exe程序的返回值 </a></li><li><a href="http://www.cnblogs.com/acloud/archive/2012/08/30/2663395.html" target="_blank" rel="noopener">调用命令行程序并获取返回信息</a></li><li><a href="http://dahua2.blog.163.com/blog/static/1748435142015317633489/" target="_blank" rel="noopener">ImageMagick–identify详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-获取外部exe程序的返回值&quot;&gt;&lt;a href=&quot;#C-获取外部exe程序的返回值&quot; class=&quot;headerlink&quot; title=&quot;C++获取外部exe程序的返回值&quot;&gt;&lt;/a&gt;C++获取外部exe程序的返回值&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#include
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="运行外部程序" scheme="https://caojingyou.github.io/tags/%E8%BF%90%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="C/C++" scheme="https://caojingyou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C#运行外部程序的两种方法</title>
    <link href="https://caojingyou.github.io/2017/01/01/CShap%20ShellExcute%E4%B8%8EProcess/"/>
    <id>https://caojingyou.github.io/2017/01/01/CShap ShellExcute与Process/</id>
    <published>2017-01-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-运行外部程序的两种方法"><a href="#C-运行外部程序的两种方法" class="headerlink" title="C#运行外部程序的两种方法"></a>C#运行外部程序的两种方法</h1><h2 id="ShellExecute"><a href="#ShellExecute" class="headerlink" title="ShellExecute"></a>ShellExecute</h2><pre><code>using System.Runtime.InteropServices;public enum ShowWindowCommands : int{    SW_HIDE = 0,    SW_SHOWNORMAL = 1,    //用最近的大小和位置显示，激活    SW_NORMAL = 1,    SW_SHOWMINIMIZED = 2,    SW_SHOWMAXIMIZED = 3,    SW_MAXIMIZE = 3,    SW_SHOWNOACTIVATE = 4,    SW_SHOW = 5,    SW_MINIMIZE = 6,    SW_SHOWMINNOACTIVE = 7,    SW_SHOWNA = 8,    SW_RESTORE = 9,    SW_SHOWDEFAULT = 10,    SW_MAX = 10}[DllImport(&quot;shell32.dll&quot;)]public static extern IntPtr ShellExecute(    IntPtr hwnd,    string lpszOp,    string lpszFile,    string lpszParams,    string lpszDir,    ShowWindowCommands FsShowCmd);</code></pre><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code>ShellExecute(IntPtr.Zero, &quot;open&quot;, UrlOrPath, null, null, ShowWindowCommands.SW_SHOWNORMAL);</code></pre><p>UrlOrPath可为exe路径或者网页url(使用默认浏览器打开网页url)</p><p>使用ie打开网页url</p><pre><code>ShellExecute(NULL, &quot;open&quot;, &quot;IEXPLORE&quot;, &quot;http://www.csdn.net&quot;, NULL, SW_SHOWMAXIMIZED);</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre><code>using System.Diagnostics;private static string Execute(string exePath, string parameters){    string result = String.Empty;    using (Process p = new Process())    {        p.StartInfo.UseShellExecute = false;        p.StartInfo.CreateNoWindow = true;        p.StartInfo.RedirectStandardOutput = true;        p.StartInfo.FileName = exePath;        p.StartInfo.Arguments = parameters;        p.Start();        p.WaitForExit();        result = p.StandardOutput.ReadToEnd();    }    return result;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-运行外部程序的两种方法&quot;&gt;&lt;a href=&quot;#C-运行外部程序的两种方法&quot; class=&quot;headerlink&quot; title=&quot;C#运行外部程序的两种方法&quot;&gt;&lt;/a&gt;C#运行外部程序的两种方法&lt;/h1&gt;&lt;h2 id=&quot;ShellExecute&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="运行外部程序" scheme="https://caojingyou.github.io/tags/%E8%BF%90%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>制作CAB包</title>
    <link href="https://caojingyou.github.io/2016/12/15/%E5%88%B6%E4%BD%9CCAB%E5%8C%85/"/>
    <id>https://caojingyou.github.io/2016/12/15/制作CAB包/</id>
    <published>2016-12-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="制作CAB包"><a href="#制作CAB包" class="headerlink" title="制作CAB包"></a>制作CAB包</h1><h2 id="inf文件"><a href="#inf文件" class="headerlink" title="inf文件"></a>inf文件</h2><p>INF是Device INFormation File的英文缩写，是Microsoft公司为硬件设备制造商发布其驱动程序推出的一种文件格式，INF文件中包含硬件设备的信息或脚本以控制硬件操作。在INF文件中指明了硬件驱动该如何安装到系统中，源文件在哪里、安装到哪一个文件夹中、怎样在注册表中加入自身相关信息等等。</p><h3 id="给硬盘（U盘）DIY一个可爱的图标"><a href="#给硬盘（U盘）DIY一个可爱的图标" class="headerlink" title="给硬盘（U盘）DIY一个可爱的图标"></a>给硬盘（U盘）DIY一个可爱的图标</h3><p>接着打开记事本程序，录入以下内容：</p><pre><code>[autorun]ICON=******.ICO</code></pre><p>其中“<strong>**</strong>”是图标文件的路径及图标文件名，请自行修改为具体的图标文件的路径及图标文件名。录入完毕，另存为“Autorun.inf”,并将其剪切到某一个你欲扮酷的分区的根目录下。</p><h3 id="在命令行下安装INF文件"><a href="#在命令行下安装INF文件" class="headerlink" title="在命令行下安装INF文件"></a>在命令行下安装INF文件</h3><p>通常情况下，我们都是在Windows环境下安装INF文件的，但是假如有一天，你需要在命令行运行INF文件该怎么办呢？</p><p>在命令行提示符后输入“ rundll32 syssetup,SetupInfObjectInstallAction DefaultInstall 128 INF文件所在的路径及文件名.inf ”，回车后即可安装相应的INF文件。</p><p>[pre]再提供两个方法：</p><p>　　方法1. 运行RunDll32 advpack.dll,LaunchINFSection YOUINF.inf,DefaultInstall</p><p>　　方法2.修复右键安装</p><p>　　操作步骤如下：</p><p>　　打开我的电脑，“工具”菜单中的“文件夹选项”。切换至“文件类型”选项卡，在其中找到inf文件，点高级按钮，双击“安装”(如没有“安装”就添加一个)，按如下内容修改</p><p>　　用于执行操作的应用程序:</p><p>　　C:\WINDOWS\System32\rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 %1</p><p>　　点选使用DDE(U)</p><p>　　应用程序(C):</p><p>　　setupapi</p><p>　　主题(T):</p><p>　　System</p><p>　　确认！</p><p>　　然后再次右键点选inf文件安装。</p><h3 id="编写inf文件"><a href="#编写inf文件" class="headerlink" title="编写inf文件"></a>编写inf文件</h3><pre><code>; Sample INF file for IMES.DLL;分号后为注释[version] ; version signature (same for both NT and Win95) do not remove;在该节中如果出现“signature=&quot;$CHICAGO$&quot;”这样的条目则表示该INF文件适用于Windows 98之后的所有操作系统，如果包含“signature=&quot;$Windows NT$&quot;”这样的条目则表示该INF文件适用于Windows 2000/XP/2003操作系统，而且两者必具其一signature=&quot;$CHICAGO$&quot;AdvancedINF=2.0  [Add.Code]Editor.ocx = Editor.ocx; needed DLL[Editor.ocx]file=thiscabclsid={8BB4EE5B-5919-11D1-A01A-0060971932BC}RegisterServer=yesFileVersion=5,0,1,7; end of INF file</code></pre><h2 id="将ActiveX控件进行打包并加数据鉴名的工具集："><a href="#将ActiveX控件进行打包并加数据鉴名的工具集：" class="headerlink" title="将ActiveX控件进行打包并加数据鉴名的工具集："></a>将ActiveX控件进行打包并加数据鉴名的工具集：</h2><ul><li>Cabarc.exe 将ocx打包成cab</li><li>Cert2spc.exe 将cer格式证书转换成spc格式证书， 即PKCS#7证书</li><li>Certmgr.exe 是管理证书用的</li><li>Chktrust.exe 检查签署证书后的ocx是否正确</li><li>Makecat.exe</li><li>Makecert.exe 制作cer格式的证书， 即X.509证书， 同时可以创建私钥和公钥</li><li>Makectl.exe</li><li>Signcode.exe 将证书签署到ocx上</li></ul><p>工具集下载：<a href="http://files.cnblogs.com/files/yhcao/makeCAB.rar" target="_blank" rel="noopener">makeCAB.rar</a></p><h2 id="制作CAB文件"><a href="#制作CAB文件" class="headerlink" title="制作CAB文件"></a>制作CAB文件</h2><ul><li>CMD 输入 iexpress，将启动Iexpress向导</li><li>选中”Create new Self Extraction Directive file”</li><li>选择”Create compressed files only(ActiveX Installs)”</li><li>添加INF文件中所列所有文件（DLL及DEF等）</li><li>单击”下一步(N)”，单击Browse按钮选择RemtCard.CAB文件，同时选中 “Store files using long Name inside Package”checkbx</li><li>选择”Don’t save”</li><li>单击完成按钮将同时生成RemtCard.CAB文件</li></ul><p>或</p><p>执行<br>    CABARC -s 6144 n RemtCard.cab ocx文件.ocx inf文件.INF</p><p>生成RemtCard.CAB文件</p><h2 id="自制数字证书"><a href="#自制数字证书" class="headerlink" title="自制数字证书"></a>自制数字证书</h2><p>用CMD进入到控件所在的目录;</p><p>创建PVK文件(私人密匙文件)，CMD输入makecert  -$ “individual” -r -sk RemtCard RemtCard.pvk -n CN=XXXXXXX</p><p>创建CER文件(公司证书)，CMD输入“makecert -sk RemtCard.pvk RemtCard.cer”，然后回车,在相对目录下会出现一个安全证书</p><p>创建SPC测试软件出版商证明书，CMD输入“cert2spc RemtCard.cer RemtCard.spc”</p><p>或</p><p>执行</p><pre><code>makecert -cy both -d RemtCard -n CN=xxxx有限公司 -sv RemtCard.pvk RemtCard.cerCert2SPC RemtCard.cer RemtCard.spc</code></pre><h2 id="文件数字签名"><a href="#文件数字签名" class="headerlink" title="文件数字签名"></a>文件数字签名</h2><p>在CMD中运行signcode</p><p>选择RemtCard.CAB</p><p>选择好RemtCard.CAB文件后单击”下一步（N）”按钮，在选择想要的签名类型里选择”自定义（C）”按钮</p><p>单击”从文件选择（F）”按钮，选择刚制作的RemtCard.cer</p><p>选择”CSP中的私钥（K）”</p><p>容器密匙选择RemtCard.pvk</p><p>在散列算法中选择”md5”</p><p>“证书路径中的证书”中选择”证书路径中的所有证书，包括根证书（C）”，在”其它证书（可选）”中选择“包括在以下PKCS #7 证书（.p7b）文件中的证书（P）：””，并单击”浏览（R）…”按钮选择RemtCard.spc文件</p><p>“数据描述”窗口中输入公司的名称及网址并单击”</p><p>或</p><p>执行</p><pre><code>signcode.exe -spc RemtCard.spc -v RemtCard.pvk -n RemtCard1.0.0.1 -i www.xxx.com.cn  RemtCard.cab</code></pre><h2 id="activeX插件安装升级"><a href="#activeX插件安装升级" class="headerlink" title="activeX插件安装升级"></a>activeX插件安装升级</h2><pre><code>&lt;object codebase=&quot;http://localhost/RemtCard.cab#version=1,1&quot;CLASSID=&quot;CLSID:8BB4EE5B-5919-11D1-A01A-0060971932BC&quot;…/&gt;    </code></pre><p>参考：</p><ul><li><a href="http://baike.baidu.com/link?url=cCp8mTjGGqdPPJzIfyBi5NIW13Y0jnETjPfegu2BI0K5SCryoFRf4dnk7BdpkMyimDKw8iTuSKAGVSFItXJcIm72x-sU_FrV_41BJS3F09m" target="_blank" rel="noopener">inf文件</a></li><li><a href="http://www.cnblogs.com/sbdx/archive/2006/12/14/whatisinffile.html?login=1" target="_blank" rel="noopener">如何编写 INF 文件</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/bfsktky3(VS.80" target="_blank" rel="noopener">证书创建工具 (Makecert.exe)</a>.aspx)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;制作CAB包&quot;&gt;&lt;a href=&quot;#制作CAB包&quot; class=&quot;headerlink&quot; title=&quot;制作CAB包&quot;&gt;&lt;/a&gt;制作CAB包&lt;/h1&gt;&lt;h2 id=&quot;inf文件&quot;&gt;&lt;a href=&quot;#inf文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="制作CAB包" scheme="https://caojingyou.github.io/tags/%E5%88%B6%E4%BD%9CCAB%E5%8C%85/"/>
    
      <category term="打包" scheme="https://caojingyou.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>C# http</title>
    <link href="https://caojingyou.github.io/2016/12/01/CShap%20http/"/>
    <id>https://caojingyou.github.io/2016/12/01/CShap http/</id>
    <published>2016-12-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minihttpd"><a href="#minihttpd" class="headerlink" title="minihttpd"></a>minihttpd</h1><p>minihttpd：HTTPWeb服务器库</p><p><a href="https://www.codeproject.com/articles/11342/minihttpd-an-http-web-server-library" target="_blank" rel="noopener">https://www.codeproject.com/articles/11342/minihttpd-an-http-web-server-library</a></p><h1 id="Embedded-NET-HTTP-Server"><a href="#Embedded-NET-HTTP-Server" class="headerlink" title="Embedded .NET HTTP Server"></a>Embedded .NET HTTP Server</h1><p>嵌入式.NET的HTTP服务器</p><p><a href="https://www.codeproject.com/Articles/25050/Embedded-NET-HTTP-Server" target="_blank" rel="noopener">https://www.codeproject.com/Articles/25050/Embedded-NET-HTTP-Server</a></p><h1 id="HttpLib"><a href="#HttpLib" class="headerlink" title="HttpLib"></a>HttpLib</h1><p>HttpLib是一个免费的.net(Apache 2.0许可协议)web请求帮助,让开发人员更容易访问和从互联网下载资源</p><p><a href="http://httplib.codeplex.com/" target="_blank" rel="noopener">http://httplib.codeplex.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;minihttpd&quot;&gt;&lt;a href=&quot;#minihttpd&quot; class=&quot;headerlink&quot; title=&quot;minihttpd&quot;&gt;&lt;/a&gt;minihttpd&lt;/h1&gt;&lt;p&gt;minihttpd：HTTPWeb服务器库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="http" scheme="https://caojingyou.github.io/tags/http/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>带你玩转Visual Studio</title>
    <link href="https://caojingyou.github.io/2016/11/15/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%ACVisual%20Studio/"/>
    <id>https://caojingyou.github.io/2016/11/15/带你玩转Visual Studio/</id>
    <published>2016-11-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="带你玩转Visual-Studio"><a href="#带你玩转Visual-Studio" class="headerlink" title="带你玩转Visual Studio"></a>带你玩转Visual Studio</h1><h2 id="带你新建一个工程"><a href="#带你新建一个工程" class="headerlink" title="带你新建一个工程"></a>带你新建一个工程</h2><h3 id="工程目录下各文件的含义"><a href="#工程目录下各文件的含义" class="headerlink" title="工程目录下各文件的含义"></a>工程目录下各文件的含义</h3><h4 id="解决方案与工程"><a href="#解决方案与工程" class="headerlink" title="解决方案与工程"></a>解决方案与工程</h4><p>在这之前先了解一个概念：解决方案与工程。<br>解决方案(Solution)：一个大型项目的整体的工作环境；<br>工程 (Project)：一个解决方案下的一个子工程；</p><p>在VS中，一个Solution可以有一个或多个Project。在我们创建一个工程时，如果没有指定Solution，VS会帮我们创建一个与工程名相同的Solution，这时一个Solution里只有一个Project。所有在我们的TestProject的文件目录结构中TestProject文件夹下还有一个TestProject文件夹(如图4)，第一个就是整个Solution的目录，第二个才是Project的目录。</p><h4 id="解决方案相关的文件："><a href="#解决方案相关的文件：" class="headerlink" title="解决方案相关的文件："></a>解决方案相关的文件：</h4><p>TestProject.sln：<br>整个解决方案(Solution)的配制文件，组织多个工程和相关的元素到一个解决方案中。用鼠标双击它就能用VS打开整个工程项目。</p><p>TestProject.sdf：<br>浏览相关的数据库文件，它支持浏览和导航的特性。如跳转到方法、变量的声明，查找所有对象的所有被引用的地方，类视图等等。</p><p>TestProject.suo：<br>(solution user opertion) 解决方案用户选项,记录所有将与解决方案建立关联的选项， 以便在每次打开时，它都包含您所做的自定义设置.</p><p>TestProject.opensdf：<br>打开解决方案(Solution)时的临时文件，这个文件只有你的解决方案在VS打开的状态才会有，工程一关闭文件就被删除了。</p><h4 id="工程相关的文件"><a href="#工程相关的文件" class="headerlink" title="工程相关的文件"></a>工程相关的文件</h4><p>TestProject.vcxproj：<br>记录工程(Project)相关的属性配制。</p><p>TestProject.vcxproj.filters：<br>文件过虑器，上图3“工程结构”中各个文件的组织和编排都是定义在这个文件中的。如果由于某种特殊的原因(如系统或VS突然崩溃)导致你打开工程时文件的组织结构是乱的，100%就是这个文件的原因。</p><p>TestProject.vcxproj.user：<br>用户相关的一些配制。</p><p>上面这些文件中有几个比较重要的一定不能删的文件是：</p><p>TestProject.sln、TestProject.vcxproj、TestProject.vcxproj.filters</p><p>不要问我是怎样知道这些文件的作用的，请看官方文档：</p><p>VS2010定义：<a href="工程目录下各文件的含义">https://msdn.microsoft.com/en-us/library/3awe4781.aspx</a>.</p><p>VS2015定义：<a href="https://msdn.microsoft.com/en-us/library/vstudio/hx0cxhaw(v=vs.110" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/vstudio/hx0cxhaw(v=vs.110).aspx</a>.aspx)</p><h2 id="带你了解VC-各种类型的工程"><a href="#带你了解VC-各种类型的工程" class="headerlink" title="带你了解VC++各种类型的工程"></a>带你了解VC++各种类型的工程</h2><h3 id="理解几个概念"><a href="#理解几个概念" class="headerlink" title="理解几个概念"></a>理解几个概念</h3><h4 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h4><p>COM(Component Object Model)组件对象模型是microsoft制定的一个组件软件标准，跟unix上的CORBA一样。凡是遵循COM标准开发出来的组件称为COM组件。目地是实现二进制方式的软件重用 。在windows平台上，COM的实现形式有DLL(进程内组件)和EXE(进程外组件)2种。</p><h4 id="OLE"><a href="#OLE" class="headerlink" title="OLE"></a>OLE</h4><p>OLE(Object Linking and Embedding)对象连接与嵌入是微软的复合文档技术，可方便实现应用程序之间的通信。在后来的OLE2中才导入了 COM，提供了对COM的支持，利用这种技术可开发可重复使用的软件组件COM。OLE是软件比较早提出的一种技术。</p><h4 id="ATL"><a href="#ATL" class="headerlink" title="ATL"></a>ATL</h4><p>ATL(Active Template Library)活动模板库是一套C++模板库，常用于开发COM程序和ActiveX程序。要理解ATL技术可从以下两方面理解：</p><ol><li>ATL可以说是把COM封装了一下，象MFC一样做成一个库，并有一个向导，使COM应用开发尽可能地自动化、可视化，这就决定了ATL只面向COM开发提供支持。</li><li>ATL因其采用了特定的基本实现技术，摆脱了大量冗余代码，使用ATL开发出来的COM应用的代码简练高效。<br>在ATL产生以前，开发COM组件的方法主要有两种：一是使用COM SDK(COM软件开发包)直接开发COM组件，另一种方式是通过MFC提供的COM支持来实现。而现在 ATL已经成为Microsoft支持COM应用开发的主要开发工具。<h4 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h4></li></ol><p>MFC(Microsoft Foundation Classes)微软基础类是微软提供的一个用于Windows程序开发的基础类库。MFC以C++类的形式封装了Windows的API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含的类包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p><h4 id="ActiveX"><a href="#ActiveX" class="headerlink" title="ActiveX"></a>ActiveX</h4><p>ActiveX是微软提出的一组使用COM技术使得软件组件在网络环境中进行交互的技术集，它与具体的编程语言无关。作为针对Internet应用开发的技术，ActiveX被广泛应用于WEB服务器以及客户端的各个方面。同时，ActiveX技术也被用于方便地创建普通的桌面应用程序，此外ActiveX一般具有界面。</p><p>ActiveX既包含服务器端技术，也包含客户端技术。其主要内容是：</p><ol><li>ActiveX控制（ActiveX Control）；用于向WEB页面、Microsoft Word等支持ActiveX的容器（Container）中插入COM对象。</li><li>ActiveX文档（ActiveX Document）；用于在WEB Browser或者其它支持ActiveX的容器中浏览复合文档（非HTML文档），例如Microsoft Word文档，Microsoft Excel文档或者用户自定义的文档等。</li><li>ActiveX脚本描述（ActiveX Scripting）；用于从客户端或者服务器端操纵ActiveX控制和Java程序，传递数据，协调它们之间的操作。</li><li>ActiveX服务器框架（ActiveX Server Framework）；提供了一系列针对WEB服务器应用程序设计各个方面的函数及其封装类，诸如服务器过滤器、HTML数据流控制等。</li><li>在Internet Explorer中内置Java虚拟机(Java Virtual Machine)，从而使Java Applet能够在Internet Explorer上运行，并可以与ActiveX控制通过脚本描述语言进行通信。</li></ol><h2 id="带你高效开发"><a href="#带你高效开发" class="headerlink" title="带你高效开发"></a>带你高效开发</h2><p>使用Visual Assist X</p><h3 id="Visual-Assist-X-Snippets-宏"><a href="#Visual-Assist-X-Snippets-宏" class="headerlink" title="Visual Assist X Snippets 宏"></a>Visual Assist X Snippets 宏</h3><p><a href="http://blog.csdn.net/ejay/article/details/7750728" target="_blank" rel="noopener">Visual Assist X Snippets 宏</a> </p><h2 id="带你高效管理代码"><a href="#带你高效管理代码" class="headerlink" title="带你高效管理代码"></a>带你高效管理代码</h2><h3 id="目前主流的版本控制系统有："><a href="#目前主流的版本控制系统有：" class="headerlink" title="目前主流的版本控制系统有："></a>目前主流的版本控制系统有：</h3><ol><li>CVS：是一个用于代码版本控制的自由软件，它是一个比较早出现的工具，由于它有很多自身的缺陷，现在几乎被SVN所取代了。</li><li>SVN：SVN是Subversion的简称，它是集中式的版本控制系统。SVN继承了CVS的基本思想，包含了CVS的几乎所有功能。你可以认为SVN是CVS的升级版(但实际上它们完全是两个软件)。</li><li>GIT：GIT是分布式的版本控制系统。相信玩过开源代码的都知道github吧，它就是一个基于git的代码托管平台</li></ol><h3 id="C-工程上传服务器要忽视的文件"><a href="#C-工程上传服务器要忽视的文件" class="headerlink" title="C++工程上传服务器要忽视的文件"></a>C++工程上传服务器要忽视的文件</h3><h4 id="C-工程上传服务器要忽视的文件-1"><a href="#C-工程上传服务器要忽视的文件-1" class="headerlink" title="C++工程上传服务器要忽视的文件"></a>C++工程上传服务器要忽视的文件</h4><pre><code>h: 头文件cpp: 源文件txt: 说明文件，如readmerc: 资源文件rc2: 资源文件ico: 图标，如logo等sln: 解决方案工程文件vcxproj: 工程文件filters: 文件过虑器</code></pre><h4 id="不要上传的文件类型"><a href="#不要上传的文件类型" class="headerlink" title="不要上传的文件类型"></a>不要上传的文件类型</h4><pre><code>Debug、Release等编译结构目录ipch目录aps: last resource editor stateexe: build resultidb: build stateipch: build helperlastbuildstate: build helperlib: build result. Can be 3rd partylog: build logmanifest: build helper. Can be written yourself.obj: build helperpch: build helperpdb: build resultres: build helpersdf: intellisense dbasesuo: solution user optionstlog: build loguser: debug settings. Do preserve if just one dev or custom debug settings</code></pre><p>如果用TortoiseSVN进行管理，需要手动添加ignore属性将不需要上传的文件忽略掉。在你工程目录里，右键-&gt;TortoiseSVN-&gt;Properties-&gt;New-&gt;Other，弹出的对话框中Property name中选择svn:ignore，Property value中填入要忽略的内容(这里可以使用能配符)。可以设置全局忽略样式。</p><h2 id="带你跳出坑爹的Runtime-Library坑"><a href="#带你跳出坑爹的Runtime-Library坑" class="headerlink" title="带你跳出坑爹的Runtime Library坑"></a>带你跳出坑爹的Runtime Library坑</h2><pre><code>Multi-threaded     /MT     Release版的多线程静态库     libcmt.lib     Multi-threaded Debug     /MTd     Debug版的多线程静态库     libcmtd.lib     Multi-threaded DLL     /MD     Release版的多线程动态库     msvcrt.lib+msvcrtxx.dll     Multi-threaded DLL Debug     MDd     Debug版的多线程动态库     msvcrtd.lib+msvcrtxxd.dll</code></pre><p>结论：/MD和/MDd将是潮流所趋，/ML和/MLd方式请及时放弃，/MT和/MTd在非必要时最好也不要采用了。</p><h2 id="带你理解多字节编码与Unicode码"><a href="#带你理解多字节编码与Unicode码" class="headerlink" title="带你理解多字节编码与Unicode码"></a>带你理解多字节编码与Unicode码</h2><ol><li>当设置为Use Unicode Character Set时，会有预编译宏：_UNICODE、UNICODE </li><li>当设置为Use Unicode Character Set时，会有预编译宏：_UNICODE、UNICODE </li></ol><h2 id="incremental-linking-增量链接-的作用"><a href="#incremental-linking-增量链接-的作用" class="headerlink" title="incremental linking(增量链接)的作用"></a>incremental linking(增量链接)的作用</h2><p><a href="http://www.cnblogs.com/lidabo/archive/2012/05/29/2524170.html" target="_blank" rel="noopener">VS中的路径宏 vc++中OutDir、ProjectDir、SolutionDir各种路径</a></p><h2 id="命令行编译C-C-程序"><a href="#命令行编译C-C-程序" class="headerlink" title="命令行编译C/C++程序"></a>命令行编译C/C++程序</h2><p>打开安装目录下的VSDIR\VC\bin可以看到一系列的可执行程序.exe和批处理文件，这些就是VS2010构建、编译、链接时要用到的工具。看一下几个主要的工具：</p><pre><code>cl.exe：编译程序link.exe：链接程序lib.exe：加载lib库的程序nmake.exe：用makefile进行构建、编译的工具</code></pre><p><a href="http://www.lellansin.com/%E5%BE%AE%E8%BD%AF-cl-exe-%E7%BC%96%E8%AF%91%E5%99%A8.html" target="_blank" rel="noopener">微软 CL.exe 编译器</a></p><p>##性能分析与优化## </p><p>使用VS的性能分析工具</p><h3 id="性能分析工具的选择"><a href="#性能分析工具的选择" class="headerlink" title="性能分析工具的选择"></a>性能分析工具的选择</h3><p>打开一个“性能分析”的会话:Debug-&gt;Start Diagnotic Tools Without Debugging(或按Alt+F2)，VS2013在Analysis菜单中。 </p><h4 id="CPU-Usage"><a href="#CPU-Usage" class="headerlink" title="CPU Usage"></a>CPU Usage</h4><p>检测CPU的性能，主要用于发现影响CPU瓶颈(消耗大量CPU资源)的代码。</p><h4 id="GPU-Usage"><a href="#GPU-Usage" class="headerlink" title="GPU Usage"></a>GPU Usage</h4><p>检测GPU的性能，常用于图形引擎的应用(如DirectX程序)，主要用于判断是CPU还是GPU的瓶颈。</p><h4 id="Memory-Usage"><a href="#Memory-Usage" class="headerlink" title="Memory Usage"></a>Memory Usage</h4><p>检测应用程序的内存，发现内存。</p><h4 id="Performance-Wizard"><a href="#Performance-Wizard" class="headerlink" title="Performance Wizard"></a>Performance Wizard</h4><p>性能(监测)向导，综合检测程序的性能瓶颈。这个比较常用，下面再逐一说明。</p><h3 id="性能-监测-向导"><a href="#性能-监测-向导" class="headerlink" title="性能(监测)向导"></a>性能(监测)向导</h3><h4 id="CPU-Sampling-CPU采样-："><a href="#CPU-Sampling-CPU采样-：" class="headerlink" title="CPU Sampling(CPU采样)："></a>CPU Sampling(CPU采样)：</h4><p>进行采样统计，以低开销水平监视占用大量CPU的应用程序。这个对于计算量大的程序可大大节省监控时间。</p><h4 id="Instrumentation-检测-："><a href="#Instrumentation-检测-：" class="headerlink" title="Instrumentation(检测)："></a>Instrumentation(检测)：</h4><p>完全统计，测量函数调用计数和用时</p><h4 id="NET-memory-allocation-NET-内存分配-："><a href="#NET-memory-allocation-NET-内存分配-：" class="headerlink" title=".NET memory allocation(.NET 内存分配)："></a>.NET memory allocation(.NET 内存分配)：</h4><p>跟踪托管内存分配。这个好像只有托管代码(如C#)才可用，一般以C++代码好像不行。</p><h4 id="Resource-contention-data-并发-："><a href="#Resource-contention-data-并发-：" class="headerlink" title="Resource contention data(并发)："></a>Resource contention data(并发)：</h4><p>检测等待其他线程的线程，多用于多线程的并发。</p><h3 id="性能分析报告"><a href="#性能分析报告" class="headerlink" title="性能分析报告"></a>性能分析报告</h3><h4 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h4><p>有几个不同的视图可供我们切换，下面加粗的部分是个人觉得比较方便和常用的视图。</p><ul><li>Summary(概要):整个报告概要说明</li><li>Call Tree(调用树):以树形表格的方式展开函数之间的关系。</li><li>Module(模块):分析调用的不同的程序模块，如不同的DLL、lib模块的耗时</li><li>Caller/Callee(调用与被调用):以数值显示的调用与被调用的关系</li><li>Functions(函数统计):以数值显示的各个函数的执行时间和执行次数统计值</li><li>Marks(标记):</li><li>Processers(进程):</li><li>Function Detials(函数详情):以图表的方式形象地显示：调用函数-当前函数-被调用子函数之间的关系和时间比例。</li></ul><h4 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h4><ul><li>Num of Calls:(函数)调用次数</li><li>Elapsed Inclusive Time:已用非独占时间</li><li>Elapsed Exclusive Time:已用独占时间</li><li>Avg Elapsed Inclusive Time:平均已用非独占时间</li><li>Avg Elapsed Exclusive Time:平均已用独占时间</li><li>Module Name:模块名称，一般为可执行文件(.exe)、动态库(.dll)、静态库(.lib)的名称。</li></ul><h2 id="调用约定cdecl、stdcall和-fastcall"><a href="#调用约定cdecl、stdcall和-fastcall" class="headerlink" title="调用约定cdecl、stdcall和__fastcall"></a>调用约定<strong>cdecl、</strong>stdcall和__fastcall</h2><h3 id="什么是调用约定"><a href="#什么是调用约定" class="headerlink" title="什么是调用约定"></a>什么是调用约定</h3><p>函数的调用约定，顾名思义就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。它决定以下内容：(1)函数参数的压栈顺序，(2)由调用者还是被调用者把参数弹出栈，(3)以及产生函数修饰名的方法。</p><p>常见的调用约定有<strong>cdecl、</strong>stdcall、fastcall，应用最广泛的是<strong>cdecl和</strong>stdcall,下面我们会详细进行讲述。。还有一些不常见的，如 <strong>pascal、</strong>thiscall、__vectorcall。</p><h3 id="cdecl的特点"><a href="#cdecl的特点" class="headerlink" title="__cdecl的特点"></a>__cdecl的特点</h3><p>__cdecl 是 C Declaration 的缩写，表示 C 和 C++ 默认的函数调用约定。是C/C++和MFCX的默认调用约定。</p><ul><li>按从右至左的顺序压参数入栈、。</li><li>由调用者把参数弹出栈。切记：对于传送参数的内存栈是由调用者来维护的，返回值在EAX中。因此对于像printf这样可变参数的函数必须用这种约定。</li><li>编译器在编译的时候对这种调用规则的函数生成修饰名的时候，在输出函数名前加上一个下划线前缀，格式为_function。如函数int add(int a, int b)的修饰名是_add。</li></ul><h3 id="stdcall的特点"><a href="#stdcall的特点" class="headerlink" title="__stdcall的特点"></a>__stdcall的特点</h3><p><strong>stdcall是Standard Call的缩写，是C++的标准调用方式,当然这是微软定义的标准，</strong>stdcall通常用于Win32 API中(可查看WINAPI的定义)。</p><ul><li>按从右至左的顺序压参数入栈。</li><li>由被调用者把参数弹出栈。切记：函数自己在退出时清空堆栈，返回值在EAX中。</li><li>__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为_function@number。如函数int sub(int a, int b)的修饰名是_sub@8。</li></ul><h3 id="fastcall的特点"><a href="#fastcall的特点" class="headerlink" title="__fastcall的特点"></a>__fastcall的特点</h3><p>__fastcall调用的主要特点就是快，因为它是通过寄存器来传送参数的。</p><ul><li>实际上__fastcall用ECX和EDX传送前两个DWORD或更小的参数，剩下的参数仍自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈。</li><li>__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@function@number,如double multi(double a, double b)的修饰名是@multi@16。</li><li><strong>fastcall和</strong>stdcall很象，唯一差别就是头两个参数通过寄存器传送。注意通过寄存器传送的两个参数是从左向右的，即第1个参数进ECX，第2个进EDX，其他参数是从右向左的入栈，返回仍然通过EAX。</li></ul><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p>__thiscall是C++类成员函数缺省的调用约定，但它没有显示的声明形式。因为在C++类中，成员函数调用还有一个this指针参数，因此必须特殊处理，thiscall调用约定的特点：</p><ul><li>参数入栈：参数从右向左入栈</li><li>this指针入栈：如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入栈。</li><li>栈恢复：对参数个数不定的，调用者清理栈，否则函数自己清理栈。</li></ul><h2 id="调用约定与-动态-库"><a href="#调用约定与-动态-库" class="headerlink" title="调用约定与(动态)库"></a>调用约定与(动态)库</h2><p><a href="http://blog.csdn.net/luoweifu/article/details/52456407" target="_blank" rel="noopener">调用约定与(动态)库</a></p><p>参考：</p><ul><li><a href="http://blog.csdn.net/column/details/visualstudio.html" target="_blank" rel="noopener">带你玩转Visual Studio</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;带你玩转Visual-Studio&quot;&gt;&lt;a href=&quot;#带你玩转Visual-Studio&quot; class=&quot;headerlink&quot; title=&quot;带你玩转Visual Studio&quot;&gt;&lt;/a&gt;带你玩转Visual Studio&lt;/h1&gt;&lt;h2 id=&quot;带你新建一
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="VC" scheme="https://caojingyou.github.io/tags/VC/"/>
    
  </entry>
  
  <entry>
    <title>C# 进程间通信</title>
    <link href="https://caojingyou.github.io/2016/11/01/CShap%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://caojingyou.github.io/2016/11/01/CShap 进程间通信/</id>
    <published>2016-11-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用SendMessage向另一进程发送WM-COPYDATA消息"><a href="#使用SendMessage向另一进程发送WM-COPYDATA消息" class="headerlink" title="使用SendMessage向另一进程发送WM_COPYDATA消息"></a>使用SendMessage向另一进程发送WM_COPYDATA消息</h1><h2 id="Send端："><a href="#Send端：" class="headerlink" title="Send端："></a>Send端：</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;using System.Windows.Shapes;using System.Runtime.InteropServices;namespace SentTest{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        public MainWindow()        {            InitializeComponent();            this.Title = &quot;发送窗口&quot;;        }        const int WM_COPYDATA = 0x004A;        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        [DllImport(&quot;User32.dll&quot;)]        public static extern int SendMessage(int hwnd, int msg, int wParam, ref COPYDATASTRUCT IParam);        [DllImport(&quot;User32.dll&quot;)]        public static extern int FindWindow(string lpClassName, string lpWindowName);        private void button1_Click(object sender, RoutedEventArgs e)        {            String strSent = &quot;需要发送的信息&quot;;            int WINDOW_HANDLE = FindWindow(null, &quot;接收窗口&quot;);            if (WINDOW_HANDLE != 0)            {                byte[] arr = System.Text.Encoding.Default.GetBytes(strSent);                int len = arr.Length;                COPYDATASTRUCT cdata;                cdata.dwData = (IntPtr)100;                cdata.lpData = strSent;                cdata.cData = len + 1;                SendMessage(WINDOW_HANDLE, WM_COPYDATA, 0, ref cdata);            }        }    }}</code></pre><h2 id="Get端："><a href="#Get端：" class="headerlink" title="Get端："></a>Get端：</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Documents;using System.Windows.Input;using System.Windows.Media;using System.Windows.Media.Imaging;using System.Windows.Navigation;using System.Windows.Shapes;using System.Runtime.InteropServices;using System.Windows.Interop;namespace GetTest{    /// &lt;summary&gt;    /// MainWindow.xaml 的交互逻辑    /// &lt;/summary&gt;    public partial class MainWindow : Window    {        IntPtr hwnd;        public MainWindow()        {            InitializeComponent();            this.Title = &quot;接受窗口&quot;;            this.Loaded += new RoutedEventHandler(MainWindow_Loaded);            this.Closed += new EventHandler(MainWindow_Closed);        }        void MainWindow_Loaded(object sender, RoutedEventArgs e)        {            //窗口加载完毕才可用，否则会报错。            hwnd = new WindowInteropHelper(this).Handle;            HwndSource source = HwndSource.FromHwnd(hwnd);            if (source != null) source.AddHook(WndProc);        }        void MainWindow_Closed(object sender, EventArgs e)        {            try            {                HwndSource.FromHwnd(hwnd).RemoveHook(WndProc);            }            catch (Exception)            {                throw;            }        }        const int WM_COPYDATA = 0x004A;//WM_COPYDATA消息的主要目的是允许在进程间传递只读数据。        //Windows在通过WM_COPYDATA消息传递期间，不提供继承同步方式。        //其中,WM_COPYDATA对应的十六进制数为0x004A        public struct COPYDATASTRUCT        {            public IntPtr dwData;            public int cData;            [MarshalAs(UnmanagedType.LPStr)]            public string lpData;        }        //wpf用此方法        private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)        {            if (msg == WM_COPYDATA)            {                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)Marshal.PtrToStructure(lParam, mytype);                this.textBox1.Text = cdata.lpData;            }            return IntPtr.Zero;        }        //WinFrom用此方法        /* protected override void DefWndProc(ref Message m)        {            switch (m.Msg)            {            case WM_COPYDATA:                COPYDATASTRUCT cdata = new COPYDATASTRUCT();                Type mytype = cdata.GetType();                cdata = (COPYDATASTRUCT)m.GetLParam(mytype);                this.textBox1.Text = cdata.lpData;                break;            default:                base.DefWndProc(ref m);                break;            }        } */    }}</code></pre><h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><p><a href="http://blog.csdn.net/feiren127/article/details/5459827" target="_blank" rel="noopener">c# 进程间同步实现 进程之间通讯的几种方法 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用SendMessage向另一进程发送WM-COPYDATA消息&quot;&gt;&lt;a href=&quot;#使用SendMessage向另一进程发送WM-COPYDATA消息&quot; class=&quot;headerlink&quot; title=&quot;使用SendMessage向另一进程发送WM_COP
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="VLC" scheme="https://caojingyou.github.io/tags/VLC/"/>
    
      <category term="通信" scheme="https://caojingyou.github.io/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++ 引用计数技术及智能指针的简单实现</title>
    <link href="https://caojingyou.github.io/2016/10/01/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://caojingyou.github.io/2016/10/01/C++智能指针/</id>
    <published>2016-10-01T08:03:00.000Z</published>
    <updated>2018-07-18T07:41:03.875Z</updated>
    
    <content type="html"><![CDATA[<p>智能指针是利用RAII（在对象的构造函数中执行资源的获取（指针的初始化），在析构函数中释放（delete 指针）：这种技法把它称之为RAII（Resource Acquisition Is Initialization：资源获取即初始化））来管理资源。</p><h1 id="引用计数技术及智能指针的简单实现"><a href="#引用计数技术及智能指针的简单实现" class="headerlink" title="引用计数技术及智能指针的简单实现"></a>引用计数技术及智能指针的简单实现</h1><h2 id="基础对象类"><a href="#基础对象类" class="headerlink" title="基础对象类"></a>基础对象类</h2><pre><code>class Point{public:    Point(int xVal = 0, int yVal = 0) : x(xVal), y(yVal) { }    int getX() const    {        return x;    }    int getY() const    {        return y;    }    void setX(int xVal)    {        x = xVal;    }    void setY(int yVal)    {        y = yVal;    }    private:    int x, y;};</code></pre><h2 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h2><pre><code>//模板类作为友元时要先有声明template &lt;typename T&gt;class SmartPtr;template &lt;typename T&gt;class U_Ptr     //辅助类{private:    //该类成员访问权限全部为private，因为不想让用户直接使用该类    friend class SmartPtr&lt;T&gt;;      //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类    //构造函数的参数为基础对象的指针    U_Ptr(T *ptr) : p(ptr), count(1) { }    //析构函数    ~U_Ptr()    {        delete p;    }    //引用计数    int count;    //基础对象指针    T *p;};</code></pre><h2 id="智能指针类"><a href="#智能指针类" class="headerlink" title="智能指针类"></a>智能指针类</h2><pre><code>template &lt;typename T&gt;class SmartPtr   //智能指针类{public:    SmartPtr(T *ptr) : rp(new U_Ptr&lt;T&gt;(ptr)) { }     //构造函数    SmartPtr(const SmartPtr&lt;T&gt; &amp;sp) : rp(sp.rp)    {        ++rp-&gt;count;    //复制构造函数    }    SmartPtr &amp;operator=(const SmartPtr&lt;T&gt; &amp;rhs)      //重载赋值操作符    {        ++rhs.rp-&gt;count;     //首先将右操作数引用计数加1，        if (--rp-&gt;count == 0)     //然后将引用计数减1，可以应对自赋值            delete rp;        rp = rhs.rp;        return *this;    }    T &amp;operator *()         //重载*操作符    {        return *(rp-&gt;p);    }    T *operator -&gt;()       //重载-&gt;操作符    {        return rp-&gt;p;    }    ~SmartPtr()          //析构函数    {        if (--rp-&gt;count == 0)    //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象            delete rp;        else            cout &lt;&lt; &quot;还有&quot; &lt;&lt; rp-&gt;count &lt;&lt; &quot;个指针指向基础对象&quot; &lt;&lt; endl;    }private:    U_Ptr&lt;T&gt; *rp;  //辅助类对象指针};</code></pre><p>使用测试</p><pre><code>int main(){    int *i = new int(2);    {        SmartPtr&lt;int&gt; ptr1(i);        {            SmartPtr&lt;int&gt; ptr2(ptr1);            {                SmartPtr&lt;int&gt; ptr3 = ptr2;                cout &lt;&lt; *ptr1 &lt;&lt; endl;                *ptr1 = 20;                cout &lt;&lt; *ptr2 &lt;&lt; endl;            }        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><h1 id="C-11智能指针"><a href="#C-11智能指针" class="headerlink" title="C++11智能指针"></a>C++11智能指针</h1><p>c++ 智能指针主要包括：<code>unique_ptr</code>,<code>shared_ptr</code>, <code>weak_ptr</code>, 这三种，其中<code>auto_ptr</code>(C++17) 已被遗弃。</p><h2 id="unique-ptr-拥有独有对象所有权语义的智能指针-类模板"><a href="#unique-ptr-拥有独有对象所有权语义的智能指针-类模板" class="headerlink" title="unique_ptr  拥有独有对象所有权语义的智能指针    (类模板)"></a><a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener"><code>unique_ptr</code></a>  拥有独有对象所有权语义的智能指针    (类模板)</h2><p><code>std::unique_ptr</code> 是通过指针占有并管理另一对象，并在 unique_ptr 离开作用域时释放该对象的智能指针。</p><h2 id="shared-ptr-拥有共享对象所有权语义的智能指针-类模板"><a href="#shared-ptr-拥有共享对象所有权语义的智能指针-类模板" class="headerlink" title="shared_ptr  拥有共享对象所有权语义的智能指针    (类模板)"></a><code>shared_ptr</code>  拥有共享对象所有权语义的智能指针    (类模板)</h2><p><code>std::shared_ptr</code> 是通过指针保持对象共享所有权的智能指针。多个 <code>shared_ptr</code> 对象可占有同一对象。</p><h2 id="weak-ptr-由std-shared-ptr所管理的对象的弱引用-类模板"><a href="#weak-ptr-由std-shared-ptr所管理的对象的弱引用-类模板" class="headerlink" title="weak_ptr  由std::shared_ptr所管理的对象的弱引用    (类模板)"></a><code>weak_ptr</code>  由<code>std::shared_ptr</code>所管理的对象的弱引用    (类模板)</h2><p><code>std::weak_ptr</code> 是一种智能指针，它对被 <code>std::shared_ptr</code> 管理的对象存在非拥有性（“弱”）引用。在访问所引用的对象前必须先转换为 <code>std::shared_ptr</code>。</p><p><code>std::weak_ptr</code> 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 <code>std::weak_ptr</code> 来跟踪该对象。需要获得临时所有权时，则将其转换为 <code>std::shared_ptr</code>，此时如果原来的 <code>std::shared_ptr</code> 被销毁，则该对象的生命期将被延长至这个临时的 <code>std::shared_ptr</code> 同样被销毁为止。</p><p>此外，<code>std::weak_ptr</code> 还可以用来避免 <code>std::shared_ptr</code> 的循环引用。</p><p>weak_ptr 只能由shared_ptr或者其它的weak_ptr构造</p><h1 id="Boost库智能指针（shared-ptr-amp-amp-scoped-ptr-amp-amp-weak-ptr）"><a href="#Boost库智能指针（shared-ptr-amp-amp-scoped-ptr-amp-amp-weak-ptr）" class="headerlink" title="Boost库智能指针（shared_ptr &amp;&amp; scoped_ptr &amp;&amp; weak_ptr）"></a>Boost库智能指针（<code>shared_ptr &amp;&amp; scoped_ptr &amp;&amp; weak_ptr</code>）</h1><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p><code>Scoped_ptr</code>不能够被拷贝和赋值，但是可以交换。不能够被拷贝和赋值的原因是赋值运算符和拷贝构造函数都是private。</p><p>reset()也可以释放堆对象，就是利用交换实现的。</p><p><code>boost::scoped_ptr</code>有着更严格的使用限制——不能拷贝。这就意味着：<code>boost::scoped_ptr</code>指针是不能转换其所有权的。</p><p>它能够保证在离开作用域后对象被自动释放。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>是可以拷贝和赋值的，拷贝行为也是等价的，并且可以被比较，这意味这它可被放入标准库的一般容器（vector，list）和关联容器中（map）.</p><p><code>boost::shared_ptr</code>的管理机制其实并不复杂，就是对所管理的对象进行了引用计数，当新增一个<code>boost::shared_ptr</code>对该对象进行管理时，就将该对象的引用计数加一；减少一个<code>boost::shared_ptr</code>对该对象进行管理时，就将该对象的引用计数减一，如果该对象的引用计数为0的时候，说明没有任何指针对其管理，才调用delete释放其所占的内存。</p><p><code>shared_ptr</code>并不能对循环引用的对象内存自动管理（这点是其它各种引用计数管理内存方式的通病）。</p><p>不要构造一个临时的<code>shared_ptr</code>作为函数的参数。</p><p>构造一个临时的<code>shared_ptr</code>作为函数的参数:</p><p>这个问题与异常和函数参数的求值顺序有关。C++构造函数发生的异常将不会调用析构函数。例如<code>f(shared_ptr&lt;int&gt;(new int(2)), g())</code>。构造了临时的 <code>shared_ptr</code> ，这就为内存泄漏留下了可乘之机。因为函数参数的求值顺序是不确定的，<code>new int(2)</code> 首先被求值，<code>g()</code> 第二个是有可能的，如果 g 抛出一个异常，我们永远也不可能到达 <code>shared_ptr</code> 的构造函数。<code>new int(2)</code>申请的资源没有机会被释放。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存.</p><p><code>boost::weak_ptr</code>必须从一个<code>boost::share_ptr</code>或另一个<code>boost::weak_ptr</code>转换而来，这也说明，进行该对象的内存管理的是那个强引用的<code>boost::share_ptr</code>。<code>boost::weak_ptr</code>只是提供了对管理对象的一个访问手段。</p><p><code>boost::weak_ptr</code>除了对所管理对象的基本访问功能（通过<code>get()</code>函数）外，还有两个常用的功能函数：<code>expired()</code>用于检测所管理的对象是否已经释放；<code>lock()</code>用于获取所管理的对象的强引用指针。</p><p><code>weak_ptr&lt;T&gt;</code>的引入主要是为了解决<code>shared_ptr</code>的循环引用的问题.</p><h1 id="CComPtr类"><a href="#CComPtr类" class="headerlink" title="CComPtr类"></a>CComPtr类</h1><p>用于管理COM接口指针的智能指针类。</p><p>ATL使用CComPtr和CComQIPtr管理COM接口指针。两者都源自CComPtrBase，并且都执行自动引用计数</p><p>CComPtr被称为智能指针，是ATL提供的一个模版类，能够从语法上自动完成AddRef和Release。（源代码在atlbase.h中）</p><p><a href="http://www.tsingfun.com/html/2015/dev_1111/ATL-CComPtr-CComQIPtr.html" target="_blank" rel="noopener">ATL CComPtr和CComQIPtr详解</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;mid=2651156666&amp;idx=1&amp;sn=4109903d526468f5913922d2f06e5a1a&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">C++ 引用计数技术及智能指针的简单实现</a>(文章写的太好了，转过了以后用)</li><li><a href="https://blog.csdn.net/leichaowen/article/details/53064294" target="_blank" rel="noopener">弱引用<code>weak_ptr</code> 解决<code>shared_ptr</code>的循环引用</a></li><li><a href="https://blog.csdn.net/applemonkey11/article/details/79031615" target="_blank" rel="noopener">将智能指针作为函数输入参数的两个问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;智能指针是利用RAII（在对象的构造函数中执行资源的获取（指针的初始化），在析构函数中释放（delete 指针）：这种技法把它称之为RAII（Resource Acquisition Is Initialization：资源获取即初始化））来管理资源。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="智能指针" scheme="https://caojingyou.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="Boost" scheme="https://caojingyou.github.io/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>C# 视频编辑</title>
    <link href="https://caojingyou.github.io/2016/10/01/CShap%20%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91/"/>
    <id>https://caojingyou.github.io/2016/10/01/CShap 视频编辑/</id>
    <published>2016-10-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VidCoder"><a href="#VidCoder" class="headerlink" title="VidCoder"></a>VidCoder</h1><p>VidCoder是一个开源免费的DVD/蓝光视频抓取和转码软件.使用HandBrake做为编码引擎.比Handbrake拥有更友好的用户界面.</p><p>可裁剪、剪切、字幕编辑、转码等。</p><p>官网：<br><a href="http://vidcoder.codeplex.com/" target="_blank" rel="noopener">http://vidcoder.codeplex.com/</a></p><h1 id="VLC-media-player"><a href="#VLC-media-player" class="headerlink" title="VLC media player"></a>VLC media player</h1><p>VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。</p><p>官网：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></p><h1 id="ffmpeg-Mencoder"><a href="#ffmpeg-Mencoder" class="headerlink" title="ffmpeg + Mencoder"></a>ffmpeg + Mencoder</h1><p>ffmpeg下载：<a href="http://ffmpeg.org/download.html" target="_blank" rel="noopener">http://ffmpeg.org/download.html</a></p><p>Mencoder下载：<a href="http://www.mplayerhq.hu/design7/dload.html" target="_blank" rel="noopener">http://www.mplayerhq.hu/design7/dload.html</a></p><p>C#调用ffmpeg的方法，仅供参考：<a href="https://github.com/CAOJINGYOU/VideoEditor" target="_blank" rel="noopener">VideoEditor</a></p><h1 id="SharpFFmpeg"><a href="#SharpFFmpeg" class="headerlink" title="SharpFFmpeg"></a>SharpFFmpeg</h1><p>SharpFFmpeg 是一个 ffmpeg 的 C# 绑定版本，允许 .NET 开发者轻松的创建音频和视频应用。</p><p>个人没用过，感觉不错，一会有机会研究下。</p><p>下载地址：<a href="https://sourceforge.net/projects/sharpffmpeg/" target="_blank" rel="noopener">https://sourceforge.net/projects/sharpffmpeg/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VidCoder&quot;&gt;&lt;a href=&quot;#VidCoder&quot; class=&quot;headerlink&quot; title=&quot;VidCoder&quot;&gt;&lt;/a&gt;VidCoder&lt;/h1&gt;&lt;p&gt;VidCoder是一个开源免费的DVD/蓝光视频抓取和转码软件.使用HandBrake做为编
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C#" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="VidCoder" scheme="https://caojingyou.github.io/tags/VidCoder/"/>
    
      <category term="VLC" scheme="https://caojingyou.github.io/tags/VLC/"/>
    
      <category term="ffmpeg" scheme="https://caojingyou.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Github pages + jekyll 博客快速搭建</title>
    <link href="https://caojingyou.github.io/2016/09/15/Github%20pages%20+%20jekyll%20%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    <id>https://caojingyou.github.io/2016/09/15/Github pages + jekyll 博客快速搭建/</id>
    <published>2016-09-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-pages-jekyll-博客快速搭建"><a href="#Github-pages-jekyll-博客快速搭建" class="headerlink" title="Github pages + jekyll 博客快速搭建"></a>Github pages + jekyll 博客快速搭建</h1><h2 id="寻找喜欢的模版"><a href="#寻找喜欢的模版" class="headerlink" title="寻找喜欢的模版"></a>寻找喜欢的模版</h2><ul><li><a href="https://github.com/jekyll/jekyll/wiki/sites" target="_blank" rel="noopener">https://github.com/jekyll/jekyll/wiki/sites</a></li><li><a href="http://jekyllthemes.org/" target="_blank" rel="noopener">http://jekyllthemes.org/</a></li></ul><h2 id="Fork到自己的github"><a href="#Fork到自己的github" class="headerlink" title="Fork到自己的github"></a>Fork到自己的github</h2><p>找到自己github中的此项目</p><p>点击“Settings”，将“Repository name”改为 {你的Github用户名}.github.io，点击“Rename”</p><p>修改成自己的名字</p><p>此时就可以通过 <a href="http://{你的Github用户名}.github.io" target="_blank" rel="noopener">http://{你的Github用户名}.github.io</a> 访问你fork下来的网站了。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>使用git for window 把此项目clone本地</p><p>在_posts 文件夹里有一篇xxx.markdown文件，模仿此文件写博客即可。</p><p>然后用git for window提交到github</p><p>参考：</p><ul><li><a href="http://www.cnblogs.com/xulei1992/p/5650329.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Github pages + jekyll 博客快速搭建</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-pages-jekyll-博客快速搭建&quot;&gt;&lt;a href=&quot;#Github-pages-jekyll-博客快速搭建&quot; class=&quot;headerlink&quot; title=&quot;Github pages + jekyll 博客快速搭建&quot;&gt;&lt;/a&gt;Github
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Github Pages" scheme="https://caojingyou.github.io/tags/Github-Pages/"/>
    
      <category term="静态博客" scheme="https://caojingyou.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="jekyll" scheme="https://caojingyou.github.io/tags/jekyll/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages和Hexo创建静态博客网站</title>
    <link href="https://caojingyou.github.io/2016/09/01/Github%20Pages%E5%92%8CHexo%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <id>https://caojingyou.github.io/2016/09/01/Github Pages和Hexo创建静态博客网站/</id>
    <published>2016-09-01T08:03:00.000Z</published>
    <updated>2018-08-31T05:59:47.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Pages和Hexo创建静态博客网站"><a href="#Github-Pages和Hexo创建静态博客网站" class="headerlink" title="Github Pages和Hexo创建静态博客网站"></a>Github Pages和Hexo创建静态博客网站</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>本人是window环境，所以下载window版。</p><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h2 id="下载-msysgit"><a href="#下载-msysgit" class="headerlink" title="下载 msysgit"></a>下载 msysgit</h2><p>下载地址：<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">https://git-for-windows.github.io/</a></p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="http://hexo.io/zh-cn/" target="_blank" rel="noopener">http://hexo.io/zh-cn/</a></p><p>点击鼠标右键菜单Git Bash Here</p><pre><code>npm install hexo-cli -gnpm install hexo --save#如果命令无法运行，可以尝试更换taobao的npm源npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>创建一个blog目录</p><p>执行命令：</p><pre><code>hexo initnpm install</code></pre><p>安装插件，可跳过此步骤：</p><pre><code>npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save</code></pre><p>最好执行：</p><pre><code>npm install hexo-generator-feed --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save</code></pre><p>分别对应：rss、百度爬虫sitemap、通用搜索引擎sitemap</p><p>运行本地Hexo:</p><pre><code>hexo generatehexo server</code></pre><p>浏览器查看效果：</p><pre><code>localhost:4000</code></pre><h2 id="上传到Github"><a href="#上传到Github" class="headerlink" title="上传到Github"></a>上传到Github</h2><p>找到主项目的https地址：<a href="https://xxx/github.io.git" target="_blank" rel="noopener">https://xxx/github.io.git</a></p><p>打开blog文件夹下_config.yml文件修改：</p><pre><code>deploy:  type: git  repository: https://xxx/github.io.git  branch: master</code></pre><p>执行命令：</p><pre><code>hexo g -d</code></pre><h2 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h2><p>Hexo主题：<a href="http://hexo.io/themes/" target="_blank" rel="noopener">http://hexo.io/themes/</a></p><p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a></p><p><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">hexo-theme-yelee</a></p><p>执行命令下载主题：</p><p>git clone <a href="https://github.com/xxx.git(主题地址" target="_blank" rel="noopener">https://github.com/xxx.git(主题地址</a>) themes/xxx(主题文件夹)</p><p>修改_config.yml文件：</p><pre><code>theme: xxx（主题名）</code></pre><p>执行命令：</p><pre><code>hexo ghexo s</code></pre><p>打开<a href="http://localhost:4000/即可看到效果。" target="_blank" rel="noopener">http://localhost:4000/即可看到效果。</a></p><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>执行命令：</p><pre><code>hexo clean   hexo g -d</code></pre><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><pre><code>hexo n &quot;文章标题&quot; #新建md文件hexo g -d #生成并部署</code></pre><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>Create a new post</p><pre><code>hexo new &quot;My New Post&quot;</code></pre><p>Run server</p><pre><code>hexo server</code></pre><p>Generate static files</p><pre><code>hexo generate</code></pre><p>Deploy to remote sites</p><pre><code>hexo deploy</code></pre><h1 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h1><p>hexo d后 ERROR Deployer not found: git</p><pre><code>npm install --save hexo-deployer-git</code></pre><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p><a href="https://github.com/litten/hexo-theme-yilia" title="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><p><a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" title="https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia/wiki/Yilia%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9E%84%E5%BB%BA%E9%A1%BB%E7%9F%A5</a></p><p>参考：</p><ul><li><a href="http://blog.csdn.net/ljcitworld/article/details/50901626" target="_blank" rel="noopener">小白独立搭建博客–Github Pages和Hexo简明教程</a></li><li><a href="http://www.jianshu.com/p/73779eacb494" target="_blank" rel="noopener">Hexo 靜態博客使用指南</a></li><li><a href="http://wiki.jikexueyuan.com/project/hexo-document/" target="_blank" rel="noopener">Hexo 中文版</a></li><li><a href="http://www.jianshu.com/p/cc38fc9493d4" target="_blank" rel="noopener">解决hexo d命令提交部署博客发生的TaskCanceledException异常</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-Pages和Hexo创建静态博客网站&quot;&gt;&lt;a href=&quot;#Github-Pages和Hexo创建静态博客网站&quot; class=&quot;headerlink&quot; title=&quot;Github Pages和Hexo创建静态博客网站&quot;&gt;&lt;/a&gt;Github Page
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Github Pages" scheme="https://caojingyou.github.io/tags/Github-Pages/"/>
    
      <category term="Hexo" scheme="https://caojingyou.github.io/tags/Hexo/"/>
    
      <category term="静态博客" scheme="https://caojingyou.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>程序打包</title>
    <link href="https://caojingyou.github.io/2016/08/15/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
    <id>https://caojingyou.github.io/2016/08/15/程序打包/</id>
    <published>2016-08-15T08:03:00.000Z</published>
    <updated>2018-09-25T08:38:07.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Installer"><a href="#Visual-Studio-Installer" class="headerlink" title="Visual Studio Installer"></a>Visual Studio Installer</h1><p><a href="http://www.cnblogs.com/daban/archive/2012/06/27/2565449.html" target="_blank" rel="noopener">VS2010程序打包操作</a></p><h1 id="InstallShield"><a href="#InstallShield" class="headerlink" title="InstallShield"></a>InstallShield</h1><p><a href="http://liucw.blog.51cto.com/6751239/1220134" target="_blank" rel="noopener">InstallShield使用完全教程</a></p><p><a href="http://www.jb51.net/softjc/467.html" target="_blank" rel="noopener">探索InstallShield——制作一个完整的应用程序安装实例</a></p><p><a href="http://blog.csdn.net/duanbeibei/article/details/50333603" target="_blank" rel="noopener">一个完整的Installshield安装程序实例</a> </p><p>从Visual Studio 2012开始，微软就把自家原来的安装与部署工具彻底废掉了，转而让大家去安装使用第三方的打包工具“InstallShield Limited Edition for Visual Studio”，注意这个版本是免费的，只需要邮件注册下，就会有要注册码。</p><p><a href="http://www.cnblogs.com/zhuxiaohui/p/5139740.html" target="_blank" rel="noopener">Visual Studio InstallShield</a></p><p><a href="http://www.cnblogs.com/wuhuacong/p/4438761.html" target="_blank" rel="noopener">Visual Studio InstallShield</a></p><h1 id="Inno"><a href="#Inno" class="headerlink" title="Inno"></a>Inno</h1><p><a href="http://blog.csdn.net/ruifangcui7758/article/details/6662646" target="_blank" rel="noopener">Inno setup 简单打包教程</a> </p><p>官网上下载的不能新建中文项目，所以还是到网上找汉化版的吧。</p><pre><code>&quot;ISCC.exe&quot; &quot;%~dp0..\Inno Setup\PeriodicalEditor.iss&quot;</code></pre><p>语言包列表</p><pre><code>http://www.jrsoftware.org/files/istrans/</code></pre><h2 id="自定义安装目录："><a href="#自定义安装目录：" class="headerlink" title="自定义安装目录："></a>自定义安装目录：</h2><pre><code>DefaultDirName={code:GetPath}[Code]//获取安装路径function GetPath(Param: String): String;varstrPath: String;begin  strPath := ExpandConstant(&apos;{pf}\{#MyAppName}&apos;);    if   RegQueryStringValue(HKEY_LOCAL_MACHINE,&apos;Software\Microsoft\Windows\CurrentVersion\App Paths\XSX.exe&apos;, &apos;Path&apos;, strPath)  then  begin  //MsgBox(&apos;安装路径为: &apos; + strPath, mbInformation, MB_OK)  strPath:=strPath+&apos;\Plugins\PeriodicalEditor\&apos;   //strPath := ExtractFilePath(strPath);  end;Result := strPath;end;</code></pre><h2 id="一个比较完整的Inno-Setup-安装脚本"><a href="#一个比较完整的Inno-Setup-安装脚本" class="headerlink" title="一个比较完整的Inno Setup 安装脚本"></a>一个比较完整的Inno Setup 安装脚本</h2><pre><code>[Setup]; 注: AppId的值为单独标识该应用程序。; 不要为其他安装程序使用相同的AppId值。; (生成新的GUID，点击 工具|在IDE中生成GUID。)AppId={{A9861883-31C5-4324-BD9A-DC3271EEB675};程序名AppName=ISsample;版本号AppVerName=ISsample 1.0.0.0;发布者名AppPublisher=Hkiss;相关连接AppPublisherURL=http://zwkufo.blog.163.comAppSupportURL=http://zwkufo.blog.163.comAppUpdatesURL=http://zwkufo.blog.163.com;默认安装目录DefaultDirName={pf}\ISsample;默认开始菜单名DefaultGroupName=ISsample;是否打开-&gt;可选安装开始菜单项;AllowNoIcons=yes;安装协议;LicenseFile=C:\Example\原始文件\agreement.txt;安装前查看的文本文件;InfoBeforeFile=C:\Example\原始文件\Setup_New.txt;安装后查看文本文件;InfoAfterFile=C:\Example\原始文件\Setup_Old.txt;输出文件夹OutputDir=C:\Example\InnoSetup\out;输出文件名OutputBaseFilename=setup;安装图标SetupIconFile=C:\Example\原始文件\title.ico;安装需要输入密码;Password=123;Encryption=yes;压缩相关Compression=lzmaSolidCompression=yes;可以让用户忽略选择语言相关ShowLanguageDialog = yes;备注版本信息VersionInfoCompany=HTTP://www.Hkiss.COMVersionInfoDescription=ISsample 汉化增强版VersionInfoVersion=1.0.0.0VersionInfoCopyright=Copyright (C) 2007-2008 Hkiss;制作选择语言[Languages]Name: &quot;chs&quot;; MessagesFile: &quot;compiler:Default.isl&quot; ;LicenSeFile :&quot;C:\Example\原始文件\chs\agreement.txt&quot;Name: &quot;en&quot;; MessagesFile: &quot;compiler:Languages\English.isl&quot;;LicenSeFile :&quot;C:\Example\原始文件\en\agreement.txt&quot;;用户定制任务[Tasks]Name: &quot;desktopicon&quot;; Description: &quot;{cm:CreateDesktopIcon}&quot;; GroupDescription: &quot;{cm:AdditionalIcons}&quot;; Flags: uncheckedName: &quot;quicklaunchicon&quot;; Description: &quot;{cm:CreateQuickLaunchIcon}&quot;; GroupDescription: &quot;{cm:AdditionalIcons}&quot;; Flags: uncheckedName: &quot;Tasks_1&quot; ; Description:&quot;用户自定义任务1&quot;; Flags: uncheckedName: &quot;Tasks_2&quot; ; Description:&quot;用户自定义任务2&quot;; Flags: unchecked;选择了组件才会出现的定制任务Name: &quot;Tasks_3&quot; ; Description:&quot;用户自定义任务3&quot;;Components: c1 ; Flags: unchecked;文件安装[Files];多语言安装环境设置    公共参数Languages 来设置Source: &quot;C:\Example\原始文件\enfile.txt&quot;; DestDir: &quot;{app}&quot;; Languages: en ; Flags: ignoreversionSource: &quot;C:\Example\原始文件\chsfile.txt&quot;; DestDir: &quot;{app}&quot;; Languages: chs ; Flags: ignoreversion;用户自定义任务 TasksSource: &quot;C:\Example\原始文件\Tasks\tasks_1.txt&quot;; DestDir: &quot;{app}\Tasks&quot;; Flags: ignoreversion ;Tasks : Tasks_1Source: &quot;C:\Example\原始文件\Tasks\tasks_2.txt&quot;; DestDir: &quot;{app}\Tasks&quot;; Flags: ignoreversion ;Tasks :Tasks_2Source: &quot;C:\Example\原始文件\Tasks\tasks_Components.txt&quot;; DestDir: &quot;{app}\Tasks&quot;; Flags: ignoreversion ;Tasks :Tasks_2;用户定义组件安装Source: &quot;C:\Example\原始文件\Components\Components_1.txt&quot;; DestDir: &quot;{app}\Components&quot;; Flags: ignoreversion ; Components: a1;Source: &quot;C:\Example\原始文件\Components\Components_2.txt&quot;; DestDir: &quot;{app}\Components&quot;; Flags: ignoreversion ; Components: a2;Source: &quot;C:\Example\原始文件\Components\Components_3.txt&quot;; DestDir: &quot;{app}\Components&quot;; Flags: ignoreversion ; Components: a3;Source: &quot;C:\Example\原始文件\Components\Components_4.txt&quot;; DestDir: &quot;{app}\Components&quot;; Flags: ignoreversion ; Components: a1 a2 a3;;用户注册自定义Dll文件      regserver 注册 noregerror 不显示错误信息Source: &quot;C:\Example\原始文件\jmail.dll&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversion regserver;添加自述文件Source: &quot;C:\Example\原始文件\ISsample.txt&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversion;添加一个文件到缓存文件夹{Tmp} deleteafterinstall 安装后删除Source: &quot;C:\Example\原始文件\test.exe&quot;; DestDir: &quot;{tmp}&quot;; Flags: ignoreversion deleteafterinstallSource: &quot;C:\Example\原始文件\ISsample.chm&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\ISsample.exe&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\ISsample.dll&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\ISsample.ini&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\ISsample.rar&quot;; DestDir: &quot;{app}&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\ISsample_sys.dll&quot;; DestDir: &quot;{win}\System32&quot;; Flags: ignoreversionSource: &quot;C:\Example\原始文件\log\*&quot;; DestDir: &quot;{app}\log&quot;; Flags: ignoreversion recursesubdirs createallsubdirs; 注意: 不要在任何共享系统文件上使用“Flags: ignoreversion”;安装类型设置[Types]Name: Full ;Description:&quot;完全安装&quot;; Flags: iscustomName: Compact ;Description:&quot;简洁安装&quot;;Name: Custom; Description:&quot;自定义安装&quot;;;组件安装[Components]Name: c1; Description: &quot;自定义任务3&quot; ; Types: FullName: a1; Description: &quot;安装Components_1&quot;; Types: Full Compact Custom ;Name: a2; Description: &quot;安装Components_2&quot;; Types : Full   CompactName: a3; Description: &quot;安装Components_3&quot;; Types : Full;开始菜单，桌面快捷方式[Icons]Name: &quot;{group}\ISsample&quot;; Filename: &quot;{app}\ISsample.exe&quot;Name: &quot;{group}\{cm:ProgramOnTheWeb,ISsample}&quot;; Filename: &quot;http://zwkufo.blog.163.com&quot;Name: &quot;{group}\{cm:UninstallProgram,ISsample}&quot;; Filename: &quot;{uninstallexe}&quot;Name: &quot;{commondesktop}\ISsample&quot;; Filename: &quot;{app}\ISsample.exe&quot;; Tasks: desktopiconName: &quot;{userappdata}\Microsoft\Internet Explorer\Quick Launch\ISsample&quot;; Filename: &quot;{app}\ISsample.exe&quot;; Tasks: quicklaunchicon;添加一个帮助文挡Name: {group}\ISsample 1.0.0.0 帮助文档;Filename: {app}\ISsample.chm;用来在程序安装完成后 在安装程序显示最终对话框之前执行程序 常用与运行主程序 显示自述文件 删除临时文件[Run]Filename: &quot;{app}\ISsample.exe&quot;; Description: &quot;{cm:LaunchProgram,ISsample}&quot;; Flags: nowait postinstall skipifsilentFilename: &quot;{app}\ISsample.txt&quot;; Description: &quot;查看显示自述文件&quot;; Flags: postinstall skipifsilent shellexec;更改显示在程序中显示的消息文本[Messages]BeveledLabel=HKiss科技;卸载对话框说明ConfirmUninstall=您真的想要从电脑中卸载ISsample吗?%n%n按 [是] 则完全删除 %1 以及它的所有组件;%n按 [否]则让软件继续留在您的电脑上.;定义解压说明;StatusExtractFiles=解压并复制主程序文件及相关库文件...;用于在用户系统中创建，修改或删除ini文件健值[INI]Filename: &quot;{app}\cfg.ini&quot;; Section: &quot;Startup Options&quot;; Flags: uninsdeletesectionFilename: &quot;{app}\cfg.ini&quot;; Section: &quot;Startup Options&quot;; Key: &quot;server ip&quot;; String: &quot;127.0.0.1&quot;Filename: &quot;{app}\cfg.ini&quot;; Section: &quot;Startup Options&quot;; Key: &quot;server port&quot;; String: &quot;8080&quot;;用于在用户系统中创建，修改或删除注册表健值[Registry]Root: HKLM ;SubKey:&quot;Software\ISsample&quot;;ValueType:dword;ValueName:config;ValueData:10 ;Flags:uninsdeletevalue;在执行脚本[code]//全局变量var MyProgChecked: Boolean;//判断程序是否存在//初始华程序事件function InitializeSetup(): boolean;var Isbl: boolean;         //声明变量var Isstr: string;begin       //开始Isbl := true;             //变量赋值Isstr := &apos;欢迎&apos;;if RegValueExists(HKEY_LOCAL_MACHINE, &apos;SOFTWARE\ISsample&apos;, &apos;config&apos;) thenbegin    MsgBox(&apos;已安装过，请先卸载在安装&apos;,mbConfirmation, MB_OK);    isbl := false;end elsebegin   //MsgBox(&apos;无值&apos;,mbConfirmation, MB_OK);     isbl := true;end;//下面是个麻烦的 条件语句 end else 注意//if MsgBox(Isstr, mbConfirmation, MB_OKCANCEL) = IDOK then//begin// isbl := true;// MsgBox(&apos;执行了&apos;, mbConfirmation, MB_OK);//end else//begin// isbl := false;//MsgBox(&apos;执行了&apos;, mbConfirmation, MB_OK);//end;Result := Isbl;end;       //结束procedure CurStepChanged(CurStep: TSetupStep);var Isstr :string;beginif CurStep=ssInstall then       //实际安装前调用begin    //MsgBox(&apos;CurStepChanged:实际安装前调用&apos;, mbConfirmation, MB_OKCANCEL);           //安装完成后调用end;if CurStep=ssPostInstall thenbegin    Isstr := ExpandConstant(&apos;{tmp}\tmp.rar&apos;);//    if FileExists(Isstr) then//    begin//      MsgBox(&apos;文件存在&apos;,mbConfirmation, MB_OK);//    end else//    begin//      MsgBox(&apos;文件不存在&apos;,mbConfirmation, MB_OK);//    end;   // MsgBox(&apos;CurStepChanged:实际安装后调用&apos;, mbConfirmation, MB_OKCANCEL);end;end;//下一步 按钮按钮 事件function NextButtonClick(CurPageID: Integer): Boolean;var ResultCode: Integer;var IsSetup : Boolean;beginIsSetup := true ;case CurPageID of    wpSelectDir:       MsgBox(&apos;NextButtonClick:&apos; #13#13 &apos;You selected: &apos;&apos;&apos; + WizardDirValue + &apos;&apos;&apos;.&apos;, mbInformation, MB_OK);   //WizardDirValue路径    wpSelectProgramGroup:       MsgBox(&apos;NextButtonClick:&apos; #13#13 &apos;You selected: &apos;&apos;&apos; + WizardGroupValue + &apos;&apos;&apos;.&apos;, mbInformation, MB_OK); //开始菜单名    wpReady:      begin       if not RegValueExists(HKEY_LOCAL_MACHINE, &apos;SOFTWARE\Test&apos;, &apos;config&apos;) then   begin          if MsgBox(&apos;程序执行需要Test.ext,是否安装!&apos;, mbConfirmation, MB_YESNO) = idYes then begin           ExtractTemporaryFile(&apos;test.exe&apos;);            if not Exec(ExpandConstant(&apos;{tmp}\test.exe&apos;), &apos;&apos;, &apos;&apos;, SW_SHOWNORMAL, ewWaitUntilTerminated, ResultCode) then              MsgBox(&apos;Test.exe出错:&apos; #13#13 &apos; &apos; + SysErrorMessage(ResultCode) + &apos;.&apos;, mbError, MB_OK);          end else begin                IsSetup := false ;          end ;          BringToFrontAndRestore();        end;      end;end;Result := IsSetup;end;</code></pre><h2 id="inno-setup读取注册表遇到的一个坑"><a href="#inno-setup读取注册表遇到的一个坑" class="headerlink" title="inno setup读取注册表遇到的一个坑"></a>inno setup读取注册表遇到的一个坑</h2><p>64位操作系统读取注册表问题：</p><pre><code>function GetInstallString(): String;var  sInstallPath: String;begin  sInstallPath := &apos;C:\Program Files\Adobe\Common\Plug-ins\7.0\MediaCore&apos;;  if RegValueExists(HKLM64, &apos;SOFTWARE\Adobe\Premiere Pro\CurrentVersion&apos;, &apos;Plug-InsDir&apos;) then  begin    RegQueryStringValue(HKLM64, &apos;SOFTWARE\Adobe\Premiere Pro\CurrentVersion&apos;, &apos;Plug-InsDir&apos;, sInstallPath)  end  Result := sInstallPath;end;</code></pre><h1 id="advanced-installer"><a href="#advanced-installer" class="headerlink" title="advanced installer"></a>advanced installer</h1><p><a href="http://anger6678.blog.163.com/blog/static/3293226201072944119412/" target="_blank" rel="noopener">Advanced Installer汉化版教程</a></p><h1 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h1><p><a href="http://blog.csdn.net/csxiaoshui/article/details/45310135" target="_blank" rel="noopener">NSIS简介</a> </p><p><a href="http://www.cnblogs.com/modou/p/3573772.html" target="_blank" rel="noopener">使用NSIS制作安装包</a></p><p><a href="http://www.hanzify.org/teach/index.php?Go=Show::196-1108396800" target="_blank" rel="noopener">NSIS安装制作基础教程[初级篇]</a></p><p><a href="http://hmne.sourceforge.net/" target="_blank" rel="noopener">NIS Edit</a></p><p><a href="https://sourceforge.net/projects/nsis/" target="_blank" rel="noopener">NSIS: Nullsoft Scriptable Install System</a></p><p><a href="http://www.nsisfans.com/" title="NSIS中文论坛" target="_blank" rel="noopener">http://www.nsisfans.com/</a></p><p><a href="http://blog.csdn.net/sdujava2011/article/details/51271567" target="_blank" rel="noopener">NSIS UI 美化类插件分享 </a></p><p><a href="http://www.aceui.cn" target="_blank" rel="noopener">www.aceui.cn-nsSkinEngine</a></p><p><a href="https://github.com/cppfuns/nsSkinEngine_NSIS_demo" target="_blank" rel="noopener">nsSkinEngine_NSIS_demo</a></p><p><a href="https://blog.csdn.net/column/details/19012.html" target="_blank" rel="noopener">打包狂魔之NSIS教程</a></p><p><a href="https://blog.csdn.net/china_jeffery/article/details/79109313" target="_blank" rel="noopener">NSIS教程(9): NSIS+duilib仿QQ安装包</a></p><p><a href="https://www.cnblogs.com/joean/p/4881191.html" target="_blank" rel="noopener">一个比较完整的Inno Setup 安装脚本</a></p><p><a href="https://blog.csdn.net/qq_34248512/article/details/77033165" target="_blank" rel="noopener">通过nsis和duilib实现自定义安装界面</a></p><h1 id="牛牛安装包界面美化控件-nsNiuniuSkin"><a href="#牛牛安装包界面美化控件-nsNiuniuSkin" class="headerlink" title="牛牛安装包界面美化控件 [nsNiuniuSkin]"></a>牛牛安装包界面美化控件 [nsNiuniuSkin]</h1><p><a href="http://www.ggniu.cn/download.htm" title="http://www.ggniu.cn/download.htm" target="_blank" rel="noopener">http://www.ggniu.cn/download.htm</a></p><h1 id="WixToolSet"><a href="#WixToolSet" class="headerlink" title="WixToolSet"></a>WixToolSet</h1><p><a href="http://wixtoolset.org/" title="http://wixtoolset.org/" target="_blank" rel="noopener">http://wixtoolset.org/</a></p><p><a href="http://wixtoolset.org/releases/" target="_blank" rel="noopener">http://wixtoolset.org/releases/</a></p><p><a href="https://www.firegiant.com/wix/tutorial/" title="WiX Toolset Tutorial" target="_blank" rel="noopener">https://www.firegiant.com/wix/tutorial/</a></p><p><a href="http://blog.csdn.net/xxdddail/article/details/12652233" target="_blank" rel="noopener">WIX安装图文并茂简易说明</a></p><p><a href="http://www.cnblogs.com/stoneniqiu/category/522235.html" title="http://www.cnblogs.com/stoneniqiu/category/522235.html" target="_blank" rel="noopener">http://www.cnblogs.com/stoneniqiu/category/522235.html</a></p><p><a href="https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/" title="https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/" target="_blank" rel="noopener">https://www.firegiant.com/wix/tutorial/getting-started/the-files-inside/</a></p><p><a href="http://wixtoolset.org/documentation/manual/v3/" title="http://wixtoolset.org/documentation/manual/v3/" target="_blank" rel="noopener">http://wixtoolset.org/documentation/manual/v3/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Visual-Studio-Installer&quot;&gt;&lt;a href=&quot;#Visual-Studio-Installer&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Installer&quot;&gt;&lt;/a&gt;Visual Studio Ins
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="打包" scheme="https://caojingyou.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
      <category term="InstallShield" scheme="https://caojingyou.github.io/tags/InstallShield/"/>
    
      <category term="Inno" scheme="https://caojingyou.github.io/tags/Inno/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢的Notepad++插件</title>
    <link href="https://caojingyou.github.io/2016/08/01/%E6%88%91%E5%96%9C%E6%AC%A2%E7%9A%84Notepad++%E6%8F%92%E4%BB%B6/"/>
    <id>https://caojingyou.github.io/2016/08/01/我喜欢的Notepad++插件/</id>
    <published>2016-08-01T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notepad-插件"><a href="#Notepad-插件" class="headerlink" title="Notepad++插件"></a>Notepad++插件</h1><h2 id="HEX-Editor"><a href="#HEX-Editor" class="headerlink" title="HEX-Editor"></a>HEX-Editor</h2><p>文本转16进制，查看编辑。</p><h2 id="NppExport"><a href="#NppExport" class="headerlink" title="NppExport"></a>NppExport</h2><p>导出已着色代码为其他格式的文件。<br>将彩色代码，导出为word文档（RFT）或网页（HTML）文件，或者将彩色代码（RTF格式或HTMl格式）拷贝到剪贴板，粘贴到别的（word文档，HTML网页）中去。</p><h2 id="CoolFormatNppPlugin"><a href="#CoolFormatNppPlugin" class="headerlink" title="CoolFormatNppPlugin"></a>CoolFormatNppPlugin</h2><p>代码格式化</p><h2 id="NppAStyle"><a href="#NppAStyle" class="headerlink" title="NppAStyle"></a>NppAStyle</h2><p>代码格式化</p><h2 id="XML-Tools"><a href="#XML-Tools" class="headerlink" title="XML Tools"></a>XML Tools</h2><p>XML语法规则检查</p><h2 id="Compare-Plugin"><a href="#Compare-Plugin" class="headerlink" title="Compare Plugin"></a>Compare Plugin</h2><p>比较文件</p><h2 id="PyNpp"><a href="#PyNpp" class="headerlink" title="PyNpp"></a>PyNpp</h2><p>直接在Notepad中编写运行Python</p><h2 id="JSON-Viewer"><a href="#JSON-Viewer" class="headerlink" title="JSON Viewer"></a>JSON Viewer</h2><p>Json查看格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Notepad-插件&quot;&gt;&lt;a href=&quot;#Notepad-插件&quot; class=&quot;headerlink&quot; title=&quot;Notepad++插件&quot;&gt;&lt;/a&gt;Notepad++插件&lt;/h1&gt;&lt;h2 id=&quot;HEX-Editor&quot;&gt;&lt;a href=&quot;#HEX-Edito
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Notepad++" scheme="https://caojingyou.github.io/tags/Notepad/"/>
    
  </entry>
  
  <entry>
    <title>Json</title>
    <link href="https://caojingyou.github.io/2016/07/15/Json/"/>
    <id>https://caojingyou.github.io/2016/07/15/Json/</id>
    <published>2016-07-15T08:03:00.000Z</published>
    <updated>2018-01-05T08:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JsonCpp"><a href="#JsonCpp" class="headerlink" title="JsonCpp"></a>JsonCpp</h1><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p><a href="https://github.com/open-source-parsers/jsoncpp" title="https://github.com/open-source-parsers/jsoncpp" target="_blank" rel="noopener">https://github.com/open-source-parsers/jsoncpp</a></p><p><a href="https://sourceforge.net/projects/jsoncpp/" title="https://sourceforge.net/projects/jsoncpp/" target="_blank" rel="noopener">https://sourceforge.net/projects/jsoncpp/</a></p><p><a href="https://github.com/open-source-parsers/jsoncpp/archive/1.7.4.zip" title="JsonCpp1.7.4" target="_blank" rel="noopener">https://github.com/open-source-parsers/jsoncpp/archive/1.7.4.zip</a></p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>本人使用的是JsonCpp1.7.4，解压后直接把include与src复制到自己的项目下。</p><p>在项目中附加包含目录：<code>../include;../src/lib_json;</code></p><p>把两个目录中的文件添加到项目中</p><p>json_reader.cpp、json_value.cpp和json_writer.cpp三个文件的预编译头改成“不使用预编译头”</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>Json::Value root;   // will contains the root value after parsing.Json::Reader reader;bool parsingSuccessful = reader.parse( config_doc, root );if ( !parsingSuccessful ){// report to the user the failure and their locations in the document.std::cout  &lt;&lt; &quot;Failed to parse configuration\n&quot;   &lt;&lt; reader.getFormattedErrorMessages();return;}// Get the value of the member of root named &apos;encoding&apos;, return &apos;UTF-8&apos; if there is no// such member.std::string encoding = root.get(&quot;encoding&quot;, &quot;UTF-8&quot; ).asString();// Get the value of the member of root named &apos;encoding&apos;, return a &apos;null&apos; value if// there is no such member.const Json::Value plugins = root[&quot;plug-ins&quot;];for ( int index = 0; index &lt; plugins.size(); ++index )  // Iterates over the sequence elements.loadPlugIn( plugins[index].asString() );setIndentLength( root[&quot;indent&quot;].get(&quot;length&quot;, 3).asInt() );setIndentUseSpace( root[&quot;indent&quot;].get(&quot;use_space&quot;, true).asBool() );// ...// At application shutdown to make the new configuration document:// Since Json::Value has implicit constructor for all value types, it is not// necessary to explicitly construct the Json::Value object:root[&quot;encoding&quot;] = getCurrentEncoding();root[&quot;indent&quot;][&quot;length&quot;] = getCurrentIndentLength();root[&quot;indent&quot;][&quot;use_space&quot;] = getCurrentIndentUseSpace();Json::StyledWriter writer;// Make a new JSON document for the configuration. Preserve original comments.std::string outputConfig = writer.write( root );// You can also use streams.  This will put the contents of any JSON// stream at a particular sub-value, if you&apos;d like.std::cin &gt;&gt; root[&quot;subtree&quot;];// And you can write to a stream, using the StyledWriter automatically.std::cout &lt;&lt; root;</code></pre><h1 id="ggicci–json"><a href="#ggicci–json" class="headerlink" title="ggicci–json"></a>ggicci–json</h1><p>发现JsonCpp竟然有内存泄露！！！可能我用法不对，放弃了。另外找了一个ggicci–json。</p><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><p><a href="https://github.com/ggicci/ggicci--json" title="https://github.com/ggicci/ggicci--json" target="_blank" rel="noopener">https://github.com/ggicci/ggicci–json</a></p><h1 id="rapidjson"><a href="#rapidjson" class="headerlink" title="rapidjson"></a>rapidjson</h1><p>rapidjson更快,最终使用了rapidjson</p><h2 id="下载地址：-1"><a href="#下载地址：-1" class="headerlink" title="下载地址："></a>下载地址：</h2><p><a href="https://github.com/miloyip/rapidjson/" title="https://github.com/miloyip/rapidjson/" target="_blank" rel="noopener">https://github.com/miloyip/rapidjson/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JsonCpp&quot;&gt;&lt;a href=&quot;#JsonCpp&quot; class=&quot;headerlink&quot; title=&quot;JsonCpp&quot;&gt;&lt;/a&gt;JsonCpp&lt;/h1&gt;&lt;h2 id=&quot;下载：&quot;&gt;&lt;a href=&quot;#下载：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://caojingyou.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C++" scheme="https://caojingyou.github.io/tags/C/"/>
    
      <category term="Json" scheme="https://caojingyou.github.io/tags/Json/"/>
    
      <category term="JsonCpp" scheme="https://caojingyou.github.io/tags/JsonCpp/"/>
    
      <category term="ggicci--json" scheme="https://caojingyou.github.io/tags/ggicci-json/"/>
    
  </entry>
  
</feed>
